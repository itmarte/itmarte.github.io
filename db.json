{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/images/0082zybply1gbq4mytke2j31gw07279o.jpg","path":"images/0082zybply1gbq4mytke2j31gw07279o.jpg","modified":1,"renderable":0},{"_id":"source/images/0082zybply1gbq3z7a7mmj31nq074qat.jpg","path":"images/0082zybply1gbq3z7a7mmj31nq074qat.jpg","modified":1,"renderable":0},{"_id":"source/images/0082zybply1gbqenjpogfj30ph05zdgv.jpg","path":"images/0082zybply1gbqenjpogfj30ph05zdgv.jpg","modified":1,"renderable":0},{"_id":"source/images/0082zybply1gbr8va8yvhj30hm0ck3z8.jpg","path":"images/0082zybply1gbr8va8yvhj30hm0ck3z8.jpg","modified":1,"renderable":0},{"_id":"source/images/031383336382e6a7067.png","path":"images/031383336382e6a7067.png","modified":1,"renderable":0},{"_id":"source/images/032362e6a7067.png","path":"images/032362e6a7067.png","modified":1,"renderable":0},{"_id":"source/images/1383336382e6a7067.png","path":"images/1383336382e6a7067.png","modified":1,"renderable":0},{"_id":"source/images/1a1742222.png","path":"images/1a1742222.png","modified":1,"renderable":0},{"_id":"source/images/125453725.png","path":"images/125453725.png","modified":1,"renderable":0},{"_id":"source/images/1a1746f33bfdcb03da074d8539ebb2f367563.png","path":"images/1a1746f33bfdcb03da074d8539ebb2f367563.png","modified":1,"renderable":0},{"_id":"source/images/1df932840b31f41931bb69e16be2932844240.png","path":"images/1df932840b31f41931bb69e16be2932844240.png","modified":1,"renderable":0},{"_id":"source/images/20151231233806229.png","path":"images/20151231233806229.png","modified":1,"renderable":0},{"_id":"source/images/20160103223150042.png","path":"images/20160103223150042.png","modified":1,"renderable":0},{"_id":"source/images/20200604161006.png","path":"images/20200604161006.png","modified":1,"renderable":0},{"_id":"source/images/20200604162924.png","path":"images/20200604162924.png","modified":1,"renderable":0},{"_id":"source/images/20200702382545352.png","path":"images/20200702382545352.png","modified":1,"renderable":0},{"_id":"source/images/238312e6a7067.png","path":"images/238312e6a7067.png","modified":1,"renderable":0},{"_id":"source/images/25453525.jpg","path":"images/25453525.jpg","modified":1,"renderable":0},{"_id":"source/images/25453525.png","path":"images/25453525.png","modified":1,"renderable":0},{"_id":"source/images/25453625.png","path":"images/25453625.png","modified":1,"renderable":0},{"_id":"source/images/31bad766983e212431077ca8da92762050214.png","path":"images/31bad766983e212431077ca8da92762050214.png","modified":1,"renderable":0},{"_id":"source/images/33343235392e6a7067.png","path":"images/33343235392e6a7067.png","modified":1,"renderable":0},{"_id":"source/images/335302e6a7067.png","path":"images/335302e6a7067.png","modified":1,"renderable":0},{"_id":"source/images/34392e6a702267.png","path":"images/34392e6a702267.png","modified":1,"renderable":0},{"_id":"source/images/34392e6a7067.png","path":"images/34392e6a7067.png","modified":1,"renderable":0},{"_id":"source/images/383738352e6a7067.png","path":"images/383738352e6a7067.png","modified":1,"renderable":0},{"_id":"source/images/453525.png","path":"images/453525.png","modified":1,"renderable":0},{"_id":"source/images/4537.png","path":"images/4537.png","modified":1,"renderable":0},{"_id":"source/images/4d5c410ad23782350cc9f980787151fd54144.png","path":"images/4d5c410ad23782350cc9f980787151fd54144.png","modified":1,"renderable":0},{"_id":"source/images/525453525.png","path":"images/525453525.png","modified":1,"renderable":0},{"_id":"source/images/525453625.jpg","path":"images/525453625.jpg","modified":1,"renderable":0},{"_id":"source/images/54546254.png","path":"images/54546254.png","modified":1,"renderable":0},{"_id":"source/images/582d1606d57ff99aa0e5f8fc59c7819329028.png","path":"images/582d1606d57ff99aa0e5f8fc59c7819329028.png","modified":1,"renderable":0},{"_id":"source/images/5911899802886.png","path":"images/5911899802886.png","modified":1,"renderable":0},{"_id":"source/images/5a086e7bb93e69e842e706e67.png","path":"images/5a086e7bb93e69e842e706e67.png","modified":1,"renderable":0},{"_id":"source/images/24a6176.png","path":"images/24a6176.png","modified":1,"renderable":0},{"_id":"source/images/625.jpg","path":"images/625.jpg","modified":1,"renderable":0},{"_id":"source/images/668e3c90f4b918bfcead2f4280091e9757284.png","path":"images/668e3c90f4b918bfcead2f4280091e9757284.png","modified":1,"renderable":0},{"_id":"source/images/68747470.png","path":"images/68747470.png","modified":1,"renderable":0},{"_id":"source/images/687474703a.png","path":"images/687474703a.png","modified":1,"renderable":0},{"_id":"source/images/842254537.png","path":"images/842254537.png","modified":1,"renderable":0},{"_id":"source/images/879edb4f06043d76cea27a3ff358cb1d45243.png","path":"images/879edb4f06043d76cea27a3ff358cb1d45243.png","modified":1,"renderable":0},{"_id":"source/images/90ea093549782945f2c968403fdc39d415386.png","path":"images/90ea093549782945f2c968403fdc39d415386.png","modified":1,"renderable":0},{"_id":"source/images/912883e51327e0c7a9d753d11896326511272.png","path":"images/912883e51327e0c7a9d753d11896326511272.png","modified":1,"renderable":0},{"_id":"source/images/96e65732e706e67.png","path":"images/96e65732e706e67.png","modified":1,"renderable":0},{"_id":"source/images/9d8dc9cebe59122127460f81a98894bb34085.png","path":"images/9d8dc9cebe59122127460f81a98894bb34085.png","modified":1,"renderable":0},{"_id":"source/images/a6176.png","path":"images/a6176.png","modified":1,"renderable":0},{"_id":"source/images/c6caa5be64f39758ada0593b995d65fd25982.png","path":"images/c6caa5be64f39758ada0593b995d65fd25982.png","modified":1,"renderable":0},{"_id":"source/images/e6a7067.png","path":"images/e6a7067.png","modified":1,"renderable":0},{"_id":"source/images/e9a363c8577f211577e4962e9110cb0226733.png","path":"images/e9a363c8577f211577e4962e9110cb0226733.png","modified":1,"renderable":0},{"_id":"source/images/f4d89c87acf102b45be8ccf3ed83352a9497.png","path":"images/f4d89c87acf102b45be8ccf3ed83352a9497.png","modified":1,"renderable":0},{"_id":"source/images/forkjoin_任务拆分.png","path":"images/forkjoin_任务拆分.png","modified":1,"renderable":0},{"_id":"source/images/getmint_20200427144736.png","path":"images/getmint_20200427144736.png","modified":1,"renderable":0},{"_id":"source/images/java-memory-g.jpg","path":"images/java-memory-g.jpg","modified":1,"renderable":0},{"_id":"source/images/java-memory-g8.jpg","path":"images/java-memory-g8.jpg","modified":1,"renderable":0},{"_id":"source/images/java-memory-mallock.png","path":"images/java-memory-mallock.png","modified":1,"renderable":0},{"_id":"source/images/java-memory-obj-create.png","path":"images/java-memory-obj-create.png","modified":1,"renderable":0},{"_id":"source/images/java-memory-str-constant.png","path":"images/java-memory-str-constant.png","modified":1,"renderable":0},{"_id":"source/images/java-memory-str-new.png","path":"images/java-memory-str-new.png","modified":1,"renderable":0},{"_id":"source/images/nio-buffer.png","path":"images/nio-buffer.png","modified":1,"renderable":0},{"_id":"source/images/nio-channels.png","path":"images/nio-channels.png","modified":1,"renderable":0},{"_id":"source/images/reduceTask-类图.png","path":"images/reduceTask-类图.png","modified":1,"renderable":0},{"_id":"source/images/thread-pool.png","path":"images/thread-pool.png","modified":1,"renderable":0},{"_id":"source/images/v2-104267f964da011318238d357f05bb6c_720w.jpg","path":"images/v2-104267f964da011318238d357f05bb6c_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-26e9c6b2d131c19e25d7283f37940ae1_720w.jpg","path":"images/v2-26e9c6b2d131c19e25d7283f37940ae1_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/java_time_task.png","path":"images/java_time_task.png","modified":1,"renderable":0},{"_id":"source/images/v2-373b769b0466f324fd0553f5074d1b37_720w.jpg","path":"images/v2-373b769b0466f324fd0553f5074d1b37_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-31eb992f13d3222fcfc4cd222158a702_720w.jpg","path":"images/v2-31eb992f13d3222fcfc4cd222158a702_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-73771a9cec11fc86e5aa0145885b05c8_720w.jpg","path":"images/v2-73771a9cec11fc86e5aa0145885b05c8_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-65d90f64aa52be10b9bdc1b8042e9e31_720w.jpg","path":"images/v2-65d90f64aa52be10b9bdc1b8042e9e31_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-60336a35f872a24562326304943292b9_720w.jpg","path":"images/v2-60336a35f872a24562326304943292b9_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-432781b10f8582f5bf192e1a050e99a1_720w.jpg","path":"images/v2-432781b10f8582f5bf192e1a050e99a1_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-73c1d9300839c0ee560c9bfcc685d653_720w.jpg","path":"images/v2-73c1d9300839c0ee560c9bfcc685d653_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-86d44b4b844c130414c4653f215ec149_720w.jpg","path":"images/v2-86d44b4b844c130414c4653f215ec149_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-94c4670cb6b6099055a5146f1a034b9b_720w.jpg","path":"images/v2-94c4670cb6b6099055a5146f1a034b9b_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-ae88013d0531eac5ebc96fad2e4f8594_720w.jpg","path":"images/v2-ae88013d0531eac5ebc96fad2e4f8594_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-b8854e3034ce49c2f8d652394c2328ac_720w.jpg","path":"images/v2-b8854e3034ce49c2f8d652394c2328ac_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-c431ecdd67246b4e7745d58155d4e64d_720w.jpg","path":"images/v2-c431ecdd67246b4e7745d58155d4e64d_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-c526027f5f2dae54753239d5d9bd277b_720w.jpg","path":"images/v2-c526027f5f2dae54753239d5d9bd277b_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-c52ddb056dbd39595e7c6f5b2c4fb3b5_720w.jpg","path":"images/v2-c52ddb056dbd39595e7c6f5b2c4fb3b5_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-9f56d1d058e3a87a8c6be5b58696f14b_720w.jpg","path":"images/v2-9f56d1d058e3a87a8c6be5b58696f14b_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-cdca1f51c4a3bef0b30221a947144bdd_720w.jpg","path":"images/v2-cdca1f51c4a3bef0b30221a947144bdd_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-eb03c274f799a5147abc23bb99a56b4c_720w.jpg","path":"images/v2-eb03c274f799a5147abc23bb99a56b4c_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-f9315b646c72eb17564ebc0507458b14_720w.jpg","path":"images/v2-f9315b646c72eb17564ebc0507458b14_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/v2-fe9119746d34b5396e48eac6ecd16746_720w.jpg","path":"images/v2-fe9119746d34b5396e48eac6ecd16746_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/实际的请求.png","path":"images/实际的请求.png","modified":1,"renderable":0},{"_id":"source/images/授权图.png","path":"images/授权图.png","modified":1,"renderable":0},{"_id":"source/images/0082zybply1gbq3md7d15j30m90cb43g.jpg","path":"images/0082zybply1gbq3md7d15j30m90cb43g.jpg","modified":1,"renderable":0},{"_id":"source/images/0082zybply1gbpy5n5wfuj31m6078wp5.jpg","path":"images/0082zybply1gbpy5n5wfuj31m6078wp5.jpg","modified":1,"renderable":0},{"_id":"source/images/0082zybply1gbqenluvenj30rz0hsjv2.jpg","path":"images/0082zybply1gbqenluvenj30rz0hsjv2.jpg","modified":1,"renderable":0},{"_id":"source/images/0082zybply1gbqennntwoj30sg0fswhn.jpg","path":"images/0082zybply1gbqennntwoj30sg0fswhn.jpg","modified":1,"renderable":0},{"_id":"source/images/0082zybply1gbqenpjnt7j30yq0higpo.jpg","path":"images/0082zybply1gbqenpjnt7j30yq0higpo.jpg","modified":1,"renderable":0},{"_id":"source/images/0082zybply1gbqenq2xc6j31820cs76u.jpg","path":"images/0082zybply1gbqenq2xc6j31820cs76u.jpg","modified":1,"renderable":0},{"_id":"source/images/03268b9dc49bd30bb63064421bb036bf90315.png","path":"images/03268b9dc49bd30bb63064421bb036bf90315.png","modified":1,"renderable":0},{"_id":"source/images/20151231232508924.png","path":"images/20151231232508924.png","modified":1,"renderable":0},{"_id":"source/images/20160103223436953.png","path":"images/20160103223436953.png","modified":1,"renderable":0},{"_id":"source/images/3832353037392e6a7067.png","path":"images/3832353037392e6a7067.png","modified":1,"renderable":0},{"_id":"source/images/38d5fbeaebd4998f3a30d44bd20b996f113233.png","path":"images/38d5fbeaebd4998f3a30d44bd20b996f113233.png","modified":1,"renderable":0},{"_id":"source/images/49527b1bb385f0f43529e57b614f59ae145454.png","path":"images/49527b1bb385f0f43529e57b614f59ae145454.png","modified":1,"renderable":0},{"_id":"source/images/49d8041f8480aba5ef59079fcc7143b996706.png","path":"images/49d8041f8480aba5ef59079fcc7143b996706.png","modified":1,"renderable":0},{"_id":"source/images/6c0091e92e90f50f89fd83f3b9eb5472135718.png","path":"images/6c0091e92e90f50f89fd83f3b9eb5472135718.png","modified":1,"renderable":0},{"_id":"source/images/9379fe1666818237f842138812bf63bd85645.png","path":"images/9379fe1666818237f842138812bf63bd85645.png","modified":1,"renderable":0},{"_id":"source/images/MVCC多版本并发控制.png","path":"images/MVCC多版本并发控制.png","modified":1,"renderable":0},{"_id":"source/images/MVCC多版本并发控制.xmind","path":"images/MVCC多版本并发控制.xmind","modified":1,"renderable":0},{"_id":"source/images/efd32f1211e9cf0a3ca9d35b0dc5de8588353.png","path":"images/efd32f1211e9cf0a3ca9d35b0dc5de8588353.png","modified":1,"renderable":0},{"_id":"source/images/forkjoin_工作窃取（双端队列）.png","path":"images/forkjoin_工作窃取（双端队列）.png","modified":1,"renderable":0},{"_id":"source/images/io.png","path":"images/io.png","modified":1,"renderable":0},{"_id":"source/images/java-memory-obj-direct.png","path":"images/java-memory-obj-direct.png","modified":1,"renderable":0},{"_id":"source/images/java-memory-obj-reference.png","path":"images/java-memory-obj-reference.png","modified":1,"renderable":0},{"_id":"source/images/java-memory.png","path":"images/java-memory.png","modified":1,"renderable":0},{"_id":"source/images/java-memoryjdk8.png","path":"images/java-memoryjdk8.png","modified":1,"renderable":0},{"_id":"source/images/v2-ddda0732607e2bcb365960c675e0dc71_720w.jpg","path":"images/v2-ddda0732607e2bcb365960c675e0dc71_720w.jpg","modified":1,"renderable":0},{"_id":"source/images/关系模型.png","path":"images/关系模型.png","modified":1,"renderable":0},{"_id":"source/images/架构.png","path":"images/架构.png","modified":1,"renderable":0},{"_id":"source/images/0082zybply1gbqenooa0ej314i0u0tf3.jpg","path":"images/0082zybply1gbqenooa0ej314i0u0tf3.jpg","modified":1,"renderable":0},{"_id":"source/images/414ba7f3abd11e5f805c58635ae10988166121.png","path":"images/414ba7f3abd11e5f805c58635ae10988166121.png","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"source/images/0082zybply1gbpxzrh8q4j31mc0u0hdt.jpg","path":"images/0082zybply1gbpxzrh8q4j31mc0u0hdt.jpg","modified":1,"renderable":0},{"_id":"source/images/0082zybply1gbqenma2pxj31au0u044x.jpg","path":"images/0082zybply1gbqenma2pxj31au0u044x.jpg","modified":1,"renderable":0},{"_id":"source/images/0082zybply1gbqemv4o7qj32780lkgrc.jpg","path":"images/0082zybply1gbqemv4o7qj32780lkgrc.jpg","modified":1,"renderable":0},{"_id":"source/images/20160308162237758.png","path":"images/20160308162237758.png","modified":1,"renderable":0},{"_id":"source/images/9ffb64cc4c64c0cb8d38dac01c89c905178456.png","path":"images/9ffb64cc4c64c0cb8d38dac01c89c905178456.png","modified":1,"renderable":0},{"_id":"source/images/aba8d9c09e6f054c7061ddd720a04a26147951.png","path":"images/aba8d9c09e6f054c7061ddd720a04a26147951.png","modified":1,"renderable":0},{"_id":"source/images/bV1IKzdae.png","path":"images/bV1IKzdae.png","modified":1,"renderable":0},{"_id":"source/images/uasyderdi.png","path":"images/uasyderdi.png","modified":1,"renderable":0},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"source/images/23a44974ff68a08261fb675242b83648181953.png","path":"images/23a44974ff68a08261fb675242b83648181953.png","modified":1,"renderable":0},{"_id":"source/images/292888-20190913111130827-1005682912.png","path":"images/292888-20190913111130827-1005682912.png","modified":1,"renderable":0},{"_id":"source/images/cd0b9445c3c93a866201b7cfb24d2ce7214776.png","path":"images/cd0b9445c3c93a866201b7cfb24d2ce7214776.png","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"source/images/04e73f7186a91d99181e1b5615ce9e4a318600.png","path":"images/04e73f7186a91d99181e1b5615ce9e4a318600.png","modified":1,"renderable":0},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"source/images/292888-20190913110608100-591376294.png","path":"images/292888-20190913110608100-591376294.png","modified":1,"renderable":0},{"_id":"source/images/725a3db5114d95675f2098c12dc331c3316963.png","path":"images/725a3db5114d95675f2098c12dc331c3316963.png","modified":1,"renderable":0},{"_id":"source/images/0082zybply1gbqenms1eqj32dw0l87h5.jpg","path":"images/0082zybply1gbqenms1eqj32dw0l87h5.jpg","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"source/images/292888-20190913110836624-260052587.png","path":"images/292888-20190913110836624-260052587.png","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"source/images/0082zybply1gbqenlanqrj327f0u04gd.jpg","path":"images/0082zybply1gbqenlanqrj327f0u04gd.jpg","modified":1,"renderable":0},{"_id":"source/images/56ab763273b2c03b2f1c37db7b150338414771.png","path":"images/56ab763273b2c03b2f1c37db7b150338414771.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1586829904665},{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1586829904667},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1586829904668},{"_id":"themes/landscape/README.md","hash":"67fedfb66304f103c412f6be110bf3c40c75d4ac","modified":1586829904669},{"_id":"themes/landscape/_config.yml","hash":"00cae20862725275aa0a822bc31c6f22f669a986","modified":1586932471995},{"_id":"themes/landscape/package.json","hash":"6e567a9654e61eb3f548c75edef380c2e135c433","modified":1586829904750},{"_id":"source/_posts/hello-world.md","hash":"f928c133e09992a944f4c1f9332e70daef42bd64","modified":1587972750284},{"_id":"source/images/0082zybply1gbq4mytke2j31gw07279o.jpg","hash":"edd20514c3d4db257469164bc91b831f935871e7","modified":1591258876831},{"_id":"source/images/0082zybply1gbq3z7a7mmj31nq074qat.jpg","hash":"14d9c464dcb0a4f205843f884f1627a46d16cb7c","modified":1591258860545},{"_id":"source/images/0082zybply1gbqenjpogfj30ph05zdgv.jpg","hash":"6297fd4072d314ce23ddbb67efeaf27bc4e3e97c","modified":1591258849461},{"_id":"source/images/0082zybply1gbr8va8yvhj30hm0ck3z8.jpg","hash":"3a12ad7c74fe9b98c8e989c237d7e5c60e7fb2df","modified":1591258823821},{"_id":"source/images/031383336382e6a7067.png","hash":"55d039592453799ee7fae2fe02bd8d11b8eb723e","modified":1590459812479},{"_id":"source/images/032362e6a7067.png","hash":"8cfea6119a4b0df0174723071898a3f293284df2","modified":1590459761100},{"_id":"source/images/1383336382e6a7067.png","hash":"55d039592453799ee7fae2fe02bd8d11b8eb723e","modified":1590459779978},{"_id":"source/images/1a1742222.png","hash":"5bf935061ed8656bb028f9e0c9183f72e999744e","modified":1590459123587},{"_id":"source/images/125453725.png","hash":"a7b70a6523d955f54959e381a610921f6689a48d","modified":1593681016304},{"_id":"source/images/1a1746f33bfdcb03da074d8539ebb2f367563.png","hash":"3fca02c8a93e95f30a5800205f318823fa851f47","modified":1590137552812},{"_id":"source/images/1df932840b31f41931bb69e16be2932844240.png","hash":"7bdf23635f898212c35938157a2048a24aaf7059","modified":1590137556525},{"_id":"source/images/20151231233806229.png","hash":"5dee9dafc6c0c1993c1fb42232c8938d2ef4013b","modified":1591249008614},{"_id":"source/images/20160103223150042.png","hash":"ed5593fb27a1f786c9fbde493d6e0b3051c6f64f","modified":1591249036927},{"_id":"source/images/20200604161006.png","hash":"a901564dc79476710ba1b5ebcf86a872dba61892","modified":1591258211863},{"_id":"source/images/20200604162924.png","hash":"b131f9f0f00779944f819120dbfecef4a08b9866","modified":1591259371817},{"_id":"source/images/20200702382545352.png","hash":"4de161b87184364a5b8291a20118683812821c37","modified":1593680922570},{"_id":"source/images/238312e6a7067.png","hash":"d07b2ec8782f6fd0200db0848930259a6c3acbec","modified":1590459503563},{"_id":"source/images/25453525.jpg","hash":"d2ad4fd0a5b2c9288b19d845b3b30ba2cd9e0d26","modified":1590459874388},{"_id":"source/images/25453525.png","hash":"ac7bc8e1bf79465c8e9eb247db5ed22d99ac406f","modified":1593681136587},{"_id":"source/images/25453625.png","hash":"f82616946731abd8d1f1ac9bac82432edaaa3f5f","modified":1591261095961},{"_id":"source/images/31bad766983e212431077ca8da92762050214.png","hash":"2c0de451e4d4489fbeba8678649cd1f8310a7a73","modified":1590137494735},{"_id":"source/images/33343235392e6a7067.png","hash":"1357a9acdcd74ce14627ee69ad4ee989b97f867e","modified":1590459290228},{"_id":"source/images/335302e6a7067.png","hash":"1807be697376ebaa4dfdcf9c3137c76734e2f920","modified":1590459211770},{"_id":"source/images/34392e6a702267.png","hash":"7738b19f8c0b9d520392ab88cfd38c1c60a7ff3e","modified":1590459657234},{"_id":"source/images/34392e6a7067.png","hash":"6de2a0dce9904791a312a91718a22cd3e4cf33aa","modified":1590459308195},{"_id":"source/images/383738352e6a7067.png","hash":"1e2f73eedc98eeff4df99c4d548e27659dc3a058","modified":1590459266179},{"_id":"source/images/453525.png","hash":"d01eebe435cc53fd539818975ea4663ccad4338d","modified":1590139058443},{"_id":"source/images/4537.png","hash":"d009d8452a109995494a15c373fa76d3c4053d92","modified":1591261127160},{"_id":"source/images/4d5c410ad23782350cc9f980787151fd54144.png","hash":"1a186fbb50ca9cabef65728197f6215c5a5d4550","modified":1590137580556},{"_id":"source/images/525453525.png","hash":"ff1fd504d71522128df23c32c600c27f861096d3","modified":1593681152321},{"_id":"source/images/525453625.jpg","hash":"b213a1963be7fc5f55dfa4ad1b1ed010d337c1bf","modified":1590459471053},{"_id":"source/images/54546254.png","hash":"9303b987c671d17121f9fd744c3dd73b5fd76ecc","modified":1590139040071},{"_id":"source/images/582d1606d57ff99aa0e5f8fc59c7819329028.png","hash":"e8b2219d72495f0ce181267012eda4bfa0ab56cc","modified":1590137481326},{"_id":"source/images/5911899802886.png","hash":"c0cba092f65031db3e7d9ca38e5249dc75813f68","modified":1591189980224},{"_id":"source/images/5a086e7bb93e69e842e706e67.png","hash":"4c217d7770502e559ee8bf0aade7b24e82e62a90","modified":1590459139509},{"_id":"source/images/24a6176.png","hash":"9a45cdd0ecf41e7ab2045d3113ffcf18405a3d35","modified":1591261109542},{"_id":"source/images/625.jpg","hash":"d4e8014839817faa5ca2ae3759946a9880fd4f93","modified":1590459725659},{"_id":"source/images/668e3c90f4b918bfcead2f4280091e9757284.png","hash":"dbee066e040141b957ea66fe39e587ffef26c502","modified":1590137561088},{"_id":"source/images/68747470.png","hash":"0315fc5140881cbd3edb960a78df3d9fe45dc75c","modified":1590459246387},{"_id":"source/images/687474703a.png","hash":"f1cff3f1a467637476bdae823ead66f50648d225","modified":1590459229203},{"_id":"source/images/842254537.png","hash":"d8a2b51a5a58033b8f76970ab57ab8a74e3c2754","modified":1591261274775},{"_id":"source/images/879edb4f06043d76cea27a3ff358cb1d45243.png","hash":"666a6c1afe503a1f423f98ab9a2a0ef9c8a5ad4c","modified":1590137539864},{"_id":"source/images/90ea093549782945f2c968403fdc39d415386.png","hash":"b0c998e7ca7f6894a1a024080e344ca73ec24436","modified":1590137535892},{"_id":"source/images/912883e51327e0c7a9d753d11896326511272.png","hash":"760736a96e81c75278cee92fec4ac0cea4e1044f","modified":1590137472891},{"_id":"source/images/96e65732e706e67.png","hash":"7aeff2c2e61fd7cf0ff62cc17ce17bae0bd80dbc","modified":1593680406246},{"_id":"source/images/9d8dc9cebe59122127460f81a98894bb34085.png","hash":"94aa10857d5caec527636002fea0c32d0223840e","modified":1590137525459},{"_id":"source/images/a6176.png","hash":"9a45cdd0ecf41e7ab2045d3113ffcf18405a3d35","modified":1591261117098},{"_id":"source/images/c6caa5be64f39758ada0593b995d65fd25982.png","hash":"0fbc41534084a1b503d301724ac4733f0e64e251","modified":1590137574608},{"_id":"source/images/e6a7067.png","hash":"39f41f42c8d3e175397c479e2b8d8d8bfddbb327","modified":1590459569075},{"_id":"source/images/e9a363c8577f211577e4962e9110cb0226733.png","hash":"a3f29d568d21fbaeefe56090c92aa4c6145099e1","modified":1590137545465},{"_id":"source/images/f4d89c87acf102b45be8ccf3ed83352a9497.png","hash":"3c1b843f8b28d88448453610b07b26ba9a514d8a","modified":1590137499391},{"_id":"source/images/forkjoin_任务拆分.png","hash":"3721c728c26bdf6000c427c01fe6e5908af4d828","modified":1589300495563},{"_id":"source/images/getmint_20200427144736.png","hash":"879734f8a1873b85a05d8628d118e0b591f757af","modified":1587970065746},{"_id":"source/images/java-memory-g.jpg","hash":"e6291736e6294fa3b4a58d1678a87105238366dc","modified":1590457646039},{"_id":"source/images/java-memory-g8.jpg","hash":"65bf31c0c1a2e21423a4d1c3594623abc6988058","modified":1590457659110},{"_id":"source/images/java-memory-mallock.png","hash":"a51f827b1bb1517e193a78004d00908e7b0437b9","modified":1590457717449},{"_id":"source/images/java-memory-obj-create.png","hash":"cfe3971735f73a833fb49c67f7ca7a57e22ceb2a","modified":1590457682271},{"_id":"source/images/java-memory-str-constant.png","hash":"1ceea6d76c003310da10a4cce5be1796294f1eb3","modified":1590457830965},{"_id":"source/images/java-memory-str-new.png","hash":"d743fe4731c53b928ba308a9abda8dc848e41324","modified":1590457801690},{"_id":"source/images/nio-buffer.png","hash":"e724e9416ad18d8c4eab363b8e94bbab81ea823a","modified":1589963365027},{"_id":"source/images/nio-channels.png","hash":"522fa8d62503a9ac2e1945468f41f0c2123fdfef","modified":1589963436858},{"_id":"source/images/reduceTask-类图.png","hash":"954e1ff05b583e8b5034ea88e92eb5e8f1aaf51a","modified":1589299908977},{"_id":"source/images/thread-pool.png","hash":"56158822d1748d09df256b6fbb0cc194279bb261","modified":1590137460214},{"_id":"source/images/v2-104267f964da011318238d357f05bb6c_720w.jpg","hash":"86459087839eadea91e6f6b3e9660e3d88671a9c","modified":1591255878253},{"_id":"source/images/v2-26e9c6b2d131c19e25d7283f37940ae1_720w.jpg","hash":"81f463286d658d37562cd5d874a7dd7c792a3ab2","modified":1591255908992},{"_id":"source/images/java_time_task.png","hash":"ee743a48922fa17710c2dcfe53ef546a423d2c02","modified":1587969932965},{"_id":"source/images/v2-373b769b0466f324fd0553f5074d1b37_720w.jpg","hash":"26356e9e2b707ceb65808dffca166b74cba02f9b","modified":1591255866496},{"_id":"source/images/v2-31eb992f13d3222fcfc4cd222158a702_720w.jpg","hash":"66199e99d026af98aac64fc11558f79ac49a95c0","modified":1591255903536},{"_id":"source/images/v2-73771a9cec11fc86e5aa0145885b05c8_720w.jpg","hash":"1ff1cc9040e207aa358274ef3338d9f73a2d8e39","modified":1591255888488},{"_id":"source/images/v2-65d90f64aa52be10b9bdc1b8042e9e31_720w.jpg","hash":"eb9b9c989bf78a779e3ef10e406c6fbd0183b370","modified":1591255881508},{"_id":"source/images/v2-60336a35f872a24562326304943292b9_720w.jpg","hash":"c0170b1e9989939b750ff5d112e1dbd4d6ad3dfc","modified":1591255840981},{"_id":"source/images/v2-432781b10f8582f5bf192e1a050e99a1_720w.jpg","hash":"a36eb2b3a31ac8f819299b77b045513868f7412e","modified":1591255862277},{"_id":"source/images/v2-73c1d9300839c0ee560c9bfcc685d653_720w.jpg","hash":"14b357a3bfa2a1464c9acabc28094b709a04ac3e","modified":1591255858558},{"_id":"source/images/v2-86d44b4b844c130414c4653f215ec149_720w.jpg","hash":"88c65748cce54914ba82c9a0710c59e69edd535a","modified":1591255892405},{"_id":"source/images/v2-94c4670cb6b6099055a5146f1a034b9b_720w.jpg","hash":"67c3d5a509c450ce9e32fe4e329fb4af8a9321ab","modified":1591255853009},{"_id":"source/images/v2-ae88013d0531eac5ebc96fad2e4f8594_720w.jpg","hash":"544cb1837f5a72fe28026a25d5aea03c48a18b17","modified":1591255912000},{"_id":"source/images/v2-b8854e3034ce49c2f8d652394c2328ac_720w.jpg","hash":"d605ba3600cdb840d7617e12f8b2c9499cca9e44","modified":1591255874956},{"_id":"source/images/v2-c431ecdd67246b4e7745d58155d4e64d_720w.jpg","hash":"ecb417a662582af72512b9ab00c474f729a65e46","modified":1591255884669},{"_id":"source/images/v2-c526027f5f2dae54753239d5d9bd277b_720w.jpg","hash":"f36393f144fd388a8ff99b693a95b519e19c1510","modified":1591255835636},{"_id":"source/images/v2-c52ddb056dbd39595e7c6f5b2c4fb3b5_720w.jpg","hash":"beaa389853380bad9f4f811a8ec79b68c338cdb7","modified":1591255849189},{"_id":"source/images/v2-9f56d1d058e3a87a8c6be5b58696f14b_720w.jpg","hash":"1465fba8602bf1894e2fb3b7f8abf24e6301a6eb","modified":1591255830486},{"_id":"source/images/v2-cdca1f51c4a3bef0b30221a947144bdd_720w.jpg","hash":"06f0e2960201d177c4945b716769cbe95b61fb19","modified":1591255824740},{"_id":"source/images/v2-eb03c274f799a5147abc23bb99a56b4c_720w.jpg","hash":"5c8090d46660bc87912e818dda4ce26cfa30640d","modified":1591255871260},{"_id":"source/images/v2-f9315b646c72eb17564ebc0507458b14_720w.jpg","hash":"4cb78040e7f0002489094b5096b9c4529e15b3da","modified":1591255900053},{"_id":"source/images/v2-fe9119746d34b5396e48eac6ecd16746_720w.jpg","hash":"e86124e8ea9fe8957f7954eb26943fa907fea906","modified":1591255895411},{"_id":"source/images/实际的请求.png","hash":"8c8dc9bedb249c32fcbb9b84a9edb1d6b7354bed","modified":1587020200916},{"_id":"source/images/授权图.png","hash":"c53271422e6eec963cdb3a932e9fa7fc5e50d8db","modified":1587090474770},{"_id":"source/java/schedule.md","hash":"2b275b4ffc608149aa14c7dc64911392aef296ed","modified":1587966329315},{"_id":"source/about/me.md","hash":"433111ff1e646d26c9d1e0a0053e35f0c6e8d058","modified":1586942818856},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1586829904690},{"_id":"themes/landscape/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1586829904695},{"_id":"themes/landscape/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1586829904673},{"_id":"themes/landscape/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1586829904696},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1586829904701},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1586829904698},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1586829904703},{"_id":"themes/landscape/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1586829904702},{"_id":"themes/landscape/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1586829904691},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1586829904704},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1586829904705},{"_id":"themes/landscape/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1586829904693},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1586829904742},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1586829904744},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1586829904747},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1586829904745},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1586829904750},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1586829904749},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1586829904743},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1586829904754},{"_id":"source/images/0082zybply1gbq3md7d15j30m90cb43g.jpg","hash":"8179fde03e012567cb709a62624fc5431052196a","modified":1591258855784},{"_id":"source/images/0082zybply1gbpy5n5wfuj31m6078wp5.jpg","hash":"139e68089f91aaa4ee1f8d9e21f82a3daaa41423","modified":1591258815635},{"_id":"source/images/0082zybply1gbqenluvenj30rz0hsjv2.jpg","hash":"1fc3f61d3f35694f7ddcc098c2e4657466baa4cc","modified":1591258868070},{"_id":"source/images/0082zybply1gbqennntwoj30sg0fswhn.jpg","hash":"d1849d5a02b8e20d081aebe1f7ded8eb64123cc8","modified":1591258864356},{"_id":"source/images/0082zybply1gbqenpjnt7j30yq0higpo.jpg","hash":"c8efaeb39dec74dab92b3b15ed06da5dd0e82905","modified":1591258898177},{"_id":"source/images/0082zybply1gbqenq2xc6j31820cs76u.jpg","hash":"9c6b1ff4a729755ff689195070d1b047fb9e3a9d","modified":1591258839763},{"_id":"source/images/03268b9dc49bd30bb63064421bb036bf90315.png","hash":"b0c262b8fac8719b16e48d682eda551c502e0a0b","modified":1590137521071},{"_id":"source/images/20151231232508924.png","hash":"3ed94de305a8530929afeabdd86c0c2d7ede68fc","modified":1591248993985},{"_id":"source/images/20160103223436953.png","hash":"971a393d09b88bcf0d44718ccbce4e4e1bc23a5c","modified":1591249052137},{"_id":"source/images/3832353037392e6a7067.png","hash":"a75db0e6eb14bd3175c18ed75c3381d9ecd0fa54","modified":1590459831571},{"_id":"source/images/38d5fbeaebd4998f3a30d44bd20b996f113233.png","hash":"7b72510519dab2536f29083bd71927f8297c3cd5","modified":1590137611337},{"_id":"source/images/49527b1bb385f0f43529e57b614f59ae145454.png","hash":"0a074128e2ce0e5b4ecb9150840955c87d56f662","modified":1590137529553},{"_id":"source/images/49d8041f8480aba5ef59079fcc7143b996706.png","hash":"35e854f54bf0d82929391a286f864eecbfce5eb3","modified":1590137509280},{"_id":"source/images/6c0091e92e90f50f89fd83f3b9eb5472135718.png","hash":"b415d338edddade8784d4abf2073da41c110cb24","modified":1590137584437},{"_id":"source/images/9379fe1666818237f842138812bf63bd85645.png","hash":"bb3c7f4e7a804107370b6f0fc4e5474968c071dd","modified":1590137592180},{"_id":"source/images/MVCC多版本并发控制.png","hash":"f5cea2b15c963fbb8aaddfaf76f8d42d27d68c0b","modified":1594087434020},{"_id":"source/images/MVCC多版本并发控制.xmind","hash":"a3985c85c3846ccdc4a8f3d2cbdc31c39c3ae99c","modified":1593746488963},{"_id":"source/images/efd32f1211e9cf0a3ca9d35b0dc5de8588353.png","hash":"fbc0856d57d029002d0f477090119f241492b90f","modified":1590137588531},{"_id":"source/images/forkjoin_工作窃取（双端队列）.png","hash":"aec7d59935c478457f278fb8067889b3796f2c89","modified":1589300818637},{"_id":"source/images/io.png","hash":"1ecf71a3d7e34dc6e795253af7ccee75fbe3a725","modified":1589962492312},{"_id":"source/images/java-memory-obj-direct.png","hash":"da8ab5b48b4189a9e59d3cf15413739ecf6ab159","modified":1590457772898},{"_id":"source/images/java-memory-obj-reference.png","hash":"da8ab5b48b4189a9e59d3cf15413739ecf6ab159","modified":1590457756076},{"_id":"source/images/java-memory.png","hash":"ad04409d1de7cdbb01b3fc6a8b7368ef80f5d80b","modified":1590457392174},{"_id":"source/images/java-memoryjdk8.png","hash":"dda2bfe438c8055100d16d9d7a132b43706e605d","modified":1590457623391},{"_id":"source/images/v2-ddda0732607e2bcb365960c675e0dc71_720w.jpg","hash":"494cc4af253d87614ebfea0490155207ca84564d","modified":1591255845453},{"_id":"source/images/关系模型.png","hash":"ea5cc6af49fcfdebc8043110c4614dc7815fdb2c","modified":1587027123024},{"_id":"source/images/架构.png","hash":"7abeb879caae31427083894e67e82b91aaf27562","modified":1587034586532},{"_id":"source/_posts/blockChain/blockChain.md","hash":"0285bc0b55f33614b77e413b8b41b6c9303de3bd","modified":1586951901906},{"_id":"source/_posts/java/JDK 监控和故障处理工具总结.md","hash":"fb8bd8db004d3fd480518577725639f2e423a113","modified":1591261617050},{"_id":"source/_posts/java/Java-thread-pool.md","hash":"5ff885808df4d94050becd4b1cb550e61a554b59","modified":1590137978696},{"_id":"source/_posts/java/Java.md","hash":"7a6f7138d7f5bdcb7f8c79ab5543d93f7f26d67f","modified":1586938753895},{"_id":"source/_posts/java/collection.md","hash":"f0a913d70a308236a2d59a96010103d8fdc2de0e","modified":1586941670762},{"_id":"source/_posts/java/disruptor.md","hash":"98f5c1a3963850cdeaab358a73b4064d76e75d5f","modified":1587974892602},{"_id":"source/_posts/java/IO-NIO.md","hash":"bfc6277e6399b560191c03f98db1d7eda8668f76","modified":1589964330726},{"_id":"source/_posts/java/java-memory.md","hash":"7b6874c185c47640b83ad5b684efc40f57bc753e","modified":1590461558015},{"_id":"source/_posts/java/j2ee.md","hash":"1c27facd0ec5fcdc491ee3bb163407a2572890dc","modified":1586947033515},{"_id":"source/_posts/java/java-syc-AQS.md","hash":"7f5908e23bcf7e2ea26a57f41c2b24584eca58c4","modified":1590140944412},{"_id":"source/_posts/java/jdk8-function-lambda.md","hash":"b8fdd2b76e117b97be872b9ef398c8bfa1b9054a","modified":1586939116918},{"_id":"source/_posts/java/jvm.md","hash":"549a127f6f56a63dcab2b12a0d813e7d64eaadf3","modified":1586947033471},{"_id":"source/_posts/java/proxy.md","hash":"0ddf66131833d0878d5cb86ca7b05f7640befdea","modified":1586939377541},{"_id":"source/_posts/java/schedule.md","hash":"eb9e2153663e2b39c09cd8d7a2fccf2db8a574a6","modified":1587970101795},{"_id":"source/_posts/java/thread-forkJoin.md","hash":"32641e36119794712231308a9d8ee17080f0c05c","modified":1589303510093},{"_id":"source/_posts/java/thread.md","hash":"db8e34ce7d3477474797a2c41d2fd3a9a3d01a7e","modified":1586938754135},{"_id":"source/_posts/java/IO-NIO-reader-line.md","hash":"c7e84bd3db897fc7664ae47b8d376bfba132eb83","modified":1589957320102},{"_id":"source/_posts/java/JVM 垃圾回收.md","hash":"65d5aa6b7ad0cd97f8d16f3254ef7843632d8326","modified":1590460234060},{"_id":"source/_posts/about/me.md","hash":"a209e7b777b1a00358864423ac046e2981939922","modified":1586942970033},{"_id":"source/_posts/linux/openssl 生产RSA密钥对.md","hash":"cf71bb8c889ea0afb57547a676c7e6b4dde086b6","modified":1593741367359},{"_id":"source/_posts/microservices/dubbo连接数配置引发的问题.md","hash":"25ddd8e0337b6fe0898bd12e6baa287a595aaea5","modified":1591259911932},{"_id":"source/_posts/linux/linux.md","hash":"dacbe04658220684c037efe958914c2bbe809c9a","modified":1586951755272},{"_id":"source/_posts/microservices/microservices.md","hash":"332ef5f527d40ed0e65b2dc54187e2b01b35eea7","modified":1586952043880},{"_id":"source/_posts/middleware/middleware.md","hash":"2d5816d2192081a1a10f5f4454c897dbc3c0e5f2","modified":1586951991314},{"_id":"source/_posts/orm/orm.md","hash":"60329922683b54c87bd65dfadfb31c8bda23d390","modified":1586952090865},{"_id":"source/_posts/packageManager/packageManager.md","hash":"bf55ca08f17ef9c0cde5aac9cc4c2f0a4507c4f5","modified":1586952217449},{"_id":"source/_posts/project/project.md","hash":"009e2197d98cd54fa6bb918e569764b70dafe89f","modified":1586952272237},{"_id":"source/_posts/project/热点账户.md","hash":"ba8ddd3ac4762c71413ad2db5768f2f30d357d8b","modified":1590495965956},{"_id":"source/_posts/project/open-api.md","hash":"6967addd5a2ca677923541c7f1880d95bd72458c","modified":1587091968129},{"_id":"source/_posts/server/server.md","hash":"68b7bb76ec4e933140e2e0ab408c8712aea1b20b","modified":1586952308746},{"_id":"source/_posts/spring/spring.md","hash":"a96e0f8748f1e662f3e0c21ff2f8b3874cb3a3f4","modified":1586952376796},{"_id":"source/_posts/sql/MySQL-InnoDB-MVCC多版本并发控制.md","hash":"e295e184d593bd44bf0e7d7246ab010cd1db7eb7","modified":1594087346157},{"_id":"source/_posts/sql/sql.md","hash":"188c7b1a85b8d138e56971594b326265e7830619","modified":1586952346783},{"_id":"source/_posts/sql/认识MYSQL.md","hash":"1e857bc6f109a6c946bdb557c78782e4190cc1d7","modified":1594000826351},{"_id":"source/_posts/sql/btree索引.md","hash":"6d801639755e1ed318bd4e6340098004c1c87703","modified":1591249798114},{"_id":"source/_posts/sql/Mysql分库分表方案.md","hash":"edce2620c76c4edb89c130776e1e43ce7c0ce7ab","modified":1591256896712},{"_id":"source/images/0082zybply1gbqenooa0ej314i0u0tf3.jpg","hash":"4e8f0d5817b480f0893ca58b81ede9790e597ad6","modified":1591258831456},{"_id":"source/_posts/algorithms/algorithms.md","hash":"5b23eea743e19506dadbc76867a29d871f79548d","modified":1586951830178},{"_id":"source/images/414ba7f3abd11e5f805c58635ae10988166121.png","hash":"991cedb17c4b3f010a20ee05186544faf16f3c16","modified":1590137596290},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1586829904738},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1586829904740},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1586829904742},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1586829904741},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1586829904739},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"017c412bd3d60d22e493f02918e436a32d96bb84","modified":1586829904717},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"5e3b70c028d518b8f765e29a5e2020e7ba6ed589","modified":1586829904712},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1586829904719},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1586829904713},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"ace3000bd3e01d03041d5be24f7640b6c003a5b5","modified":1586829904720},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1586829904721},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"a36cec48782782bac92622f369c750e5c7396510","modified":1586829904722},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"cf755454675d13a0813a922b575c06b6b74ab9fd","modified":1586829904723},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1586829904724},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1586829904718},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1586829904734},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1586829904760},{"_id":"themes/landscape/source/css/_variables.styl","hash":"57bb02270eef16b4823a64ba663ccf2f247f34e5","modified":1586829904781},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1586829904800},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1586829904807},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1586829904808},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1586829904806},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1586829904809},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1586829904811},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1586829904805},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1586829904823},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1586829904825},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1586829904829},{"_id":"source/images/0082zybply1gbpxzrh8q4j31mc0u0hdt.jpg","hash":"9094a5d9f6088d350ba2e9229ebe857a669ee545","modified":1591258808339},{"_id":"source/images/0082zybply1gbqenma2pxj31au0u044x.jpg","hash":"b249ed917fe7ee3bd797375445402c64bbb62f30","modified":1591258844530},{"_id":"source/images/0082zybply1gbqemv4o7qj32780lkgrc.jpg","hash":"337e0e620ae547d347c53dffca26019a6f3a9b2a","modified":1591258880363},{"_id":"source/images/20160308162237758.png","hash":"a6cb74a1b2b9af067db93a7d814de1175d6ea5ab","modified":1591249028255},{"_id":"source/images/9ffb64cc4c64c0cb8d38dac01c89c905178456.png","hash":"ddcff2297b29df91df06355ee2c64e46903e9fd6","modified":1590137515554},{"_id":"source/images/aba8d9c09e6f054c7061ddd720a04a26147951.png","hash":"98c5e3d63e1864765b174120c4736313b317694b","modified":1590137608233},{"_id":"source/images/bV1IKzdae.png","hash":"46c7aca28b343ed654a9ffb6b2947acb73a19914","modified":1593682291197},{"_id":"source/images/uasyderdi.png","hash":"0260fd5cb0a32939a29b49ad6e636be546cc085f","modified":1593682330700},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1586829904824},{"_id":"source/images/23a44974ff68a08261fb675242b83648181953.png","hash":"e2f58f3b1100e92619e1a74107dc2d55ca285bde","modified":1590137569953},{"_id":"source/images/292888-20190913111130827-1005682912.png","hash":"93e9dc44fdca0337500b3070e416afb22deb0586","modified":1589301419445},{"_id":"source/images/cd0b9445c3c93a866201b7cfb24d2ce7214776.png","hash":"2aa653ffef16579745f10034f6a8e3d7658579a3","modified":1590137604764},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1586829904731},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1586829904728},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1586829904727},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1586829904729},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1586829904732},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1586829904733},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1586829904787},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1586829904786},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1586829904779},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1586829904792},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1586829904778},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1586829904765},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1586829904768},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1586829904769},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1586829904766},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1586829904770},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1586829904771},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1586829904772},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1586829904773},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1586829904774},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1586829904767},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1586829904816},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1586829904817},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1586829904820},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1586829904822},{"_id":"source/images/04e73f7186a91d99181e1b5615ce9e4a318600.png","hash":"20d6ff6ee87bb71b567d7aa35d589302c1c128b3","modified":1590137600451},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1586829904818},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1586829904819},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1586829904791},{"_id":"source/images/292888-20190913110608100-591376294.png","hash":"81c72625037f2c6de6f174dab59340be8714b5d7","modified":1589301323603},{"_id":"source/images/725a3db5114d95675f2098c12dc331c3316963.png","hash":"191638b733691e36493144f333e79997540748ee","modified":1590137504881},{"_id":"source/images/0082zybply1gbqenms1eqj32dw0l87h5.jpg","hash":"98f2f4f6faae466a1543753b2f02730a185fa812","modified":1591258884764},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1586829904789},{"_id":"source/images/292888-20190913110836624-260052587.png","hash":"89eea925e392aad647ff6891936a0c1fb70a1ad1","modified":1589301489894},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1586829904799},{"_id":"source/images/0082zybply1gbqenlanqrj327f0u04gd.jpg","hash":"9f41da969aa0242ae9e0e645562b14e48d39dbb4","modified":1591258872751},{"_id":"source/images/56ab763273b2c03b2f1c37db7b150338414771.png","hash":"10995c179425878633d71e640aaa3230e2f32f76","modified":1590137565716},{"_id":"public/about/me.html","hash":"3e3c90c77607d0e965dc83c1a8c71ed969a82d20","modified":1594087488731},{"_id":"public/java/schedule.html","hash":"50583b52d2f23247bccd5d1f91e2577d02faaaae","modified":1594087488731},{"_id":"public/2020/07/02/sql/MySQL-InnoDB-MVCC多版本并发控制/index.html","hash":"202f66d074d5e586a16dc75c56ea98b2e4077df8","modified":1594087488731},{"_id":"public/2020/07/01/linux/openssl 生产RSA密钥对/index.html","hash":"400f160ae6d01523ba15babde4b09d2970241e63","modified":1594087488731},{"_id":"public/2020/06/04/java/JDK 监控和故障处理工具总结/index.html","hash":"bf2c97fb6b528b73d63d24d13179b9dc1a1016b0","modified":1594087488731},{"_id":"public/2020/06/04/sql/Mysql分库分表方案/index.html","hash":"1a8b6935aa31c76d6f9fdda0e6d6ed8ecff98905","modified":1594087488731},{"_id":"public/2020/06/04/microservices/dubbo连接数配置引发的问题/index.html","hash":"9959e6b7737851276c787230033064ac0f23e883","modified":1594087488731},{"_id":"public/2020/06/03/sql/btree索引/index.html","hash":"ec363ae0ebce9976cb16124778d4c68da4d46589","modified":1594087488731},{"_id":"public/2020/05/26/project/热点账户/index.html","hash":"ed24db4d6ebbdc4f0620c3869783a1e19cec3cb5","modified":1594087488731},{"_id":"public/2020/05/26/java/JVM 垃圾回收/index.html","hash":"1a720f255d0dc9a7c463d5e535032bc3ede1e49c","modified":1594087488731},{"_id":"public/2020/05/26/java/java-memory/index.html","hash":"260740aa10dd496c8887d767a6b4e93547f6160c","modified":1594087488731},{"_id":"public/2020/05/22/java/Java-thread-pool/index.html","hash":"bd6bfba10d98e76a089ec6a0f8c5160f6c99c3ca","modified":1594087488731},{"_id":"public/2020/05/22/java/java-syc-AQS/index.html","hash":"ea3ba70d0aa658365eaa82687c0df95ef705396a","modified":1594087488731},{"_id":"public/2020/05/20/java/IO-NIO/index.html","hash":"9036fab189a41f4372f5f519effa4730874c0e24","modified":1594087488731},{"_id":"public/2020/05/20/java/IO-NIO-reader-line/index.html","hash":"c6ee77842e88bbe1e7e67b409c80b016f79c2575","modified":1594087488731},{"_id":"public/2020/05/13/java/thread-forkJoin/index.html","hash":"4d9d65a9e9766ba49e7dad219f452a4615555b02","modified":1594087488731},{"_id":"public/2020/04/27/java/disruptor/index.html","hash":"87b24dc42c3e0cf5ed633f0d5785cca580f1d85c","modified":1594087488731},{"_id":"public/2020/04/27/hello-world/index.html","hash":"5170b4d121dcd5d641c30c5bb94f33a4d753b3f6","modified":1594087488731},{"_id":"public/2020/04/27/java/schedule/index.html","hash":"820fab8588c16a706da9a9a864940cfc0638316b","modified":1594087488731},{"_id":"public/2020/04/15/project/open-api/index.html","hash":"c9e149f19e86e9d9edc189707a2296f50fb4d429","modified":1594087488731},{"_id":"public/2020/04/15/spring/spring/index.html","hash":"2621239c8a5dbff62646de746a4b691f59bf0bde","modified":1594087488731},{"_id":"public/2020/04/15/sql/认识MYSQL/index.html","hash":"5fa13dfd4869a590b2649d0dc82ee548446eea03","modified":1594087488731},{"_id":"public/2020/04/15/sql/sql/index.html","hash":"2b4a7f6910a64a6e7523b8f56d109b2f433cdf7e","modified":1594087488731},{"_id":"public/2020/04/15/server/server/index.html","hash":"8e744d667fed3a2dbe1a5dfc7c1331182bcd302d","modified":1594087488731},{"_id":"public/2020/04/15/project/project/index.html","hash":"6f91eb1ef987979b968b3eddca8ce07eb8e66476","modified":1594087488731},{"_id":"public/2020/04/15/packageManager/packageManager/index.html","hash":"68b5f397927bd0ac86283f2186c9f182221ec6c6","modified":1594087488731},{"_id":"public/2020/04/15/orm/orm/index.html","hash":"d60198510fdb6d3d49b43b2a435cb5d0d09dcc1a","modified":1594087488731},{"_id":"public/2020/04/15/microservices/microservices/index.html","hash":"8ea35b24b511dfc60bf1cfd59584f17aa167eeca","modified":1594087488731},{"_id":"public/2020/04/15/middleware/middleware/index.html","hash":"c00873b035f56f8ed2310ac9ad8c80bacf6390f4","modified":1594087488731},{"_id":"public/2020/04/15/blockChain/blockChain/index.html","hash":"01aed3ab7c52cc350a863793f08fe3638d409552","modified":1594087488731},{"_id":"public/2020/04/15/algorithms/algorithms/index.html","hash":"ef21c1c98af42f94023acffe52387db1fb36bf09","modified":1594087488731},{"_id":"public/2020/04/15/linux/linux/index.html","hash":"d721e54356df86b62d571a0eef27e4710a2f5d34","modified":1594087488731},{"_id":"public/2020/04/15/about/me/index.html","hash":"d641ac894442d6e8f400e3dffecc6d18d5b9cd4e","modified":1594087488731},{"_id":"public/2020/04/15/java/collection/index.html","hash":"7c45eeca8e33d25d736149a145bc4475f3c2ec71","modified":1594087488731},{"_id":"public/2020/04/15/java/jvm/index.html","hash":"4f9dbc3f68422f07638640c1e407195a8dac9c60","modified":1594087488731},{"_id":"public/2020/04/15/java/proxy/index.html","hash":"9265a5554c5f2be9cdb5ca06a8fca5f090067fd4","modified":1594087488731},{"_id":"public/2020/04/15/java/j2ee/index.html","hash":"458cdd21926b4b295f5e01b2de70a7174badaccf","modified":1594087488731},{"_id":"public/2020/04/15/java/thread/index.html","hash":"7213f4b095d7cd7d0e4f3082ab10054972ffd669","modified":1594087488731},{"_id":"public/2020/04/15/java/jdk8-function-lambda/index.html","hash":"2d90d5477b982c800f4cc2e877cdcb0096e9ef35","modified":1594087488731},{"_id":"public/2020/04/15/java/Java/index.html","hash":"3bde11ecbd66f7d3a657e2931f0cc4a1da56cfdd","modified":1594087488731},{"_id":"public/archives/index.html","hash":"2e18e456940ddd0e390867c91a83558128bd118f","modified":1594087488731},{"_id":"public/archives/page/2/index.html","hash":"4ede6eaff46241fde18d9fabf99412beec5ee60e","modified":1594087488731},{"_id":"public/archives/page/3/index.html","hash":"046597b53e74c7d78e12af6df6a7cee5f05d7243","modified":1594087488731},{"_id":"public/archives/page/4/index.html","hash":"02f061dc07e581f6f76387cacffafe2006e1f787","modified":1594087488731},{"_id":"public/archives/2020/index.html","hash":"f49b84b6596c519fa39200cf8bcb5418f1d56ba7","modified":1594087488731},{"_id":"public/archives/2020/page/2/index.html","hash":"27cad4b529734924433eec6991bdec5867a44b04","modified":1594087488731},{"_id":"public/archives/2020/page/3/index.html","hash":"4209274b20b5da65a809a158761babdb79fefb0e","modified":1594087488731},{"_id":"public/archives/2020/page/4/index.html","hash":"18402303a0d64c944bf38f4cb09cd9f20dd0d080","modified":1594087488731},{"_id":"public/archives/2020/04/index.html","hash":"b622f4ec7887af27f1d4d0285f984588f7f1bc45","modified":1594087488731},{"_id":"public/archives/2020/04/page/2/index.html","hash":"460d1d5156ae22a288fb94af578bf1d845275102","modified":1594087488731},{"_id":"public/archives/2020/04/page/3/index.html","hash":"eefc212ceda4d85e868339b3fb1d99596b6b145b","modified":1594087488731},{"_id":"public/archives/2020/05/index.html","hash":"d827974db0799a9df0ea3e3010487451e802f592","modified":1594087488731},{"_id":"public/archives/2020/06/index.html","hash":"2a808a8579037e31c6aec7982ee3ca4c93483024","modified":1594087488731},{"_id":"public/archives/2020/07/index.html","hash":"bf12e4b1a6a99dfb2a391d217ac9699b144626e4","modified":1594087488731},{"_id":"public/categories/java/index.html","hash":"b22ec0797a6cd7fa49c1825a8d6f2c3fc6779249","modified":1594087488731},{"_id":"public/categories/java/page/2/index.html","hash":"7cc455ea983f80b6f92f5f2ad2fb18056537de44","modified":1594087488731},{"_id":"public/categories/区块链/index.html","hash":"cccbc6b71fdb9325a1112b27553e7dc4c3da0d05","modified":1594087488731},{"_id":"public/categories/java/j2ee/index.html","hash":"77a5c6bb2dd3ce2c4ddbdd21871a73dd266f5ab5","modified":1594087488731},{"_id":"public/categories/java/collection/index.html","hash":"d736dbb3b8f89e646ac09b0a06f1c7a8e3c953af","modified":1594087488731},{"_id":"public/categories/java/jdk8/index.html","hash":"9b1eba8ecaef4ecdea8c248f39c0f57e5cae25c6","modified":1594087488731},{"_id":"public/categories/java/jvm/index.html","hash":"5e18145eeef3636c102c4dc892560f798c7a2992","modified":1594087488731},{"_id":"public/categories/区块链/blockChina/index.html","hash":"9069c2a18a5d7eadc7ed9b768334db563dcedd46","modified":1594087488731},{"_id":"public/categories/java/proxy/index.html","hash":"2ae915d8e8a514ae60998a8308a01fdbd842ef91","modified":1594087488731},{"_id":"public/categories/java/thread/index.html","hash":"cb4dfe79d6ae66afb5dc788cd5daaa33806c4185","modified":1594087488731},{"_id":"public/categories/linux/index.html","hash":"739ecd7a34157b4b1359cc4ce20ba6f89bd7bdb5","modified":1594087488731},{"_id":"public/categories/分布式与微服务/index.html","hash":"48bf5e55008ae0b3cb5fa4d3dd8a4404a3a49458","modified":1594087488731},{"_id":"public/categories/中间件/index.html","hash":"b3c008a5efe213790bd3c33dc5403966f744dcf2","modified":1594087488731},{"_id":"public/categories/ORM/index.html","hash":"3a009aad77c856a9e27ee80ef7688a065947a8dc","modified":1594087488731},{"_id":"public/categories/包管理/index.html","hash":"837ca8f95029026fa6eca5d673f78f97843a7fa1","modified":1594087488731},{"_id":"public/categories/项目/index.html","hash":"156529e1e07295b5f5f3b59c834db80cf2b7a409","modified":1594087488731},{"_id":"public/categories/spring/index.html","hash":"119cc9b4789298d379a3e0cba8b86f928874f603","modified":1594087488731},{"_id":"public/categories/服务器/index.html","hash":"b127443b3f68fbd52547b0abe9dc2ccfddb0763a","modified":1594087488731},{"_id":"public/categories/数据库/index.html","hash":"6ddc87c47e51e0da7b007a2be4885fee9661eb5f","modified":1594087488731},{"_id":"public/categories/数据结构与算法/index.html","hash":"69ce589ba6fb5a56899a57eeabdb6ae9d940d749","modified":1594087488731},{"_id":"public/categories/linux/openssl/index.html","hash":"b2a5b43bf5c608334ea7f7352537e14b943a2d4d","modified":1594087488731},{"_id":"public/categories/linux/linux/index.html","hash":"314910dbea70a13685e7f7e94b246b0888e5cb94","modified":1594087488731},{"_id":"public/categories/分布式与微服务/microservices/index.html","hash":"3cbeb00cdd3af390dde363ce80221b7682f00d80","modified":1594087488731},{"_id":"public/categories/中间件/middleware/index.html","hash":"d50dd1aca74e379ea8b39ac843af59d7001979ad","modified":1594087488731},{"_id":"public/categories/ORM/orm/index.html","hash":"b344ee1ac9d06e9d38c2343a3a4ecf1a14ca02e7","modified":1594087488731},{"_id":"public/categories/包管理/packageManager/index.html","hash":"082acf48db22a51f1b38431fc6083553b4adb324","modified":1594087488731},{"_id":"public/categories/项目/project/index.html","hash":"7eabdb3c7b73bea366e925a15ca757dd35125845","modified":1594087488731},{"_id":"public/categories/spring/spring/index.html","hash":"dbb59b83ae5ec966d727a126eeee8341315abb27","modified":1594087488731},{"_id":"public/categories/服务器/server/index.html","hash":"519909e8693021897c10d5a6ff67334ef1a537f9","modified":1594087488731},{"_id":"public/categories/数据库/sql/index.html","hash":"9018a6574b0f111ec906967a4d02fdd3be3c692c","modified":1594087488731},{"_id":"public/categories/数据库/索引/index.html","hash":"be804f8d0be53ab4fb8be335ac7a2035840dd193","modified":1594087488731},{"_id":"public/categories/数据结构与算法/algorithms/index.html","hash":"876bb3e1ac428fc456faf644a703693f5824b1c6","modified":1594087488731},{"_id":"public/categories/java/jvm工具/index.html","hash":"591a95844d08c531782fde18961db76a53c24243","modified":1594087488731},{"_id":"public/categories/java/read-line/index.html","hash":"a3b64a7f17b1acfad42a71fe5ba2b00a9f1bc4f9","modified":1594087488731},{"_id":"public/categories/分布式与微服务/dubbo配置/index.html","hash":"667c57727317ecb1e65a228b35c2bb5c741e65fd","modified":1594087488731},{"_id":"public/categories/项目/Open-API/index.html","hash":"5d9e67c14c1d7eac9f1edbb21f1b6ca13f994a70","modified":1594087488731},{"_id":"public/categories/数据库/MySql/index.html","hash":"31c4dd10650a69c7df3f051fa6ba79c971a7da15","modified":1594087488731},{"_id":"public/categories/数据库/MySql/MVCC多版本并发控制/index.html","hash":"bfd647cf3b2d0876c6963db4d03622d4ed98854f","modified":1594087488731},{"_id":"public/categories/java/IO-NIO/index.html","hash":"02651b31d4c38fab76efbf1cfbc8bebbc7489156","modified":1594087488731},{"_id":"public/categories/java/schedule/index.html","hash":"cd9d77123e722a43fa90309a01c105567fc43db0","modified":1594087488731},{"_id":"public/categories/数据库/MySQL/index.html","hash":"3c77b818d14a549300dd94ab7ab47492907c4aff","modified":1594087488731},{"_id":"public/categories/java/collection/queue/index.html","hash":"3b28d6c80fcf8908f6f208fd48bfefd9906385b5","modified":1594087488731},{"_id":"public/categories/java/memory/index.html","hash":"756a159770080c9ecd53a414dbcb68e87808492d","modified":1594087488731},{"_id":"public/categories/数据库/分库分表方案/index.html","hash":"53a61718d0ecb42e8ea39cbc01838e4565a1fc01","modified":1594087488731},{"_id":"public/categories/java/collection/queue/disruptor/index.html","hash":"fc4a9f4a66392e48182e86f2893c95039a5dfb22","modified":1594087488731},{"_id":"public/categories/java/memory/garbage/index.html","hash":"dc1d9c1e23b66028ed7c7b57a38047680d159807","modified":1594087488731},{"_id":"public/categories/java/concurrent/index.html","hash":"d595045e682f9d356ef6d7074571ef9bbdf62198","modified":1594087488731},{"_id":"public/categories/java/thread-pool/index.html","hash":"5509ef3853197ac4e2f655230515e320a4a993c3","modified":1594087488731},{"_id":"public/categories/java/concurrent/AQS/index.html","hash":"8cef44ac8c9fc8abd17a0f072a336c1d44a2ec3c","modified":1594087488731},{"_id":"public/categories/java/thread/fork-join/index.html","hash":"ea26402e58fdf3fbbb395353d439c104e639d73d","modified":1594087488731},{"_id":"public/index.html","hash":"12be025bd6dc6700a41280fea9d9c39b1f89bf1e","modified":1594087488731},{"_id":"public/page/2/index.html","hash":"44a5075ad57b8992718acd7fb38da77a375be4a1","modified":1594087488731},{"_id":"public/page/3/index.html","hash":"3c1f4effadcb076121398f4f9a3ccfcc0f6939cd","modified":1594087488731},{"_id":"public/page/4/index.html","hash":"bebb555c52379c1df995c228a1a35ce04efb9ab8","modified":1594087488731},{"_id":"public/tags/java/index.html","hash":"ca65ef5e5a49b8af35ac26cdc35f119e6be1ed7f","modified":1594087488731},{"_id":"public/tags/java/page/2/index.html","hash":"ac208c1d2ae53bb33297a8b6f6197d5f034a8b96","modified":1594087488731},{"_id":"public/tags/区块链/index.html","hash":"ece9ce3d4b19248374c986f464df709e1b909615","modified":1594087488731},{"_id":"public/tags/jdk8/index.html","hash":"e61077a68ee58d189588947edcf54ff03c8b7735","modified":1594087488731},{"_id":"public/tags/lambda/index.html","hash":"39e65477b7a4e9e9314122ee9b62486252b9c172","modified":1594087488731},{"_id":"public/tags/function-函数式编程/index.html","hash":"657aa17617bb0a39471851553853304c28245961","modified":1594087488731},{"_id":"public/tags/proxy/index.html","hash":"d44a29e1e7378b24f9f27c4cc6e2e310ffebc58c","modified":1594087488731},{"_id":"public/tags/javassist/index.html","hash":"77e145ed2f0cf236fb4a34c35508b1ffa779acc1","modified":1594087488731},{"_id":"public/tags/jdk-动态代理/index.html","hash":"713430ac9c6afce4a2db1351f477fa7b8cf5060c","modified":1594087488731},{"_id":"public/tags/cglib-动态代理/index.html","hash":"5530353768fb4cde59d3d6786bd22c1bb7aa7f65","modified":1594087488731},{"_id":"public/tags/thread/index.html","hash":"673cec08cf77872084bb7791f793135351219f6f","modified":1594087488731},{"_id":"public/tags/synchronized-lock/index.html","hash":"abfc4049b6b9bfff218a958f89de0eb3f1a7f889","modified":1594087488731},{"_id":"public/tags/ThreadPoolExecutor/index.html","hash":"f98edf769cad4998a092fad052ab73ac7e794025","modified":1594087488731},{"_id":"public/tags/fork-join/index.html","hash":"df327a9680e2a07c94c0bad2bfb61a6b6faad4c4","modified":1594087488731},{"_id":"public/tags/schedule/index.html","hash":"b3e8372f678f119e607b0225e2b177063cfac22a","modified":1594087488731},{"_id":"public/tags/linux/index.html","hash":"cf13e92a52746443eb6aadbf50b423117b4ac99a","modified":1594087488731},{"_id":"public/tags/openssl/index.html","hash":"ff7eaa21a07d957dcc7070e566c71ca001fa091f","modified":1594087488731},{"_id":"public/tags/分布式与微服务/index.html","hash":"52b6d2bd90d3ce0d7de98005c5802e163e9e96ba","modified":1594087488731},{"_id":"public/tags/中间件/index.html","hash":"7c50e467eb670f432ad25fcc8481a67e876127ec","modified":1594087488731},{"_id":"public/tags/ORM/index.html","hash":"c120d3e09a7a5d2a740fe81dcb89331b07eec41e","modified":1594087488731},{"_id":"public/tags/包管理/index.html","hash":"0f637d4414843a4d4798fba216ebd24ca50805ca","modified":1594087488731},{"_id":"public/tags/项目/index.html","hash":"98f5d5cbd35a764439b700318090ab4d7c860164","modified":1594087488731},{"_id":"public/tags/spring/index.html","hash":"fc5da32bc20d0581022a6c61a9fd037538d7a94f","modified":1594087488731},{"_id":"public/tags/服务器/index.html","hash":"07da9cc0ce14aa12960634ffd39bc9b8b6d7d9d6","modified":1594087488731},{"_id":"public/tags/数据库/index.html","hash":"49ca7fa28758af47e6065df8c8cfb2cb76360b33","modified":1594087488731},{"_id":"public/tags/b-tree/index.html","hash":"8bafb899b7bc11ce2a9f93ebe9335dfb371dfe8d","modified":1594087488731},{"_id":"public/tags/数据结构与算法/index.html","hash":"b6aad8613d98f679ecc8e31d528f8af6699aed59","modified":1594087488731},{"_id":"public/tags/jvm工具/index.html","hash":"cb91c3de9b9260ba5aa7ceb3e2f25e33789bc0d3","modified":1594087488731},{"_id":"public/tags/io/index.html","hash":"96ead622bb7180d61dc348b6205a5bd2e80f3d35","modified":1594087488731},{"_id":"public/tags/nio/index.html","hash":"20993ca924396a4f17f8f8b30186342777aaee27","modified":1594087488731},{"_id":"public/tags/dubbo-配置/index.html","hash":"fac130768db1c4b225aaf1186ead9739cd8b7d17","modified":1594087488731},{"_id":"public/tags/MySql/index.html","hash":"f146700cabc163a243a8319b1904124215a0611d","modified":1594087488731},{"_id":"public/tags/MVCC多版本并发控制/index.html","hash":"e80f0d6228d48c412207c4280741ae4e66481580","modified":1594087488731},{"_id":"public/tags/MySQL/index.html","hash":"78c5fb14f5f8cf6a3bcdcea050dc2c36e8967dec","modified":1594087488731},{"_id":"public/tags/collection/index.html","hash":"10e5ce609c85f00585497433dec1803a1a965ba0","modified":1594087488731},{"_id":"public/tags/disruptor/index.html","hash":"3fdc88005cdd01e8c5fb502884359640d2ab21c4","modified":1594087488731},{"_id":"public/tags/队列/index.html","hash":"47009bddc2f8b1623c3f6b32f778d22f301c94a4","modified":1594087488731},{"_id":"public/tags/memory/index.html","hash":"cd73e3c54a3961241890fce9afc2bd9c86bbaa73","modified":1594087488731},{"_id":"public/tags/分库分表方案/index.html","hash":"1ce8c4362edc16030177bfc3bbfdec41c10824e0","modified":1594087488731},{"_id":"public/tags/garbage/index.html","hash":"f796c9789cd9909f1c541250e12e0df3f8ca2cf2","modified":1594087488731},{"_id":"public/tags/concurrent/index.html","hash":"3473af3f78e1f981c3a42bad5338bec50975c378","modified":1594087488731},{"_id":"public/tags/AQS/index.html","hash":"ea9600f4edfa0bac3c10b32c08ade4bb4595ef46","modified":1594087488731},{"_id":"public/tags/thread-pool/index.html","hash":"a92e963b29fcd6ad21e22c1c403a068fea6ea726","modified":1594087488731},{"_id":"public/images/0082zybply1gbr8va8yvhj30hm0ck3z8.jpg","hash":"3a12ad7c74fe9b98c8e989c237d7e5c60e7fb2df","modified":1594087488731},{"_id":"public/images/031383336382e6a7067.png","hash":"55d039592453799ee7fae2fe02bd8d11b8eb723e","modified":1594087488731},{"_id":"public/images/032362e6a7067.png","hash":"8cfea6119a4b0df0174723071898a3f293284df2","modified":1594087488731},{"_id":"public/images/125453725.png","hash":"a7b70a6523d955f54959e381a610921f6689a48d","modified":1594087488731},{"_id":"public/images/1a1746f33bfdcb03da074d8539ebb2f367563.png","hash":"3fca02c8a93e95f30a5800205f318823fa851f47","modified":1594087488731},{"_id":"public/images/1df932840b31f41931bb69e16be2932844240.png","hash":"7bdf23635f898212c35938157a2048a24aaf7059","modified":1594087488731},{"_id":"public/images/20151231233806229.png","hash":"5dee9dafc6c0c1993c1fb42232c8938d2ef4013b","modified":1594087488731},{"_id":"public/images/20160103223150042.png","hash":"ed5593fb27a1f786c9fbde493d6e0b3051c6f64f","modified":1594087488731},{"_id":"public/images/20200702382545352.png","hash":"4de161b87184364a5b8291a20118683812821c37","modified":1594087488731},{"_id":"public/images/20200604161006.png","hash":"a901564dc79476710ba1b5ebcf86a872dba61892","modified":1594087488731},{"_id":"public/images/25453525.png","hash":"ac7bc8e1bf79465c8e9eb247db5ed22d99ac406f","modified":1594087488731},{"_id":"public/images/25453625.png","hash":"f82616946731abd8d1f1ac9bac82432edaaa3f5f","modified":1594087488731},{"_id":"public/images/33343235392e6a7067.png","hash":"1357a9acdcd74ce14627ee69ad4ee989b97f867e","modified":1594087488731},{"_id":"public/images/335302e6a7067.png","hash":"1807be697376ebaa4dfdcf9c3137c76734e2f920","modified":1594087488731},{"_id":"public/images/34392e6a702267.png","hash":"7738b19f8c0b9d520392ab88cfd38c1c60a7ff3e","modified":1594087488731},{"_id":"public/images/34392e6a7067.png","hash":"6de2a0dce9904791a312a91718a22cd3e4cf33aa","modified":1594087488731},{"_id":"public/images/453525.png","hash":"d01eebe435cc53fd539818975ea4663ccad4338d","modified":1594087488731},{"_id":"public/images/4537.png","hash":"d009d8452a109995494a15c373fa76d3c4053d92","modified":1594087488731},{"_id":"public/images/4d5c410ad23782350cc9f980787151fd54144.png","hash":"1a186fbb50ca9cabef65728197f6215c5a5d4550","modified":1594087488731},{"_id":"public/images/525453525.png","hash":"ff1fd504d71522128df23c32c600c27f861096d3","modified":1594087488731},{"_id":"public/images/525453625.jpg","hash":"b213a1963be7fc5f55dfa4ad1b1ed010d337c1bf","modified":1594087488731},{"_id":"public/images/582d1606d57ff99aa0e5f8fc59c7819329028.png","hash":"e8b2219d72495f0ce181267012eda4bfa0ab56cc","modified":1594087488731},{"_id":"public/images/5a086e7bb93e69e842e706e67.png","hash":"4c217d7770502e559ee8bf0aade7b24e82e62a90","modified":1594087488731},{"_id":"public/images/5911899802886.png","hash":"c0cba092f65031db3e7d9ca38e5249dc75813f68","modified":1594087488731},{"_id":"public/images/24a6176.png","hash":"9a45cdd0ecf41e7ab2045d3113ffcf18405a3d35","modified":1594087488731},{"_id":"public/images/625.jpg","hash":"d4e8014839817faa5ca2ae3759946a9880fd4f93","modified":1594087488731},{"_id":"public/images/68747470.png","hash":"0315fc5140881cbd3edb960a78df3d9fe45dc75c","modified":1594087488731},{"_id":"public/images/879edb4f06043d76cea27a3ff358cb1d45243.png","hash":"666a6c1afe503a1f423f98ab9a2a0ef9c8a5ad4c","modified":1594087488731},{"_id":"public/images/90ea093549782945f2c968403fdc39d415386.png","hash":"b0c998e7ca7f6894a1a024080e344ca73ec24436","modified":1594087488731},{"_id":"public/images/912883e51327e0c7a9d753d11896326511272.png","hash":"760736a96e81c75278cee92fec4ac0cea4e1044f","modified":1594087488731},{"_id":"public/images/96e65732e706e67.png","hash":"7aeff2c2e61fd7cf0ff62cc17ce17bae0bd80dbc","modified":1594087488731},{"_id":"public/images/9d8dc9cebe59122127460f81a98894bb34085.png","hash":"94aa10857d5caec527636002fea0c32d0223840e","modified":1594087488731},{"_id":"public/images/a6176.png","hash":"9a45cdd0ecf41e7ab2045d3113ffcf18405a3d35","modified":1594087488731},{"_id":"public/images/c6caa5be64f39758ada0593b995d65fd25982.png","hash":"0fbc41534084a1b503d301724ac4733f0e64e251","modified":1594087488731},{"_id":"public/images/e9a363c8577f211577e4962e9110cb0226733.png","hash":"a3f29d568d21fbaeefe56090c92aa4c6145099e1","modified":1594087488731},{"_id":"public/images/f4d89c87acf102b45be8ccf3ed83352a9497.png","hash":"3c1b843f8b28d88448453610b07b26ba9a514d8a","modified":1594087488731},{"_id":"public/images/forkjoin_任务拆分.png","hash":"3721c728c26bdf6000c427c01fe6e5908af4d828","modified":1594087488731},{"_id":"public/images/java-memory-g.jpg","hash":"e6291736e6294fa3b4a58d1678a87105238366dc","modified":1594087488731},{"_id":"public/images/java-memory-g8.jpg","hash":"65bf31c0c1a2e21423a4d1c3594623abc6988058","modified":1594087488731},{"_id":"public/images/java-memory-mallock.png","hash":"a51f827b1bb1517e193a78004d00908e7b0437b9","modified":1594087488731},{"_id":"public/images/54546254.png","hash":"9303b987c671d17121f9fd744c3dd73b5fd76ecc","modified":1594087488731},{"_id":"public/images/java-memory-obj-create.png","hash":"cfe3971735f73a833fb49c67f7ca7a57e22ceb2a","modified":1594087488731},{"_id":"public/images/reduceTask-类图.png","hash":"954e1ff05b583e8b5034ea88e92eb5e8f1aaf51a","modified":1594087488731},{"_id":"public/images/v2-26e9c6b2d131c19e25d7283f37940ae1_720w.jpg","hash":"81f463286d658d37562cd5d874a7dd7c792a3ab2","modified":1594087488731},{"_id":"public/images/v2-104267f964da011318238d357f05bb6c_720w.jpg","hash":"86459087839eadea91e6f6b3e9660e3d88671a9c","modified":1594087488731},{"_id":"public/images/v2-73771a9cec11fc86e5aa0145885b05c8_720w.jpg","hash":"1ff1cc9040e207aa358274ef3338d9f73a2d8e39","modified":1594087488731},{"_id":"public/images/v2-73c1d9300839c0ee560c9bfcc685d653_720w.jpg","hash":"14b357a3bfa2a1464c9acabc28094b709a04ac3e","modified":1594087488731},{"_id":"public/images/v2-432781b10f8582f5bf192e1a050e99a1_720w.jpg","hash":"a36eb2b3a31ac8f819299b77b045513868f7412e","modified":1594087488731},{"_id":"public/images/v2-86d44b4b844c130414c4653f215ec149_720w.jpg","hash":"88c65748cce54914ba82c9a0710c59e69edd535a","modified":1594087488731},{"_id":"public/images/v2-b8854e3034ce49c2f8d652394c2328ac_720w.jpg","hash":"d605ba3600cdb840d7617e12f8b2c9499cca9e44","modified":1594087488731},{"_id":"public/images/v2-c431ecdd67246b4e7745d58155d4e64d_720w.jpg","hash":"ecb417a662582af72512b9ab00c474f729a65e46","modified":1594087488731},{"_id":"public/images/v2-c526027f5f2dae54753239d5d9bd277b_720w.jpg","hash":"f36393f144fd388a8ff99b693a95b519e19c1510","modified":1594087488731},{"_id":"public/images/v2-c52ddb056dbd39595e7c6f5b2c4fb3b5_720w.jpg","hash":"beaa389853380bad9f4f811a8ec79b68c338cdb7","modified":1594087488731},{"_id":"public/images/v2-cdca1f51c4a3bef0b30221a947144bdd_720w.jpg","hash":"06f0e2960201d177c4945b716769cbe95b61fb19","modified":1594087488731},{"_id":"public/images/v2-f9315b646c72eb17564ebc0507458b14_720w.jpg","hash":"4cb78040e7f0002489094b5096b9c4529e15b3da","modified":1594087488731},{"_id":"public/images/实际的请求.png","hash":"8c8dc9bedb249c32fcbb9b84a9edb1d6b7354bed","modified":1594087488731},{"_id":"public/images/授权图.png","hash":"c53271422e6eec963cdb3a932e9fa7fc5e50d8db","modified":1594087488731},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1594087488731},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1594087488731},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1594087488731},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1594087488731},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1594087488731},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1594087488731},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1594087488731},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1594087488731},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1594087488731},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1594087488731},{"_id":"public/images/0082zybply1gbq4mytke2j31gw07279o.jpg","hash":"edd20514c3d4db257469164bc91b831f935871e7","modified":1594087488731},{"_id":"public/images/0082zybply1gbq3z7a7mmj31nq074qat.jpg","hash":"14d9c464dcb0a4f205843f884f1627a46d16cb7c","modified":1594087488731},{"_id":"public/images/0082zybply1gbqenjpogfj30ph05zdgv.jpg","hash":"6297fd4072d314ce23ddbb67efeaf27bc4e3e97c","modified":1594087488731},{"_id":"public/images/1383336382e6a7067.png","hash":"55d039592453799ee7fae2fe02bd8d11b8eb723e","modified":1594087488731},{"_id":"public/images/1a1742222.png","hash":"5bf935061ed8656bb028f9e0c9183f72e999744e","modified":1594087488731},{"_id":"public/images/238312e6a7067.png","hash":"d07b2ec8782f6fd0200db0848930259a6c3acbec","modified":1594087488731},{"_id":"public/images/20200604162924.png","hash":"b131f9f0f00779944f819120dbfecef4a08b9866","modified":1594087488731},{"_id":"public/images/31bad766983e212431077ca8da92762050214.png","hash":"2c0de451e4d4489fbeba8678649cd1f8310a7a73","modified":1594087488731},{"_id":"public/images/383738352e6a7067.png","hash":"1e2f73eedc98eeff4df99c4d548e27659dc3a058","modified":1594087488731},{"_id":"public/images/668e3c90f4b918bfcead2f4280091e9757284.png","hash":"dbee066e040141b957ea66fe39e587ffef26c502","modified":1594087488731},{"_id":"public/images/687474703a.png","hash":"f1cff3f1a467637476bdae823ead66f50648d225","modified":1594087488731},{"_id":"public/images/842254537.png","hash":"d8a2b51a5a58033b8f76970ab57ab8a74e3c2754","modified":1594087488731},{"_id":"public/images/e6a7067.png","hash":"39f41f42c8d3e175397c479e2b8d8d8bfddbb327","modified":1594087488731},{"_id":"public/images/getmint_20200427144736.png","hash":"879734f8a1873b85a05d8628d118e0b591f757af","modified":1594087488731},{"_id":"public/images/java-memory-str-constant.png","hash":"1ceea6d76c003310da10a4cce5be1796294f1eb3","modified":1594087488731},{"_id":"public/images/thread-pool.png","hash":"56158822d1748d09df256b6fbb0cc194279bb261","modified":1594087488731},{"_id":"public/images/nio-buffer.png","hash":"e724e9416ad18d8c4eab363b8e94bbab81ea823a","modified":1594087488731},{"_id":"public/images/nio-channels.png","hash":"522fa8d62503a9ac2e1945468f41f0c2123fdfef","modified":1594087488731},{"_id":"public/images/java_time_task.png","hash":"ee743a48922fa17710c2dcfe53ef546a423d2c02","modified":1594087488731},{"_id":"public/images/v2-373b769b0466f324fd0553f5074d1b37_720w.jpg","hash":"26356e9e2b707ceb65808dffca166b74cba02f9b","modified":1594087488731},{"_id":"public/images/v2-31eb992f13d3222fcfc4cd222158a702_720w.jpg","hash":"66199e99d026af98aac64fc11558f79ac49a95c0","modified":1594087488731},{"_id":"public/images/java-memory-str-new.png","hash":"d743fe4731c53b928ba308a9abda8dc848e41324","modified":1594087488731},{"_id":"public/images/v2-65d90f64aa52be10b9bdc1b8042e9e31_720w.jpg","hash":"eb9b9c989bf78a779e3ef10e406c6fbd0183b370","modified":1594087488731},{"_id":"public/images/v2-60336a35f872a24562326304943292b9_720w.jpg","hash":"c0170b1e9989939b750ff5d112e1dbd4d6ad3dfc","modified":1594087488731},{"_id":"public/images/v2-ae88013d0531eac5ebc96fad2e4f8594_720w.jpg","hash":"544cb1837f5a72fe28026a25d5aea03c48a18b17","modified":1594087488731},{"_id":"public/images/v2-94c4670cb6b6099055a5146f1a034b9b_720w.jpg","hash":"67c3d5a509c450ce9e32fe4e329fb4af8a9321ab","modified":1594087488731},{"_id":"public/images/v2-9f56d1d058e3a87a8c6be5b58696f14b_720w.jpg","hash":"1465fba8602bf1894e2fb3b7f8abf24e6301a6eb","modified":1594087488731},{"_id":"public/images/25453525.jpg","hash":"d2ad4fd0a5b2c9288b19d845b3b30ba2cd9e0d26","modified":1594087488731},{"_id":"public/images/v2-eb03c274f799a5147abc23bb99a56b4c_720w.jpg","hash":"5c8090d46660bc87912e818dda4ce26cfa30640d","modified":1594087488731},{"_id":"public/images/v2-fe9119746d34b5396e48eac6ecd16746_720w.jpg","hash":"e86124e8ea9fe8957f7954eb26943fa907fea906","modified":1594087488731},{"_id":"public/images/0082zybply1gbq3md7d15j30m90cb43g.jpg","hash":"8179fde03e012567cb709a62624fc5431052196a","modified":1594087488731},{"_id":"public/images/0082zybply1gbpy5n5wfuj31m6078wp5.jpg","hash":"139e68089f91aaa4ee1f8d9e21f82a3daaa41423","modified":1594087488731},{"_id":"public/images/0082zybply1gbqenluvenj30rz0hsjv2.jpg","hash":"1fc3f61d3f35694f7ddcc098c2e4657466baa4cc","modified":1594087488731},{"_id":"public/images/0082zybply1gbqenq2xc6j31820cs76u.jpg","hash":"9c6b1ff4a729755ff689195070d1b047fb9e3a9d","modified":1594087488731},{"_id":"public/images/03268b9dc49bd30bb63064421bb036bf90315.png","hash":"b0c262b8fac8719b16e48d682eda551c502e0a0b","modified":1594087488731},{"_id":"public/images/20151231232508924.png","hash":"3ed94de305a8530929afeabdd86c0c2d7ede68fc","modified":1594087488731},{"_id":"public/images/20160103223436953.png","hash":"971a393d09b88bcf0d44718ccbce4e4e1bc23a5c","modified":1594087488731},{"_id":"public/images/3832353037392e6a7067.png","hash":"a75db0e6eb14bd3175c18ed75c3381d9ecd0fa54","modified":1594087488731},{"_id":"public/images/49d8041f8480aba5ef59079fcc7143b996706.png","hash":"35e854f54bf0d82929391a286f864eecbfce5eb3","modified":1594087488731},{"_id":"public/images/9379fe1666818237f842138812bf63bd85645.png","hash":"bb3c7f4e7a804107370b6f0fc4e5474968c071dd","modified":1594087488731},{"_id":"public/images/MVCC多版本并发控制.png","hash":"f5cea2b15c963fbb8aaddfaf76f8d42d27d68c0b","modified":1594087488731},{"_id":"public/images/MVCC多版本并发控制.xmind","hash":"a3985c85c3846ccdc4a8f3d2cbdc31c39c3ae99c","modified":1594087488731},{"_id":"public/images/efd32f1211e9cf0a3ca9d35b0dc5de8588353.png","hash":"fbc0856d57d029002d0f477090119f241492b90f","modified":1594087488731},{"_id":"public/images/forkjoin_工作窃取（双端队列）.png","hash":"aec7d59935c478457f278fb8067889b3796f2c89","modified":1594087488731},{"_id":"public/images/io.png","hash":"1ecf71a3d7e34dc6e795253af7ccee75fbe3a725","modified":1594087488731},{"_id":"public/images/java-memory.png","hash":"ad04409d1de7cdbb01b3fc6a8b7368ef80f5d80b","modified":1594087488731},{"_id":"public/images/java-memoryjdk8.png","hash":"dda2bfe438c8055100d16d9d7a132b43706e605d","modified":1594087488731},{"_id":"public/images/关系模型.png","hash":"ea5cc6af49fcfdebc8043110c4614dc7815fdb2c","modified":1594087488731},{"_id":"public/images/0082zybply1gbqenpjnt7j30yq0higpo.jpg","hash":"c8efaeb39dec74dab92b3b15ed06da5dd0e82905","modified":1594087488731},{"_id":"public/images/架构.png","hash":"7abeb879caae31427083894e67e82b91aaf27562","modified":1594087488731},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1594087488731},{"_id":"public/images/v2-ddda0732607e2bcb365960c675e0dc71_720w.jpg","hash":"494cc4af253d87614ebfea0490155207ca84564d","modified":1594087488731},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1594087488731},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1594087488731},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1594087488731},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1594087488731},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1594087488731},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1594087488731},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1594087488731},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1594087488731},{"_id":"public/images/0082zybply1gbqennntwoj30sg0fswhn.jpg","hash":"d1849d5a02b8e20d081aebe1f7ded8eb64123cc8","modified":1594087488731},{"_id":"public/images/414ba7f3abd11e5f805c58635ae10988166121.png","hash":"991cedb17c4b3f010a20ee05186544faf16f3c16","modified":1594087488731},{"_id":"public/images/20160308162237758.png","hash":"a6cb74a1b2b9af067db93a7d814de1175d6ea5ab","modified":1594087488731},{"_id":"public/images/aba8d9c09e6f054c7061ddd720a04a26147951.png","hash":"98c5e3d63e1864765b174120c4736313b317694b","modified":1594087488731},{"_id":"public/images/0082zybply1gbqenma2pxj31au0u044x.jpg","hash":"b249ed917fe7ee3bd797375445402c64bbb62f30","modified":1594087488731},{"_id":"public/images/38d5fbeaebd4998f3a30d44bd20b996f113233.png","hash":"7b72510519dab2536f29083bd71927f8297c3cd5","modified":1594087488731},{"_id":"public/images/6c0091e92e90f50f89fd83f3b9eb5472135718.png","hash":"b415d338edddade8784d4abf2073da41c110cb24","modified":1594087488731},{"_id":"public/images/java-memory-obj-direct.png","hash":"da8ab5b48b4189a9e59d3cf15413739ecf6ab159","modified":1594087488731},{"_id":"public/images/java-memory-obj-reference.png","hash":"da8ab5b48b4189a9e59d3cf15413739ecf6ab159","modified":1594087488731},{"_id":"public/images/0082zybply1gbqenooa0ej314i0u0tf3.jpg","hash":"4e8f0d5817b480f0893ca58b81ede9790e597ad6","modified":1594087488731},{"_id":"public/images/0082zybply1gbqemv4o7qj32780lkgrc.jpg","hash":"337e0e620ae547d347c53dffca26019a6f3a9b2a","modified":1594087488731},{"_id":"public/images/uasyderdi.png","hash":"0260fd5cb0a32939a29b49ad6e636be546cc085f","modified":1594087488731},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1594087488731},{"_id":"public/images/49527b1bb385f0f43529e57b614f59ae145454.png","hash":"0a074128e2ce0e5b4ecb9150840955c87d56f662","modified":1594087488731},{"_id":"public/images/0082zybply1gbpxzrh8q4j31mc0u0hdt.jpg","hash":"9094a5d9f6088d350ba2e9229ebe857a669ee545","modified":1594087488731},{"_id":"public/images/bV1IKzdae.png","hash":"46c7aca28b343ed654a9ffb6b2947acb73a19914","modified":1594087488731},{"_id":"public/images/cd0b9445c3c93a866201b7cfb24d2ce7214776.png","hash":"2aa653ffef16579745f10034f6a8e3d7658579a3","modified":1594087488731},{"_id":"public/images/04e73f7186a91d99181e1b5615ce9e4a318600.png","hash":"20d6ff6ee87bb71b567d7aa35d589302c1c128b3","modified":1594087488731},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1594087488731},{"_id":"public/images/23a44974ff68a08261fb675242b83648181953.png","hash":"e2f58f3b1100e92619e1a74107dc2d55ca285bde","modified":1594087488731},{"_id":"public/images/292888-20190913110608100-591376294.png","hash":"81c72625037f2c6de6f174dab59340be8714b5d7","modified":1594087488731},{"_id":"public/images/9ffb64cc4c64c0cb8d38dac01c89c905178456.png","hash":"ddcff2297b29df91df06355ee2c64e46903e9fd6","modified":1594087488731},{"_id":"public/images/292888-20190913111130827-1005682912.png","hash":"93e9dc44fdca0337500b3070e416afb22deb0586","modified":1594087488731},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1594087488731},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1594087488731},{"_id":"public/images/292888-20190913110836624-260052587.png","hash":"89eea925e392aad647ff6891936a0c1fb70a1ad1","modified":1594087488731},{"_id":"public/images/0082zybply1gbqenlanqrj327f0u04gd.jpg","hash":"9f41da969aa0242ae9e0e645562b14e48d39dbb4","modified":1594087488731},{"_id":"public/images/56ab763273b2c03b2f1c37db7b150338414771.png","hash":"10995c179425878633d71e640aaa3230e2f32f76","modified":1594087488731},{"_id":"public/images/0082zybply1gbqenms1eqj32dw0l87h5.jpg","hash":"98f2f4f6faae466a1543753b2f02730a185fa812","modified":1594087488731},{"_id":"public/images/725a3db5114d95675f2098c12dc331c3316963.png","hash":"191638b733691e36493144f333e79997540748ee","modified":1594087488731}],"Category":[{"name":"java","_id":"ckcbaj7jh0005vgjaf3mxaoew"},{"name":"区块链","_id":"ckcbaj7jm000avgjady1h3qr2"},{"name":"j2ee","parent":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7jt000mvgjael4u3de2"},{"name":"collection","parent":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7jv000svgja7tpv19ib"},{"name":"jdk8","parent":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7jy000xvgja8yzg1sfp"},{"name":"jvm","parent":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7k10014vgja09aj5848"},{"name":"blockChina","parent":"ckcbaj7jm000avgjady1h3qr2","_id":"ckcbaj7k3001cvgja3az5a012"},{"name":"proxy","parent":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7k5001kvgja44fz3wws"},{"name":"thread","parent":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7k7001qvgja9ps67mzd"},{"name":"linux","_id":"ckcbaj7kc001uvgjaeg45ftnn"},{"name":"分布式与微服务","_id":"ckcbaj7ke0025vgjah57oexmd"},{"name":"中间件","_id":"ckcbaj7ke0028vgja96ku8tzb"},{"name":"ORM","_id":"ckcbaj7kf002avgja6nqtb4m5"},{"name":"包管理","_id":"ckcbaj7kg002cvgjabrwp16zp"},{"name":"项目","_id":"ckcbaj7kh002gvgja3edz2dns"},{"name":"spring","_id":"ckcbaj7ki002kvgja6udbcrlj"},{"name":"服务器","_id":"ckcbaj7kj002ovgja92u6cbls"},{"name":"数据库","_id":"ckcbaj7kk002svgja5oree4fe"},{"name":"数据结构与算法","_id":"ckcbaj7km002zvgjacah87l53"},{"name":"openssl","parent":"ckcbaj7kc001uvgjaeg45ftnn","_id":"ckcbaj7ko0032vgja5t3ofqwd"},{"name":"linux","parent":"ckcbaj7kc001uvgjaeg45ftnn","_id":"ckcbaj7kp0035vgja322ggi33"},{"name":"microservices","parent":"ckcbaj7ke0025vgjah57oexmd","_id":"ckcbaj7kq0039vgja504g1ix7"},{"name":"middleware","parent":"ckcbaj7ke0028vgja96ku8tzb","_id":"ckcbaj7kr003evgjafb9dg2us"},{"name":"orm","parent":"ckcbaj7kf002avgja6nqtb4m5","_id":"ckcbaj7ks003jvgjadb7wf1a3"},{"name":"packageManager","parent":"ckcbaj7kg002cvgjabrwp16zp","_id":"ckcbaj7kt003ovgjafh93cwr6"},{"name":"project","parent":"ckcbaj7kh002gvgja3edz2dns","_id":"ckcbaj7ku003svgja9cbi69y0"},{"name":"spring","parent":"ckcbaj7ki002kvgja6udbcrlj","_id":"ckcbaj7ku003wvgja2scshsrp"},{"name":"server","parent":"ckcbaj7kj002ovgja92u6cbls","_id":"ckcbaj7kv0042vgja3r17a16s"},{"name":"sql","parent":"ckcbaj7kk002svgja5oree4fe","_id":"ckcbaj7kx0047vgjaebzv0mm8"},{"name":"索引","parent":"ckcbaj7kk002svgja5oree4fe","_id":"ckcbaj7ky004avgjafp0h3n1f"},{"name":"algorithms","parent":"ckcbaj7km002zvgjacah87l53","_id":"ckcbaj7l1004dvgja4e7y770s"},{"name":"jvm工具","parent":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7li004nvgja5vnb1d45"},{"name":"read line","parent":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7lk004rvgja65qz7qjk"},{"name":"dubbo配置","parent":"ckcbaj7ke0025vgjah57oexmd","_id":"ckcbaj7ll004wvgja1mlcfass"},{"name":"Open API","parent":"ckcbaj7kh002gvgja3edz2dns","_id":"ckcbaj7ll0051vgjae4ny56gc"},{"name":"MySql","parent":"ckcbaj7kk002svgja5oree4fe","_id":"ckcbaj7lm0057vgja4fd1577y"},{"name":"MVCC多版本并发控制","parent":"ckcbaj7lm0057vgja4fd1577y","_id":"ckcbaj7ln005fvgjaf8bg7wsi"},{"name":"IO/NIO","parent":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7ls005qvgja6qy7b7ac"},{"name":"schedule","parent":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7lt005uvgja24oy0f9o"},{"name":"MySQL","parent":"ckcbaj7kk002svgja5oree4fe","_id":"ckcbaj7lu005yvgjaa623c3xq"},{"name":"queue","parent":"ckcbaj7jv000svgja7tpv19ib","_id":"ckcbaj7m5006avgjad5cafue5"},{"name":"memory","parent":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7m8006dvgjae30t37tb"},{"name":"分库分表方案","parent":"ckcbaj7kk002svgja5oree4fe","_id":"ckcbaj7m9006fvgja8igx71gg"},{"name":"disruptor","parent":"ckcbaj7m5006avgjad5cafue5","_id":"ckcbaj7mc006nvgja3tqjcggd"},{"name":"garbage","parent":"ckcbaj7m8006dvgjae30t37tb","_id":"ckcbaj7mc006tvgja7stz7y60"},{"name":"concurrent","parent":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7mi007cvgja9f2i8wof"},{"name":"thread-pool","parent":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7mi007evgja1iw06c2y"},{"name":"AQS","parent":"ckcbaj7mi007cvgja9f2i8wof","_id":"ckcbaj7mj007gvgja8duz42ou"},{"name":"fork/join","parent":"ckcbaj7k7001qvgja9ps67mzd","_id":"ckcbaj7mo007tvgjaeaff4kto"}],"Data":[],"Page":[{"title":"About me","date":"2020-04-15T09:26:58.000Z","_content":"","source":"about/me.md","raw":"---\ntitle: About me\ndate: 2020-04-15 17:26:58\n---\n","updated":"2020-04-15T09:26:58.856Z","path":"about/me.html","comments":1,"layout":"page","_id":"ckcbaj7iu0001vgjah7eyfz57","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"schedule","date":"2020-04-27T05:45:29.000Z","_content":"","source":"java/schedule.md","raw":"---\ntitle: schedule\ndate: 2020-04-27 13:45:29\n---\n","updated":"2020-04-27T05:45:29.315Z","path":"java/schedule.html","comments":1,"layout":"page","_id":"ckcbaj7iv0002vgjah20y9gmp","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n## test\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n# 创建layout为 `post-java` 且路径为 java/schedule 文件名为chedule\n$ hexo new post-java  -p \"java/schedule\" schedule\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n## test\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n# 创建layout为 `post-java` 且路径为 java/schedule 文件名为chedule\n$ hexo new post-java  -p \"java/schedule\" schedule\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2020-04-27T07:32:30.284Z","updated":"2020-04-27T07:32:30.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7i00000vgjagf3894t8","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><h2 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test\"></a>test</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br><span class=\"line\"><span class=\"comment\"># 创建layout为 `post-java` 且路径为 java/schedule 文件名为chedule</span></span><br><span class=\"line\">$ hexo new post-java  -p <span class=\"string\">\"java/schedule\"</span> schedule</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><h2 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test\"></a>test</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br><span class=\"line\"><span class=\"comment\"># 创建layout为 `post-java` 且路径为 java/schedule 文件名为chedule</span></span><br><span class=\"line\">$ hexo new post-java  -p <span class=\"string\">\"java/schedule\"</span> schedule</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"java 容器","date":"2020-04-15T09:06:56.000Z","_content":"","source":"_posts/java/collection.md","raw":"---\ntitle: java 容器\ntags:\n  - java\ncategories:\n  - java\n  - collection\ndate: 2020-04-15 17:06:56\n---\n","slug":"java/collection","published":1,"updated":"2020-04-15T09:07:50.762Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7jf0003vgjae7r8d0iy","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"blockChina","date":"2020-04-15T11:58:21.000Z","_content":"","source":"_posts/blockChain/blockChain.md","raw":"---\ntitle: blockChina\ntags:\n  - 区块链\ncategories:\n  - 区块链\n  - blockChina\ndate: 2020-04-15 19:58:21\n---\n","slug":"blockChain/blockChain","published":1,"updated":"2020-04-15T11:58:21.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7jg0004vgja9pesbh1f","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Java","date":"2020-04-15T07:38:43.000Z","_content":"","source":"_posts/java/Java.md","raw":"---\ntitle: Java\ndate: 2020-04-15 15:38:43\ntags:\n    - java\ncategories:\n    - java\n---\n","slug":"java/Java","published":1,"updated":"2020-04-15T08:19:13.895Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7jk0007vgja33027yzv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"j2ee","date":"2020-04-15T08:21:08.000Z","_content":"","source":"_posts/java/j2ee.md","raw":"---\ntitle: j2ee\ndate: 2020-04-15 16:21:08\ntags:\n    - java\ncategories:\n    - java\n    - j2ee\n---\n","slug":"java/j2ee","published":1,"updated":"2020-04-15T10:37:13.515Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7jl0008vgja06sybtvr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"jdk8 function lambda","date":"2020-04-15T08:09:14.000Z","_content":"","source":"_posts/java/jdk8-function-lambda.md","raw":"---\ntitle: jdk8 function lambda\ndate: 2020-04-15 16:09:14\ntags:\n    - java\n    - jdk8\n    - lambda\n    - function/函数式编程\ncategories:\n    - java\n    - jdk8\n---\n","slug":"java/jdk8-function-lambda","published":1,"updated":"2020-04-15T08:25:16.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7jm0009vgjaegny5rux","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"jvm","date":"2020-04-15T08:24:15.000Z","_content":"","source":"_posts/java/jvm.md","raw":"---\ntitle: jvm\ndate: 2020-04-15 16:24:15\ntags:\n    - java\ncategories:\n    - java\n    - jvm\n---\n","slug":"java/jvm","published":1,"updated":"2020-04-15T10:37:13.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7jo000dvgjaa8498xy4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"proxy","date":"2020-04-15T08:21:41.000Z","_content":"","source":"_posts/java/proxy.md","raw":"---\ntitle: proxy\ndate: 2020-04-15 16:21:41\ntags:\n    - java\n    - proxy\n    - javassist\n    - jdk 动态代理\n    - cglib 动态代理\ncategories:\n    - java\n    - proxy\n---\n","slug":"java/proxy","published":1,"updated":"2020-04-15T08:29:37.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7jp000fvgjahip84slm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Java 线程相关 线程池","date":"2020-04-15T08:14:40.000Z","_content":"","source":"_posts/java/thread.md","raw":"---\ntitle: Java 线程相关 线程池\ndate: 2020-04-15 16:14:40\ntags:\n    - java\n    - thread\n    - synchronized/lock\n    - ThreadPoolExecutor\n    - fork/join\n    - schedule\ncategories:\n    - java\n    - thread\n---\n","slug":"java/thread","published":1,"updated":"2020-04-15T08:19:14.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7jr000jvgja5imf67pt","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"page","date":"2020-04-15T09:29:29.000Z","_content":"","source":"_posts/about/me.md","raw":"---\ntitle: page\ndate: 2020-04-15 17:29:29\ntags:\n---\n","slug":"about/me","published":1,"updated":"2020-04-15T09:29:30.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7js000lvgja81sgeotm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"RSA加解密钥对生成","date":"2020-07-01T11:55:55.000Z","_content":"\n\\#creating rsa private key\n\n```shell\nopenssl genrsa -out rsa_private_key.pem 2048\n```\n\n\n\n\\#convert private key into PKCS#8 format\n\n```shell\nopenssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt -out private_pkcs8.pem\n```\n\n\n\n\\#get public key from private key (X509 format)\n\n```shell\nopenssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem\n```","source":"_posts/linux/openssl 生产RSA密钥对.md","raw":"---\ntitle: RSA加解密钥对生成\ntags:\n  - linux\n  - openssl\ncategories:\n  - linux\n  - openssl\ndate: 2020-07-01 19:55:55\n---\n\n\\#creating rsa private key\n\n```shell\nopenssl genrsa -out rsa_private_key.pem 2048\n```\n\n\n\n\\#convert private key into PKCS#8 format\n\n```shell\nopenssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt -out private_pkcs8.pem\n```\n\n\n\n\\#get public key from private key (X509 format)\n\n```shell\nopenssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem\n```","slug":"linux/openssl 生产RSA密钥对","published":1,"updated":"2020-07-03T01:56:07.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7ju000ovgja7vof0z62","content":"<p>#creating rsa private key</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -out rsa_private_key.pem 2048</span><br></pre></td></tr></table></figure>\n\n\n\n<p>#convert private key into PKCS#8 format</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt -out private_pkcs8.pem</span><br></pre></td></tr></table></figure>\n\n\n\n<p>#get public key from private key (X509 format)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>#creating rsa private key</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl genrsa -out rsa_private_key.pem 2048</span><br></pre></td></tr></table></figure>\n\n\n\n<p>#convert private key into PKCS#8 format</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt -out private_pkcs8.pem</span><br></pre></td></tr></table></figure>\n\n\n\n<p>#get public key from private key (X509 format)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem</span><br></pre></td></tr></table></figure>"},{"title":"linux","date":"2020-04-15T11:55:55.000Z","_content":"","source":"_posts/linux/linux.md","raw":"---\ntitle: linux\ntags:\n  - linux\ncategories:\n  - linux\n  - linux\ndate: 2020-04-15 19:55:55\n---\n","slug":"linux/linux","published":1,"updated":"2020-04-15T11:55:55.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7jv000qvgjahqn26zx2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"microservices","date":"2020-04-15T12:00:43.000Z","_content":"","source":"_posts/microservices/microservices.md","raw":"---\ntitle: microservices\ntags:\n  - 分布式与微服务\ncategories:\n  - 分布式与微服务\n  - microservices\ndate: 2020-04-15 20:00:43\n---\n","slug":"microservices/microservices","published":1,"updated":"2020-04-15T12:00:43.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7jw000uvgja9tps11em","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"middleware","date":"2020-04-15T11:59:51.000Z","_content":"","source":"_posts/middleware/middleware.md","raw":"---\ntitle: middleware\ntags:\n  - 中间件\ncategories:\n  - 中间件\n  - middleware\ndate: 2020-04-15 19:59:51\n---\n","slug":"middleware/middleware","published":1,"updated":"2020-04-15T11:59:51.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7jx000vvgja4i9o0zlr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"orm","date":"2020-04-15T12:01:30.000Z","_content":"","source":"_posts/orm/orm.md","raw":"---\ntitle: orm\ntags:\n  - ORM\ncategories:\n  - ORM\n  - orm\ndate: 2020-04-15 20:01:30\n---\n","slug":"orm/orm","published":1,"updated":"2020-04-15T12:01:30.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7jy000zvgjac9dx3i9k","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"packageManager","date":"2020-04-15T12:03:37.000Z","_content":"","source":"_posts/packageManager/packageManager.md","raw":"---\ntitle: packageManager\ntags:\n  - 包管理\ncategories:\n  - 包管理\n  - packageManager\ndate: 2020-04-15 20:03:37\n---\n","slug":"packageManager/packageManager","published":1,"updated":"2020-04-15T12:03:37.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7jz0011vgja0bgk1ihc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"project","date":"2020-04-15T12:04:32.000Z","_content":"","source":"_posts/project/project.md","raw":"---\ntitle: project\ntags:\n  - 项目\ncategories:\n  - 项目\n  - project\ndate: 2020-04-15 20:04:32\n---\n","slug":"project/project","published":1,"updated":"2020-04-15T12:04:32.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7k00013vgjaeo0040q5","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"### **一、概述**\n\n本篇着重介绍一下从业务层面的热点账户的经验与实践，修改余额的几种方式见上篇介绍[交易系统热点账户问题（一）](https://blog.csdn.net/laoxilaoxi_/article/details/80963905)     \n\n### 二、业务场景分析\n\n可将业务场景划分为如下：\n\n高频入：B端收单账户（结算账户），业务中间账户（业务处理时记录在途资金）\n\n高频扣：B端代扣代发账户（B端支付账户），B端手续费账户（用于做收支分离）\n\n \n\n### **三、业务角度热点账户实践及其特点**\n\n**1.异步削峰入账**\n\n适用场景：\n\n1.适用B端收单账户与业务中间账户，一般B端收单账户资金是在清结算场景时会扣除，不会影响正常的业务，且MQ处理一般也会在毫秒级别完成，高并发时延迟也是在秒级，所以异步入账对商户几乎无感知。\n\n**2.异步削峰扣款**\n\n\n\n适用场景：\n\n1.适用B端代付代发账户以及手续费账户，一般B端高频扣款对相应时间都有一定的要求，且存在余额不足这种不可抗拒的失败因素，所以采用优先判断余额（脏读余额），拒绝掉大部分账户余额不足的请求，其次是异步增加超时以及重试次数的判断，确保请求的有效处理时间保持在一定范围里（超时时间及重试次数可由业务传入）。\n\n**3.批量入账（缓冲入账）**\n\n\n\n适用场景：\n\n1.适用B端收单账户与业务中间账户，一般**异步削峰入账**可解决大部分高并发问题，但有一些超级B端商户的交易量超级大，可采用该种方式应对。同样，也不会影响该类商户的清结算。\n\n其中，批量入账需新增一种修改余额的方式，**一次更新余额，批量插入账户历史**\n\n\n\n**4.子账户（拆分多账户）**\n\n\n\n适用场景：\n\n1.适用与所有账户的扣款入账。\n\n但是其中存在一些问题解决起来需要多写点代码:\n\n​                   ①扣款入账实际操作的是子账户（就是一个单独的账户，只是存了与原本账户之间的关系），主账户不存放余额，余额都是存放在子账户，所以查询余额时，需要做特殊处理（求和子账户）。\n\n​                   ②因为分散到多个子账户去处理扣款入账，那么账户的发生后余额就会是个问题（如果不需要发生后余额的话那就很赞了），扣入账产生的账户历史都存放的是子账户的发生后余额（或者不存），要是必须要的话，那就异步计算生成。\n\n​                   ③多子账户扣款时会存在子账户余额不足的问题，但实际所有子账户的余额总和可能是充足的，所以需要在余额不足时做子账户资金归集。且若为代付代发的场景，那么对其进行充值时，需要做充值资金拆分，去加到每个子账户中。                  \n\n### **四、其他角度方案**\n\n单热点账户常见问题及解决方案在上文已经说的差不多了，但是实际场景中并非为单个热点账户。例如，账户基数为1000W，其中高并发账户有1W-5W，在正常扣入账时，这些热点账户在数据库上产生的锁等以及占用的数据库连接都是共享资源，会相互影响，以至于性能很难提升。\n\n分库分表，是个很常见也很好的解决方案，下节单独详说一下。","source":"_posts/project/热点账户.md","raw":"### **一、概述**\n\n本篇着重介绍一下从业务层面的热点账户的经验与实践，修改余额的几种方式见上篇介绍[交易系统热点账户问题（一）](https://blog.csdn.net/laoxilaoxi_/article/details/80963905)     \n\n### 二、业务场景分析\n\n可将业务场景划分为如下：\n\n高频入：B端收单账户（结算账户），业务中间账户（业务处理时记录在途资金）\n\n高频扣：B端代扣代发账户（B端支付账户），B端手续费账户（用于做收支分离）\n\n \n\n### **三、业务角度热点账户实践及其特点**\n\n**1.异步削峰入账**\n\n适用场景：\n\n1.适用B端收单账户与业务中间账户，一般B端收单账户资金是在清结算场景时会扣除，不会影响正常的业务，且MQ处理一般也会在毫秒级别完成，高并发时延迟也是在秒级，所以异步入账对商户几乎无感知。\n\n**2.异步削峰扣款**\n\n\n\n适用场景：\n\n1.适用B端代付代发账户以及手续费账户，一般B端高频扣款对相应时间都有一定的要求，且存在余额不足这种不可抗拒的失败因素，所以采用优先判断余额（脏读余额），拒绝掉大部分账户余额不足的请求，其次是异步增加超时以及重试次数的判断，确保请求的有效处理时间保持在一定范围里（超时时间及重试次数可由业务传入）。\n\n**3.批量入账（缓冲入账）**\n\n\n\n适用场景：\n\n1.适用B端收单账户与业务中间账户，一般**异步削峰入账**可解决大部分高并发问题，但有一些超级B端商户的交易量超级大，可采用该种方式应对。同样，也不会影响该类商户的清结算。\n\n其中，批量入账需新增一种修改余额的方式，**一次更新余额，批量插入账户历史**\n\n\n\n**4.子账户（拆分多账户）**\n\n\n\n适用场景：\n\n1.适用与所有账户的扣款入账。\n\n但是其中存在一些问题解决起来需要多写点代码:\n\n​                   ①扣款入账实际操作的是子账户（就是一个单独的账户，只是存了与原本账户之间的关系），主账户不存放余额，余额都是存放在子账户，所以查询余额时，需要做特殊处理（求和子账户）。\n\n​                   ②因为分散到多个子账户去处理扣款入账，那么账户的发生后余额就会是个问题（如果不需要发生后余额的话那就很赞了），扣入账产生的账户历史都存放的是子账户的发生后余额（或者不存），要是必须要的话，那就异步计算生成。\n\n​                   ③多子账户扣款时会存在子账户余额不足的问题，但实际所有子账户的余额总和可能是充足的，所以需要在余额不足时做子账户资金归集。且若为代付代发的场景，那么对其进行充值时，需要做充值资金拆分，去加到每个子账户中。                  \n\n### **四、其他角度方案**\n\n单热点账户常见问题及解决方案在上文已经说的差不多了，但是实际场景中并非为单个热点账户。例如，账户基数为1000W，其中高并发账户有1W-5W，在正常扣入账时，这些热点账户在数据库上产生的锁等以及占用的数据库连接都是共享资源，会相互影响，以至于性能很难提升。\n\n分库分表，是个很常见也很好的解决方案，下节单独详说一下。","slug":"project/热点账户","published":1,"date":"2020-05-26T12:13:16.755Z","updated":"2020-05-26T12:26:05.956Z","title":"project/热点账户","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7k20018vgja7j24hbr3","content":"<h3 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a><strong>一、概述</strong></h3><p>本篇着重介绍一下从业务层面的热点账户的经验与实践，修改余额的几种方式见上篇介绍<a href=\"https://blog.csdn.net/laoxilaoxi_/article/details/80963905\" target=\"_blank\" rel=\"noopener\">交易系统热点账户问题（一）</a>     </p>\n<h3 id=\"二、业务场景分析\"><a href=\"#二、业务场景分析\" class=\"headerlink\" title=\"二、业务场景分析\"></a>二、业务场景分析</h3><p>可将业务场景划分为如下：</p>\n<p>高频入：B端收单账户（结算账户），业务中间账户（业务处理时记录在途资金）</p>\n<p>高频扣：B端代扣代发账户（B端支付账户），B端手续费账户（用于做收支分离）</p>\n<h3 id=\"三、业务角度热点账户实践及其特点\"><a href=\"#三、业务角度热点账户实践及其特点\" class=\"headerlink\" title=\"三、业务角度热点账户实践及其特点\"></a><strong>三、业务角度热点账户实践及其特点</strong></h3><p><strong>1.异步削峰入账</strong></p>\n<p>适用场景：</p>\n<p>1.适用B端收单账户与业务中间账户，一般B端收单账户资金是在清结算场景时会扣除，不会影响正常的业务，且MQ处理一般也会在毫秒级别完成，高并发时延迟也是在秒级，所以异步入账对商户几乎无感知。</p>\n<p><strong>2.异步削峰扣款</strong></p>\n<p>适用场景：</p>\n<p>1.适用B端代付代发账户以及手续费账户，一般B端高频扣款对相应时间都有一定的要求，且存在余额不足这种不可抗拒的失败因素，所以采用优先判断余额（脏读余额），拒绝掉大部分账户余额不足的请求，其次是异步增加超时以及重试次数的判断，确保请求的有效处理时间保持在一定范围里（超时时间及重试次数可由业务传入）。</p>\n<p><strong>3.批量入账（缓冲入账）</strong></p>\n<p>适用场景：</p>\n<p>1.适用B端收单账户与业务中间账户，一般<strong>异步削峰入账</strong>可解决大部分高并发问题，但有一些超级B端商户的交易量超级大，可采用该种方式应对。同样，也不会影响该类商户的清结算。</p>\n<p>其中，批量入账需新增一种修改余额的方式，<strong>一次更新余额，批量插入账户历史</strong></p>\n<p><strong>4.子账户（拆分多账户）</strong></p>\n<p>适用场景：</p>\n<p>1.适用与所有账户的扣款入账。</p>\n<p>但是其中存在一些问题解决起来需要多写点代码:</p>\n<p>​                   ①扣款入账实际操作的是子账户（就是一个单独的账户，只是存了与原本账户之间的关系），主账户不存放余额，余额都是存放在子账户，所以查询余额时，需要做特殊处理（求和子账户）。</p>\n<p>​                   ②因为分散到多个子账户去处理扣款入账，那么账户的发生后余额就会是个问题（如果不需要发生后余额的话那就很赞了），扣入账产生的账户历史都存放的是子账户的发生后余额（或者不存），要是必须要的话，那就异步计算生成。</p>\n<p>​                   ③多子账户扣款时会存在子账户余额不足的问题，但实际所有子账户的余额总和可能是充足的，所以需要在余额不足时做子账户资金归集。且若为代付代发的场景，那么对其进行充值时，需要做充值资金拆分，去加到每个子账户中。                  </p>\n<h3 id=\"四、其他角度方案\"><a href=\"#四、其他角度方案\" class=\"headerlink\" title=\"四、其他角度方案\"></a><strong>四、其他角度方案</strong></h3><p>单热点账户常见问题及解决方案在上文已经说的差不多了，但是实际场景中并非为单个热点账户。例如，账户基数为1000W，其中高并发账户有1W-5W，在正常扣入账时，这些热点账户在数据库上产生的锁等以及占用的数据库连接都是共享资源，会相互影响，以至于性能很难提升。</p>\n<p>分库分表，是个很常见也很好的解决方案，下节单独详说一下。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a><strong>一、概述</strong></h3><p>本篇着重介绍一下从业务层面的热点账户的经验与实践，修改余额的几种方式见上篇介绍<a href=\"https://blog.csdn.net/laoxilaoxi_/article/details/80963905\" target=\"_blank\" rel=\"noopener\">交易系统热点账户问题（一）</a>     </p>\n<h3 id=\"二、业务场景分析\"><a href=\"#二、业务场景分析\" class=\"headerlink\" title=\"二、业务场景分析\"></a>二、业务场景分析</h3><p>可将业务场景划分为如下：</p>\n<p>高频入：B端收单账户（结算账户），业务中间账户（业务处理时记录在途资金）</p>\n<p>高频扣：B端代扣代发账户（B端支付账户），B端手续费账户（用于做收支分离）</p>\n<h3 id=\"三、业务角度热点账户实践及其特点\"><a href=\"#三、业务角度热点账户实践及其特点\" class=\"headerlink\" title=\"三、业务角度热点账户实践及其特点\"></a><strong>三、业务角度热点账户实践及其特点</strong></h3><p><strong>1.异步削峰入账</strong></p>\n<p>适用场景：</p>\n<p>1.适用B端收单账户与业务中间账户，一般B端收单账户资金是在清结算场景时会扣除，不会影响正常的业务，且MQ处理一般也会在毫秒级别完成，高并发时延迟也是在秒级，所以异步入账对商户几乎无感知。</p>\n<p><strong>2.异步削峰扣款</strong></p>\n<p>适用场景：</p>\n<p>1.适用B端代付代发账户以及手续费账户，一般B端高频扣款对相应时间都有一定的要求，且存在余额不足这种不可抗拒的失败因素，所以采用优先判断余额（脏读余额），拒绝掉大部分账户余额不足的请求，其次是异步增加超时以及重试次数的判断，确保请求的有效处理时间保持在一定范围里（超时时间及重试次数可由业务传入）。</p>\n<p><strong>3.批量入账（缓冲入账）</strong></p>\n<p>适用场景：</p>\n<p>1.适用B端收单账户与业务中间账户，一般<strong>异步削峰入账</strong>可解决大部分高并发问题，但有一些超级B端商户的交易量超级大，可采用该种方式应对。同样，也不会影响该类商户的清结算。</p>\n<p>其中，批量入账需新增一种修改余额的方式，<strong>一次更新余额，批量插入账户历史</strong></p>\n<p><strong>4.子账户（拆分多账户）</strong></p>\n<p>适用场景：</p>\n<p>1.适用与所有账户的扣款入账。</p>\n<p>但是其中存在一些问题解决起来需要多写点代码:</p>\n<p>​                   ①扣款入账实际操作的是子账户（就是一个单独的账户，只是存了与原本账户之间的关系），主账户不存放余额，余额都是存放在子账户，所以查询余额时，需要做特殊处理（求和子账户）。</p>\n<p>​                   ②因为分散到多个子账户去处理扣款入账，那么账户的发生后余额就会是个问题（如果不需要发生后余额的话那就很赞了），扣入账产生的账户历史都存放的是子账户的发生后余额（或者不存），要是必须要的话，那就异步计算生成。</p>\n<p>​                   ③多子账户扣款时会存在子账户余额不足的问题，但实际所有子账户的余额总和可能是充足的，所以需要在余额不足时做子账户资金归集。且若为代付代发的场景，那么对其进行充值时，需要做充值资金拆分，去加到每个子账户中。                  </p>\n<h3 id=\"四、其他角度方案\"><a href=\"#四、其他角度方案\" class=\"headerlink\" title=\"四、其他角度方案\"></a><strong>四、其他角度方案</strong></h3><p>单热点账户常见问题及解决方案在上文已经说的差不多了，但是实际场景中并非为单个热点账户。例如，账户基数为1000W，其中高并发账户有1W-5W，在正常扣入账时，这些热点账户在数据库上产生的锁等以及占用的数据库连接都是共享资源，会相互影响，以至于性能很难提升。</p>\n<p>分库分表，是个很常见也很好的解决方案，下节单独详说一下。</p>\n"},{"title":"spring","date":"2020-04-15T12:06:16.000Z","_content":"","source":"_posts/spring/spring.md","raw":"---\ntitle: spring\ntags:\n  - spring\ncategories:\n  - spring\n  - spring\ndate: 2020-04-15 20:06:16\n---\n","slug":"spring/spring","published":1,"updated":"2020-04-15T12:06:16.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7k3001avgja4dyg5k5e","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"server","date":"2020-04-15T12:05:08.000Z","_content":"","source":"_posts/server/server.md","raw":"---\ntitle: server\ntags:\n  - 服务器\ncategories:\n  - 服务器\n  - server\ndate: 2020-04-15 20:05:08\n---\n","slug":"server/server","published":1,"updated":"2020-04-15T12:05:08.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7k4001fvgja2niu2vf0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"sql","date":"2020-04-15T12:05:46.000Z","_content":"","source":"_posts/sql/sql.md","raw":"---\ntitle: sql\ntags:\n  - 数据库\ncategories:\n  - 数据库\n  - sql\ndate: 2020-04-15 20:05:46\n---\n","slug":"sql/sql","published":1,"updated":"2020-04-15T12:05:46.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7k5001ivgjacbqqfpvq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"MySQL索引使用的数据结构：B-Tree和B+Tree","date":"2020-06-03T12:05:46.000Z","_content":"\nMyISAM是[MySQL](http://lib.csdn.net/base/mysql) 5.5之前版本默认的存储引擎，从5.5之后，InnoDB开始成为MySQL默认的存储引擎。\n\nMyISAM使用B-Tree实现主键索引、唯一索引和非主键索引。\n\nInnoDB中非主键索引使用的是B-Tree[数据结构](http://lib.csdn.net/base/datastructure)，而主键索引使用的是B+Tree。\n\n本文就是对这两种数据结构做简单的介绍。\n\n**1. B-Tree**\n\nB-Tree不是“B减树”，而是“B树”。\n\n这里参考了严蔚敏《数据结构》对B-Tree的定义：\n\n一棵m阶的B-Tree,或者为空树，或者满足下列特性：\n1.树中每个结点至多有m棵子树；\n2.若根结点不是叶子结点，则至少有两棵子树；\n3.除根节点之外的所有非终端结点至少有[m/2]棵子树；\n4.所有非终端结点中包含下列信息数据:\n(n,A0,K1,A1,K2,A2……Kn,An)\n其中，n为关键字的数目，K(i)为关键字，且K(i) < K(i+1), Ai为指向子树根结点的指针，且指针A(i-1)所指子树中所有结点的关键字均小于Ki，Ai所指子树中所有结点的关键字均大于Ki；\n5.所有叶子结点都出现在同一层次上；\n\n下面通过一个例子解释一下B-Tree的查找过程。\n![b-Tree](/images/20151231232508924.png)\n这是一棵4阶的B-Tree，深度为4。\n\n假如在该图中查找关键字47，首先从根结点开始，根据根结点指针t找到*a结点，因为47大于 *a 结点的关键字35，所以会去A1指针指向的 *c结点继续寻找，因为 *c的关键字 43 < 要查找的47 < *c结点的关键字78，所以去 *c结点A1指针指向的 *g结点去寻找，结果在 *g结点中找到了关键字47，查找成功。\n\n**2. B+Tree**\n\n不同的存储引擎可能使用不同的数据结构存储，InnoDB使用的是B+Tree；那什么是B+Tree呢？\nB+Tree是应文件系统所需而出的一种B-Tree的变型树，一棵m阶的B+树和m阶的B-树的差异在于:\n1.有n棵子树的结点中含有n个关键字；\n2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字的记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；\n3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树(根结点)中的最大（或最小）关键字；\n\n还是通过一个例子来说明。\n![B+Tree](/images/20151231233806229.png)\n这个例子中，所有非终端结点仅含有子树中最大的关键字。\n\n因为叶子节点本身依据关键字的大小自小而大顺序链接，所以可以从最小关键字起顺序查找。也可以从根结点开始，进行随机查找。\n\n在B+树中随机差找和在B-树中类似，以上图为例。假设要查找关键字51，现在根节点中比较，发现51<59，因为这里使用的是非终端结点的关键字是子树中最大的关键字，所以进入最大值为59的子结点(15\\44\\59)中查找，同理，因为44<51<59，所以进入P3指向的结点(51\\59)中查找，然后命中关键字51，因为此结点(51\\59)是叶子结点，所以查找终止，该结点包含指向数据的指针。\n\n![B+Tree](/images/20160308162237758.png)\n\n**3.索引如何在B+Tree中组织数据存储**\n\n假设有如下表:\n![People_table](/images/20160103223150042.png)\n对于表中的每一行数据，索引中包含了last_name、first_name和dob列的值，下图展示索引是如何组织数据存储的:\n![索引](/images/20160103223436953.png)\n\n索引对多个值进行排序的依据是定义索引时列的顺序。\n(Allen Cuba 1960-01-01)结点左侧的指针指向[?,Allen Cuba 1960-01-01)的叶子页，(Allen Cuba 1960-01-01)和(Astaire,Angelina,1980-03-04)之间的指针指向[Allen Cuba 1960-01-01,Astaire Angelina 1980-03-04)的叶子页，以此类推。总之，每个指针指向的结点中的最小值就是该指针左侧的的值。\n\n这种存储结构也说明了在定义多个列组成的多列索引中，为什么需要把重复率最低的列放到最左侧，因为这会减少比较的次数，查找起来更加高效。\n\n4.索引为什么选用B树这种数据结构？\n因为使用B树查找时，所用的磁盘IO操作次数比平衡二叉树更少，效率也更高。\n为什么使用B树查找所用的磁盘IO操作次数比平衡二叉树更少？\n大规模数据存储中，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的高度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。那么我们就需要减少树的高度以提高查找效率。而平衡多路查找树结构B树就满足这样的要求。B树的各种操作能使B树保持较低的高度，从而达到有效减少磁盘IO操作次数。\n\n参考资料:\n《数据结构（[C语言](http://lib.csdn.net/base/c)版）》\n《Effective MySQL之SQL语句最优化》\n《高性能MySQL》","source":"_posts/sql/btree索引.md","raw":"---\ntitle: MySQL索引使用的数据结构：B-Tree和B+Tree\ntags:\n  - 数据库\n  - b+ tree\n  - b tree\ncategories:\n  - 数据库\n  - 索引\ndate: 2020-06-03 20:05:46\n---\n\nMyISAM是[MySQL](http://lib.csdn.net/base/mysql) 5.5之前版本默认的存储引擎，从5.5之后，InnoDB开始成为MySQL默认的存储引擎。\n\nMyISAM使用B-Tree实现主键索引、唯一索引和非主键索引。\n\nInnoDB中非主键索引使用的是B-Tree[数据结构](http://lib.csdn.net/base/datastructure)，而主键索引使用的是B+Tree。\n\n本文就是对这两种数据结构做简单的介绍。\n\n**1. B-Tree**\n\nB-Tree不是“B减树”，而是“B树”。\n\n这里参考了严蔚敏《数据结构》对B-Tree的定义：\n\n一棵m阶的B-Tree,或者为空树，或者满足下列特性：\n1.树中每个结点至多有m棵子树；\n2.若根结点不是叶子结点，则至少有两棵子树；\n3.除根节点之外的所有非终端结点至少有[m/2]棵子树；\n4.所有非终端结点中包含下列信息数据:\n(n,A0,K1,A1,K2,A2……Kn,An)\n其中，n为关键字的数目，K(i)为关键字，且K(i) < K(i+1), Ai为指向子树根结点的指针，且指针A(i-1)所指子树中所有结点的关键字均小于Ki，Ai所指子树中所有结点的关键字均大于Ki；\n5.所有叶子结点都出现在同一层次上；\n\n下面通过一个例子解释一下B-Tree的查找过程。\n![b-Tree](/images/20151231232508924.png)\n这是一棵4阶的B-Tree，深度为4。\n\n假如在该图中查找关键字47，首先从根结点开始，根据根结点指针t找到*a结点，因为47大于 *a 结点的关键字35，所以会去A1指针指向的 *c结点继续寻找，因为 *c的关键字 43 < 要查找的47 < *c结点的关键字78，所以去 *c结点A1指针指向的 *g结点去寻找，结果在 *g结点中找到了关键字47，查找成功。\n\n**2. B+Tree**\n\n不同的存储引擎可能使用不同的数据结构存储，InnoDB使用的是B+Tree；那什么是B+Tree呢？\nB+Tree是应文件系统所需而出的一种B-Tree的变型树，一棵m阶的B+树和m阶的B-树的差异在于:\n1.有n棵子树的结点中含有n个关键字；\n2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字的记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；\n3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树(根结点)中的最大（或最小）关键字；\n\n还是通过一个例子来说明。\n![B+Tree](/images/20151231233806229.png)\n这个例子中，所有非终端结点仅含有子树中最大的关键字。\n\n因为叶子节点本身依据关键字的大小自小而大顺序链接，所以可以从最小关键字起顺序查找。也可以从根结点开始，进行随机查找。\n\n在B+树中随机差找和在B-树中类似，以上图为例。假设要查找关键字51，现在根节点中比较，发现51<59，因为这里使用的是非终端结点的关键字是子树中最大的关键字，所以进入最大值为59的子结点(15\\44\\59)中查找，同理，因为44<51<59，所以进入P3指向的结点(51\\59)中查找，然后命中关键字51，因为此结点(51\\59)是叶子结点，所以查找终止，该结点包含指向数据的指针。\n\n![B+Tree](/images/20160308162237758.png)\n\n**3.索引如何在B+Tree中组织数据存储**\n\n假设有如下表:\n![People_table](/images/20160103223150042.png)\n对于表中的每一行数据，索引中包含了last_name、first_name和dob列的值，下图展示索引是如何组织数据存储的:\n![索引](/images/20160103223436953.png)\n\n索引对多个值进行排序的依据是定义索引时列的顺序。\n(Allen Cuba 1960-01-01)结点左侧的指针指向[?,Allen Cuba 1960-01-01)的叶子页，(Allen Cuba 1960-01-01)和(Astaire,Angelina,1980-03-04)之间的指针指向[Allen Cuba 1960-01-01,Astaire Angelina 1980-03-04)的叶子页，以此类推。总之，每个指针指向的结点中的最小值就是该指针左侧的的值。\n\n这种存储结构也说明了在定义多个列组成的多列索引中，为什么需要把重复率最低的列放到最左侧，因为这会减少比较的次数，查找起来更加高效。\n\n4.索引为什么选用B树这种数据结构？\n因为使用B树查找时，所用的磁盘IO操作次数比平衡二叉树更少，效率也更高。\n为什么使用B树查找所用的磁盘IO操作次数比平衡二叉树更少？\n大规模数据存储中，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的高度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。那么我们就需要减少树的高度以提高查找效率。而平衡多路查找树结构B树就满足这样的要求。B树的各种操作能使B树保持较低的高度，从而达到有效减少磁盘IO操作次数。\n\n参考资料:\n《数据结构（[C语言](http://lib.csdn.net/base/c)版）》\n《Effective MySQL之SQL语句最优化》\n《高性能MySQL》","slug":"sql/btree索引","published":1,"updated":"2020-06-04T05:49:58.114Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7k6001mvgja0fcz4189","content":"<p>MyISAM是<a href=\"http://lib.csdn.net/base/mysql\" target=\"_blank\" rel=\"noopener\">MySQL</a> 5.5之前版本默认的存储引擎，从5.5之后，InnoDB开始成为MySQL默认的存储引擎。</p>\n<p>MyISAM使用B-Tree实现主键索引、唯一索引和非主键索引。</p>\n<p>InnoDB中非主键索引使用的是B-Tree<a href=\"http://lib.csdn.net/base/datastructure\" target=\"_blank\" rel=\"noopener\">数据结构</a>，而主键索引使用的是B+Tree。</p>\n<p>本文就是对这两种数据结构做简单的介绍。</p>\n<p><strong>1. B-Tree</strong></p>\n<p>B-Tree不是“B减树”，而是“B树”。</p>\n<p>这里参考了严蔚敏《数据结构》对B-Tree的定义：</p>\n<p>一棵m阶的B-Tree,或者为空树，或者满足下列特性：<br>1.树中每个结点至多有m棵子树；<br>2.若根结点不是叶子结点，则至少有两棵子树；<br>3.除根节点之外的所有非终端结点至少有[m/2]棵子树；<br>4.所有非终端结点中包含下列信息数据:<br>(n,A0,K1,A1,K2,A2……Kn,An)<br>其中，n为关键字的数目，K(i)为关键字，且K(i) &lt; K(i+1), Ai为指向子树根结点的指针，且指针A(i-1)所指子树中所有结点的关键字均小于Ki，Ai所指子树中所有结点的关键字均大于Ki；<br>5.所有叶子结点都出现在同一层次上；</p>\n<p>下面通过一个例子解释一下B-Tree的查找过程。<br><img src=\"/images/20151231232508924.png\" alt=\"b-Tree\"><br>这是一棵4阶的B-Tree，深度为4。</p>\n<p>假如在该图中查找关键字47，首先从根结点开始，根据根结点指针t找到*a结点，因为47大于 *a 结点的关键字35，所以会去A1指针指向的 *c结点继续寻找，因为 *c的关键字 43 &lt; 要查找的47 &lt; *c结点的关键字78，所以去 *c结点A1指针指向的 *g结点去寻找，结果在 *g结点中找到了关键字47，查找成功。</p>\n<p><strong>2. B+Tree</strong></p>\n<p>不同的存储引擎可能使用不同的数据结构存储，InnoDB使用的是B+Tree；那什么是B+Tree呢？<br>B+Tree是应文件系统所需而出的一种B-Tree的变型树，一棵m阶的B+树和m阶的B-树的差异在于:<br>1.有n棵子树的结点中含有n个关键字；<br>2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字的记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；<br>3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树(根结点)中的最大（或最小）关键字；</p>\n<p>还是通过一个例子来说明。<br><img src=\"/images/20151231233806229.png\" alt=\"B+Tree\"><br>这个例子中，所有非终端结点仅含有子树中最大的关键字。</p>\n<p>因为叶子节点本身依据关键字的大小自小而大顺序链接，所以可以从最小关键字起顺序查找。也可以从根结点开始，进行随机查找。</p>\n<p>在B+树中随机差找和在B-树中类似，以上图为例。假设要查找关键字51，现在根节点中比较，发现51&lt;59，因为这里使用的是非终端结点的关键字是子树中最大的关键字，所以进入最大值为59的子结点(15\\44\\59)中查找，同理，因为44&lt;51&lt;59，所以进入P3指向的结点(51\\59)中查找，然后命中关键字51，因为此结点(51\\59)是叶子结点，所以查找终止，该结点包含指向数据的指针。</p>\n<p><img src=\"/images/20160308162237758.png\" alt=\"B+Tree\"></p>\n<p><strong>3.索引如何在B+Tree中组织数据存储</strong></p>\n<p>假设有如下表:<br><img src=\"/images/20160103223150042.png\" alt=\"People_table\"><br>对于表中的每一行数据，索引中包含了last_name、first_name和dob列的值，下图展示索引是如何组织数据存储的:<br><img src=\"/images/20160103223436953.png\" alt=\"索引\"></p>\n<p>索引对多个值进行排序的依据是定义索引时列的顺序。<br>(Allen Cuba 1960-01-01)结点左侧的指针指向[?,Allen Cuba 1960-01-01)的叶子页，(Allen Cuba 1960-01-01)和(Astaire,Angelina,1980-03-04)之间的指针指向[Allen Cuba 1960-01-01,Astaire Angelina 1980-03-04)的叶子页，以此类推。总之，每个指针指向的结点中的最小值就是该指针左侧的的值。</p>\n<p>这种存储结构也说明了在定义多个列组成的多列索引中，为什么需要把重复率最低的列放到最左侧，因为这会减少比较的次数，查找起来更加高效。</p>\n<p>4.索引为什么选用B树这种数据结构？<br>因为使用B树查找时，所用的磁盘IO操作次数比平衡二叉树更少，效率也更高。<br>为什么使用B树查找所用的磁盘IO操作次数比平衡二叉树更少？<br>大规模数据存储中，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的高度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。那么我们就需要减少树的高度以提高查找效率。而平衡多路查找树结构B树就满足这样的要求。B树的各种操作能使B树保持较低的高度，从而达到有效减少磁盘IO操作次数。</p>\n<p>参考资料:<br>《数据结构（<a href=\"http://lib.csdn.net/base/c\" target=\"_blank\" rel=\"noopener\">C语言</a>版）》<br>《Effective MySQL之SQL语句最优化》<br>《高性能MySQL》</p>\n","site":{"data":{}},"excerpt":"","more":"<p>MyISAM是<a href=\"http://lib.csdn.net/base/mysql\" target=\"_blank\" rel=\"noopener\">MySQL</a> 5.5之前版本默认的存储引擎，从5.5之后，InnoDB开始成为MySQL默认的存储引擎。</p>\n<p>MyISAM使用B-Tree实现主键索引、唯一索引和非主键索引。</p>\n<p>InnoDB中非主键索引使用的是B-Tree<a href=\"http://lib.csdn.net/base/datastructure\" target=\"_blank\" rel=\"noopener\">数据结构</a>，而主键索引使用的是B+Tree。</p>\n<p>本文就是对这两种数据结构做简单的介绍。</p>\n<p><strong>1. B-Tree</strong></p>\n<p>B-Tree不是“B减树”，而是“B树”。</p>\n<p>这里参考了严蔚敏《数据结构》对B-Tree的定义：</p>\n<p>一棵m阶的B-Tree,或者为空树，或者满足下列特性：<br>1.树中每个结点至多有m棵子树；<br>2.若根结点不是叶子结点，则至少有两棵子树；<br>3.除根节点之外的所有非终端结点至少有[m/2]棵子树；<br>4.所有非终端结点中包含下列信息数据:<br>(n,A0,K1,A1,K2,A2……Kn,An)<br>其中，n为关键字的数目，K(i)为关键字，且K(i) &lt; K(i+1), Ai为指向子树根结点的指针，且指针A(i-1)所指子树中所有结点的关键字均小于Ki，Ai所指子树中所有结点的关键字均大于Ki；<br>5.所有叶子结点都出现在同一层次上；</p>\n<p>下面通过一个例子解释一下B-Tree的查找过程。<br><img src=\"/images/20151231232508924.png\" alt=\"b-Tree\"><br>这是一棵4阶的B-Tree，深度为4。</p>\n<p>假如在该图中查找关键字47，首先从根结点开始，根据根结点指针t找到*a结点，因为47大于 *a 结点的关键字35，所以会去A1指针指向的 *c结点继续寻找，因为 *c的关键字 43 &lt; 要查找的47 &lt; *c结点的关键字78，所以去 *c结点A1指针指向的 *g结点去寻找，结果在 *g结点中找到了关键字47，查找成功。</p>\n<p><strong>2. B+Tree</strong></p>\n<p>不同的存储引擎可能使用不同的数据结构存储，InnoDB使用的是B+Tree；那什么是B+Tree呢？<br>B+Tree是应文件系统所需而出的一种B-Tree的变型树，一棵m阶的B+树和m阶的B-树的差异在于:<br>1.有n棵子树的结点中含有n个关键字；<br>2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字的记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接；<br>3.所有的非终端结点可以看成是索引部分，结点中仅含有其子树(根结点)中的最大（或最小）关键字；</p>\n<p>还是通过一个例子来说明。<br><img src=\"/images/20151231233806229.png\" alt=\"B+Tree\"><br>这个例子中，所有非终端结点仅含有子树中最大的关键字。</p>\n<p>因为叶子节点本身依据关键字的大小自小而大顺序链接，所以可以从最小关键字起顺序查找。也可以从根结点开始，进行随机查找。</p>\n<p>在B+树中随机差找和在B-树中类似，以上图为例。假设要查找关键字51，现在根节点中比较，发现51&lt;59，因为这里使用的是非终端结点的关键字是子树中最大的关键字，所以进入最大值为59的子结点(15\\44\\59)中查找，同理，因为44&lt;51&lt;59，所以进入P3指向的结点(51\\59)中查找，然后命中关键字51，因为此结点(51\\59)是叶子结点，所以查找终止，该结点包含指向数据的指针。</p>\n<p><img src=\"/images/20160308162237758.png\" alt=\"B+Tree\"></p>\n<p><strong>3.索引如何在B+Tree中组织数据存储</strong></p>\n<p>假设有如下表:<br><img src=\"/images/20160103223150042.png\" alt=\"People_table\"><br>对于表中的每一行数据，索引中包含了last_name、first_name和dob列的值，下图展示索引是如何组织数据存储的:<br><img src=\"/images/20160103223436953.png\" alt=\"索引\"></p>\n<p>索引对多个值进行排序的依据是定义索引时列的顺序。<br>(Allen Cuba 1960-01-01)结点左侧的指针指向[?,Allen Cuba 1960-01-01)的叶子页，(Allen Cuba 1960-01-01)和(Astaire,Angelina,1980-03-04)之间的指针指向[Allen Cuba 1960-01-01,Astaire Angelina 1980-03-04)的叶子页，以此类推。总之，每个指针指向的结点中的最小值就是该指针左侧的的值。</p>\n<p>这种存储结构也说明了在定义多个列组成的多列索引中，为什么需要把重复率最低的列放到最左侧，因为这会减少比较的次数，查找起来更加高效。</p>\n<p>4.索引为什么选用B树这种数据结构？<br>因为使用B树查找时，所用的磁盘IO操作次数比平衡二叉树更少，效率也更高。<br>为什么使用B树查找所用的磁盘IO操作次数比平衡二叉树更少？<br>大规模数据存储中，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的高度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。那么我们就需要减少树的高度以提高查找效率。而平衡多路查找树结构B树就满足这样的要求。B树的各种操作能使B树保持较低的高度，从而达到有效减少磁盘IO操作次数。</p>\n<p>参考资料:<br>《数据结构（<a href=\"http://lib.csdn.net/base/c\" target=\"_blank\" rel=\"noopener\">C语言</a>版）》<br>《Effective MySQL之SQL语句最优化》<br>《高性能MySQL》</p>\n"},{"title":"algorithms","date":"2020-04-15T11:57:09.000Z","_content":"","source":"_posts/algorithms/algorithms.md","raw":"---\ntitle: algorithms\ntags:\n  - 数据结构与算法\ncategories:\n  - 数据结构与算法\n  - algorithms\ndate: 2020-04-15 19:57:09\n---\n","slug":"algorithms/algorithms","published":1,"updated":"2020-04-15T11:57:10.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7k7001ovgjaf5z0ag3v","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"JDK 监控和故障处理工具总结","date":"2020-06-04T08:55:23.000Z","_content":"## JDK 命令行工具\n\n这些命令在 JDK 安装目录下的 bin 目录下：\n\n- **jps** (JVM Process Status）: 类似 UNIX 的 `ps` 命令。用户查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；\n- **jstat**（ JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;\n- **jinfo** (Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;\n- **jmap** (Memory Map for Java) :生成堆转储快照;\n- **jhat** (JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;\n- **jstack** (Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。\n\n### `jps`:查看所有 Java 进程\n\n`jps`(JVM Process Status) 命令类似 UNIX 的 `ps` 命令。\n\n`jps`：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。`jps -q` ：只输出进程的本地虚拟机唯一 ID。\n\n```java\nC:\\Users\\SnailClimb>jps\n7360 NettyClient2\n17396\n7972 Launcher\n16504 Jps\n17340 NettyServer\n```\n\n`jps -l`:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。\n\n```java\nC:\\Users\\SnailClimb>jps -l\n7360 firstNettyDemo.NettyClient2\n17396\n7972 org.jetbrains.jps.cmdline.Launcher\n16492 sun.tools.jps.Jps\n17340 firstNettyDemo.NettyServer\n```\n\n`jps -v`：输出虚拟机进程启动时 JVM 参数。\n\n`jps -m`：输出传递给 Java 进程 main() 函数的参数。\n\n### `jstat`: 监视虚拟机各种运行状态信息\n\njstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。\n\n**jstat 命令使用格式：**\n\n```java\njstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]\n```\n\n比如 `jstat -gc -h3 31736 1000 10`表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。\n\n**常见的 option 如下：**\n\n- `jstat -class vmid` ：显示 ClassLoader 的相关信息；\n- `jstat -compiler vmid` ：显示 JIT 编译的相关信息；\n- `jstat -gc vmid` ：显示与 GC 相关的堆信息；\n- `jstat -gccapacity vmid` ：显示各个代的容量及使用情况；\n- `jstat -gcnew vmid` ：显示新生代信息；\n- `jstat -gcnewcapcacity vmid` ：显示新生代大小与使用情况；\n- `jstat -gcold vmid` ：显示老年代和永久代的行为统计，从jdk1.8开始,该选项仅表示老年代，因为永久代被移除了；\n- `jstat -gcoldcapacity vmid` ：显示老年代的大小；\n- `jstat -gcpermcapacity vmid` ：显示永久代大小，从jdk1.8开始,该选项不存在了，因为永久代被移除了；\n- `jstat -gcutil vmid` ：显示垃圾收集信息；\n\n另外，加上 `-t`参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。\n\n### `jinfo`: 实时地查看和调整虚拟机各项参数\n\n`jinfo vmid` :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。\n\n`jinfo -flag name vmid` :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( `-XX:PrintGCDetails` :详细 GC 日志模式，这两个都是默认关闭的)。\n\n```java\nC:\\Users\\SnailClimb>jinfo  -flag MaxHeapSize 17340\n-XX:MaxHeapSize=2124414976\nC:\\Users\\SnailClimb>jinfo  -flag PrintGC 17340\n-XX:-PrintGC\n```\n\n使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：\n\n`jinfo -flag [+|-]name vmid` 开启或者关闭对应名称的参数。\n\n```java\nC:\\Users\\SnailClimb>jinfo  -flag  PrintGC 17340\n-XX:-PrintGC\n\nC:\\Users\\SnailClimb>jinfo  -flag  +PrintGC 17340\n\nC:\\Users\\SnailClimb>jinfo  -flag  PrintGC 17340\n-XX:+PrintGC\n```\n\n### `jmap`:生成堆转储快照\n\n`jmap`（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 `jmap` 命令，要想获取 Java 堆转储，可以使用 `“-XX:+HeapDumpOnOutOfMemoryError”` 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 `kill -3` 发送进程退出信号也能拿到 dump 文件。\n\n`jmap` 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和`jinfo`一样，`jmap`有不少功能在 Windows 平台下也是受限制的。\n\n示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。\n\n```java\nC:\\Users\\SnailClimb>jmap -dump:format=b,file=C:\\Users\\SnailClimb\\Desktop\\heap.hprof 17340\nDumping heap to C:\\Users\\SnailClimb\\Desktop\\heap.hprof ...\nHeap dump file created\n```\n\n### **jhat**: 分析 heapdump 文件\n\n**jhat** 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。\n\n```java\nC:\\Users\\SnailClimb>jhat C:\\Users\\SnailClimb\\Desktop\\heap.hprof\nReading from C:\\Users\\SnailClimb\\Desktop\\heap.hprof...\nDump file created Sat May 04 12:30:31 CST 2019\nSnapshot read, resolving...\nResolving 131419 objects...\nChasing references, expect 26 dots..........................\nEliminating duplicate references..........................\nSnapshot resolved.\nStarted HTTP server on port 7000\nServer is ready.\n```\n\n访问 <http://localhost:7000/>\n\n### **jstack** :生成虚拟机当前时刻的线程快照\n\n`jstack`（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.\n\n生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过`jstack`来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。\n\n**下面是一个线程死锁的代码。我们下面会通过 jstack 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。**\n\n```java\npublic class DeadLockDemo {\n    private static Object resource1 = new Object();//资源 1\n    private static Object resource2 = new Object();//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -> {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n```\n\nOutput\n\n```java\nThread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n```\n\n线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过` Thread.sleep(1000);`让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。\n\n**通过 jstack 命令分析：**\n\n```java\nC:\\Users\\SnailClimb>jps\n13792 KotlinCompileDaemon\n7360 NettyClient2\n17396\n7972 Launcher\n8932 Launcher\n9256 DeadLockDemo\n10764 Jps\n17340 NettyServer\n\nC:\\Users\\SnailClimb>jstack 9256\n```\n\n输出的部分内容如下：\n\n```java\nFound one Java-level deadlock:\n=============================\n\"线程 2\":\n  waiting to lock monitor 0x000000000333e668 (object 0x00000000d5efe1c0, a java.lang.Object),\n  which is held by \"线程 1\"\n\"线程 1\":\n  waiting to lock monitor 0x000000000333be88 (object 0x00000000d5efe1d0, a java.lang.Object),\n  which is held by \"线程 2\"\n\nJava stack information for the threads listed above:\n===================================================\n\"线程 2\":\n        at DeadLockDemo.lambda$main$1(DeadLockDemo.java:31)\n        - waiting to lock <0x00000000d5efe1c0> (a java.lang.Object)\n        - locked <0x00000000d5efe1d0> (a java.lang.Object)\n        at DeadLockDemo$$Lambda$2/1078694789.run(Unknown Source)\n        at java.lang.Thread.run(Thread.java:748)\n\"线程 1\":\n        at DeadLockDemo.lambda$main$0(DeadLockDemo.java:16)\n        - waiting to lock <0x00000000d5efe1d0> (a java.lang.Object)\n        - locked <0x00000000d5efe1c0> (a java.lang.Object)\n        at DeadLockDemo$$Lambda$1/1324119927.run(Unknown Source)\n        at java.lang.Thread.run(Thread.java:748)\n\nFound 1 deadlock.\n```\n\n可以看到 `jstack` 命令已经帮我们找到发生死锁的线程的具体信息。\n\n## JDK 可视化分析工具\n\n### JConsole:Java 监视与管理控制台\n\nJConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出`console`命令启动或者在 JDK 目录下的 bin 目录找到`jconsole.exe`然后双击启动。\n\n#### 连接 Jconsole\n\n![545362](/images/25453625.png)\n\n如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:\n\n```\n-Djava.rmi.server.hostname=外网访问 ip 地址 \n-Dcom.sun.management.jmxremote.port=60001   //监控的端口号\n-Dcom.sun.management.jmxremote.authenticate=false   //关闭认证\n-Dcom.sun.management.jmxremote.ssl=false\n```\n\n在使用 JConsole 连接时，远程进程地址如下：\n\n```\n外网访问 ip 地址:60001 \n```\n\n#### 查看 Java 程序概况\n\n![4a617](/images/24a6176.png)\n\n#### 内存监控\n\nJConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。\n\n点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。\n\n> - **新生代 GC（Minor GC）**:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。\n> - **老年代 GC（Major GC/Full GC）**:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。\n\n![53](/images/4537.png)\n\n#### 线程监控\n\n类似我们前面讲的 `jstack` 命令，不过这个是可视化的。\n\n最下面有一个\"检测死锁 (D)\"按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。\n\n![4225453](/images/842254537.png)\n\n### Visual VM:多合一故障处理工具\n\nVisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<https://visualvm.github.io/> 。Visual VM 中文文档:<https://visualvm.github.io/documentation.html>。\n\n下面这段话摘自《深入理解 Java 虚拟机》。\n\n> VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。\n\nVisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：\n\n- **显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。**\n- **监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。**\n- **dump 以及分析堆转储快照（jmap、jhat）。**\n- **方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。**\n- **离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。**\n- **其他 plugins 的无限的可能性......**\n\n这里就不具体介绍 VisualVM 的使用，如果想了解的话可以看:\n\n- <https://visualvm.github.io/documentation.html>\n- <https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html>\n\n## 公众号\n\n如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。\n\n**《Java面试突击》:** 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本公众号后台回复 **\"Java面试突击\"** 即可免费领取！\n\n**Java工程师必备学习资源:** 一些Java工程师常用学习资源公众号后台回复关键字 **“1”** 即可免费无套路获取。","source":"_posts/java/JDK 监控和故障处理工具总结.md","raw":"---\ntitle: JDK 监控和故障处理工具总结\ndate: 2020-06-04 16:55:23\ntags:\n    - java\n    - jvm工具\ncategories:\n    - java\n    - jvm工具\n---\n## JDK 命令行工具\n\n这些命令在 JDK 安装目录下的 bin 目录下：\n\n- **jps** (JVM Process Status）: 类似 UNIX 的 `ps` 命令。用户查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；\n- **jstat**（ JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;\n- **jinfo** (Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;\n- **jmap** (Memory Map for Java) :生成堆转储快照;\n- **jhat** (JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;\n- **jstack** (Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。\n\n### `jps`:查看所有 Java 进程\n\n`jps`(JVM Process Status) 命令类似 UNIX 的 `ps` 命令。\n\n`jps`：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。`jps -q` ：只输出进程的本地虚拟机唯一 ID。\n\n```java\nC:\\Users\\SnailClimb>jps\n7360 NettyClient2\n17396\n7972 Launcher\n16504 Jps\n17340 NettyServer\n```\n\n`jps -l`:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。\n\n```java\nC:\\Users\\SnailClimb>jps -l\n7360 firstNettyDemo.NettyClient2\n17396\n7972 org.jetbrains.jps.cmdline.Launcher\n16492 sun.tools.jps.Jps\n17340 firstNettyDemo.NettyServer\n```\n\n`jps -v`：输出虚拟机进程启动时 JVM 参数。\n\n`jps -m`：输出传递给 Java 进程 main() 函数的参数。\n\n### `jstat`: 监视虚拟机各种运行状态信息\n\njstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。\n\n**jstat 命令使用格式：**\n\n```java\njstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]\n```\n\n比如 `jstat -gc -h3 31736 1000 10`表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。\n\n**常见的 option 如下：**\n\n- `jstat -class vmid` ：显示 ClassLoader 的相关信息；\n- `jstat -compiler vmid` ：显示 JIT 编译的相关信息；\n- `jstat -gc vmid` ：显示与 GC 相关的堆信息；\n- `jstat -gccapacity vmid` ：显示各个代的容量及使用情况；\n- `jstat -gcnew vmid` ：显示新生代信息；\n- `jstat -gcnewcapcacity vmid` ：显示新生代大小与使用情况；\n- `jstat -gcold vmid` ：显示老年代和永久代的行为统计，从jdk1.8开始,该选项仅表示老年代，因为永久代被移除了；\n- `jstat -gcoldcapacity vmid` ：显示老年代的大小；\n- `jstat -gcpermcapacity vmid` ：显示永久代大小，从jdk1.8开始,该选项不存在了，因为永久代被移除了；\n- `jstat -gcutil vmid` ：显示垃圾收集信息；\n\n另外，加上 `-t`参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。\n\n### `jinfo`: 实时地查看和调整虚拟机各项参数\n\n`jinfo vmid` :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。\n\n`jinfo -flag name vmid` :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( `-XX:PrintGCDetails` :详细 GC 日志模式，这两个都是默认关闭的)。\n\n```java\nC:\\Users\\SnailClimb>jinfo  -flag MaxHeapSize 17340\n-XX:MaxHeapSize=2124414976\nC:\\Users\\SnailClimb>jinfo  -flag PrintGC 17340\n-XX:-PrintGC\n```\n\n使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：\n\n`jinfo -flag [+|-]name vmid` 开启或者关闭对应名称的参数。\n\n```java\nC:\\Users\\SnailClimb>jinfo  -flag  PrintGC 17340\n-XX:-PrintGC\n\nC:\\Users\\SnailClimb>jinfo  -flag  +PrintGC 17340\n\nC:\\Users\\SnailClimb>jinfo  -flag  PrintGC 17340\n-XX:+PrintGC\n```\n\n### `jmap`:生成堆转储快照\n\n`jmap`（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 `jmap` 命令，要想获取 Java 堆转储，可以使用 `“-XX:+HeapDumpOnOutOfMemoryError”` 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 `kill -3` 发送进程退出信号也能拿到 dump 文件。\n\n`jmap` 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和`jinfo`一样，`jmap`有不少功能在 Windows 平台下也是受限制的。\n\n示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。\n\n```java\nC:\\Users\\SnailClimb>jmap -dump:format=b,file=C:\\Users\\SnailClimb\\Desktop\\heap.hprof 17340\nDumping heap to C:\\Users\\SnailClimb\\Desktop\\heap.hprof ...\nHeap dump file created\n```\n\n### **jhat**: 分析 heapdump 文件\n\n**jhat** 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。\n\n```java\nC:\\Users\\SnailClimb>jhat C:\\Users\\SnailClimb\\Desktop\\heap.hprof\nReading from C:\\Users\\SnailClimb\\Desktop\\heap.hprof...\nDump file created Sat May 04 12:30:31 CST 2019\nSnapshot read, resolving...\nResolving 131419 objects...\nChasing references, expect 26 dots..........................\nEliminating duplicate references..........................\nSnapshot resolved.\nStarted HTTP server on port 7000\nServer is ready.\n```\n\n访问 <http://localhost:7000/>\n\n### **jstack** :生成虚拟机当前时刻的线程快照\n\n`jstack`（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.\n\n生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过`jstack`来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。\n\n**下面是一个线程死锁的代码。我们下面会通过 jstack 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。**\n\n```java\npublic class DeadLockDemo {\n    private static Object resource1 = new Object();//资源 1\n    private static Object resource2 = new Object();//资源 2\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (resource1) {\n                System.out.println(Thread.currentThread() + \"get resource1\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource2\");\n                synchronized (resource2) {\n                    System.out.println(Thread.currentThread() + \"get resource2\");\n                }\n            }\n        }, \"线程 1\").start();\n\n        new Thread(() -> {\n            synchronized (resource2) {\n                System.out.println(Thread.currentThread() + \"get resource2\");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread() + \"waiting get resource1\");\n                synchronized (resource1) {\n                    System.out.println(Thread.currentThread() + \"get resource1\");\n                }\n            }\n        }, \"线程 2\").start();\n    }\n}\n```\n\nOutput\n\n```java\nThread[线程 1,5,main]get resource1\nThread[线程 2,5,main]get resource2\nThread[线程 1,5,main]waiting get resource2\nThread[线程 2,5,main]waiting get resource1\n```\n\n线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过` Thread.sleep(1000);`让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。\n\n**通过 jstack 命令分析：**\n\n```java\nC:\\Users\\SnailClimb>jps\n13792 KotlinCompileDaemon\n7360 NettyClient2\n17396\n7972 Launcher\n8932 Launcher\n9256 DeadLockDemo\n10764 Jps\n17340 NettyServer\n\nC:\\Users\\SnailClimb>jstack 9256\n```\n\n输出的部分内容如下：\n\n```java\nFound one Java-level deadlock:\n=============================\n\"线程 2\":\n  waiting to lock monitor 0x000000000333e668 (object 0x00000000d5efe1c0, a java.lang.Object),\n  which is held by \"线程 1\"\n\"线程 1\":\n  waiting to lock monitor 0x000000000333be88 (object 0x00000000d5efe1d0, a java.lang.Object),\n  which is held by \"线程 2\"\n\nJava stack information for the threads listed above:\n===================================================\n\"线程 2\":\n        at DeadLockDemo.lambda$main$1(DeadLockDemo.java:31)\n        - waiting to lock <0x00000000d5efe1c0> (a java.lang.Object)\n        - locked <0x00000000d5efe1d0> (a java.lang.Object)\n        at DeadLockDemo$$Lambda$2/1078694789.run(Unknown Source)\n        at java.lang.Thread.run(Thread.java:748)\n\"线程 1\":\n        at DeadLockDemo.lambda$main$0(DeadLockDemo.java:16)\n        - waiting to lock <0x00000000d5efe1d0> (a java.lang.Object)\n        - locked <0x00000000d5efe1c0> (a java.lang.Object)\n        at DeadLockDemo$$Lambda$1/1324119927.run(Unknown Source)\n        at java.lang.Thread.run(Thread.java:748)\n\nFound 1 deadlock.\n```\n\n可以看到 `jstack` 命令已经帮我们找到发生死锁的线程的具体信息。\n\n## JDK 可视化分析工具\n\n### JConsole:Java 监视与管理控制台\n\nJConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出`console`命令启动或者在 JDK 目录下的 bin 目录找到`jconsole.exe`然后双击启动。\n\n#### 连接 Jconsole\n\n![545362](/images/25453625.png)\n\n如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:\n\n```\n-Djava.rmi.server.hostname=外网访问 ip 地址 \n-Dcom.sun.management.jmxremote.port=60001   //监控的端口号\n-Dcom.sun.management.jmxremote.authenticate=false   //关闭认证\n-Dcom.sun.management.jmxremote.ssl=false\n```\n\n在使用 JConsole 连接时，远程进程地址如下：\n\n```\n外网访问 ip 地址:60001 \n```\n\n#### 查看 Java 程序概况\n\n![4a617](/images/24a6176.png)\n\n#### 内存监控\n\nJConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。\n\n点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。\n\n> - **新生代 GC（Minor GC）**:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。\n> - **老年代 GC（Major GC/Full GC）**:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。\n\n![53](/images/4537.png)\n\n#### 线程监控\n\n类似我们前面讲的 `jstack` 命令，不过这个是可视化的。\n\n最下面有一个\"检测死锁 (D)\"按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。\n\n![4225453](/images/842254537.png)\n\n### Visual VM:多合一故障处理工具\n\nVisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<https://visualvm.github.io/> 。Visual VM 中文文档:<https://visualvm.github.io/documentation.html>。\n\n下面这段话摘自《深入理解 Java 虚拟机》。\n\n> VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。\n\nVisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：\n\n- **显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。**\n- **监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。**\n- **dump 以及分析堆转储快照（jmap、jhat）。**\n- **方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。**\n- **离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。**\n- **其他 plugins 的无限的可能性......**\n\n这里就不具体介绍 VisualVM 的使用，如果想了解的话可以看:\n\n- <https://visualvm.github.io/documentation.html>\n- <https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html>\n\n## 公众号\n\n如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。\n\n**《Java面试突击》:** 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本公众号后台回复 **\"Java面试突击\"** 即可免费领取！\n\n**Java工程师必备学习资源:** 一些Java工程师常用学习资源公众号后台回复关键字 **“1”** 即可免费无套路获取。","slug":"java/JDK 监控和故障处理工具总结","published":1,"updated":"2020-06-04T09:06:57.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7lf004jvgjaa0hoh8uv","content":"<h2 id=\"JDK-命令行工具\"><a href=\"#JDK-命令行工具\" class=\"headerlink\" title=\"JDK 命令行工具\"></a>JDK 命令行工具</h2><p>这些命令在 JDK 安装目录下的 bin 目录下：</p>\n<ul>\n<li><strong>jps</strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用户查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li>\n<li><strong>jstat</strong>（ JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li>\n<li><strong>jinfo</strong> (Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;</li>\n<li><strong>jmap</strong> (Memory Map for Java) :生成堆转储快照;</li>\n<li><strong>jhat</strong> (JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</li>\n<li><strong>jstack</strong> (Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li>\n</ul>\n<h3 id=\"jps-查看所有-Java-进程\"><a href=\"#jps-查看所有-Java-进程\" class=\"headerlink\" title=\"jps:查看所有 Java 进程\"></a><code>jps</code>:查看所有 Java 进程</h3><p><code>jps</code>(JVM Process Status) 命令类似 UNIX 的 <code>ps</code> 命令。</p>\n<p><code>jps</code>：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。<code>jps -q</code> ：只输出进程的本地虚拟机唯一 ID。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jps</span><br><span class=\"line\"><span class=\"number\">7360</span> NettyClient2</span><br><span class=\"line\"><span class=\"number\">17396</span></span><br><span class=\"line\"><span class=\"number\">7972</span> Launcher</span><br><span class=\"line\"><span class=\"number\">16504</span> Jps</span><br><span class=\"line\"><span class=\"number\">17340</span> NettyServer</span><br></pre></td></tr></table></figure>\n\n<p><code>jps -l</code>:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jps -l</span><br><span class=\"line\"><span class=\"number\">7360</span> firstNettyDemo.NettyClient2</span><br><span class=\"line\"><span class=\"number\">17396</span></span><br><span class=\"line\"><span class=\"number\">7972</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class=\"line\"><span class=\"number\">16492</span> sun.tools.jps.Jps</span><br><span class=\"line\"><span class=\"number\">17340</span> firstNettyDemo.NettyServer</span><br></pre></td></tr></table></figure>\n\n<p><code>jps -v</code>：输出虚拟机进程启动时 JVM 参数。</p>\n<p><code>jps -m</code>：输出传递给 Java 进程 main() 函数的参数。</p>\n<h3 id=\"jstat-监视虚拟机各种运行状态信息\"><a href=\"#jstat-监视虚拟机各种运行状态信息\" class=\"headerlink\" title=\"jstat: 监视虚拟机各种运行状态信息\"></a><code>jstat</code>: 监视虚拟机各种运行状态信息</h3><p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p>\n<p><strong>jstat 命令使用格式：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure>\n\n<p>比如 <code>jstat -gc -h3 31736 1000 10</code>表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p>\n<p><strong>常见的 option 如下：</strong></p>\n<ul>\n<li><code>jstat -class vmid</code> ：显示 ClassLoader 的相关信息；</li>\n<li><code>jstat -compiler vmid</code> ：显示 JIT 编译的相关信息；</li>\n<li><code>jstat -gc vmid</code> ：显示与 GC 相关的堆信息；</li>\n<li><code>jstat -gccapacity vmid</code> ：显示各个代的容量及使用情况；</li>\n<li><code>jstat -gcnew vmid</code> ：显示新生代信息；</li>\n<li><code>jstat -gcnewcapcacity vmid</code> ：显示新生代大小与使用情况；</li>\n<li><code>jstat -gcold vmid</code> ：显示老年代和永久代的行为统计，从jdk1.8开始,该选项仅表示老年代，因为永久代被移除了；</li>\n<li><code>jstat -gcoldcapacity vmid</code> ：显示老年代的大小；</li>\n<li><code>jstat -gcpermcapacity vmid</code> ：显示永久代大小，从jdk1.8开始,该选项不存在了，因为永久代被移除了；</li>\n<li><code>jstat -gcutil vmid</code> ：显示垃圾收集信息；</li>\n</ul>\n<p>另外，加上 <code>-t</code>参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。</p>\n<h3 id=\"jinfo-实时地查看和调整虚拟机各项参数\"><a href=\"#jinfo-实时地查看和调整虚拟机各项参数\" class=\"headerlink\" title=\"jinfo: 实时地查看和调整虚拟机各项参数\"></a><code>jinfo</code>: 实时地查看和调整虚拟机各项参数</h3><p><code>jinfo vmid</code> :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。</p>\n<p><code>jinfo -flag name vmid</code> :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( <code>-XX:PrintGCDetails</code> :详细 GC 日志模式，这两个都是默认关闭的)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jinfo  -flag MaxHeapSize <span class=\"number\">17340</span></span><br><span class=\"line\">-XX:MaxHeapSize=<span class=\"number\">2124414976</span></span><br><span class=\"line\">C:\\Users\\SnailClimb&gt;jinfo  -flag PrintGC <span class=\"number\">17340</span></span><br><span class=\"line\">-XX:-PrintGC</span><br></pre></td></tr></table></figure>\n\n<p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：</p>\n<p><code>jinfo -flag [+|-]name vmid</code> 开启或者关闭对应名称的参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jinfo  -flag  PrintGC <span class=\"number\">17340</span></span><br><span class=\"line\">-XX:-PrintGC</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\SnailClimb&gt;jinfo  -flag  +PrintGC <span class=\"number\">17340</span></span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\SnailClimb&gt;jinfo  -flag  PrintGC <span class=\"number\">17340</span></span><br><span class=\"line\">-XX:+PrintGC</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"jmap-生成堆转储快照\"><a href=\"#jmap-生成堆转储快照\" class=\"headerlink\" title=\"jmap:生成堆转储快照\"></a><code>jmap</code>:生成堆转储快照</h3><p><code>jmap</code>（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 <code>jmap</code> 命令，要想获取 Java 堆转储，可以使用 <code>“-XX:+HeapDumpOnOutOfMemoryError”</code> 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 <code>kill -3</code> 发送进程退出信号也能拿到 dump 文件。</p>\n<p><code>jmap</code> 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和<code>jinfo</code>一样，<code>jmap</code>有不少功能在 Windows 平台下也是受限制的。</p>\n<p>示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jmap -dump:format=b,file=C:\\Users\\SnailClimb\\Desktop\\heap.hprof <span class=\"number\">17340</span></span><br><span class=\"line\">Dumping heap to C:\\Users\\SnailClimb\\Desktop\\heap.hprof ...</span><br><span class=\"line\">Heap dump file created</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"jhat-分析-heapdump-文件\"><a href=\"#jhat-分析-heapdump-文件\" class=\"headerlink\" title=\"jhat: 分析 heapdump 文件\"></a><strong>jhat</strong>: 分析 heapdump 文件</h3><p><strong>jhat</strong> 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jhat C:\\Users\\SnailClimb\\Desktop\\heap.hprof</span><br><span class=\"line\">Reading from C:\\Users\\SnailClimb\\Desktop\\heap.hprof...</span><br><span class=\"line\">Dump file created Sat May <span class=\"number\">04</span> <span class=\"number\">12</span>:<span class=\"number\">30</span>:<span class=\"number\">31</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">Snapshot read, resolving...</span><br><span class=\"line\">Resolving <span class=\"number\">131419</span> objects...</span><br><span class=\"line\">Chasing references, expect <span class=\"number\">26</span> dots..........................</span><br><span class=\"line\">Eliminating duplicate references..........................</span><br><span class=\"line\">Snapshot resolved.</span><br><span class=\"line\">Started HTTP server on port <span class=\"number\">7000</span></span><br><span class=\"line\">Server is ready.</span><br></pre></td></tr></table></figure>\n\n<p>访问 <a href=\"http://localhost:7000/\" target=\"_blank\" rel=\"noopener\">http://localhost:7000/</a></p>\n<h3 id=\"jstack-生成虚拟机当前时刻的线程快照\"><a href=\"#jstack-生成虚拟机当前时刻的线程快照\" class=\"headerlink\" title=\"jstack :生成虚拟机当前时刻的线程快照\"></a><strong>jstack</strong> :生成虚拟机当前时刻的线程快照</h3><p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p>\n<p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p>\n<p><strong>下面是一个线程死锁的代码。我们下面会通过 jstack 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadLockDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object resource1 = <span class=\"keyword\">new</span> Object();<span class=\"comment\">//资源 1</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object resource2 = <span class=\"keyword\">new</span> Object();<span class=\"comment\">//资源 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource2\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"线程 1\"</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource1\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"线程 2\"</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Output</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure>\n\n<p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p>\n<p><strong>通过 jstack 命令分析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jps</span><br><span class=\"line\"><span class=\"number\">13792</span> KotlinCompileDaemon</span><br><span class=\"line\"><span class=\"number\">7360</span> NettyClient2</span><br><span class=\"line\"><span class=\"number\">17396</span></span><br><span class=\"line\"><span class=\"number\">7972</span> Launcher</span><br><span class=\"line\"><span class=\"number\">8932</span> Launcher</span><br><span class=\"line\"><span class=\"number\">9256</span> DeadLockDemo</span><br><span class=\"line\"><span class=\"number\">10764</span> Jps</span><br><span class=\"line\"><span class=\"number\">17340</span> NettyServer</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\SnailClimb&gt;jstack <span class=\"number\">9256</span></span><br></pre></td></tr></table></figure>\n\n<p>输出的部分内容如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Found one Java-level deadlock:</span><br><span class=\"line\">=============================</span><br><span class=\"line\"><span class=\"string\">\"线程 2\"</span>:</span><br><span class=\"line\">  waiting to lock monitor <span class=\"number\">0x000000000333e668</span> (object <span class=\"number\">0x00000000d5efe1c0</span>, a java.lang.Object),</span><br><span class=\"line\">  which is held by <span class=\"string\">\"线程 1\"</span></span><br><span class=\"line\"><span class=\"string\">\"线程 1\"</span>:</span><br><span class=\"line\">  waiting to lock monitor <span class=\"number\">0x000000000333be88</span> (object <span class=\"number\">0x00000000d5efe1d0</span>, a java.lang.Object),</span><br><span class=\"line\">  which is held by <span class=\"string\">\"线程 2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Java stack information <span class=\"keyword\">for</span> the threads listed above:</span><br><span class=\"line\">===================================================</span><br><span class=\"line\"><span class=\"string\">\"线程 2\"</span>:</span><br><span class=\"line\">        at DeadLockDemo.lambda$main$<span class=\"number\">1</span>(DeadLockDemo.java:<span class=\"number\">31</span>)</span><br><span class=\"line\">        - waiting to lock &lt;<span class=\"number\">0x00000000d5efe1c0</span>&gt; (a java.lang.Object)</span><br><span class=\"line\">        - locked &lt;<span class=\"number\">0x00000000d5efe1d0</span>&gt; (a java.lang.Object)</span><br><span class=\"line\">        at DeadLockDemo$$Lambda$<span class=\"number\">2</span>/<span class=\"number\">1078694789</span>.run(Unknown Source)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">748</span>)</span><br><span class=\"line\"><span class=\"string\">\"线程 1\"</span>:</span><br><span class=\"line\">        at DeadLockDemo.lambda$main$<span class=\"number\">0</span>(DeadLockDemo.java:<span class=\"number\">16</span>)</span><br><span class=\"line\">        - waiting to lock &lt;<span class=\"number\">0x00000000d5efe1d0</span>&gt; (a java.lang.Object)</span><br><span class=\"line\">        - locked &lt;<span class=\"number\">0x00000000d5efe1c0</span>&gt; (a java.lang.Object)</span><br><span class=\"line\">        at DeadLockDemo$$Lambda$<span class=\"number\">1</span>/<span class=\"number\">1324119927</span>.run(Unknown Source)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">748</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">Found <span class=\"number\">1</span> deadlock.</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 <code>jstack</code> 命令已经帮我们找到发生死锁的线程的具体信息。</p>\n<h2 id=\"JDK-可视化分析工具\"><a href=\"#JDK-可视化分析工具\" class=\"headerlink\" title=\"JDK 可视化分析工具\"></a>JDK 可视化分析工具</h2><h3 id=\"JConsole-Java-监视与管理控制台\"><a href=\"#JConsole-Java-监视与管理控制台\" class=\"headerlink\" title=\"JConsole:Java 监视与管理控制台\"></a>JConsole:Java 监视与管理控制台</h3><p>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出<code>console</code>命令启动或者在 JDK 目录下的 bin 目录找到<code>jconsole.exe</code>然后双击启动。</p>\n<h4 id=\"连接-Jconsole\"><a href=\"#连接-Jconsole\" class=\"headerlink\" title=\"连接 Jconsole\"></a>连接 Jconsole</h4><p><img src=\"/images/25453625.png\" alt=\"545362\"></p>\n<p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Djava.rmi.server.hostname&#x3D;外网访问 ip 地址 </span><br><span class=\"line\">-Dcom.sun.management.jmxremote.port&#x3D;60001   &#x2F;&#x2F;监控的端口号</span><br><span class=\"line\">-Dcom.sun.management.jmxremote.authenticate&#x3D;false   &#x2F;&#x2F;关闭认证</span><br><span class=\"line\">-Dcom.sun.management.jmxremote.ssl&#x3D;false</span><br></pre></td></tr></table></figure>\n\n<p>在使用 JConsole 连接时，远程进程地址如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">外网访问 ip 地址:60001</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查看-Java-程序概况\"><a href=\"#查看-Java-程序概况\" class=\"headerlink\" title=\"查看 Java 程序概况\"></a>查看 Java 程序概况</h4><p><img src=\"/images/24a6176.png\" alt=\"4a617\"></p>\n<h4 id=\"内存监控\"><a href=\"#内存监控\" class=\"headerlink\" title=\"内存监控\"></a>内存监控</h4><p>JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。</p>\n<p>点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。</p>\n<blockquote>\n<ul>\n<li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li>\n<li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li>\n</ul>\n</blockquote>\n<p><img src=\"/images/4537.png\" alt=\"53\"></p>\n<h4 id=\"线程监控\"><a href=\"#线程监控\" class=\"headerlink\" title=\"线程监控\"></a>线程监控</h4><p>类似我们前面讲的 <code>jstack</code> 命令，不过这个是可视化的。</p>\n<p>最下面有一个”检测死锁 (D)”按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。</p>\n<p><img src=\"/images/842254537.png\" alt=\"4225453\"></p>\n<h3 id=\"Visual-VM-多合一故障处理工具\"><a href=\"#Visual-VM-多合一故障处理工具\" class=\"headerlink\" title=\"Visual VM:多合一故障处理工具\"></a>Visual VM:多合一故障处理工具</h3><p>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<a href=\"https://visualvm.github.io/\" target=\"_blank\" rel=\"noopener\">https://visualvm.github.io/</a> 。Visual VM 中文文档:<a href=\"https://visualvm.github.io/documentation.html\" target=\"_blank\" rel=\"noopener\">https://visualvm.github.io/documentation.html</a>。</p>\n<p>下面这段话摘自《深入理解 Java 虚拟机》。</p>\n<blockquote>\n<p>VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。</p>\n</blockquote>\n<p>VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p>\n<ul>\n<li><strong>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</strong></li>\n<li><strong>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</strong></li>\n<li><strong>dump 以及分析堆转储快照（jmap、jhat）。</strong></li>\n<li><strong>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。</strong></li>\n<li><strong>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</strong></li>\n<li><strong>其他 plugins 的无限的可能性……</strong></li>\n</ul>\n<p>这里就不具体介绍 VisualVM 的使用，如果想了解的话可以看:</p>\n<ul>\n<li><a href=\"https://visualvm.github.io/documentation.html\" target=\"_blank\" rel=\"noopener\">https://visualvm.github.io/documentation.html</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html</a></li>\n</ul>\n<h2 id=\"公众号\"><a href=\"#公众号\" class=\"headerlink\" title=\"公众号\"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p>\n<p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本公众号后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</p>\n<p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"JDK-命令行工具\"><a href=\"#JDK-命令行工具\" class=\"headerlink\" title=\"JDK 命令行工具\"></a>JDK 命令行工具</h2><p>这些命令在 JDK 安装目录下的 bin 目录下：</p>\n<ul>\n<li><strong>jps</strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用户查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li>\n<li><strong>jstat</strong>（ JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li>\n<li><strong>jinfo</strong> (Configuration Info for Java) : Configuration Info forJava,显示虚拟机配置信息;</li>\n<li><strong>jmap</strong> (Memory Map for Java) :生成堆转储快照;</li>\n<li><strong>jhat</strong> (JVM Heap Dump Browser ) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</li>\n<li><strong>jstack</strong> (Stack Trace for Java):生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li>\n</ul>\n<h3 id=\"jps-查看所有-Java-进程\"><a href=\"#jps-查看所有-Java-进程\" class=\"headerlink\" title=\"jps:查看所有 Java 进程\"></a><code>jps</code>:查看所有 Java 进程</h3><p><code>jps</code>(JVM Process Status) 命令类似 UNIX 的 <code>ps</code> 命令。</p>\n<p><code>jps</code>：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。<code>jps -q</code> ：只输出进程的本地虚拟机唯一 ID。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jps</span><br><span class=\"line\"><span class=\"number\">7360</span> NettyClient2</span><br><span class=\"line\"><span class=\"number\">17396</span></span><br><span class=\"line\"><span class=\"number\">7972</span> Launcher</span><br><span class=\"line\"><span class=\"number\">16504</span> Jps</span><br><span class=\"line\"><span class=\"number\">17340</span> NettyServer</span><br></pre></td></tr></table></figure>\n\n<p><code>jps -l</code>:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jps -l</span><br><span class=\"line\"><span class=\"number\">7360</span> firstNettyDemo.NettyClient2</span><br><span class=\"line\"><span class=\"number\">17396</span></span><br><span class=\"line\"><span class=\"number\">7972</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class=\"line\"><span class=\"number\">16492</span> sun.tools.jps.Jps</span><br><span class=\"line\"><span class=\"number\">17340</span> firstNettyDemo.NettyServer</span><br></pre></td></tr></table></figure>\n\n<p><code>jps -v</code>：输出虚拟机进程启动时 JVM 参数。</p>\n<p><code>jps -m</code>：输出传递给 Java 进程 main() 函数的参数。</p>\n<h3 id=\"jstat-监视虚拟机各种运行状态信息\"><a href=\"#jstat-监视虚拟机各种运行状态信息\" class=\"headerlink\" title=\"jstat: 监视虚拟机各种运行状态信息\"></a><code>jstat</code>: 监视虚拟机各种运行状态信息</h3><p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p>\n<p><strong>jstat 命令使用格式：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure>\n\n<p>比如 <code>jstat -gc -h3 31736 1000 10</code>表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p>\n<p><strong>常见的 option 如下：</strong></p>\n<ul>\n<li><code>jstat -class vmid</code> ：显示 ClassLoader 的相关信息；</li>\n<li><code>jstat -compiler vmid</code> ：显示 JIT 编译的相关信息；</li>\n<li><code>jstat -gc vmid</code> ：显示与 GC 相关的堆信息；</li>\n<li><code>jstat -gccapacity vmid</code> ：显示各个代的容量及使用情况；</li>\n<li><code>jstat -gcnew vmid</code> ：显示新生代信息；</li>\n<li><code>jstat -gcnewcapcacity vmid</code> ：显示新生代大小与使用情况；</li>\n<li><code>jstat -gcold vmid</code> ：显示老年代和永久代的行为统计，从jdk1.8开始,该选项仅表示老年代，因为永久代被移除了；</li>\n<li><code>jstat -gcoldcapacity vmid</code> ：显示老年代的大小；</li>\n<li><code>jstat -gcpermcapacity vmid</code> ：显示永久代大小，从jdk1.8开始,该选项不存在了，因为永久代被移除了；</li>\n<li><code>jstat -gcutil vmid</code> ：显示垃圾收集信息；</li>\n</ul>\n<p>另外，加上 <code>-t</code>参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。</p>\n<h3 id=\"jinfo-实时地查看和调整虚拟机各项参数\"><a href=\"#jinfo-实时地查看和调整虚拟机各项参数\" class=\"headerlink\" title=\"jinfo: 实时地查看和调整虚拟机各项参数\"></a><code>jinfo</code>: 实时地查看和调整虚拟机各项参数</h3><p><code>jinfo vmid</code> :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。</p>\n<p><code>jinfo -flag name vmid</code> :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( <code>-XX:PrintGCDetails</code> :详细 GC 日志模式，这两个都是默认关闭的)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jinfo  -flag MaxHeapSize <span class=\"number\">17340</span></span><br><span class=\"line\">-XX:MaxHeapSize=<span class=\"number\">2124414976</span></span><br><span class=\"line\">C:\\Users\\SnailClimb&gt;jinfo  -flag PrintGC <span class=\"number\">17340</span></span><br><span class=\"line\">-XX:-PrintGC</span><br></pre></td></tr></table></figure>\n\n<p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：</p>\n<p><code>jinfo -flag [+|-]name vmid</code> 开启或者关闭对应名称的参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jinfo  -flag  PrintGC <span class=\"number\">17340</span></span><br><span class=\"line\">-XX:-PrintGC</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\SnailClimb&gt;jinfo  -flag  +PrintGC <span class=\"number\">17340</span></span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\SnailClimb&gt;jinfo  -flag  PrintGC <span class=\"number\">17340</span></span><br><span class=\"line\">-XX:+PrintGC</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"jmap-生成堆转储快照\"><a href=\"#jmap-生成堆转储快照\" class=\"headerlink\" title=\"jmap:生成堆转储快照\"></a><code>jmap</code>:生成堆转储快照</h3><p><code>jmap</code>（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 <code>jmap</code> 命令，要想获取 Java 堆转储，可以使用 <code>“-XX:+HeapDumpOnOutOfMemoryError”</code> 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 <code>kill -3</code> 发送进程退出信号也能拿到 dump 文件。</p>\n<p><code>jmap</code> 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和<code>jinfo</code>一样，<code>jmap</code>有不少功能在 Windows 平台下也是受限制的。</p>\n<p>示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jmap -dump:format=b,file=C:\\Users\\SnailClimb\\Desktop\\heap.hprof <span class=\"number\">17340</span></span><br><span class=\"line\">Dumping heap to C:\\Users\\SnailClimb\\Desktop\\heap.hprof ...</span><br><span class=\"line\">Heap dump file created</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"jhat-分析-heapdump-文件\"><a href=\"#jhat-分析-heapdump-文件\" class=\"headerlink\" title=\"jhat: 分析 heapdump 文件\"></a><strong>jhat</strong>: 分析 heapdump 文件</h3><p><strong>jhat</strong> 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jhat C:\\Users\\SnailClimb\\Desktop\\heap.hprof</span><br><span class=\"line\">Reading from C:\\Users\\SnailClimb\\Desktop\\heap.hprof...</span><br><span class=\"line\">Dump file created Sat May <span class=\"number\">04</span> <span class=\"number\">12</span>:<span class=\"number\">30</span>:<span class=\"number\">31</span> CST <span class=\"number\">2019</span></span><br><span class=\"line\">Snapshot read, resolving...</span><br><span class=\"line\">Resolving <span class=\"number\">131419</span> objects...</span><br><span class=\"line\">Chasing references, expect <span class=\"number\">26</span> dots..........................</span><br><span class=\"line\">Eliminating duplicate references..........................</span><br><span class=\"line\">Snapshot resolved.</span><br><span class=\"line\">Started HTTP server on port <span class=\"number\">7000</span></span><br><span class=\"line\">Server is ready.</span><br></pre></td></tr></table></figure>\n\n<p>访问 <a href=\"http://localhost:7000/\" target=\"_blank\" rel=\"noopener\">http://localhost:7000/</a></p>\n<h3 id=\"jstack-生成虚拟机当前时刻的线程快照\"><a href=\"#jstack-生成虚拟机当前时刻的线程快照\" class=\"headerlink\" title=\"jstack :生成虚拟机当前时刻的线程快照\"></a><strong>jstack</strong> :生成虚拟机当前时刻的线程快照</h3><p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p>\n<p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p>\n<p><strong>下面是一个线程死锁的代码。我们下面会通过 jstack 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadLockDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object resource1 = <span class=\"keyword\">new</span> Object();<span class=\"comment\">//资源 1</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object resource2 = <span class=\"keyword\">new</span> Object();<span class=\"comment\">//资源 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource2\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"线程 1\"</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (resource2) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource2\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(Thread.currentThread() + <span class=\"string\">\"waiting get resource1\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (resource1) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread() + <span class=\"string\">\"get resource1\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">\"线程 2\"</span>).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Output</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]get resource1</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">1</span>,<span class=\"number\">5</span>,main]waiting get resource2</span><br><span class=\"line\">Thread[线程 <span class=\"number\">2</span>,<span class=\"number\">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure>\n\n<p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p>\n<p><strong>通过 jstack 命令分析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\SnailClimb&gt;jps</span><br><span class=\"line\"><span class=\"number\">13792</span> KotlinCompileDaemon</span><br><span class=\"line\"><span class=\"number\">7360</span> NettyClient2</span><br><span class=\"line\"><span class=\"number\">17396</span></span><br><span class=\"line\"><span class=\"number\">7972</span> Launcher</span><br><span class=\"line\"><span class=\"number\">8932</span> Launcher</span><br><span class=\"line\"><span class=\"number\">9256</span> DeadLockDemo</span><br><span class=\"line\"><span class=\"number\">10764</span> Jps</span><br><span class=\"line\"><span class=\"number\">17340</span> NettyServer</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Users\\SnailClimb&gt;jstack <span class=\"number\">9256</span></span><br></pre></td></tr></table></figure>\n\n<p>输出的部分内容如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Found one Java-level deadlock:</span><br><span class=\"line\">=============================</span><br><span class=\"line\"><span class=\"string\">\"线程 2\"</span>:</span><br><span class=\"line\">  waiting to lock monitor <span class=\"number\">0x000000000333e668</span> (object <span class=\"number\">0x00000000d5efe1c0</span>, a java.lang.Object),</span><br><span class=\"line\">  which is held by <span class=\"string\">\"线程 1\"</span></span><br><span class=\"line\"><span class=\"string\">\"线程 1\"</span>:</span><br><span class=\"line\">  waiting to lock monitor <span class=\"number\">0x000000000333be88</span> (object <span class=\"number\">0x00000000d5efe1d0</span>, a java.lang.Object),</span><br><span class=\"line\">  which is held by <span class=\"string\">\"线程 2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">Java stack information <span class=\"keyword\">for</span> the threads listed above:</span><br><span class=\"line\">===================================================</span><br><span class=\"line\"><span class=\"string\">\"线程 2\"</span>:</span><br><span class=\"line\">        at DeadLockDemo.lambda$main$<span class=\"number\">1</span>(DeadLockDemo.java:<span class=\"number\">31</span>)</span><br><span class=\"line\">        - waiting to lock &lt;<span class=\"number\">0x00000000d5efe1c0</span>&gt; (a java.lang.Object)</span><br><span class=\"line\">        - locked &lt;<span class=\"number\">0x00000000d5efe1d0</span>&gt; (a java.lang.Object)</span><br><span class=\"line\">        at DeadLockDemo$$Lambda$<span class=\"number\">2</span>/<span class=\"number\">1078694789</span>.run(Unknown Source)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">748</span>)</span><br><span class=\"line\"><span class=\"string\">\"线程 1\"</span>:</span><br><span class=\"line\">        at DeadLockDemo.lambda$main$<span class=\"number\">0</span>(DeadLockDemo.java:<span class=\"number\">16</span>)</span><br><span class=\"line\">        - waiting to lock &lt;<span class=\"number\">0x00000000d5efe1d0</span>&gt; (a java.lang.Object)</span><br><span class=\"line\">        - locked &lt;<span class=\"number\">0x00000000d5efe1c0</span>&gt; (a java.lang.Object)</span><br><span class=\"line\">        at DeadLockDemo$$Lambda$<span class=\"number\">1</span>/<span class=\"number\">1324119927</span>.run(Unknown Source)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">748</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">Found <span class=\"number\">1</span> deadlock.</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 <code>jstack</code> 命令已经帮我们找到发生死锁的线程的具体信息。</p>\n<h2 id=\"JDK-可视化分析工具\"><a href=\"#JDK-可视化分析工具\" class=\"headerlink\" title=\"JDK 可视化分析工具\"></a>JDK 可视化分析工具</h2><h3 id=\"JConsole-Java-监视与管理控制台\"><a href=\"#JConsole-Java-监视与管理控制台\" class=\"headerlink\" title=\"JConsole:Java 监视与管理控制台\"></a>JConsole:Java 监视与管理控制台</h3><p>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出<code>console</code>命令启动或者在 JDK 目录下的 bin 目录找到<code>jconsole.exe</code>然后双击启动。</p>\n<h4 id=\"连接-Jconsole\"><a href=\"#连接-Jconsole\" class=\"headerlink\" title=\"连接 Jconsole\"></a>连接 Jconsole</h4><p><img src=\"/images/25453625.png\" alt=\"545362\"></p>\n<p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Djava.rmi.server.hostname&#x3D;外网访问 ip 地址 </span><br><span class=\"line\">-Dcom.sun.management.jmxremote.port&#x3D;60001   &#x2F;&#x2F;监控的端口号</span><br><span class=\"line\">-Dcom.sun.management.jmxremote.authenticate&#x3D;false   &#x2F;&#x2F;关闭认证</span><br><span class=\"line\">-Dcom.sun.management.jmxremote.ssl&#x3D;false</span><br></pre></td></tr></table></figure>\n\n<p>在使用 JConsole 连接时，远程进程地址如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">外网访问 ip 地址:60001</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查看-Java-程序概况\"><a href=\"#查看-Java-程序概况\" class=\"headerlink\" title=\"查看 Java 程序概况\"></a>查看 Java 程序概况</h4><p><img src=\"/images/24a6176.png\" alt=\"4a617\"></p>\n<h4 id=\"内存监控\"><a href=\"#内存监控\" class=\"headerlink\" title=\"内存监控\"></a>内存监控</h4><p>JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。</p>\n<p>点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。</p>\n<blockquote>\n<ul>\n<li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li>\n<li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li>\n</ul>\n</blockquote>\n<p><img src=\"/images/4537.png\" alt=\"53\"></p>\n<h4 id=\"线程监控\"><a href=\"#线程监控\" class=\"headerlink\" title=\"线程监控\"></a>线程监控</h4><p>类似我们前面讲的 <code>jstack</code> 命令，不过这个是可视化的。</p>\n<p>最下面有一个”检测死锁 (D)”按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。</p>\n<p><img src=\"/images/842254537.png\" alt=\"4225453\"></p>\n<h3 id=\"Visual-VM-多合一故障处理工具\"><a href=\"#Visual-VM-多合一故障处理工具\" class=\"headerlink\" title=\"Visual VM:多合一故障处理工具\"></a>Visual VM:多合一故障处理工具</h3><p>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<a href=\"https://visualvm.github.io/\" target=\"_blank\" rel=\"noopener\">https://visualvm.github.io/</a> 。Visual VM 中文文档:<a href=\"https://visualvm.github.io/documentation.html\" target=\"_blank\" rel=\"noopener\">https://visualvm.github.io/documentation.html</a>。</p>\n<p>下面这段话摘自《深入理解 Java 虚拟机》。</p>\n<blockquote>\n<p>VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。</p>\n</blockquote>\n<p>VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p>\n<ul>\n<li><strong>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</strong></li>\n<li><strong>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</strong></li>\n<li><strong>dump 以及分析堆转储快照（jmap、jhat）。</strong></li>\n<li><strong>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。</strong></li>\n<li><strong>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</strong></li>\n<li><strong>其他 plugins 的无限的可能性……</strong></li>\n</ul>\n<p>这里就不具体介绍 VisualVM 的使用，如果想了解的话可以看:</p>\n<ul>\n<li><a href=\"https://visualvm.github.io/documentation.html\" target=\"_blank\" rel=\"noopener\">https://visualvm.github.io/documentation.html</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html\" target=\"_blank\" rel=\"noopener\">https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html</a></li>\n</ul>\n<h2 id=\"公众号\"><a href=\"#公众号\" class=\"headerlink\" title=\"公众号\"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p>\n<p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本公众号后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</p>\n<p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p>\n"},{"title":"scanner、buffer reader、jdk8 stream、apache common io 效率对比","date":"2020-05-20T06:48:27.000Z","_content":"  \n## 文件行读效率测试\n\n## scanner、buffer reader、jdk8 stream、apache common io\n\n### 一、先看下代码\n\n```java\npublic static void main(String[] args) throws IOException {\n        File file = new File(FILE_PATH);\n\n        // scanner\n        System.out.println(\"------------************************-------------\");\n        System.out.println(\">>>>>>scanner 开始 >>>>>>>\");\n        Long cur = System.currentTimeMillis();\n        scanner(file);\n        System.out.println(\"scanner 耗时[\" + (System.currentTimeMillis() - cur) + \"]ms\");\n        System.out.println(\"<<<<<<<scanner 结束 <<<<<<<\");\n        System.out.println(\"------------************************-------------\");\n        System.out.println();\n\n        // buffer reader\n        System.out.println(\"------------************************-------------\");\n        System.out.println(\">>>>>>buffer reader 开始 >>>>>>>\");\n        cur = System.currentTimeMillis();\n        bufferReader(file);\n        System.out.println(\"buffer reader 耗时[\" + (System.currentTimeMillis() - cur) + \"]ms\");\n        System.out.println(\"<<<<<<<buffer reader 结束 <<<<<<<\");\n        System.out.println(\"------------************************-------------\");\n        System.out.println();\n\n        // JDK8\n        System.out.println(\"------------************************-------------\");\n        System.out.println(\">>>>>>JDK8 stream开始 >>>>>>>\");\n        cur = System.currentTimeMillis();\n        jdk8Reader(FILE_PATH);\n        System.out.println(\"JDK8 stream 耗时[\" + (System.currentTimeMillis() - cur) + \"]ms\");\n        System.out.println(\"<<<<<<<JDK8 stream 结束 <<<<<<<\");\n        System.out.println(\"------------************************-------------\");\n        System.out.println();\n\n        // apache common io\n        System.out.println(\"------------************************-------------\");\n        System.out.println(\">>>>>>apache common io >>>>>>>\");\n        cur = System.currentTimeMillis();\n        commonIo(file);\n        System.out.println(\"apache common io 耗时[\" + (System.currentTimeMillis() - cur) + \"]ms\");\n        System.out.println(\"<<<<<<<apache common io 结束 <<<<<<<\");\n        System.out.println(\"------------************************-------------\");\n\n    }\n\n    private static void commonIo(File file) throws IOException {\n        int total = 0;\n        try (LineIterator lineIterator = FileUtils.lineIterator(file, \"UTF-8\")) {\n            while (lineIterator.hasNext()) {\n                lineIterator.next();\n                total += 1;\n            }\n        } finally {\n            System.out.println(\"[总行数]:\" + total);\n        }\n    }\n\n    /**\n     * JDK8\n     *\n     * @param filePath\n     * @throws IOException\n     */\n    private static void jdk8Reader(String filePath) throws IOException {\n        // Files.readAllLine 内部使用的是buffer reader\n//        Files.readAllLines(file.toPath());\n        int total = 0;\n        try (Stream<String> stream = Files.lines(Paths.get(filePath), StandardCharsets.UTF_8)) {\n            total = stream.reduce(0, (cur, op) -> cur + 1, (a, b) -> a + b);\n        } finally {\n            System.out.println(\"[总行数]:\" + total);\n        }\n    }\n\n    /**\n     * buffer reader\n     *\n     * @param file\n     * @throws IOException\n     */\n    private static void bufferReader(File file) throws IOException {\n        int total = 0;\n        try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n            for (String line; (line = br.readLine()) != null; total++);\n            // line is not visible here.\n        } finally {\n            System.out.println(\"[总行数]:\" + total);\n        }\n    }\n\n    private static void scanner(File file) throws FileNotFoundException {\n        int total = 0;\n        try(Scanner scanner = new Scanner(file)){\n            while (scanner.hasNextLine()) {\n                scanner.nextLine();\n                total+=1;\n            }\n        } finally {\n            System.out.println(\"[总行数]:\" + total);\n        }\n    }\n```\n\n#### 100W条真实数据测试结果：\n\n```java\n------------************************-------------\n>>>>>>scanner 开始 >>>>>>>\n[总行数]:1056322\nscanner 耗时[8379]ms\n<<<<<<<scanner 结束 <<<<<<<\n------------************************-------------\n    \n------------************************-------------\n>>>>>>buffer reader 开始 >>>>>>>\n[总行数]:1056322\nbuffer reader 耗时[901]ms\n<<<<<<<buffer reader 结束 <<<<<<<\n------------************************-------------\n    \n------------************************-------------\n>>>>>>JDK8 stream开始 >>>>>>>\n[总行数]:1056322\nJDK8 stream 耗时[916]ms\n<<<<<<<JDK8 stream 结束 <<<<<<<\n------------************************-------------\n    \n------------************************-------------\n>>>>>>apache common io >>>>>>>\n[总行数]:1056322\napache common io 耗时[929]ms\n<<<<<<<apache common io 结束 <<<<<<<\n------------************************-------------\n```\n\n#### 1000W条真实数据测试结果：\n\n```java\n------------************************-------------\n>>>>>>scanner 开始 >>>>>>>\n[总行数]:10563211\nscanner 耗时[79109]ms\n<<<<<<<scanner 结束 <<<<<<<\n------------************************-------------\n\n------------************************-------------\n>>>>>>buffer reader 开始 >>>>>>>\n[总行数]:10563211\nbuffer reader 耗时[8477]ms\n<<<<<<<buffer reader 结束 <<<<<<<\n------------************************-------------\n\n------------************************-------------\n>>>>>>JDK8 stream开始 >>>>>>>\n[总行数]:10563211\nJDK8 stream 耗时[8623]ms\n<<<<<<<JDK8 stream 结束 <<<<<<<\n------------************************-------------\n\n------------************************-------------\n>>>>>>apache common io >>>>>>>\n[总行数]:10563211\napache common io 耗时[8573]ms\n<<<<<<<apache common io 结束 <<<<<<<\n------------************************-------------\n```\n\n总结：\n\nscanner：\n\n```java\n// Tries to read more input. May block.\nprivate void readInput() {\n    if (buf.limit() == buf.capacity())\n        makeSpace();\n\n    // Prepare to receive data\n    int p = buf.position();\n    buf.position(buf.limit());\n    buf.limit(buf.capacity());\n\n    int n = 0;\n    try {\n        n = source.read(buf);\n    } catch (IOException ioe) {\n        lastException = ioe;\n        n = -1;\n    }\n\n    if (n == -1) {\n        sourceClosed = true;\n        needInput = false;\n    }\n\n    if (n > 0)\n        needInput = false;\n\n    // Restore current position and limit for reading\n    buf.limit(buf.position());\n    buf.position(p);\n}\n```\n\nbuffer reader\n\n```java\n// 初始大小为8192字节\nprivate static int defaultCharBufferSize = 8192;\nprivate static int defaultExpectedLineLength = 80;\n\nString readLine(boolean ignoreLF) throws IOException {\n    StringBuffer s = null;\n    int startChar;\n\n    synchronized (lock) {\n        ensureOpen();\n        boolean omitLF = ignoreLF || skipLF;\n\n    bufferLoop:\n        for (;;) {\n\n            if (nextChar >= nChars)\n                fill();\n            if (nextChar >= nChars) { /* EOF */\n                if (s != null && s.length() > 0)\n                    return s.toString();\n                else\n                    return null;\n            }\n            boolean eol = false;\n            char c = 0;\n            int i;\n\n            /* Skip a leftover '\\n', if necessary */\n            if (omitLF && (cb[nextChar] == '\\n'))\n                nextChar++;\n            skipLF = false;\n            omitLF = false;\n\n        charLoop:\n            for (i = nextChar; i < nChars; i++) {\n                c = cb[i];\n                if ((c == '\\n') || (c == '\\r')) {\n                    eol = true;\n                    break charLoop;\n                }\n            }\n\n            startChar = nextChar;\n            nextChar = i;\n\n            if (eol) {\n                String str;\n                if (s == null) {\n                    str = new String(cb, startChar, i - startChar);\n                } else {\n                    s.append(cb, startChar, i - startChar);\n                    str = s.toString();\n                }\n                nextChar++;\n                if (c == '\\r') {\n                    skipLF = true;\n                }\n                return str;\n            }\n\n            if (s == null)\n                s = new StringBuffer(defaultExpectedLineLength);\n            s.append(cb, startChar, i - startChar);\n        }\n    }\n}\n```\n\nJDK stream\n\n```java\npublic static Stream<String> lines(Path path, Charset cs) throws IOException {\n    // 实际也用的buffer reader\n    BufferedReader br = Files.newBufferedReader(path, cs);\n    try {\n        return br.lines().onClose(asUncheckedRunnable(br));\n    } catch (Error|RuntimeException e) {\n        try {\n            br.close();\n        } catch (IOException ex) {\n            try {\n                e.addSuppressed(ex);\n            } catch (Throwable ignore) {}\n        }\n        throw e;\n    }\n}\n```\n\ncommon io\n\n```java\npublic boolean hasNext() {\n    if (this.cachedLine != null) {\n        return true;\n    } else if (this.finished) {\n        return false;\n    } else {\n        try {\n            String line;\n            do {\n                line = this.bufferedReader.readLine();\n                if (line == null) {\n                    this.finished = true;\n                    return false;\n                }\n            } while(!this.isValidLine(line));\n\n            this.cachedLine = line;\n            return true;\n        } catch (IOException var4) {\n            try {\n                this.close();\n            } catch (IOException var3) {\n                var4.addSuppressed(var3);\n            }\n\n            throw new IllegalStateException(var4);\n        }\n    }\n}\n```\n\n所以出了Scanner用的自己的缓存机制，其他的都用的buffer reader的缓存机制，所以后面的三种方法效果差不多，不过笔者还是喜欢jdk8的stream机制，所以选择了jdk8的","source":"_posts/java/IO-NIO-reader-line.md","raw":"---\ntitle: scanner、buffer reader、jdk8 stream、apache common io 效率对比\ndate: 2020-05-20 14:48:27\ntags:\n    - java\n    - io\n    - nio\ncategories:\n    - java\n    - read line\n---\n  \n## 文件行读效率测试\n\n## scanner、buffer reader、jdk8 stream、apache common io\n\n### 一、先看下代码\n\n```java\npublic static void main(String[] args) throws IOException {\n        File file = new File(FILE_PATH);\n\n        // scanner\n        System.out.println(\"------------************************-------------\");\n        System.out.println(\">>>>>>scanner 开始 >>>>>>>\");\n        Long cur = System.currentTimeMillis();\n        scanner(file);\n        System.out.println(\"scanner 耗时[\" + (System.currentTimeMillis() - cur) + \"]ms\");\n        System.out.println(\"<<<<<<<scanner 结束 <<<<<<<\");\n        System.out.println(\"------------************************-------------\");\n        System.out.println();\n\n        // buffer reader\n        System.out.println(\"------------************************-------------\");\n        System.out.println(\">>>>>>buffer reader 开始 >>>>>>>\");\n        cur = System.currentTimeMillis();\n        bufferReader(file);\n        System.out.println(\"buffer reader 耗时[\" + (System.currentTimeMillis() - cur) + \"]ms\");\n        System.out.println(\"<<<<<<<buffer reader 结束 <<<<<<<\");\n        System.out.println(\"------------************************-------------\");\n        System.out.println();\n\n        // JDK8\n        System.out.println(\"------------************************-------------\");\n        System.out.println(\">>>>>>JDK8 stream开始 >>>>>>>\");\n        cur = System.currentTimeMillis();\n        jdk8Reader(FILE_PATH);\n        System.out.println(\"JDK8 stream 耗时[\" + (System.currentTimeMillis() - cur) + \"]ms\");\n        System.out.println(\"<<<<<<<JDK8 stream 结束 <<<<<<<\");\n        System.out.println(\"------------************************-------------\");\n        System.out.println();\n\n        // apache common io\n        System.out.println(\"------------************************-------------\");\n        System.out.println(\">>>>>>apache common io >>>>>>>\");\n        cur = System.currentTimeMillis();\n        commonIo(file);\n        System.out.println(\"apache common io 耗时[\" + (System.currentTimeMillis() - cur) + \"]ms\");\n        System.out.println(\"<<<<<<<apache common io 结束 <<<<<<<\");\n        System.out.println(\"------------************************-------------\");\n\n    }\n\n    private static void commonIo(File file) throws IOException {\n        int total = 0;\n        try (LineIterator lineIterator = FileUtils.lineIterator(file, \"UTF-8\")) {\n            while (lineIterator.hasNext()) {\n                lineIterator.next();\n                total += 1;\n            }\n        } finally {\n            System.out.println(\"[总行数]:\" + total);\n        }\n    }\n\n    /**\n     * JDK8\n     *\n     * @param filePath\n     * @throws IOException\n     */\n    private static void jdk8Reader(String filePath) throws IOException {\n        // Files.readAllLine 内部使用的是buffer reader\n//        Files.readAllLines(file.toPath());\n        int total = 0;\n        try (Stream<String> stream = Files.lines(Paths.get(filePath), StandardCharsets.UTF_8)) {\n            total = stream.reduce(0, (cur, op) -> cur + 1, (a, b) -> a + b);\n        } finally {\n            System.out.println(\"[总行数]:\" + total);\n        }\n    }\n\n    /**\n     * buffer reader\n     *\n     * @param file\n     * @throws IOException\n     */\n    private static void bufferReader(File file) throws IOException {\n        int total = 0;\n        try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n            for (String line; (line = br.readLine()) != null; total++);\n            // line is not visible here.\n        } finally {\n            System.out.println(\"[总行数]:\" + total);\n        }\n    }\n\n    private static void scanner(File file) throws FileNotFoundException {\n        int total = 0;\n        try(Scanner scanner = new Scanner(file)){\n            while (scanner.hasNextLine()) {\n                scanner.nextLine();\n                total+=1;\n            }\n        } finally {\n            System.out.println(\"[总行数]:\" + total);\n        }\n    }\n```\n\n#### 100W条真实数据测试结果：\n\n```java\n------------************************-------------\n>>>>>>scanner 开始 >>>>>>>\n[总行数]:1056322\nscanner 耗时[8379]ms\n<<<<<<<scanner 结束 <<<<<<<\n------------************************-------------\n    \n------------************************-------------\n>>>>>>buffer reader 开始 >>>>>>>\n[总行数]:1056322\nbuffer reader 耗时[901]ms\n<<<<<<<buffer reader 结束 <<<<<<<\n------------************************-------------\n    \n------------************************-------------\n>>>>>>JDK8 stream开始 >>>>>>>\n[总行数]:1056322\nJDK8 stream 耗时[916]ms\n<<<<<<<JDK8 stream 结束 <<<<<<<\n------------************************-------------\n    \n------------************************-------------\n>>>>>>apache common io >>>>>>>\n[总行数]:1056322\napache common io 耗时[929]ms\n<<<<<<<apache common io 结束 <<<<<<<\n------------************************-------------\n```\n\n#### 1000W条真实数据测试结果：\n\n```java\n------------************************-------------\n>>>>>>scanner 开始 >>>>>>>\n[总行数]:10563211\nscanner 耗时[79109]ms\n<<<<<<<scanner 结束 <<<<<<<\n------------************************-------------\n\n------------************************-------------\n>>>>>>buffer reader 开始 >>>>>>>\n[总行数]:10563211\nbuffer reader 耗时[8477]ms\n<<<<<<<buffer reader 结束 <<<<<<<\n------------************************-------------\n\n------------************************-------------\n>>>>>>JDK8 stream开始 >>>>>>>\n[总行数]:10563211\nJDK8 stream 耗时[8623]ms\n<<<<<<<JDK8 stream 结束 <<<<<<<\n------------************************-------------\n\n------------************************-------------\n>>>>>>apache common io >>>>>>>\n[总行数]:10563211\napache common io 耗时[8573]ms\n<<<<<<<apache common io 结束 <<<<<<<\n------------************************-------------\n```\n\n总结：\n\nscanner：\n\n```java\n// Tries to read more input. May block.\nprivate void readInput() {\n    if (buf.limit() == buf.capacity())\n        makeSpace();\n\n    // Prepare to receive data\n    int p = buf.position();\n    buf.position(buf.limit());\n    buf.limit(buf.capacity());\n\n    int n = 0;\n    try {\n        n = source.read(buf);\n    } catch (IOException ioe) {\n        lastException = ioe;\n        n = -1;\n    }\n\n    if (n == -1) {\n        sourceClosed = true;\n        needInput = false;\n    }\n\n    if (n > 0)\n        needInput = false;\n\n    // Restore current position and limit for reading\n    buf.limit(buf.position());\n    buf.position(p);\n}\n```\n\nbuffer reader\n\n```java\n// 初始大小为8192字节\nprivate static int defaultCharBufferSize = 8192;\nprivate static int defaultExpectedLineLength = 80;\n\nString readLine(boolean ignoreLF) throws IOException {\n    StringBuffer s = null;\n    int startChar;\n\n    synchronized (lock) {\n        ensureOpen();\n        boolean omitLF = ignoreLF || skipLF;\n\n    bufferLoop:\n        for (;;) {\n\n            if (nextChar >= nChars)\n                fill();\n            if (nextChar >= nChars) { /* EOF */\n                if (s != null && s.length() > 0)\n                    return s.toString();\n                else\n                    return null;\n            }\n            boolean eol = false;\n            char c = 0;\n            int i;\n\n            /* Skip a leftover '\\n', if necessary */\n            if (omitLF && (cb[nextChar] == '\\n'))\n                nextChar++;\n            skipLF = false;\n            omitLF = false;\n\n        charLoop:\n            for (i = nextChar; i < nChars; i++) {\n                c = cb[i];\n                if ((c == '\\n') || (c == '\\r')) {\n                    eol = true;\n                    break charLoop;\n                }\n            }\n\n            startChar = nextChar;\n            nextChar = i;\n\n            if (eol) {\n                String str;\n                if (s == null) {\n                    str = new String(cb, startChar, i - startChar);\n                } else {\n                    s.append(cb, startChar, i - startChar);\n                    str = s.toString();\n                }\n                nextChar++;\n                if (c == '\\r') {\n                    skipLF = true;\n                }\n                return str;\n            }\n\n            if (s == null)\n                s = new StringBuffer(defaultExpectedLineLength);\n            s.append(cb, startChar, i - startChar);\n        }\n    }\n}\n```\n\nJDK stream\n\n```java\npublic static Stream<String> lines(Path path, Charset cs) throws IOException {\n    // 实际也用的buffer reader\n    BufferedReader br = Files.newBufferedReader(path, cs);\n    try {\n        return br.lines().onClose(asUncheckedRunnable(br));\n    } catch (Error|RuntimeException e) {\n        try {\n            br.close();\n        } catch (IOException ex) {\n            try {\n                e.addSuppressed(ex);\n            } catch (Throwable ignore) {}\n        }\n        throw e;\n    }\n}\n```\n\ncommon io\n\n```java\npublic boolean hasNext() {\n    if (this.cachedLine != null) {\n        return true;\n    } else if (this.finished) {\n        return false;\n    } else {\n        try {\n            String line;\n            do {\n                line = this.bufferedReader.readLine();\n                if (line == null) {\n                    this.finished = true;\n                    return false;\n                }\n            } while(!this.isValidLine(line));\n\n            this.cachedLine = line;\n            return true;\n        } catch (IOException var4) {\n            try {\n                this.close();\n            } catch (IOException var3) {\n                var4.addSuppressed(var3);\n            }\n\n            throw new IllegalStateException(var4);\n        }\n    }\n}\n```\n\n所以出了Scanner用的自己的缓存机制，其他的都用的buffer reader的缓存机制，所以后面的三种方法效果差不多，不过笔者还是喜欢jdk8的stream机制，所以选择了jdk8的","slug":"java/IO-NIO-reader-line","published":1,"updated":"2020-05-20T06:48:40.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7lg004kvgja2tug5tui","content":"<h2 id=\"文件行读效率测试\"><a href=\"#文件行读效率测试\" class=\"headerlink\" title=\"文件行读效率测试\"></a>文件行读效率测试</h2><h2 id=\"scanner、buffer-reader、jdk8-stream、apache-common-io\"><a href=\"#scanner、buffer-reader、jdk8-stream、apache-common-io\" class=\"headerlink\" title=\"scanner、buffer reader、jdk8 stream、apache common io\"></a>scanner、buffer reader、jdk8 stream、apache common io</h2><h3 id=\"一、先看下代码\"><a href=\"#一、先看下代码\" class=\"headerlink\" title=\"一、先看下代码\"></a>一、先看下代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(FILE_PATH);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// scanner</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt;&gt;scanner 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;\"</span>);</span><br><span class=\"line\">        Long cur = System.currentTimeMillis();</span><br><span class=\"line\">        scanner(file);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"scanner 耗时[\"</span> + (System.currentTimeMillis() - cur) + <span class=\"string\">\"]ms\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt;&lt;&lt;scanner 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// buffer reader</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt;&gt;buffer reader 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;\"</span>);</span><br><span class=\"line\">        cur = System.currentTimeMillis();</span><br><span class=\"line\">        bufferReader(file);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"buffer reader 耗时[\"</span> + (System.currentTimeMillis() - cur) + <span class=\"string\">\"]ms\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt;&lt;&lt;buffer reader 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// JDK8</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt;&gt;JDK8 stream开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;\"</span>);</span><br><span class=\"line\">        cur = System.currentTimeMillis();</span><br><span class=\"line\">        jdk8Reader(FILE_PATH);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"JDK8 stream 耗时[\"</span> + (System.currentTimeMillis() - cur) + <span class=\"string\">\"]ms\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt;&lt;&lt;JDK8 stream 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// apache common io</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt;&gt;apache common io &gt;&gt;&gt;&gt;&gt;&gt;&gt;\"</span>);</span><br><span class=\"line\">        cur = System.currentTimeMillis();</span><br><span class=\"line\">        commonIo(file);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"apache common io 耗时[\"</span> + (System.currentTimeMillis() - cur) + <span class=\"string\">\"]ms\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt;&lt;&lt;apache common io 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">commonIo</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (LineIterator lineIterator = FileUtils.lineIterator(file, <span class=\"string\">\"UTF-8\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (lineIterator.hasNext()) &#123;</span><br><span class=\"line\">                lineIterator.next();</span><br><span class=\"line\">                total += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"[总行数]:\"</span> + total);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * JDK8</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> filePath</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">jdk8Reader</span><span class=\"params\">(String filePath)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Files.readAllLine 内部使用的是buffer reader</span></span><br><span class=\"line\"><span class=\"comment\">//        Files.readAllLines(file.toPath());</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (Stream&lt;String&gt; stream = Files.lines(Paths.get(filePath), StandardCharsets.UTF_8)) &#123;</span><br><span class=\"line\">            total = stream.reduce(<span class=\"number\">0</span>, (cur, op) -&gt; cur + <span class=\"number\">1</span>, (a, b) -&gt; a + b);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"[总行数]:\"</span> + total);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * buffer reader</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> file</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bufferReader</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(file))) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String line; (line = br.readLine()) != <span class=\"keyword\">null</span>; total++);</span><br><span class=\"line\">            <span class=\"comment\">// line is not visible here.</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"[总行数]:\"</span> + total);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">scanner</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(Scanner scanner = <span class=\"keyword\">new</span> Scanner(file))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (scanner.hasNextLine()) &#123;</span><br><span class=\"line\">                scanner.nextLine();</span><br><span class=\"line\">                total+=<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"[总行数]:\"</span> + total);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"100W条真实数据测试结果：\"><a href=\"#100W条真实数据测试结果：\" class=\"headerlink\" title=\"100W条真实数据测试结果：\"></a>100W条真实数据测试结果：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;scanner 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">1056322</span></span><br><span class=\"line\">scanner 耗时[<span class=\"number\">8379</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;scanner 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">    </span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;buffer reader 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">1056322</span></span><br><span class=\"line\">buffer reader 耗时[<span class=\"number\">901</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;buffer reader 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">    </span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;JDK8 stream开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">1056322</span></span><br><span class=\"line\">JDK8 stream 耗时[<span class=\"number\">916</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;JDK8 stream 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">    </span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;apache common io &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">1056322</span></span><br><span class=\"line\">apache common io 耗时[<span class=\"number\">929</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;apache common io 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1000W条真实数据测试结果：\"><a href=\"#1000W条真实数据测试结果：\" class=\"headerlink\" title=\"1000W条真实数据测试结果：\"></a>1000W条真实数据测试结果：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;scanner 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">10563211</span></span><br><span class=\"line\">scanner 耗时[<span class=\"number\">79109</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;scanner 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\"></span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;buffer reader 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">10563211</span></span><br><span class=\"line\">buffer reader 耗时[<span class=\"number\">8477</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;buffer reader 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\"></span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;JDK8 stream开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">10563211</span></span><br><span class=\"line\">JDK8 stream 耗时[<span class=\"number\">8623</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;JDK8 stream 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\"></span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;apache common io &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">10563211</span></span><br><span class=\"line\">apache common io 耗时[<span class=\"number\">8573</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;apache common io 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br></pre></td></tr></table></figure>\n\n<p>总结：</p>\n<p>scanner：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Tries to read more input. May block.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readInput</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buf.limit() == buf.capacity())</span><br><span class=\"line\">        makeSpace();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Prepare to receive data</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = buf.position();</span><br><span class=\"line\">    buf.position(buf.limit());</span><br><span class=\"line\">    buf.limit(buf.capacity());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        n = source.read(buf);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">        lastException = ioe;</span><br><span class=\"line\">        n = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        sourceClosed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        needInput = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        needInput = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Restore current position and limit for reading</span></span><br><span class=\"line\">    buf.limit(buf.position());</span><br><span class=\"line\">    buf.position(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>buffer reader</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始大小为8192字节</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> defaultCharBufferSize = <span class=\"number\">8192</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> defaultExpectedLineLength = <span class=\"number\">80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">String <span class=\"title\">readLine</span><span class=\"params\">(<span class=\"keyword\">boolean</span> ignoreLF)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    StringBuffer s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> startChar;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">        ensureOpen();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> omitLF = ignoreLF || skipLF;</span><br><span class=\"line\"></span><br><span class=\"line\">    bufferLoop:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextChar &gt;= nChars)</span><br><span class=\"line\">                fill();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextChar &gt;= nChars) &#123; <span class=\"comment\">/* EOF */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span> &amp;&amp; s.length() &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> s.toString();</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> eol = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Skip a leftover '\\n', if necessary */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (omitLF &amp;&amp; (cb[nextChar] == <span class=\"string\">'\\n'</span>))</span><br><span class=\"line\">                nextChar++;</span><br><span class=\"line\">            skipLF = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            omitLF = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        charLoop:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = nextChar; i &lt; nChars; i++) &#123;</span><br><span class=\"line\">                c = cb[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((c == <span class=\"string\">'\\n'</span>) || (c == <span class=\"string\">'\\r'</span>)) &#123;</span><br><span class=\"line\">                    eol = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span> charLoop;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            startChar = nextChar;</span><br><span class=\"line\">            nextChar = i;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (eol) &#123;</span><br><span class=\"line\">                String str;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    str = <span class=\"keyword\">new</span> String(cb, startChar, i - startChar);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    s.append(cb, startChar, i - startChar);</span><br><span class=\"line\">                    str = s.toString();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                nextChar++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"string\">'\\r'</span>) &#123;</span><br><span class=\"line\">                    skipLF = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                s = <span class=\"keyword\">new</span> StringBuffer(defaultExpectedLineLength);</span><br><span class=\"line\">            s.append(cb, startChar, i - startChar);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JDK stream</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Stream&lt;String&gt; <span class=\"title\">lines</span><span class=\"params\">(Path path, Charset cs)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实际也用的buffer reader</span></span><br><span class=\"line\">    BufferedReader br = Files.newBufferedReader(path, cs);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> br.lines().onClose(asUncheckedRunnable(br));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Error|RuntimeException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            br.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                e.addSuppressed(ex);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ignore) &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>common io</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.cachedLine != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.finished) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String line;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                line = <span class=\"keyword\">this</span>.bufferedReader.readLine();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (line == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.finished = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.isValidLine(line));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.cachedLine = line;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException var4) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException var3) &#123;</span><br><span class=\"line\">                var4.addSuppressed(var3);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(var4);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以出了Scanner用的自己的缓存机制，其他的都用的buffer reader的缓存机制，所以后面的三种方法效果差不多，不过笔者还是喜欢jdk8的stream机制，所以选择了jdk8的</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"文件行读效率测试\"><a href=\"#文件行读效率测试\" class=\"headerlink\" title=\"文件行读效率测试\"></a>文件行读效率测试</h2><h2 id=\"scanner、buffer-reader、jdk8-stream、apache-common-io\"><a href=\"#scanner、buffer-reader、jdk8-stream、apache-common-io\" class=\"headerlink\" title=\"scanner、buffer reader、jdk8 stream、apache common io\"></a>scanner、buffer reader、jdk8 stream、apache common io</h2><h3 id=\"一、先看下代码\"><a href=\"#一、先看下代码\" class=\"headerlink\" title=\"一、先看下代码\"></a>一、先看下代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(FILE_PATH);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// scanner</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt;&gt;scanner 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;\"</span>);</span><br><span class=\"line\">        Long cur = System.currentTimeMillis();</span><br><span class=\"line\">        scanner(file);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"scanner 耗时[\"</span> + (System.currentTimeMillis() - cur) + <span class=\"string\">\"]ms\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt;&lt;&lt;scanner 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// buffer reader</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt;&gt;buffer reader 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;\"</span>);</span><br><span class=\"line\">        cur = System.currentTimeMillis();</span><br><span class=\"line\">        bufferReader(file);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"buffer reader 耗时[\"</span> + (System.currentTimeMillis() - cur) + <span class=\"string\">\"]ms\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt;&lt;&lt;buffer reader 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// JDK8</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt;&gt;JDK8 stream开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;\"</span>);</span><br><span class=\"line\">        cur = System.currentTimeMillis();</span><br><span class=\"line\">        jdk8Reader(FILE_PATH);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"JDK8 stream 耗时[\"</span> + (System.currentTimeMillis() - cur) + <span class=\"string\">\"]ms\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt;&lt;&lt;JDK8 stream 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// apache common io</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&gt;&gt;&gt;&gt;&gt;&gt;apache common io &gt;&gt;&gt;&gt;&gt;&gt;&gt;\"</span>);</span><br><span class=\"line\">        cur = System.currentTimeMillis();</span><br><span class=\"line\">        commonIo(file);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"apache common io 耗时[\"</span> + (System.currentTimeMillis() - cur) + <span class=\"string\">\"]ms\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"&lt;&lt;&lt;&lt;&lt;&lt;&lt;apache common io 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"------------************************-------------\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">commonIo</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (LineIterator lineIterator = FileUtils.lineIterator(file, <span class=\"string\">\"UTF-8\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (lineIterator.hasNext()) &#123;</span><br><span class=\"line\">                lineIterator.next();</span><br><span class=\"line\">                total += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"[总行数]:\"</span> + total);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * JDK8</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> filePath</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">jdk8Reader</span><span class=\"params\">(String filePath)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Files.readAllLine 内部使用的是buffer reader</span></span><br><span class=\"line\"><span class=\"comment\">//        Files.readAllLines(file.toPath());</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (Stream&lt;String&gt; stream = Files.lines(Paths.get(filePath), StandardCharsets.UTF_8)) &#123;</span><br><span class=\"line\">            total = stream.reduce(<span class=\"number\">0</span>, (cur, op) -&gt; cur + <span class=\"number\">1</span>, (a, b) -&gt; a + b);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"[总行数]:\"</span> + total);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * buffer reader</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> file</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bufferReader</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(file))) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String line; (line = br.readLine()) != <span class=\"keyword\">null</span>; total++);</span><br><span class=\"line\">            <span class=\"comment\">// line is not visible here.</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"[总行数]:\"</span> + total);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">scanner</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>(Scanner scanner = <span class=\"keyword\">new</span> Scanner(file))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (scanner.hasNextLine()) &#123;</span><br><span class=\"line\">                scanner.nextLine();</span><br><span class=\"line\">                total+=<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"[总行数]:\"</span> + total);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"100W条真实数据测试结果：\"><a href=\"#100W条真实数据测试结果：\" class=\"headerlink\" title=\"100W条真实数据测试结果：\"></a>100W条真实数据测试结果：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;scanner 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">1056322</span></span><br><span class=\"line\">scanner 耗时[<span class=\"number\">8379</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;scanner 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">    </span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;buffer reader 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">1056322</span></span><br><span class=\"line\">buffer reader 耗时[<span class=\"number\">901</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;buffer reader 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">    </span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;JDK8 stream开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">1056322</span></span><br><span class=\"line\">JDK8 stream 耗时[<span class=\"number\">916</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;JDK8 stream 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">    </span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;apache common io &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">1056322</span></span><br><span class=\"line\">apache common io 耗时[<span class=\"number\">929</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;apache common io 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1000W条真实数据测试结果：\"><a href=\"#1000W条真实数据测试结果：\" class=\"headerlink\" title=\"1000W条真实数据测试结果：\"></a>1000W条真实数据测试结果：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;scanner 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">10563211</span></span><br><span class=\"line\">scanner 耗时[<span class=\"number\">79109</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;scanner 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\"></span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;buffer reader 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">10563211</span></span><br><span class=\"line\">buffer reader 耗时[<span class=\"number\">8477</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;buffer reader 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\"></span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;JDK8 stream开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">10563211</span></span><br><span class=\"line\">JDK8 stream 耗时[<span class=\"number\">8623</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;JDK8 stream 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\"></span><br><span class=\"line\">------------************************-------------</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;apache common io &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class=\"line\">[总行数]:<span class=\"number\">10563211</span></span><br><span class=\"line\">apache common io 耗时[<span class=\"number\">8573</span>]ms</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;apache common io 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">------------************************-------------</span><br></pre></td></tr></table></figure>\n\n<p>总结：</p>\n<p>scanner：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Tries to read more input. May block.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readInput</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buf.limit() == buf.capacity())</span><br><span class=\"line\">        makeSpace();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Prepare to receive data</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = buf.position();</span><br><span class=\"line\">    buf.position(buf.limit());</span><br><span class=\"line\">    buf.limit(buf.capacity());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        n = source.read(buf);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">        lastException = ioe;</span><br><span class=\"line\">        n = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        sourceClosed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        needInput = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        needInput = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Restore current position and limit for reading</span></span><br><span class=\"line\">    buf.limit(buf.position());</span><br><span class=\"line\">    buf.position(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>buffer reader</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始大小为8192字节</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> defaultCharBufferSize = <span class=\"number\">8192</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> defaultExpectedLineLength = <span class=\"number\">80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">String <span class=\"title\">readLine</span><span class=\"params\">(<span class=\"keyword\">boolean</span> ignoreLF)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    StringBuffer s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> startChar;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">        ensureOpen();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> omitLF = ignoreLF || skipLF;</span><br><span class=\"line\"></span><br><span class=\"line\">    bufferLoop:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextChar &gt;= nChars)</span><br><span class=\"line\">                fill();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextChar &gt;= nChars) &#123; <span class=\"comment\">/* EOF */</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span> &amp;&amp; s.length() &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> s.toString();</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> eol = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* Skip a leftover '\\n', if necessary */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (omitLF &amp;&amp; (cb[nextChar] == <span class=\"string\">'\\n'</span>))</span><br><span class=\"line\">                nextChar++;</span><br><span class=\"line\">            skipLF = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            omitLF = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        charLoop:</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = nextChar; i &lt; nChars; i++) &#123;</span><br><span class=\"line\">                c = cb[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((c == <span class=\"string\">'\\n'</span>) || (c == <span class=\"string\">'\\r'</span>)) &#123;</span><br><span class=\"line\">                    eol = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span> charLoop;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            startChar = nextChar;</span><br><span class=\"line\">            nextChar = i;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (eol) &#123;</span><br><span class=\"line\">                String str;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    str = <span class=\"keyword\">new</span> String(cb, startChar, i - startChar);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    s.append(cb, startChar, i - startChar);</span><br><span class=\"line\">                    str = s.toString();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                nextChar++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"string\">'\\r'</span>) &#123;</span><br><span class=\"line\">                    skipLF = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                s = <span class=\"keyword\">new</span> StringBuffer(defaultExpectedLineLength);</span><br><span class=\"line\">            s.append(cb, startChar, i - startChar);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JDK stream</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Stream&lt;String&gt; <span class=\"title\">lines</span><span class=\"params\">(Path path, Charset cs)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实际也用的buffer reader</span></span><br><span class=\"line\">    BufferedReader br = Files.newBufferedReader(path, cs);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> br.lines().onClose(asUncheckedRunnable(br));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Error|RuntimeException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            br.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                e.addSuppressed(ex);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ignore) &#123;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>common io</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.cachedLine != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.finished) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String line;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                line = <span class=\"keyword\">this</span>.bufferedReader.readLine();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (line == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.finished = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.isValidLine(line));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.cachedLine = line;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException var4) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException var3) &#123;</span><br><span class=\"line\">                var4.addSuppressed(var3);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(var4);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以出了Scanner用的自己的缓存机制，其他的都用的buffer reader的缓存机制，所以后面的三种方法效果差不多，不过笔者还是喜欢jdk8的stream机制，所以选择了jdk8的</p>\n"},{"title":"dubbo 连接数配置导致连接爆发","date":"2020-06-04T07:31:13.000Z","_content":"\n## 0x00. 翻车现场\n\n收到运维noc告警：\n\n![img](/images/0082zybply1gbqenpjnt7j30yq0higpo.jpg)\n\n## 0x01. 历尽艰辛，深入排查\n\n打开电脑，首先确认生产交易一切还正常。查看这段时间日志，发现并没有什么异常情况，日志都是正常输出。没办法只好再次走查此次改动的代码，发现全是业务代码，并没有任何与网络连接有关的代码改动。\n\n`netstat -anp|grep 6701|wc -l `  查看连接情况\n\n![img](/images/5911899802886.png)\n\n\n\n`jmap -histo 6701|less` 查看堆内存情况\n\n![020060416292](/images/20200604162924.png)\n\n问题真的请奇怪，一时半会想不到解决方案，只好先实施重启大法。重启过后，连接数下降了，到达了正常阈值。但是不一会连接数持续升高，不一会还是升到上万。\n\n这下重启解决不了办法，只好从应用出发，找找到底什么问题。\n\n这个应用是一个路由服务，会根据上游系统指定路由编码，将交易分发到下游子系统。架构图如下:\n\n![img](/images/0082zybply1gbr8va8yvhj30hm0ck3z8.jpg)\n\n之前在这篇文章[路由系统演化史](https://mp.weixin.qq.com/s/Det95SU1u1dDH7nT_B1XEQ)讲过，路由系统使用 **Dubbo API** ，代码如下：\n\n![img](/images/0082zybply1gbqenooa0ej314i0u0tf3.jpg)\n\n由于我们还有另外一套系统，也部署这个应用，但是该系统生产机器连接数却很少。交叉比对了两套系统应用的系统配置值，只有 **connections** 设置不一样，当前有问题的系统设置为 **1000**，另外一个系统为 **10** 。\n\n大致找到原因，也将 **connections** 设置为 **10**，重启应用，生产机器连接数恢复正常。\n\n## 0x02. 抽丝剥茧，还原经过\n\n首先我们来看下 **connections** 这个配置的作用，可以直接查看官方文档<http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-reference.html>。\n\n下面配置来源于：**dubbo:reference**\n\n![img](/images/0082zybply1gbpy5n5wfuj31m6078wp5.jpg)\n\n总共可以在三个地方配置 **connections** 参数，分别为：**dubbo:reference**，**dubbo:consumer**，**dubbo:provider**。\n\n> **注意**：图中标示地方实际上与源码存在出入。截止 **Dubbo 2.7.3** 版本，图中 ① 处，**dubbo:consumer** 文档上显示为 **100**，实际源码默认配置为 **0**，这点需要注意。另外 ② 处文字描述存在问题，目前 **connections** 参数主要对 **dubbo** 协议有用，**http** 短连接协议还未使用该配置\n\n其中 **reference.connections** 为服务级别的配置，若未配置将会使用 **consumer.connections** 配置值。另外这个参数若在 **provider.connections** 配置，其对服务提供者无效，参数将通过注册中心传递给消费者成为其默认配置。三者实际作用顺序如下：\n\n![img](/images/0082zybply1gbpxzrh8q4j31mc0u0hdt.jpg)\n\n**Debug** 源码，**connections** 最终会在 **DubboProtocol#getClients** 被使用，方法源码如下：\n\n![img](/images/0082zybply1gbqenq2xc6j31820cs76u.jpg)\n\n![img](/images/0082zybply1gbqenma2pxj31au0u044x.jpg)\n\n> **Dubbo** 协议默认将会使用 **Netty** 与服务提供者建立长连接\n\n首先将会获取 **connections** 配置，规则如上图，若其大于 **0**，建立 **connections** 数量的长连接。\n\n如果一个提供者对外暴露 **10** 个接口，且其有两个节点。消费者端引入提供者所有服务，配置 **connections=1000**。当消费者启动之后，将会立刻创建 **1000x2x10=20000** 连接。**这就是生产机器连接数飙升的根本原因**。\n\n> 路由服务使用 **Dubbo API** 编程，服务启动成功之后，只有上游系统调用路由服务时， **Dubbo** 才会与与下游服务提供者建立连接，所以现象看起来服务连接数是慢慢激增。\n\n如果未设置 **connections** 参数，Dubbo 将会创建**共享连接（shareconnections）**。消费者调用的服务若为同一个服务提供者（**IP+PORT** 区分），这些服务接口将会共享这些连接。\n\n**shareconnections** 可以在 **dubbo:consumer** 配置中配置，也可以在启动 **JVM** 参数加入如下配置：\n\n```\n-Dshareconnections=10\n```\n\n如果消费者需要调用同个服务提供者应用的 **10** 个服务接口，服务提供者提供两个节点，**shareconnections=1000**，消费者服务启动之后，仅会创建 **1000\\*2=2000** 连接。\n\n这么对比，**shareconnections** 与 **connections** 建立连不是一个量级。\n\n### 2.1 使用连接\n\n消费者调用服务时，将会随机从连接数组中取一个连接使用，代码位于 `DubboInvoker#doInvoke`。\n\n![img](/images/0082zybply1gbqenjpogfj30ph05zdgv.jpg)\n\n### 2.2 如何正确配置连接数\n\n首先我们来看下单一长连接性能，文档地址:<http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html>\n\n![img](/images/0082zybply1gbq3md7d15j30m90cb43g.jpg)\n\n对于只有少数消费者场景，我们可以使用默认配置，即不配置 **connections** 参数 。若调用同一个提供者服务过多，可以考虑适当多配增加 **shareconnections**。最后若某一服务接口调用量特别大，可以考虑为这个服务单独配置 **connections**。\n\n## 0x03. 举一反三，聊聊其他配置\n\nDubbo 还有很多配置项，下面着重介绍一些配置参数。\n\n### 3.1 dubbo.provider.executes\n\n该参数用来控制每个方法最大并行数。如果该值设置为 **10** ，每个服务方法若已有 **10** 个请求正在处理，第 **11** 个服务请求将会抛出异常，直到之前服务调用完成，正在请求数量小于 **10** 未知。\n\n![img](/images/0082zybply1gbq3z7a7mmj31nq074qat.jpg)\n\n一旦设置 **executes>0**,**Dubbo** 将会通过 **SPI** 机制启用 `ExecuteLimitFilter`，源码还是比较简单。\n\n![img](/images/0082zybply1gbqennntwoj30sg0fswhn.jpg)\n\n### 3.2 dubbo.reference.actives\n\n这个参数将会控制消费者每个服务每个方法最大并发数。可以通过 **dubbo:method.actives** 单独为服务方法设置。如果该值为 **10**，一旦某个服务某个方法并发数超过 **10**，第 **11** 个服务将会等待，若在超时时间内其他请求执行结束，计数值减值小于阈值，第 **11** 个请求将会被执行，否者将会抛错。\n\n![img](https://tva1.sinaimg.cn/large/0082zybply1gbr8wael1dj31lw07qdgq.jpg)\n\n> `dubbo.provider` 上也可以配置这个值，其将会与 **connections** 一样，将会传递给消费者。\n\n原理等同上面方法，将会启用 `ActiveLimitFilter`，源码如下 ：\n\n![img](/images/0082zybply1gbqenluvenj30rz0hsjv2.jpg)\n\n这里需要注意 **actives** 引起超时与服务端超时区别。\n\n![img](/images/0082zybply1gbqenlanqrj327f0u04gd.jpg)\n\n### 3.3 dubbo.protocol.accepts\n\n服务提供者最大连接数，如果设置 **accepts=10**,一旦服务提供者连接数大于 **10**，其余新增连接将会被拒绝。\n\n![img](/images/0082zybply1gbq4mytke2j31gw07279o.jpg)\n\n方法源码如下：\n\n![img](/images/0082zybply1gbqemv4o7qj32780lkgrc.jpg)\n\n服务提供者断开连接，消费端将会打印连接断开日志。另外消费者会定时检查长连接可用性，若不可用，将会重新发起连接。所以在消费者端就会看到连接断开，重连，然后又被服务提供者断开的现象。\n\n![img](/images/0082zybply1gbqenms1eqj32dw0l87h5.jpg)\n\n## 0x04. 总结\n\n本文通过一次生产连接数过多的现象，详细剖析定位问题的原因。作为一个合格的开发，对于开源框架，我们不仅要会熟练使用，也要了解其底层实现，相关参数设置。一旦参数设置不合理就可能引发生产事故。\n\n另外对于生产系统，监控系统非常重要。比如上面的问题，如果没有监控发现，小黑哥可能一时半会都不知道有这个问题存在，毕竟平时也不会太关注连接数这个指标。","source":"_posts/microservices/dubbo连接数配置引发的问题.md","raw":"---\ntitle: dubbo 连接数配置导致连接爆发\ntags:\n  - 分布式与微服务\n  - dubbo 配置\ncategories:\n  - 分布式与微服务\n  - dubbo配置\ndate: 2020-06-04 15:31:13\n---\n\n## 0x00. 翻车现场\n\n收到运维noc告警：\n\n![img](/images/0082zybply1gbqenpjnt7j30yq0higpo.jpg)\n\n## 0x01. 历尽艰辛，深入排查\n\n打开电脑，首先确认生产交易一切还正常。查看这段时间日志，发现并没有什么异常情况，日志都是正常输出。没办法只好再次走查此次改动的代码，发现全是业务代码，并没有任何与网络连接有关的代码改动。\n\n`netstat -anp|grep 6701|wc -l `  查看连接情况\n\n![img](/images/5911899802886.png)\n\n\n\n`jmap -histo 6701|less` 查看堆内存情况\n\n![020060416292](/images/20200604162924.png)\n\n问题真的请奇怪，一时半会想不到解决方案，只好先实施重启大法。重启过后，连接数下降了，到达了正常阈值。但是不一会连接数持续升高，不一会还是升到上万。\n\n这下重启解决不了办法，只好从应用出发，找找到底什么问题。\n\n这个应用是一个路由服务，会根据上游系统指定路由编码，将交易分发到下游子系统。架构图如下:\n\n![img](/images/0082zybply1gbr8va8yvhj30hm0ck3z8.jpg)\n\n之前在这篇文章[路由系统演化史](https://mp.weixin.qq.com/s/Det95SU1u1dDH7nT_B1XEQ)讲过，路由系统使用 **Dubbo API** ，代码如下：\n\n![img](/images/0082zybply1gbqenooa0ej314i0u0tf3.jpg)\n\n由于我们还有另外一套系统，也部署这个应用，但是该系统生产机器连接数却很少。交叉比对了两套系统应用的系统配置值，只有 **connections** 设置不一样，当前有问题的系统设置为 **1000**，另外一个系统为 **10** 。\n\n大致找到原因，也将 **connections** 设置为 **10**，重启应用，生产机器连接数恢复正常。\n\n## 0x02. 抽丝剥茧，还原经过\n\n首先我们来看下 **connections** 这个配置的作用，可以直接查看官方文档<http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-reference.html>。\n\n下面配置来源于：**dubbo:reference**\n\n![img](/images/0082zybply1gbpy5n5wfuj31m6078wp5.jpg)\n\n总共可以在三个地方配置 **connections** 参数，分别为：**dubbo:reference**，**dubbo:consumer**，**dubbo:provider**。\n\n> **注意**：图中标示地方实际上与源码存在出入。截止 **Dubbo 2.7.3** 版本，图中 ① 处，**dubbo:consumer** 文档上显示为 **100**，实际源码默认配置为 **0**，这点需要注意。另外 ② 处文字描述存在问题，目前 **connections** 参数主要对 **dubbo** 协议有用，**http** 短连接协议还未使用该配置\n\n其中 **reference.connections** 为服务级别的配置，若未配置将会使用 **consumer.connections** 配置值。另外这个参数若在 **provider.connections** 配置，其对服务提供者无效，参数将通过注册中心传递给消费者成为其默认配置。三者实际作用顺序如下：\n\n![img](/images/0082zybply1gbpxzrh8q4j31mc0u0hdt.jpg)\n\n**Debug** 源码，**connections** 最终会在 **DubboProtocol#getClients** 被使用，方法源码如下：\n\n![img](/images/0082zybply1gbqenq2xc6j31820cs76u.jpg)\n\n![img](/images/0082zybply1gbqenma2pxj31au0u044x.jpg)\n\n> **Dubbo** 协议默认将会使用 **Netty** 与服务提供者建立长连接\n\n首先将会获取 **connections** 配置，规则如上图，若其大于 **0**，建立 **connections** 数量的长连接。\n\n如果一个提供者对外暴露 **10** 个接口，且其有两个节点。消费者端引入提供者所有服务，配置 **connections=1000**。当消费者启动之后，将会立刻创建 **1000x2x10=20000** 连接。**这就是生产机器连接数飙升的根本原因**。\n\n> 路由服务使用 **Dubbo API** 编程，服务启动成功之后，只有上游系统调用路由服务时， **Dubbo** 才会与与下游服务提供者建立连接，所以现象看起来服务连接数是慢慢激增。\n\n如果未设置 **connections** 参数，Dubbo 将会创建**共享连接（shareconnections）**。消费者调用的服务若为同一个服务提供者（**IP+PORT** 区分），这些服务接口将会共享这些连接。\n\n**shareconnections** 可以在 **dubbo:consumer** 配置中配置，也可以在启动 **JVM** 参数加入如下配置：\n\n```\n-Dshareconnections=10\n```\n\n如果消费者需要调用同个服务提供者应用的 **10** 个服务接口，服务提供者提供两个节点，**shareconnections=1000**，消费者服务启动之后，仅会创建 **1000\\*2=2000** 连接。\n\n这么对比，**shareconnections** 与 **connections** 建立连不是一个量级。\n\n### 2.1 使用连接\n\n消费者调用服务时，将会随机从连接数组中取一个连接使用，代码位于 `DubboInvoker#doInvoke`。\n\n![img](/images/0082zybply1gbqenjpogfj30ph05zdgv.jpg)\n\n### 2.2 如何正确配置连接数\n\n首先我们来看下单一长连接性能，文档地址:<http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html>\n\n![img](/images/0082zybply1gbq3md7d15j30m90cb43g.jpg)\n\n对于只有少数消费者场景，我们可以使用默认配置，即不配置 **connections** 参数 。若调用同一个提供者服务过多，可以考虑适当多配增加 **shareconnections**。最后若某一服务接口调用量特别大，可以考虑为这个服务单独配置 **connections**。\n\n## 0x03. 举一反三，聊聊其他配置\n\nDubbo 还有很多配置项，下面着重介绍一些配置参数。\n\n### 3.1 dubbo.provider.executes\n\n该参数用来控制每个方法最大并行数。如果该值设置为 **10** ，每个服务方法若已有 **10** 个请求正在处理，第 **11** 个服务请求将会抛出异常，直到之前服务调用完成，正在请求数量小于 **10** 未知。\n\n![img](/images/0082zybply1gbq3z7a7mmj31nq074qat.jpg)\n\n一旦设置 **executes>0**,**Dubbo** 将会通过 **SPI** 机制启用 `ExecuteLimitFilter`，源码还是比较简单。\n\n![img](/images/0082zybply1gbqennntwoj30sg0fswhn.jpg)\n\n### 3.2 dubbo.reference.actives\n\n这个参数将会控制消费者每个服务每个方法最大并发数。可以通过 **dubbo:method.actives** 单独为服务方法设置。如果该值为 **10**，一旦某个服务某个方法并发数超过 **10**，第 **11** 个服务将会等待，若在超时时间内其他请求执行结束，计数值减值小于阈值，第 **11** 个请求将会被执行，否者将会抛错。\n\n![img](https://tva1.sinaimg.cn/large/0082zybply1gbr8wael1dj31lw07qdgq.jpg)\n\n> `dubbo.provider` 上也可以配置这个值，其将会与 **connections** 一样，将会传递给消费者。\n\n原理等同上面方法，将会启用 `ActiveLimitFilter`，源码如下 ：\n\n![img](/images/0082zybply1gbqenluvenj30rz0hsjv2.jpg)\n\n这里需要注意 **actives** 引起超时与服务端超时区别。\n\n![img](/images/0082zybply1gbqenlanqrj327f0u04gd.jpg)\n\n### 3.3 dubbo.protocol.accepts\n\n服务提供者最大连接数，如果设置 **accepts=10**,一旦服务提供者连接数大于 **10**，其余新增连接将会被拒绝。\n\n![img](/images/0082zybply1gbq4mytke2j31gw07279o.jpg)\n\n方法源码如下：\n\n![img](/images/0082zybply1gbqemv4o7qj32780lkgrc.jpg)\n\n服务提供者断开连接，消费端将会打印连接断开日志。另外消费者会定时检查长连接可用性，若不可用，将会重新发起连接。所以在消费者端就会看到连接断开，重连，然后又被服务提供者断开的现象。\n\n![img](/images/0082zybply1gbqenms1eqj32dw0l87h5.jpg)\n\n## 0x04. 总结\n\n本文通过一次生产连接数过多的现象，详细剖析定位问题的原因。作为一个合格的开发，对于开源框架，我们不仅要会熟练使用，也要了解其底层实现，相关参数设置。一旦参数设置不合理就可能引发生产事故。\n\n另外对于生产系统，监控系统非常重要。比如上面的问题，如果没有监控发现，小黑哥可能一时半会都不知道有这个问题存在，毕竟平时也不会太关注连接数这个指标。","slug":"microservices/dubbo连接数配置引发的问题","published":1,"updated":"2020-06-04T08:38:31.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7lh004mvgja3rm4g69k","content":"<h2 id=\"0x00-翻车现场\"><a href=\"#0x00-翻车现场\" class=\"headerlink\" title=\"0x00. 翻车现场\"></a>0x00. 翻车现场</h2><p>收到运维noc告警：</p>\n<p><img src=\"/images/0082zybply1gbqenpjnt7j30yq0higpo.jpg\" alt=\"img\"></p>\n<h2 id=\"0x01-历尽艰辛，深入排查\"><a href=\"#0x01-历尽艰辛，深入排查\" class=\"headerlink\" title=\"0x01. 历尽艰辛，深入排查\"></a>0x01. 历尽艰辛，深入排查</h2><p>打开电脑，首先确认生产交易一切还正常。查看这段时间日志，发现并没有什么异常情况，日志都是正常输出。没办法只好再次走查此次改动的代码，发现全是业务代码，并没有任何与网络连接有关的代码改动。</p>\n<p><code>netstat -anp|grep 6701|wc -l</code>  查看连接情况</p>\n<p><img src=\"/images/5911899802886.png\" alt=\"img\"></p>\n<p><code>jmap -histo 6701|less</code> 查看堆内存情况</p>\n<p><img src=\"/images/20200604162924.png\" alt=\"020060416292\"></p>\n<p>问题真的请奇怪，一时半会想不到解决方案，只好先实施重启大法。重启过后，连接数下降了，到达了正常阈值。但是不一会连接数持续升高，不一会还是升到上万。</p>\n<p>这下重启解决不了办法，只好从应用出发，找找到底什么问题。</p>\n<p>这个应用是一个路由服务，会根据上游系统指定路由编码，将交易分发到下游子系统。架构图如下:</p>\n<p><img src=\"/images/0082zybply1gbr8va8yvhj30hm0ck3z8.jpg\" alt=\"img\"></p>\n<p>之前在这篇文章<a href=\"https://mp.weixin.qq.com/s/Det95SU1u1dDH7nT_B1XEQ\" target=\"_blank\" rel=\"noopener\">路由系统演化史</a>讲过，路由系统使用 <strong>Dubbo API</strong> ，代码如下：</p>\n<p><img src=\"/images/0082zybply1gbqenooa0ej314i0u0tf3.jpg\" alt=\"img\"></p>\n<p>由于我们还有另外一套系统，也部署这个应用，但是该系统生产机器连接数却很少。交叉比对了两套系统应用的系统配置值，只有 <strong>connections</strong> 设置不一样，当前有问题的系统设置为 <strong>1000</strong>，另外一个系统为 <strong>10</strong> 。</p>\n<p>大致找到原因，也将 <strong>connections</strong> 设置为 <strong>10</strong>，重启应用，生产机器连接数恢复正常。</p>\n<h2 id=\"0x02-抽丝剥茧，还原经过\"><a href=\"#0x02-抽丝剥茧，还原经过\" class=\"headerlink\" title=\"0x02. 抽丝剥茧，还原经过\"></a>0x02. 抽丝剥茧，还原经过</h2><p>首先我们来看下 <strong>connections</strong> 这个配置的作用，可以直接查看官方文档<a href=\"http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-reference.html\" target=\"_blank\" rel=\"noopener\">http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-reference.html</a>。</p>\n<p>下面配置来源于：<strong>dubbo:reference</strong></p>\n<p><img src=\"/images/0082zybply1gbpy5n5wfuj31m6078wp5.jpg\" alt=\"img\"></p>\n<p>总共可以在三个地方配置 <strong>connections</strong> 参数，分别为：<strong>dubbo:reference</strong>，<strong>dubbo:consumer</strong>，<strong>dubbo:provider</strong>。</p>\n<blockquote>\n<p><strong>注意</strong>：图中标示地方实际上与源码存在出入。截止 <strong>Dubbo 2.7.3</strong> 版本，图中 ① 处，<strong>dubbo:consumer</strong> 文档上显示为 <strong>100</strong>，实际源码默认配置为 <strong>0</strong>，这点需要注意。另外 ② 处文字描述存在问题，目前 <strong>connections</strong> 参数主要对 <strong>dubbo</strong> 协议有用，<strong>http</strong> 短连接协议还未使用该配置</p>\n</blockquote>\n<p>其中 <strong>reference.connections</strong> 为服务级别的配置，若未配置将会使用 <strong>consumer.connections</strong> 配置值。另外这个参数若在 <strong>provider.connections</strong> 配置，其对服务提供者无效，参数将通过注册中心传递给消费者成为其默认配置。三者实际作用顺序如下：</p>\n<p><img src=\"/images/0082zybply1gbpxzrh8q4j31mc0u0hdt.jpg\" alt=\"img\"></p>\n<p><strong>Debug</strong> 源码，<strong>connections</strong> 最终会在 <strong>DubboProtocol#getClients</strong> 被使用，方法源码如下：</p>\n<p><img src=\"/images/0082zybply1gbqenq2xc6j31820cs76u.jpg\" alt=\"img\"></p>\n<p><img src=\"/images/0082zybply1gbqenma2pxj31au0u044x.jpg\" alt=\"img\"></p>\n<blockquote>\n<p><strong>Dubbo</strong> 协议默认将会使用 <strong>Netty</strong> 与服务提供者建立长连接</p>\n</blockquote>\n<p>首先将会获取 <strong>connections</strong> 配置，规则如上图，若其大于 <strong>0</strong>，建立 <strong>connections</strong> 数量的长连接。</p>\n<p>如果一个提供者对外暴露 <strong>10</strong> 个接口，且其有两个节点。消费者端引入提供者所有服务，配置 <strong>connections=1000</strong>。当消费者启动之后，将会立刻创建 <strong>1000x2x10=20000</strong> 连接。<strong>这就是生产机器连接数飙升的根本原因</strong>。</p>\n<blockquote>\n<p>路由服务使用 <strong>Dubbo API</strong> 编程，服务启动成功之后，只有上游系统调用路由服务时， <strong>Dubbo</strong> 才会与与下游服务提供者建立连接，所以现象看起来服务连接数是慢慢激增。</p>\n</blockquote>\n<p>如果未设置 <strong>connections</strong> 参数，Dubbo 将会创建<strong>共享连接（shareconnections）</strong>。消费者调用的服务若为同一个服务提供者（<strong>IP+PORT</strong> 区分），这些服务接口将会共享这些连接。</p>\n<p><strong>shareconnections</strong> 可以在 <strong>dubbo:consumer</strong> 配置中配置，也可以在启动 <strong>JVM</strong> 参数加入如下配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dshareconnections&#x3D;10</span><br></pre></td></tr></table></figure>\n\n<p>如果消费者需要调用同个服务提供者应用的 <strong>10</strong> 个服务接口，服务提供者提供两个节点，<strong>shareconnections=1000</strong>，消费者服务启动之后，仅会创建 <strong>1000*2=2000</strong> 连接。</p>\n<p>这么对比，<strong>shareconnections</strong> 与 <strong>connections</strong> 建立连不是一个量级。</p>\n<h3 id=\"2-1-使用连接\"><a href=\"#2-1-使用连接\" class=\"headerlink\" title=\"2.1 使用连接\"></a>2.1 使用连接</h3><p>消费者调用服务时，将会随机从连接数组中取一个连接使用，代码位于 <code>DubboInvoker#doInvoke</code>。</p>\n<p><img src=\"/images/0082zybply1gbqenjpogfj30ph05zdgv.jpg\" alt=\"img\"></p>\n<h3 id=\"2-2-如何正确配置连接数\"><a href=\"#2-2-如何正确配置连接数\" class=\"headerlink\" title=\"2.2 如何正确配置连接数\"></a>2.2 如何正确配置连接数</h3><p>首先我们来看下单一长连接性能，文档地址:<a href=\"http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html\" target=\"_blank\" rel=\"noopener\">http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html</a></p>\n<p><img src=\"/images/0082zybply1gbq3md7d15j30m90cb43g.jpg\" alt=\"img\"></p>\n<p>对于只有少数消费者场景，我们可以使用默认配置，即不配置 <strong>connections</strong> 参数 。若调用同一个提供者服务过多，可以考虑适当多配增加 <strong>shareconnections</strong>。最后若某一服务接口调用量特别大，可以考虑为这个服务单独配置 <strong>connections</strong>。</p>\n<h2 id=\"0x03-举一反三，聊聊其他配置\"><a href=\"#0x03-举一反三，聊聊其他配置\" class=\"headerlink\" title=\"0x03. 举一反三，聊聊其他配置\"></a>0x03. 举一反三，聊聊其他配置</h2><p>Dubbo 还有很多配置项，下面着重介绍一些配置参数。</p>\n<h3 id=\"3-1-dubbo-provider-executes\"><a href=\"#3-1-dubbo-provider-executes\" class=\"headerlink\" title=\"3.1 dubbo.provider.executes\"></a>3.1 dubbo.provider.executes</h3><p>该参数用来控制每个方法最大并行数。如果该值设置为 <strong>10</strong> ，每个服务方法若已有 <strong>10</strong> 个请求正在处理，第 <strong>11</strong> 个服务请求将会抛出异常，直到之前服务调用完成，正在请求数量小于 <strong>10</strong> 未知。</p>\n<p><img src=\"/images/0082zybply1gbq3z7a7mmj31nq074qat.jpg\" alt=\"img\"></p>\n<p>一旦设置 <strong>executes&gt;0</strong>,<strong>Dubbo</strong> 将会通过 <strong>SPI</strong> 机制启用 <code>ExecuteLimitFilter</code>，源码还是比较简单。</p>\n<p><img src=\"/images/0082zybply1gbqennntwoj30sg0fswhn.jpg\" alt=\"img\"></p>\n<h3 id=\"3-2-dubbo-reference-actives\"><a href=\"#3-2-dubbo-reference-actives\" class=\"headerlink\" title=\"3.2 dubbo.reference.actives\"></a>3.2 dubbo.reference.actives</h3><p>这个参数将会控制消费者每个服务每个方法最大并发数。可以通过 <strong>dubbo:method.actives</strong> 单独为服务方法设置。如果该值为 <strong>10</strong>，一旦某个服务某个方法并发数超过 <strong>10</strong>，第 <strong>11</strong> 个服务将会等待，若在超时时间内其他请求执行结束，计数值减值小于阈值，第 <strong>11</strong> 个请求将会被执行，否者将会抛错。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbr8wael1dj31lw07qdgq.jpg\" alt=\"img\"></p>\n<blockquote>\n<p><code>dubbo.provider</code> 上也可以配置这个值，其将会与 <strong>connections</strong> 一样，将会传递给消费者。</p>\n</blockquote>\n<p>原理等同上面方法，将会启用 <code>ActiveLimitFilter</code>，源码如下 ：</p>\n<p><img src=\"/images/0082zybply1gbqenluvenj30rz0hsjv2.jpg\" alt=\"img\"></p>\n<p>这里需要注意 <strong>actives</strong> 引起超时与服务端超时区别。</p>\n<p><img src=\"/images/0082zybply1gbqenlanqrj327f0u04gd.jpg\" alt=\"img\"></p>\n<h3 id=\"3-3-dubbo-protocol-accepts\"><a href=\"#3-3-dubbo-protocol-accepts\" class=\"headerlink\" title=\"3.3 dubbo.protocol.accepts\"></a>3.3 dubbo.protocol.accepts</h3><p>服务提供者最大连接数，如果设置 <strong>accepts=10</strong>,一旦服务提供者连接数大于 <strong>10</strong>，其余新增连接将会被拒绝。</p>\n<p><img src=\"/images/0082zybply1gbq4mytke2j31gw07279o.jpg\" alt=\"img\"></p>\n<p>方法源码如下：</p>\n<p><img src=\"/images/0082zybply1gbqemv4o7qj32780lkgrc.jpg\" alt=\"img\"></p>\n<p>服务提供者断开连接，消费端将会打印连接断开日志。另外消费者会定时检查长连接可用性，若不可用，将会重新发起连接。所以在消费者端就会看到连接断开，重连，然后又被服务提供者断开的现象。</p>\n<p><img src=\"/images/0082zybply1gbqenms1eqj32dw0l87h5.jpg\" alt=\"img\"></p>\n<h2 id=\"0x04-总结\"><a href=\"#0x04-总结\" class=\"headerlink\" title=\"0x04. 总结\"></a>0x04. 总结</h2><p>本文通过一次生产连接数过多的现象，详细剖析定位问题的原因。作为一个合格的开发，对于开源框架，我们不仅要会熟练使用，也要了解其底层实现，相关参数设置。一旦参数设置不合理就可能引发生产事故。</p>\n<p>另外对于生产系统，监控系统非常重要。比如上面的问题，如果没有监控发现，小黑哥可能一时半会都不知道有这个问题存在，毕竟平时也不会太关注连接数这个指标。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"0x00-翻车现场\"><a href=\"#0x00-翻车现场\" class=\"headerlink\" title=\"0x00. 翻车现场\"></a>0x00. 翻车现场</h2><p>收到运维noc告警：</p>\n<p><img src=\"/images/0082zybply1gbqenpjnt7j30yq0higpo.jpg\" alt=\"img\"></p>\n<h2 id=\"0x01-历尽艰辛，深入排查\"><a href=\"#0x01-历尽艰辛，深入排查\" class=\"headerlink\" title=\"0x01. 历尽艰辛，深入排查\"></a>0x01. 历尽艰辛，深入排查</h2><p>打开电脑，首先确认生产交易一切还正常。查看这段时间日志，发现并没有什么异常情况，日志都是正常输出。没办法只好再次走查此次改动的代码，发现全是业务代码，并没有任何与网络连接有关的代码改动。</p>\n<p><code>netstat -anp|grep 6701|wc -l</code>  查看连接情况</p>\n<p><img src=\"/images/5911899802886.png\" alt=\"img\"></p>\n<p><code>jmap -histo 6701|less</code> 查看堆内存情况</p>\n<p><img src=\"/images/20200604162924.png\" alt=\"020060416292\"></p>\n<p>问题真的请奇怪，一时半会想不到解决方案，只好先实施重启大法。重启过后，连接数下降了，到达了正常阈值。但是不一会连接数持续升高，不一会还是升到上万。</p>\n<p>这下重启解决不了办法，只好从应用出发，找找到底什么问题。</p>\n<p>这个应用是一个路由服务，会根据上游系统指定路由编码，将交易分发到下游子系统。架构图如下:</p>\n<p><img src=\"/images/0082zybply1gbr8va8yvhj30hm0ck3z8.jpg\" alt=\"img\"></p>\n<p>之前在这篇文章<a href=\"https://mp.weixin.qq.com/s/Det95SU1u1dDH7nT_B1XEQ\" target=\"_blank\" rel=\"noopener\">路由系统演化史</a>讲过，路由系统使用 <strong>Dubbo API</strong> ，代码如下：</p>\n<p><img src=\"/images/0082zybply1gbqenooa0ej314i0u0tf3.jpg\" alt=\"img\"></p>\n<p>由于我们还有另外一套系统，也部署这个应用，但是该系统生产机器连接数却很少。交叉比对了两套系统应用的系统配置值，只有 <strong>connections</strong> 设置不一样，当前有问题的系统设置为 <strong>1000</strong>，另外一个系统为 <strong>10</strong> 。</p>\n<p>大致找到原因，也将 <strong>connections</strong> 设置为 <strong>10</strong>，重启应用，生产机器连接数恢复正常。</p>\n<h2 id=\"0x02-抽丝剥茧，还原经过\"><a href=\"#0x02-抽丝剥茧，还原经过\" class=\"headerlink\" title=\"0x02. 抽丝剥茧，还原经过\"></a>0x02. 抽丝剥茧，还原经过</h2><p>首先我们来看下 <strong>connections</strong> 这个配置的作用，可以直接查看官方文档<a href=\"http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-reference.html\" target=\"_blank\" rel=\"noopener\">http://dubbo.apache.org/zh-cn/docs/user/references/xml/dubbo-reference.html</a>。</p>\n<p>下面配置来源于：<strong>dubbo:reference</strong></p>\n<p><img src=\"/images/0082zybply1gbpy5n5wfuj31m6078wp5.jpg\" alt=\"img\"></p>\n<p>总共可以在三个地方配置 <strong>connections</strong> 参数，分别为：<strong>dubbo:reference</strong>，<strong>dubbo:consumer</strong>，<strong>dubbo:provider</strong>。</p>\n<blockquote>\n<p><strong>注意</strong>：图中标示地方实际上与源码存在出入。截止 <strong>Dubbo 2.7.3</strong> 版本，图中 ① 处，<strong>dubbo:consumer</strong> 文档上显示为 <strong>100</strong>，实际源码默认配置为 <strong>0</strong>，这点需要注意。另外 ② 处文字描述存在问题，目前 <strong>connections</strong> 参数主要对 <strong>dubbo</strong> 协议有用，<strong>http</strong> 短连接协议还未使用该配置</p>\n</blockquote>\n<p>其中 <strong>reference.connections</strong> 为服务级别的配置，若未配置将会使用 <strong>consumer.connections</strong> 配置值。另外这个参数若在 <strong>provider.connections</strong> 配置，其对服务提供者无效，参数将通过注册中心传递给消费者成为其默认配置。三者实际作用顺序如下：</p>\n<p><img src=\"/images/0082zybply1gbpxzrh8q4j31mc0u0hdt.jpg\" alt=\"img\"></p>\n<p><strong>Debug</strong> 源码，<strong>connections</strong> 最终会在 <strong>DubboProtocol#getClients</strong> 被使用，方法源码如下：</p>\n<p><img src=\"/images/0082zybply1gbqenq2xc6j31820cs76u.jpg\" alt=\"img\"></p>\n<p><img src=\"/images/0082zybply1gbqenma2pxj31au0u044x.jpg\" alt=\"img\"></p>\n<blockquote>\n<p><strong>Dubbo</strong> 协议默认将会使用 <strong>Netty</strong> 与服务提供者建立长连接</p>\n</blockquote>\n<p>首先将会获取 <strong>connections</strong> 配置，规则如上图，若其大于 <strong>0</strong>，建立 <strong>connections</strong> 数量的长连接。</p>\n<p>如果一个提供者对外暴露 <strong>10</strong> 个接口，且其有两个节点。消费者端引入提供者所有服务，配置 <strong>connections=1000</strong>。当消费者启动之后，将会立刻创建 <strong>1000x2x10=20000</strong> 连接。<strong>这就是生产机器连接数飙升的根本原因</strong>。</p>\n<blockquote>\n<p>路由服务使用 <strong>Dubbo API</strong> 编程，服务启动成功之后，只有上游系统调用路由服务时， <strong>Dubbo</strong> 才会与与下游服务提供者建立连接，所以现象看起来服务连接数是慢慢激增。</p>\n</blockquote>\n<p>如果未设置 <strong>connections</strong> 参数，Dubbo 将会创建<strong>共享连接（shareconnections）</strong>。消费者调用的服务若为同一个服务提供者（<strong>IP+PORT</strong> 区分），这些服务接口将会共享这些连接。</p>\n<p><strong>shareconnections</strong> 可以在 <strong>dubbo:consumer</strong> 配置中配置，也可以在启动 <strong>JVM</strong> 参数加入如下配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dshareconnections&#x3D;10</span><br></pre></td></tr></table></figure>\n\n<p>如果消费者需要调用同个服务提供者应用的 <strong>10</strong> 个服务接口，服务提供者提供两个节点，<strong>shareconnections=1000</strong>，消费者服务启动之后，仅会创建 <strong>1000*2=2000</strong> 连接。</p>\n<p>这么对比，<strong>shareconnections</strong> 与 <strong>connections</strong> 建立连不是一个量级。</p>\n<h3 id=\"2-1-使用连接\"><a href=\"#2-1-使用连接\" class=\"headerlink\" title=\"2.1 使用连接\"></a>2.1 使用连接</h3><p>消费者调用服务时，将会随机从连接数组中取一个连接使用，代码位于 <code>DubboInvoker#doInvoke</code>。</p>\n<p><img src=\"/images/0082zybply1gbqenjpogfj30ph05zdgv.jpg\" alt=\"img\"></p>\n<h3 id=\"2-2-如何正确配置连接数\"><a href=\"#2-2-如何正确配置连接数\" class=\"headerlink\" title=\"2.2 如何正确配置连接数\"></a>2.2 如何正确配置连接数</h3><p>首先我们来看下单一长连接性能，文档地址:<a href=\"http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html\" target=\"_blank\" rel=\"noopener\">http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html</a></p>\n<p><img src=\"/images/0082zybply1gbq3md7d15j30m90cb43g.jpg\" alt=\"img\"></p>\n<p>对于只有少数消费者场景，我们可以使用默认配置，即不配置 <strong>connections</strong> 参数 。若调用同一个提供者服务过多，可以考虑适当多配增加 <strong>shareconnections</strong>。最后若某一服务接口调用量特别大，可以考虑为这个服务单独配置 <strong>connections</strong>。</p>\n<h2 id=\"0x03-举一反三，聊聊其他配置\"><a href=\"#0x03-举一反三，聊聊其他配置\" class=\"headerlink\" title=\"0x03. 举一反三，聊聊其他配置\"></a>0x03. 举一反三，聊聊其他配置</h2><p>Dubbo 还有很多配置项，下面着重介绍一些配置参数。</p>\n<h3 id=\"3-1-dubbo-provider-executes\"><a href=\"#3-1-dubbo-provider-executes\" class=\"headerlink\" title=\"3.1 dubbo.provider.executes\"></a>3.1 dubbo.provider.executes</h3><p>该参数用来控制每个方法最大并行数。如果该值设置为 <strong>10</strong> ，每个服务方法若已有 <strong>10</strong> 个请求正在处理，第 <strong>11</strong> 个服务请求将会抛出异常，直到之前服务调用完成，正在请求数量小于 <strong>10</strong> 未知。</p>\n<p><img src=\"/images/0082zybply1gbq3z7a7mmj31nq074qat.jpg\" alt=\"img\"></p>\n<p>一旦设置 <strong>executes&gt;0</strong>,<strong>Dubbo</strong> 将会通过 <strong>SPI</strong> 机制启用 <code>ExecuteLimitFilter</code>，源码还是比较简单。</p>\n<p><img src=\"/images/0082zybply1gbqennntwoj30sg0fswhn.jpg\" alt=\"img\"></p>\n<h3 id=\"3-2-dubbo-reference-actives\"><a href=\"#3-2-dubbo-reference-actives\" class=\"headerlink\" title=\"3.2 dubbo.reference.actives\"></a>3.2 dubbo.reference.actives</h3><p>这个参数将会控制消费者每个服务每个方法最大并发数。可以通过 <strong>dubbo:method.actives</strong> 单独为服务方法设置。如果该值为 <strong>10</strong>，一旦某个服务某个方法并发数超过 <strong>10</strong>，第 <strong>11</strong> 个服务将会等待，若在超时时间内其他请求执行结束，计数值减值小于阈值，第 <strong>11</strong> 个请求将会被执行，否者将会抛错。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbr8wael1dj31lw07qdgq.jpg\" alt=\"img\"></p>\n<blockquote>\n<p><code>dubbo.provider</code> 上也可以配置这个值，其将会与 <strong>connections</strong> 一样，将会传递给消费者。</p>\n</blockquote>\n<p>原理等同上面方法，将会启用 <code>ActiveLimitFilter</code>，源码如下 ：</p>\n<p><img src=\"/images/0082zybply1gbqenluvenj30rz0hsjv2.jpg\" alt=\"img\"></p>\n<p>这里需要注意 <strong>actives</strong> 引起超时与服务端超时区别。</p>\n<p><img src=\"/images/0082zybply1gbqenlanqrj327f0u04gd.jpg\" alt=\"img\"></p>\n<h3 id=\"3-3-dubbo-protocol-accepts\"><a href=\"#3-3-dubbo-protocol-accepts\" class=\"headerlink\" title=\"3.3 dubbo.protocol.accepts\"></a>3.3 dubbo.protocol.accepts</h3><p>服务提供者最大连接数，如果设置 <strong>accepts=10</strong>,一旦服务提供者连接数大于 <strong>10</strong>，其余新增连接将会被拒绝。</p>\n<p><img src=\"/images/0082zybply1gbq4mytke2j31gw07279o.jpg\" alt=\"img\"></p>\n<p>方法源码如下：</p>\n<p><img src=\"/images/0082zybply1gbqemv4o7qj32780lkgrc.jpg\" alt=\"img\"></p>\n<p>服务提供者断开连接，消费端将会打印连接断开日志。另外消费者会定时检查长连接可用性，若不可用，将会重新发起连接。所以在消费者端就会看到连接断开，重连，然后又被服务提供者断开的现象。</p>\n<p><img src=\"/images/0082zybply1gbqenms1eqj32dw0l87h5.jpg\" alt=\"img\"></p>\n<h2 id=\"0x04-总结\"><a href=\"#0x04-总结\" class=\"headerlink\" title=\"0x04. 总结\"></a>0x04. 总结</h2><p>本文通过一次生产连接数过多的现象，详细剖析定位问题的原因。作为一个合格的开发，对于开源框架，我们不仅要会熟练使用，也要了解其底层实现，相关参数设置。一旦参数设置不合理就可能引发生产事故。</p>\n<p>另外对于生产系统，监控系统非常重要。比如上面的问题，如果没有监控发现，小黑哥可能一时半会都不知道有这个问题存在，毕竟平时也不会太关注连接数这个指标。</p>\n"},{"title":"Open API","date":"2020-04-15T12:16:19.000Z","_content":"\n#架构图\n### 架构类\n#### 框架上使用\n`spring`/`mybatis`/`undertow`  \n#### 服务治理使用 \n`dubbo`   \n#### 缓存服务使用\n`redis`（身份认证状态缓存，临时性字典数据缓存，提升效率）\n#### MQ\n`RocketMQ`（mq做业务解耦，流量削峰，业务驱动，回调通知队列，消息持久化和定时任务补偿保证数据不被丢失）\n#### 分布式锁服务\nzk\n#### webhook通知服务\nokhttp3、forkjoin框架、rocketMq队列、elasticJob补偿\n#### 流量控制\nnginx、lua、redis、mq\n#### 服务稳定性\nhystrix 熔断\n#### 模块划分\n    接口模块-----api\n        核心模块----core\n        管理端模块----manager\n        webhook回调通知模块----webhook --> 订阅event --> 消息letter生成 -->入库 -->生成待发送队列（两级队列：内存队列20w，rocketMQ消息队列；一个补偿任务elasticJob)-->\n\n   \n![架构](/images/架构.png)\n\n# Open API 介绍\n\nOpenAPI 项目是基于REST标准来设计的，为保证统一和安全，全局编码格式为UTF-8，全局使用https。我们的API具有可预测的面向资源的url，返回json编码的响应，并使用标准的HTTP响应代码、身份验证和请求动词。\n\n为了数据准确性和生产环境数据安全，建议在沙盒环境测试这些接口.\n\n# 版本控制\n\n当我们对API进行向后不兼容的更改时，我们会发布新版本。要使用的版本在URL中指定。当前版本是v1，比如:\n\n    https://api.itmarte.com/payments/v1/...\n\n# 授权认证\n\n在不同的对接场景下Open API存在两种认证方式（用户开发者和第三方应用开发者，通常情况下申请用户开发者），使用http头`Authorization`做认证：   \n![授权图](/images/授权图.png)\n### 用户开发者模式\n\n创建了用户开发者之后，会收到给您返回的`developerId`、`masterToken`（`masterToken`能行使用户所有权限，请您务必安全保管）和`LLP_RSA_PUB_KEY.pem`，身份认证格式如下:\n\n    Authorization: Basic &lt;&lt;Base64.encode(developerId:masterToken)&gt;&gt;\n\n### 第三方应用开发者模式\n\n创建第三方应用开发者之后，会收到`clientId`、`clientSecret`和`LLP_RSA_PUB_KEY.pem`，至于`accessToken`则需要通过OAuth2.0模式向有资源的用户申请，身份认证格式如下:\n\n    Authorization: Bearer &lt;&lt;accessToken&gt;&gt;\n\n# 请求安全\n\n为了请求安全防止重放攻击，要求所有请求都得有签名认证，在http头定义了`xxx-Signature`字段作为签名信息载体，`xxx-Signature`头文件中包含了请求包体和响应的epoch时间戳（是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数）例如：`xxx-Signature:t=&lt;&lt;epoch&gt;&gt;,v=&lt;&lt;signature&gt;&gt;`，一个请求的有效时间是5分钟。下面介绍下请求的签名格式：\n\n### 请求签名\n\n2. 对`HTTP请求方式`、`URI`、`请求epoch时间`（单位秒）、`请求包体`的数据按照一定顺序用字符串“&”做拼接后使用对接方的`RSA私钥`通过`SHA256WithRSA`算法做签名并用`Base64编码`，生成的签名字符串（`signature`）和`epoch`时间放入HTTP包头的`xxx-Signature`标签中，格式为：\n\n<!---->\n\n   \n    xxx-Signature:t=&lt;&lt;epoch&gt;&gt;,v=&lt;&lt;signature&gt;&gt;\n   \n\n**第一步:** 确定签名`payload`\n\n如下字段请用`&`一次连接\n\n- `HTTP_METHOD`: 对应实际接口的方法（统一用大写），如`POST`、`PUT`、`GET`、`DELETE`等；\n- `URI`: 请求的URI地址（除去host）.  例如`https://api.sandbox.itmarte.com/collections/v1/merchants`中`/collections/v1/merchants`为URI\n- `REQUEST_EPOCH`: 是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数,该值应与`t`值保持一致\n- `REQUEST_PAYLOAD`: 请求包体  `{\"currency\":\"USD\"}`\n- `QUERY_STRING`: 查询字段例如：`https://api.sandbox.itmarte.com/collections/v1/merchants?attr1=value1&attr2=value2`,其中`QUERY_STRING`=`attr1=value1&attr2=value2`格式化为`attr1%3Dvalue1%26attr2%3Dvalue2`\n\n `payload`示例:\n\n    POST&/collections/v1/merchants&19879234&{\"currency\":\"USD\"}&attr1%3Dvalue1%26attr2%3Dvalue2\n\n**第二部:** 准备 `xxx-Signature` 签名头\n\n你会用到以下内容:\n\n- REQUEST_EPOCH (Seconds elapsed since 1970/1/1 00:00:00 GMT as a string)\n- 连接字符串 `,`\n- payload（第一步的结果）\n- your_rsa_pri_key：你的RSA私钥\n\n<!---->\n\n    xxx-Signature: t=REQUEST_EPOCH,v=BASE64_ENCODE(SHA256WithRSA.sign(&lt;&lt;payload&gt;&gt;, &lt;&lt;your_rsa_pri_key&gt;&gt;))\n\n**请求示例**\n\n    POST /api/mkt/balance HTTP/1.1 \n    Host: api.itmarte.com \n    Content-Type: application/json \n    Authorization: Basic WTgzcHNkcFdqY3J0Vml5eHVveTNyWGp2OWpzMjV3aUs6WTgzcHNkcFdqY3J0Vml5eHVveTNyWGp2OWpzMjV3aUs= \n    xxx-Signature: t=1574130344,v=cJKgD/EpqNVnITR7yZ8BIev5j1E0ub0VbG4uGA69gR4T1FFc7NzqbiBoDEOBvkQtJXytQd7dY+WDo0Qm0c6gCnRHqIEyBen6SnBk/PjhIn7H93sHMyUEbesJqB6NAzOHA4uVj+8aTfREQWxKaizkDTT1dnrBUZ7KPxz4KKzRXtZ6tEh48HKsA5xqviedc+kpilaFbFSaoJmFj760TV8FB+mKCkZSrvX1Y+4x0bqTVBXAt2kE2Z8vCH16BDtlWGLZRSlWtZWyvpz6F0a/VWYVhoBEmgNFevnYDeAMGB6VEDBE1pZLMnhxfLfz6yu/p1pv1c2N2Yk5YSahQw4lLLiqQQ== \n    Accept: */* \n    Cache-Control: no-cache \n    Content-Length: 18 \n    Connection: keep-alive \n\n    {\"currency\":\"USD\"} \n\n### 请求结果签名验证\n\n-   若请求成功返回200，包体格式查看具体接口，对响应包体使用连连支付的RSA私钥用SHA256WithRSA做签名并用Base64编码，生成的签名字符串放入HTTP包头xxx-Signature标签中，格式为xxx-Signature: t = response_epoch, v = signature。\n    其中：\n- t=响应时间戳(格林威治时间1970年01月01日00时00分00秒起至现在的总秒数)\n- v=BASE64_ENCODE(SHA256WithRSA(RESPONSE_EPOCH&RESPONSE_BODY, LLPAY_RSA_PRIVATE_KEY))\n\n**第一步:** 确定 `payload`\n\n如下字段创建`payload`用 `&` 做连接\n\n- Response Timestamp: 响应时间戳(格林威治时间1970年01月01日00时00分00秒起至现在的总秒数)\n- Response Payload: 响应包体，指定为JSON字符串如： `{\"currency\":\"USD\"}`\n\n`payload`示例:\n\n    19879234&{\"currency\":\"USD\"}\n\n**第二部:** 使用连连的RSA公钥校验签名的有效性\n\n    SHA256WithRSA.verify(xxx-Signature, '19879234&{\" currency\":\"USD\"}',  LLPAY_RSA_PRIVATE_KEY)\n\n# 响应结果\n\n**成功返回结果示例**\n\n连连通过http状态码来判断请求的结果，一个成功的请求的http状态码为2XX，请求结果为相应的objects对象，例如:\n\n```\nHTTP/1.1 200 \nstatus: 200 \nContent-Type: application/json \nContent-Length: 61\nConnection: keep-alive \nxxx-Signature:t=1574130398,v=b0VbG4uGA69gR4T1FFc7NzqbiBoDEOBvkQtJXytQd7dY+WDo0QmgR4T1FFc7NzqbiBoDEOBvkQtJXytQpzMjV3aUs6R4T1FFc7NzqbiBoDEOBvWTgzcHNkcFdqY3J0Vml5eHVc6gCnRHqIEyBen6SnBk/PjhIn7H93sHMyUEbesJqB6NAzOHA4uVj+8aTfREQWxKaizkDTT1dnrBUZ7KPxz4KKzRXtZ6tEh48HKsA5xqWGLZRSlWtZWyvpz6F0a/VWYVhoBEmgNFevkE2Z8vCH16VEDBE1pZ6VEDBE1pZ6BDBE1pZ6VEDBE1DtlWGLnYviedc+kpilaFbFSaoJmFj76==\n\n{\"currency\":\"USD\",\"balance\":\"12.25\"}\n\n```\n\n#### Errors\n\n一个失败的请求会收到4XX类的http状态码表示已知错误内容（具体错误码API文档给出），5XX的状态码表示未知的错误类型：\n\n#### Attributes\n\n**_code_** _number_\n失败码类型，数字类型，用于快速定位错误类型\n\n**_message_** _string_\n失败描述\n\n**失败返回结果示例**\n\n    HTTP/1.1 400\n    status: 400\n    Date: Tue, 19 Nov 2019 02:26:38 GMT\n    Content-Type: application/json\n    Content-Length: 77\n    Connection: keep-alive\n\n    {\"code\":\"999995\",\"message\":\"[holderType] is invalid\"}\n\n### HTTP状态码一览表\n\n| CODE               | DESCRIPTION                |\n| ------------------ | -------------------------- |\n| 400                | 请求错误，例如：参数错误               |\n| 401                | 授权认证失败或者是签名认证失败            |\n| 403                | 请求未授权                      |\n| 404                | 资源未找到，这里的资源指的是实际的Objects对象 |\n| 500, 502, 503, 504 | 系统错误                       |\n\n# 请求幂等保证\n\n实际运行场景中，由于网络原因或者其他原因导致的网络中断是不可避免的，所以连连这边特意设计了请求幂等保证操作，所有的POST、PUT、DELETE请求都可以做幂等校验，幂等请求认证成功之后，会返回最初的请求结果（5XX未知异常类型的错误除外）。\n\n你需要在http头加入`Idempotency-Key`以便让系统失败你的幂等请求：\n\n    Idempotency-Key:&lt;&lt;unique id for client &gt;&gt;\n\n# Request IDs\n\n每个API请求都有一个关联的请求标识符。您可以响应头找到`Request-Id`下这个键值。\n\n# 字段命名规范\n\n连连所有的字段命名规范为驼峰式:\n\n    https://api...com/resource/?filterBy=\"filter\"\n\n    {\n      \"storeName\": \"My Store\",\n      \"kycStatus\": \"success\"\n    }\n\n# Webhook\n\n你可以配置webhook地址来接收连连这边的回调信息（`event`），具体的回调信息（`event`）在相应的接口中定义\n\n# 对象关系模型\n![对象关系模型](/images/关系模型.png)\n\n","source":"_posts/project/open-api.md","raw":"---\ntitle: Open API\ntags:\n  - 项目\ncategories:\n  - 项目\n  - Open API\ndate: 2020-04-15 20:16:19\n---\n\n#架构图\n### 架构类\n#### 框架上使用\n`spring`/`mybatis`/`undertow`  \n#### 服务治理使用 \n`dubbo`   \n#### 缓存服务使用\n`redis`（身份认证状态缓存，临时性字典数据缓存，提升效率）\n#### MQ\n`RocketMQ`（mq做业务解耦，流量削峰，业务驱动，回调通知队列，消息持久化和定时任务补偿保证数据不被丢失）\n#### 分布式锁服务\nzk\n#### webhook通知服务\nokhttp3、forkjoin框架、rocketMq队列、elasticJob补偿\n#### 流量控制\nnginx、lua、redis、mq\n#### 服务稳定性\nhystrix 熔断\n#### 模块划分\n    接口模块-----api\n        核心模块----core\n        管理端模块----manager\n        webhook回调通知模块----webhook --> 订阅event --> 消息letter生成 -->入库 -->生成待发送队列（两级队列：内存队列20w，rocketMQ消息队列；一个补偿任务elasticJob)-->\n\n   \n![架构](/images/架构.png)\n\n# Open API 介绍\n\nOpenAPI 项目是基于REST标准来设计的，为保证统一和安全，全局编码格式为UTF-8，全局使用https。我们的API具有可预测的面向资源的url，返回json编码的响应，并使用标准的HTTP响应代码、身份验证和请求动词。\n\n为了数据准确性和生产环境数据安全，建议在沙盒环境测试这些接口.\n\n# 版本控制\n\n当我们对API进行向后不兼容的更改时，我们会发布新版本。要使用的版本在URL中指定。当前版本是v1，比如:\n\n    https://api.itmarte.com/payments/v1/...\n\n# 授权认证\n\n在不同的对接场景下Open API存在两种认证方式（用户开发者和第三方应用开发者，通常情况下申请用户开发者），使用http头`Authorization`做认证：   \n![授权图](/images/授权图.png)\n### 用户开发者模式\n\n创建了用户开发者之后，会收到给您返回的`developerId`、`masterToken`（`masterToken`能行使用户所有权限，请您务必安全保管）和`LLP_RSA_PUB_KEY.pem`，身份认证格式如下:\n\n    Authorization: Basic &lt;&lt;Base64.encode(developerId:masterToken)&gt;&gt;\n\n### 第三方应用开发者模式\n\n创建第三方应用开发者之后，会收到`clientId`、`clientSecret`和`LLP_RSA_PUB_KEY.pem`，至于`accessToken`则需要通过OAuth2.0模式向有资源的用户申请，身份认证格式如下:\n\n    Authorization: Bearer &lt;&lt;accessToken&gt;&gt;\n\n# 请求安全\n\n为了请求安全防止重放攻击，要求所有请求都得有签名认证，在http头定义了`xxx-Signature`字段作为签名信息载体，`xxx-Signature`头文件中包含了请求包体和响应的epoch时间戳（是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数）例如：`xxx-Signature:t=&lt;&lt;epoch&gt;&gt;,v=&lt;&lt;signature&gt;&gt;`，一个请求的有效时间是5分钟。下面介绍下请求的签名格式：\n\n### 请求签名\n\n2. 对`HTTP请求方式`、`URI`、`请求epoch时间`（单位秒）、`请求包体`的数据按照一定顺序用字符串“&”做拼接后使用对接方的`RSA私钥`通过`SHA256WithRSA`算法做签名并用`Base64编码`，生成的签名字符串（`signature`）和`epoch`时间放入HTTP包头的`xxx-Signature`标签中，格式为：\n\n<!---->\n\n   \n    xxx-Signature:t=&lt;&lt;epoch&gt;&gt;,v=&lt;&lt;signature&gt;&gt;\n   \n\n**第一步:** 确定签名`payload`\n\n如下字段请用`&`一次连接\n\n- `HTTP_METHOD`: 对应实际接口的方法（统一用大写），如`POST`、`PUT`、`GET`、`DELETE`等；\n- `URI`: 请求的URI地址（除去host）.  例如`https://api.sandbox.itmarte.com/collections/v1/merchants`中`/collections/v1/merchants`为URI\n- `REQUEST_EPOCH`: 是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数,该值应与`t`值保持一致\n- `REQUEST_PAYLOAD`: 请求包体  `{\"currency\":\"USD\"}`\n- `QUERY_STRING`: 查询字段例如：`https://api.sandbox.itmarte.com/collections/v1/merchants?attr1=value1&attr2=value2`,其中`QUERY_STRING`=`attr1=value1&attr2=value2`格式化为`attr1%3Dvalue1%26attr2%3Dvalue2`\n\n `payload`示例:\n\n    POST&/collections/v1/merchants&19879234&{\"currency\":\"USD\"}&attr1%3Dvalue1%26attr2%3Dvalue2\n\n**第二部:** 准备 `xxx-Signature` 签名头\n\n你会用到以下内容:\n\n- REQUEST_EPOCH (Seconds elapsed since 1970/1/1 00:00:00 GMT as a string)\n- 连接字符串 `,`\n- payload（第一步的结果）\n- your_rsa_pri_key：你的RSA私钥\n\n<!---->\n\n    xxx-Signature: t=REQUEST_EPOCH,v=BASE64_ENCODE(SHA256WithRSA.sign(&lt;&lt;payload&gt;&gt;, &lt;&lt;your_rsa_pri_key&gt;&gt;))\n\n**请求示例**\n\n    POST /api/mkt/balance HTTP/1.1 \n    Host: api.itmarte.com \n    Content-Type: application/json \n    Authorization: Basic WTgzcHNkcFdqY3J0Vml5eHVveTNyWGp2OWpzMjV3aUs6WTgzcHNkcFdqY3J0Vml5eHVveTNyWGp2OWpzMjV3aUs= \n    xxx-Signature: t=1574130344,v=cJKgD/EpqNVnITR7yZ8BIev5j1E0ub0VbG4uGA69gR4T1FFc7NzqbiBoDEOBvkQtJXytQd7dY+WDo0Qm0c6gCnRHqIEyBen6SnBk/PjhIn7H93sHMyUEbesJqB6NAzOHA4uVj+8aTfREQWxKaizkDTT1dnrBUZ7KPxz4KKzRXtZ6tEh48HKsA5xqviedc+kpilaFbFSaoJmFj760TV8FB+mKCkZSrvX1Y+4x0bqTVBXAt2kE2Z8vCH16BDtlWGLZRSlWtZWyvpz6F0a/VWYVhoBEmgNFevnYDeAMGB6VEDBE1pZLMnhxfLfz6yu/p1pv1c2N2Yk5YSahQw4lLLiqQQ== \n    Accept: */* \n    Cache-Control: no-cache \n    Content-Length: 18 \n    Connection: keep-alive \n\n    {\"currency\":\"USD\"} \n\n### 请求结果签名验证\n\n-   若请求成功返回200，包体格式查看具体接口，对响应包体使用连连支付的RSA私钥用SHA256WithRSA做签名并用Base64编码，生成的签名字符串放入HTTP包头xxx-Signature标签中，格式为xxx-Signature: t = response_epoch, v = signature。\n    其中：\n- t=响应时间戳(格林威治时间1970年01月01日00时00分00秒起至现在的总秒数)\n- v=BASE64_ENCODE(SHA256WithRSA(RESPONSE_EPOCH&RESPONSE_BODY, LLPAY_RSA_PRIVATE_KEY))\n\n**第一步:** 确定 `payload`\n\n如下字段创建`payload`用 `&` 做连接\n\n- Response Timestamp: 响应时间戳(格林威治时间1970年01月01日00时00分00秒起至现在的总秒数)\n- Response Payload: 响应包体，指定为JSON字符串如： `{\"currency\":\"USD\"}`\n\n`payload`示例:\n\n    19879234&{\"currency\":\"USD\"}\n\n**第二部:** 使用连连的RSA公钥校验签名的有效性\n\n    SHA256WithRSA.verify(xxx-Signature, '19879234&{\" currency\":\"USD\"}',  LLPAY_RSA_PRIVATE_KEY)\n\n# 响应结果\n\n**成功返回结果示例**\n\n连连通过http状态码来判断请求的结果，一个成功的请求的http状态码为2XX，请求结果为相应的objects对象，例如:\n\n```\nHTTP/1.1 200 \nstatus: 200 \nContent-Type: application/json \nContent-Length: 61\nConnection: keep-alive \nxxx-Signature:t=1574130398,v=b0VbG4uGA69gR4T1FFc7NzqbiBoDEOBvkQtJXytQd7dY+WDo0QmgR4T1FFc7NzqbiBoDEOBvkQtJXytQpzMjV3aUs6R4T1FFc7NzqbiBoDEOBvWTgzcHNkcFdqY3J0Vml5eHVc6gCnRHqIEyBen6SnBk/PjhIn7H93sHMyUEbesJqB6NAzOHA4uVj+8aTfREQWxKaizkDTT1dnrBUZ7KPxz4KKzRXtZ6tEh48HKsA5xqWGLZRSlWtZWyvpz6F0a/VWYVhoBEmgNFevkE2Z8vCH16VEDBE1pZ6VEDBE1pZ6BDBE1pZ6VEDBE1DtlWGLnYviedc+kpilaFbFSaoJmFj76==\n\n{\"currency\":\"USD\",\"balance\":\"12.25\"}\n\n```\n\n#### Errors\n\n一个失败的请求会收到4XX类的http状态码表示已知错误内容（具体错误码API文档给出），5XX的状态码表示未知的错误类型：\n\n#### Attributes\n\n**_code_** _number_\n失败码类型，数字类型，用于快速定位错误类型\n\n**_message_** _string_\n失败描述\n\n**失败返回结果示例**\n\n    HTTP/1.1 400\n    status: 400\n    Date: Tue, 19 Nov 2019 02:26:38 GMT\n    Content-Type: application/json\n    Content-Length: 77\n    Connection: keep-alive\n\n    {\"code\":\"999995\",\"message\":\"[holderType] is invalid\"}\n\n### HTTP状态码一览表\n\n| CODE               | DESCRIPTION                |\n| ------------------ | -------------------------- |\n| 400                | 请求错误，例如：参数错误               |\n| 401                | 授权认证失败或者是签名认证失败            |\n| 403                | 请求未授权                      |\n| 404                | 资源未找到，这里的资源指的是实际的Objects对象 |\n| 500, 502, 503, 504 | 系统错误                       |\n\n# 请求幂等保证\n\n实际运行场景中，由于网络原因或者其他原因导致的网络中断是不可避免的，所以连连这边特意设计了请求幂等保证操作，所有的POST、PUT、DELETE请求都可以做幂等校验，幂等请求认证成功之后，会返回最初的请求结果（5XX未知异常类型的错误除外）。\n\n你需要在http头加入`Idempotency-Key`以便让系统失败你的幂等请求：\n\n    Idempotency-Key:&lt;&lt;unique id for client &gt;&gt;\n\n# Request IDs\n\n每个API请求都有一个关联的请求标识符。您可以响应头找到`Request-Id`下这个键值。\n\n# 字段命名规范\n\n连连所有的字段命名规范为驼峰式:\n\n    https://api...com/resource/?filterBy=\"filter\"\n\n    {\n      \"storeName\": \"My Store\",\n      \"kycStatus\": \"success\"\n    }\n\n# Webhook\n\n你可以配置webhook地址来接收连连这边的回调信息（`event`），具体的回调信息（`event`）在相应的接口中定义\n\n# 对象关系模型\n![对象关系模型](/images/关系模型.png)\n\n","slug":"project/open-api","published":1,"updated":"2020-04-17T02:52:48.129Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7li004ovgja9jpvha7s","content":"<p>#架构图</p>\n<h3 id=\"架构类\"><a href=\"#架构类\" class=\"headerlink\" title=\"架构类\"></a>架构类</h3><h4 id=\"框架上使用\"><a href=\"#框架上使用\" class=\"headerlink\" title=\"框架上使用\"></a>框架上使用</h4><p><code>spring</code>/<code>mybatis</code>/<code>undertow</code>  </p>\n<h4 id=\"服务治理使用\"><a href=\"#服务治理使用\" class=\"headerlink\" title=\"服务治理使用\"></a>服务治理使用</h4><p><code>dubbo</code>   </p>\n<h4 id=\"缓存服务使用\"><a href=\"#缓存服务使用\" class=\"headerlink\" title=\"缓存服务使用\"></a>缓存服务使用</h4><p><code>redis</code>（身份认证状态缓存，临时性字典数据缓存，提升效率）</p>\n<h4 id=\"MQ\"><a href=\"#MQ\" class=\"headerlink\" title=\"MQ\"></a>MQ</h4><p><code>RocketMQ</code>（mq做业务解耦，流量削峰，业务驱动，回调通知队列，消息持久化和定时任务补偿保证数据不被丢失）</p>\n<h4 id=\"分布式锁服务\"><a href=\"#分布式锁服务\" class=\"headerlink\" title=\"分布式锁服务\"></a>分布式锁服务</h4><p>zk</p>\n<h4 id=\"webhook通知服务\"><a href=\"#webhook通知服务\" class=\"headerlink\" title=\"webhook通知服务\"></a>webhook通知服务</h4><p>okhttp3、forkjoin框架、rocketMq队列、elasticJob补偿</p>\n<h4 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h4><p>nginx、lua、redis、mq</p>\n<h4 id=\"服务稳定性\"><a href=\"#服务稳定性\" class=\"headerlink\" title=\"服务稳定性\"></a>服务稳定性</h4><p>hystrix 熔断</p>\n<h4 id=\"模块划分\"><a href=\"#模块划分\" class=\"headerlink\" title=\"模块划分\"></a>模块划分</h4><pre><code>接口模块-----api\n    核心模块----core\n    管理端模块----manager\n    webhook回调通知模块----webhook --&gt; 订阅event --&gt; 消息letter生成 --&gt;入库 --&gt;生成待发送队列（两级队列：内存队列20w，rocketMQ消息队列；一个补偿任务elasticJob)--&gt;</code></pre><p><img src=\"/images/%E6%9E%B6%E6%9E%84.png\" alt=\"架构\"></p>\n<h1 id=\"Open-API-介绍\"><a href=\"#Open-API-介绍\" class=\"headerlink\" title=\"Open API 介绍\"></a>Open API 介绍</h1><p>OpenAPI 项目是基于REST标准来设计的，为保证统一和安全，全局编码格式为UTF-8，全局使用https。我们的API具有可预测的面向资源的url，返回json编码的响应，并使用标准的HTTP响应代码、身份验证和请求动词。</p>\n<p>为了数据准确性和生产环境数据安全，建议在沙盒环境测试这些接口.</p>\n<h1 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h1><p>当我们对API进行向后不兼容的更改时，我们会发布新版本。要使用的版本在URL中指定。当前版本是v1，比如:</p>\n<pre><code>https://api.itmarte.com/payments/v1/...</code></pre><h1 id=\"授权认证\"><a href=\"#授权认证\" class=\"headerlink\" title=\"授权认证\"></a>授权认证</h1><p>在不同的对接场景下Open API存在两种认证方式（用户开发者和第三方应用开发者，通常情况下申请用户开发者），使用http头<code>Authorization</code>做认证：<br><img src=\"/images/%E6%8E%88%E6%9D%83%E5%9B%BE.png\" alt=\"授权图\"></p>\n<h3 id=\"用户开发者模式\"><a href=\"#用户开发者模式\" class=\"headerlink\" title=\"用户开发者模式\"></a>用户开发者模式</h3><p>创建了用户开发者之后，会收到给您返回的<code>developerId</code>、<code>masterToken</code>（<code>masterToken</code>能行使用户所有权限，请您务必安全保管）和<code>LLP_RSA_PUB_KEY.pem</code>，身份认证格式如下:</p>\n<pre><code>Authorization: Basic &amp;lt;&amp;lt;Base64.encode(developerId:masterToken)&amp;gt;&amp;gt;</code></pre><h3 id=\"第三方应用开发者模式\"><a href=\"#第三方应用开发者模式\" class=\"headerlink\" title=\"第三方应用开发者模式\"></a>第三方应用开发者模式</h3><p>创建第三方应用开发者之后，会收到<code>clientId</code>、<code>clientSecret</code>和<code>LLP_RSA_PUB_KEY.pem</code>，至于<code>accessToken</code>则需要通过OAuth2.0模式向有资源的用户申请，身份认证格式如下:</p>\n<pre><code>Authorization: Bearer &amp;lt;&amp;lt;accessToken&amp;gt;&amp;gt;</code></pre><h1 id=\"请求安全\"><a href=\"#请求安全\" class=\"headerlink\" title=\"请求安全\"></a>请求安全</h1><p>为了请求安全防止重放攻击，要求所有请求都得有签名认证，在http头定义了<code>xxx-Signature</code>字段作为签名信息载体，<code>xxx-Signature</code>头文件中包含了请求包体和响应的epoch时间戳（是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数）例如：<code>xxx-Signature:t=&amp;lt;&amp;lt;epoch&amp;gt;&amp;gt;,v=&amp;lt;&amp;lt;signature&amp;gt;&amp;gt;</code>，一个请求的有效时间是5分钟。下面介绍下请求的签名格式：</p>\n<h3 id=\"请求签名\"><a href=\"#请求签名\" class=\"headerlink\" title=\"请求签名\"></a>请求签名</h3><ol start=\"2\">\n<li>对<code>HTTP请求方式</code>、<code>URI</code>、<code>请求epoch时间</code>（单位秒）、<code>请求包体</code>的数据按照一定顺序用字符串“&amp;”做拼接后使用对接方的<code>RSA私钥</code>通过<code>SHA256WithRSA</code>算法做签名并用<code>Base64编码</code>，生成的签名字符串（<code>signature</code>）和<code>epoch</code>时间放入HTTP包头的<code>xxx-Signature</code>标签中，格式为：</li>\n</ol>\n<!---->\n\n\n<pre><code>xxx-Signature:t=&amp;lt;&amp;lt;epoch&amp;gt;&amp;gt;,v=&amp;lt;&amp;lt;signature&amp;gt;&amp;gt;</code></pre><p><strong>第一步:</strong> 确定签名<code>payload</code></p>\n<p>如下字段请用<code>&amp;</code>一次连接</p>\n<ul>\n<li><p><code>HTTP_METHOD</code>: 对应实际接口的方法（统一用大写），如<code>POST</code>、<code>PUT</code>、<code>GET</code>、<code>DELETE</code>等；</p>\n</li>\n<li><p><code>URI</code>: 请求的URI地址（除去host）.  例如<code>https://api.sandbox.itmarte.com/collections/v1/merchants</code>中<code>/collections/v1/merchants</code>为URI</p>\n</li>\n<li><p><code>REQUEST_EPOCH</code>: 是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数,该值应与<code>t</code>值保持一致</p>\n</li>\n<li><p><code>REQUEST_PAYLOAD</code>: 请求包体  <code>{&quot;currency&quot;:&quot;USD&quot;}</code></p>\n</li>\n<li><p><code>QUERY_STRING</code>: 查询字段例如：<code>https://api.sandbox.itmarte.com/collections/v1/merchants?attr1=value1&amp;attr2=value2</code>,其中<code>QUERY_STRING</code>=<code>attr1=value1&amp;attr2=value2</code>格式化为<code>attr1%3Dvalue1%26attr2%3Dvalue2</code></p>\n<p><code>payload</code>示例:</p>\n<p>  POST&amp;/collections/v1/merchants&amp;19879234&amp;{“currency”:”USD”}&amp;attr1%3Dvalue1%26attr2%3Dvalue2</p>\n</li>\n</ul>\n<p><strong>第二部:</strong> 准备 <code>xxx-Signature</code> 签名头</p>\n<p>你会用到以下内容:</p>\n<ul>\n<li>REQUEST_EPOCH (Seconds elapsed since 1970/1/1 00:00:00 GMT as a string)</li>\n<li>连接字符串 <code>,</code></li>\n<li>payload（第一步的结果）</li>\n<li>your_rsa_pri_key：你的RSA私钥</li>\n</ul>\n<!---->\n\n<pre><code>xxx-Signature: t=REQUEST_EPOCH,v=BASE64_ENCODE(SHA256WithRSA.sign(&amp;lt;&amp;lt;payload&amp;gt;&amp;gt;, &amp;lt;&amp;lt;your_rsa_pri_key&amp;gt;&amp;gt;))</code></pre><p><strong>请求示例</strong></p>\n<pre><code>POST /api/mkt/balance HTTP/1.1 \nHost: api.itmarte.com \nContent-Type: application/json \nAuthorization: Basic WTgzcHNkcFdqY3J0Vml5eHVveTNyWGp2OWpzMjV3aUs6WTgzcHNkcFdqY3J0Vml5eHVveTNyWGp2OWpzMjV3aUs= \nxxx-Signature: t=1574130344,v=cJKgD/EpqNVnITR7yZ8BIev5j1E0ub0VbG4uGA69gR4T1FFc7NzqbiBoDEOBvkQtJXytQd7dY+WDo0Qm0c6gCnRHqIEyBen6SnBk/PjhIn7H93sHMyUEbesJqB6NAzOHA4uVj+8aTfREQWxKaizkDTT1dnrBUZ7KPxz4KKzRXtZ6tEh48HKsA5xqviedc+kpilaFbFSaoJmFj760TV8FB+mKCkZSrvX1Y+4x0bqTVBXAt2kE2Z8vCH16BDtlWGLZRSlWtZWyvpz6F0a/VWYVhoBEmgNFevnYDeAMGB6VEDBE1pZLMnhxfLfz6yu/p1pv1c2N2Yk5YSahQw4lLLiqQQ== \nAccept: */* \nCache-Control: no-cache \nContent-Length: 18 \nConnection: keep-alive \n\n{&quot;currency&quot;:&quot;USD&quot;} </code></pre><h3 id=\"请求结果签名验证\"><a href=\"#请求结果签名验证\" class=\"headerlink\" title=\"请求结果签名验证\"></a>请求结果签名验证</h3><ul>\n<li>若请求成功返回200，包体格式查看具体接口，对响应包体使用连连支付的RSA私钥用SHA256WithRSA做签名并用Base64编码，生成的签名字符串放入HTTP包头xxx-Signature标签中，格式为xxx-Signature: t = response_epoch, v = signature。<br>其中：</li>\n<li>t=响应时间戳(格林威治时间1970年01月01日00时00分00秒起至现在的总秒数)</li>\n<li>v=BASE64_ENCODE(SHA256WithRSA(RESPONSE_EPOCH&amp;RESPONSE_BODY, LLPAY_RSA_PRIVATE_KEY))</li>\n</ul>\n<p><strong>第一步:</strong> 确定 <code>payload</code></p>\n<p>如下字段创建<code>payload</code>用 <code>&amp;</code> 做连接</p>\n<ul>\n<li>Response Timestamp: 响应时间戳(格林威治时间1970年01月01日00时00分00秒起至现在的总秒数)</li>\n<li>Response Payload: 响应包体，指定为JSON字符串如： <code>{&quot;currency&quot;:&quot;USD&quot;}</code></li>\n</ul>\n<p><code>payload</code>示例:</p>\n<pre><code>19879234&amp;{&quot;currency&quot;:&quot;USD&quot;}</code></pre><p><strong>第二部:</strong> 使用连连的RSA公钥校验签名的有效性</p>\n<pre><code>SHA256WithRSA.verify(xxx-Signature, &apos;19879234&amp;{&quot; currency&quot;:&quot;USD&quot;}&apos;,  LLPAY_RSA_PRIVATE_KEY)</code></pre><h1 id=\"响应结果\"><a href=\"#响应结果\" class=\"headerlink\" title=\"响应结果\"></a>响应结果</h1><p><strong>成功返回结果示例</strong></p>\n<p>连连通过http状态码来判断请求的结果，一个成功的请求的http状态码为2XX，请求结果为相应的objects对象，例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP&#x2F;1.1 200 </span><br><span class=\"line\">status: 200 </span><br><span class=\"line\">Content-Type: application&#x2F;json </span><br><span class=\"line\">Content-Length: 61</span><br><span class=\"line\">Connection: keep-alive </span><br><span class=\"line\">xxx-Signature:t&#x3D;1574130398,v&#x3D;b0VbG4uGA69gR4T1FFc7NzqbiBoDEOBvkQtJXytQd7dY+WDo0QmgR4T1FFc7NzqbiBoDEOBvkQtJXytQpzMjV3aUs6R4T1FFc7NzqbiBoDEOBvWTgzcHNkcFdqY3J0Vml5eHVc6gCnRHqIEyBen6SnBk&#x2F;PjhIn7H93sHMyUEbesJqB6NAzOHA4uVj+8aTfREQWxKaizkDTT1dnrBUZ7KPxz4KKzRXtZ6tEh48HKsA5xqWGLZRSlWtZWyvpz6F0a&#x2F;VWYVhoBEmgNFevkE2Z8vCH16VEDBE1pZ6VEDBE1pZ6BDBE1pZ6VEDBE1DtlWGLnYviedc+kpilaFbFSaoJmFj76&#x3D;&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;currency&quot;:&quot;USD&quot;,&quot;balance&quot;:&quot;12.25&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Errors\"><a href=\"#Errors\" class=\"headerlink\" title=\"Errors\"></a>Errors</h4><p>一个失败的请求会收到4XX类的http状态码表示已知错误内容（具体错误码API文档给出），5XX的状态码表示未知的错误类型：</p>\n<h4 id=\"Attributes\"><a href=\"#Attributes\" class=\"headerlink\" title=\"Attributes\"></a>Attributes</h4><p><strong><em>code</em></strong> <em>number</em><br>失败码类型，数字类型，用于快速定位错误类型</p>\n<p><strong><em>message</em></strong> <em>string</em><br>失败描述</p>\n<p><strong>失败返回结果示例</strong></p>\n<pre><code>HTTP/1.1 400\nstatus: 400\nDate: Tue, 19 Nov 2019 02:26:38 GMT\nContent-Type: application/json\nContent-Length: 77\nConnection: keep-alive\n\n{&quot;code&quot;:&quot;999995&quot;,&quot;message&quot;:&quot;[holderType] is invalid&quot;}</code></pre><h3 id=\"HTTP状态码一览表\"><a href=\"#HTTP状态码一览表\" class=\"headerlink\" title=\"HTTP状态码一览表\"></a>HTTP状态码一览表</h3><table>\n<thead>\n<tr>\n<th>CODE</th>\n<th>DESCRIPTION</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>400</td>\n<td>请求错误，例如：参数错误</td>\n</tr>\n<tr>\n<td>401</td>\n<td>授权认证失败或者是签名认证失败</td>\n</tr>\n<tr>\n<td>403</td>\n<td>请求未授权</td>\n</tr>\n<tr>\n<td>404</td>\n<td>资源未找到，这里的资源指的是实际的Objects对象</td>\n</tr>\n<tr>\n<td>500, 502, 503, 504</td>\n<td>系统错误</td>\n</tr>\n</tbody></table>\n<h1 id=\"请求幂等保证\"><a href=\"#请求幂等保证\" class=\"headerlink\" title=\"请求幂等保证\"></a>请求幂等保证</h1><p>实际运行场景中，由于网络原因或者其他原因导致的网络中断是不可避免的，所以连连这边特意设计了请求幂等保证操作，所有的POST、PUT、DELETE请求都可以做幂等校验，幂等请求认证成功之后，会返回最初的请求结果（5XX未知异常类型的错误除外）。</p>\n<p>你需要在http头加入<code>Idempotency-Key</code>以便让系统失败你的幂等请求：</p>\n<pre><code>Idempotency-Key:&amp;lt;&amp;lt;unique id for client &amp;gt;&amp;gt;</code></pre><h1 id=\"Request-IDs\"><a href=\"#Request-IDs\" class=\"headerlink\" title=\"Request IDs\"></a>Request IDs</h1><p>每个API请求都有一个关联的请求标识符。您可以响应头找到<code>Request-Id</code>下这个键值。</p>\n<h1 id=\"字段命名规范\"><a href=\"#字段命名规范\" class=\"headerlink\" title=\"字段命名规范\"></a>字段命名规范</h1><p>连连所有的字段命名规范为驼峰式:</p>\n<pre><code>https://api...com/resource/?filterBy=&quot;filter&quot;\n\n{\n  &quot;storeName&quot;: &quot;My Store&quot;,\n  &quot;kycStatus&quot;: &quot;success&quot;\n}</code></pre><h1 id=\"Webhook\"><a href=\"#Webhook\" class=\"headerlink\" title=\"Webhook\"></a>Webhook</h1><p>你可以配置webhook地址来接收连连这边的回调信息（<code>event</code>），具体的回调信息（<code>event</code>）在相应的接口中定义</p>\n<h1 id=\"对象关系模型\"><a href=\"#对象关系模型\" class=\"headerlink\" title=\"对象关系模型\"></a>对象关系模型</h1><p><img src=\"/images/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B.png\" alt=\"对象关系模型\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>#架构图</p>\n<h3 id=\"架构类\"><a href=\"#架构类\" class=\"headerlink\" title=\"架构类\"></a>架构类</h3><h4 id=\"框架上使用\"><a href=\"#框架上使用\" class=\"headerlink\" title=\"框架上使用\"></a>框架上使用</h4><p><code>spring</code>/<code>mybatis</code>/<code>undertow</code>  </p>\n<h4 id=\"服务治理使用\"><a href=\"#服务治理使用\" class=\"headerlink\" title=\"服务治理使用\"></a>服务治理使用</h4><p><code>dubbo</code>   </p>\n<h4 id=\"缓存服务使用\"><a href=\"#缓存服务使用\" class=\"headerlink\" title=\"缓存服务使用\"></a>缓存服务使用</h4><p><code>redis</code>（身份认证状态缓存，临时性字典数据缓存，提升效率）</p>\n<h4 id=\"MQ\"><a href=\"#MQ\" class=\"headerlink\" title=\"MQ\"></a>MQ</h4><p><code>RocketMQ</code>（mq做业务解耦，流量削峰，业务驱动，回调通知队列，消息持久化和定时任务补偿保证数据不被丢失）</p>\n<h4 id=\"分布式锁服务\"><a href=\"#分布式锁服务\" class=\"headerlink\" title=\"分布式锁服务\"></a>分布式锁服务</h4><p>zk</p>\n<h4 id=\"webhook通知服务\"><a href=\"#webhook通知服务\" class=\"headerlink\" title=\"webhook通知服务\"></a>webhook通知服务</h4><p>okhttp3、forkjoin框架、rocketMq队列、elasticJob补偿</p>\n<h4 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h4><p>nginx、lua、redis、mq</p>\n<h4 id=\"服务稳定性\"><a href=\"#服务稳定性\" class=\"headerlink\" title=\"服务稳定性\"></a>服务稳定性</h4><p>hystrix 熔断</p>\n<h4 id=\"模块划分\"><a href=\"#模块划分\" class=\"headerlink\" title=\"模块划分\"></a>模块划分</h4><pre><code>接口模块-----api\n    核心模块----core\n    管理端模块----manager\n    webhook回调通知模块----webhook --&gt; 订阅event --&gt; 消息letter生成 --&gt;入库 --&gt;生成待发送队列（两级队列：内存队列20w，rocketMQ消息队列；一个补偿任务elasticJob)--&gt;</code></pre><p><img src=\"/images/%E6%9E%B6%E6%9E%84.png\" alt=\"架构\"></p>\n<h1 id=\"Open-API-介绍\"><a href=\"#Open-API-介绍\" class=\"headerlink\" title=\"Open API 介绍\"></a>Open API 介绍</h1><p>OpenAPI 项目是基于REST标准来设计的，为保证统一和安全，全局编码格式为UTF-8，全局使用https。我们的API具有可预测的面向资源的url，返回json编码的响应，并使用标准的HTTP响应代码、身份验证和请求动词。</p>\n<p>为了数据准确性和生产环境数据安全，建议在沙盒环境测试这些接口.</p>\n<h1 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h1><p>当我们对API进行向后不兼容的更改时，我们会发布新版本。要使用的版本在URL中指定。当前版本是v1，比如:</p>\n<pre><code>https://api.itmarte.com/payments/v1/...</code></pre><h1 id=\"授权认证\"><a href=\"#授权认证\" class=\"headerlink\" title=\"授权认证\"></a>授权认证</h1><p>在不同的对接场景下Open API存在两种认证方式（用户开发者和第三方应用开发者，通常情况下申请用户开发者），使用http头<code>Authorization</code>做认证：<br><img src=\"/images/%E6%8E%88%E6%9D%83%E5%9B%BE.png\" alt=\"授权图\"></p>\n<h3 id=\"用户开发者模式\"><a href=\"#用户开发者模式\" class=\"headerlink\" title=\"用户开发者模式\"></a>用户开发者模式</h3><p>创建了用户开发者之后，会收到给您返回的<code>developerId</code>、<code>masterToken</code>（<code>masterToken</code>能行使用户所有权限，请您务必安全保管）和<code>LLP_RSA_PUB_KEY.pem</code>，身份认证格式如下:</p>\n<pre><code>Authorization: Basic &amp;lt;&amp;lt;Base64.encode(developerId:masterToken)&amp;gt;&amp;gt;</code></pre><h3 id=\"第三方应用开发者模式\"><a href=\"#第三方应用开发者模式\" class=\"headerlink\" title=\"第三方应用开发者模式\"></a>第三方应用开发者模式</h3><p>创建第三方应用开发者之后，会收到<code>clientId</code>、<code>clientSecret</code>和<code>LLP_RSA_PUB_KEY.pem</code>，至于<code>accessToken</code>则需要通过OAuth2.0模式向有资源的用户申请，身份认证格式如下:</p>\n<pre><code>Authorization: Bearer &amp;lt;&amp;lt;accessToken&amp;gt;&amp;gt;</code></pre><h1 id=\"请求安全\"><a href=\"#请求安全\" class=\"headerlink\" title=\"请求安全\"></a>请求安全</h1><p>为了请求安全防止重放攻击，要求所有请求都得有签名认证，在http头定义了<code>xxx-Signature</code>字段作为签名信息载体，<code>xxx-Signature</code>头文件中包含了请求包体和响应的epoch时间戳（是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数）例如：<code>xxx-Signature:t=&amp;lt;&amp;lt;epoch&amp;gt;&amp;gt;,v=&amp;lt;&amp;lt;signature&amp;gt;&amp;gt;</code>，一个请求的有效时间是5分钟。下面介绍下请求的签名格式：</p>\n<h3 id=\"请求签名\"><a href=\"#请求签名\" class=\"headerlink\" title=\"请求签名\"></a>请求签名</h3><ol start=\"2\">\n<li>对<code>HTTP请求方式</code>、<code>URI</code>、<code>请求epoch时间</code>（单位秒）、<code>请求包体</code>的数据按照一定顺序用字符串“&amp;”做拼接后使用对接方的<code>RSA私钥</code>通过<code>SHA256WithRSA</code>算法做签名并用<code>Base64编码</code>，生成的签名字符串（<code>signature</code>）和<code>epoch</code>时间放入HTTP包头的<code>xxx-Signature</code>标签中，格式为：</li>\n</ol>\n<!---->\n\n\n<pre><code>xxx-Signature:t=&amp;lt;&amp;lt;epoch&amp;gt;&amp;gt;,v=&amp;lt;&amp;lt;signature&amp;gt;&amp;gt;</code></pre><p><strong>第一步:</strong> 确定签名<code>payload</code></p>\n<p>如下字段请用<code>&amp;</code>一次连接</p>\n<ul>\n<li><p><code>HTTP_METHOD</code>: 对应实际接口的方法（统一用大写），如<code>POST</code>、<code>PUT</code>、<code>GET</code>、<code>DELETE</code>等；</p>\n</li>\n<li><p><code>URI</code>: 请求的URI地址（除去host）.  例如<code>https://api.sandbox.itmarte.com/collections/v1/merchants</code>中<code>/collections/v1/merchants</code>为URI</p>\n</li>\n<li><p><code>REQUEST_EPOCH</code>: 是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数,该值应与<code>t</code>值保持一致</p>\n</li>\n<li><p><code>REQUEST_PAYLOAD</code>: 请求包体  <code>{&quot;currency&quot;:&quot;USD&quot;}</code></p>\n</li>\n<li><p><code>QUERY_STRING</code>: 查询字段例如：<code>https://api.sandbox.itmarte.com/collections/v1/merchants?attr1=value1&amp;attr2=value2</code>,其中<code>QUERY_STRING</code>=<code>attr1=value1&amp;attr2=value2</code>格式化为<code>attr1%3Dvalue1%26attr2%3Dvalue2</code></p>\n<p><code>payload</code>示例:</p>\n<p>  POST&amp;/collections/v1/merchants&amp;19879234&amp;{“currency”:”USD”}&amp;attr1%3Dvalue1%26attr2%3Dvalue2</p>\n</li>\n</ul>\n<p><strong>第二部:</strong> 准备 <code>xxx-Signature</code> 签名头</p>\n<p>你会用到以下内容:</p>\n<ul>\n<li>REQUEST_EPOCH (Seconds elapsed since 1970/1/1 00:00:00 GMT as a string)</li>\n<li>连接字符串 <code>,</code></li>\n<li>payload（第一步的结果）</li>\n<li>your_rsa_pri_key：你的RSA私钥</li>\n</ul>\n<!---->\n\n<pre><code>xxx-Signature: t=REQUEST_EPOCH,v=BASE64_ENCODE(SHA256WithRSA.sign(&amp;lt;&amp;lt;payload&amp;gt;&amp;gt;, &amp;lt;&amp;lt;your_rsa_pri_key&amp;gt;&amp;gt;))</code></pre><p><strong>请求示例</strong></p>\n<pre><code>POST /api/mkt/balance HTTP/1.1 \nHost: api.itmarte.com \nContent-Type: application/json \nAuthorization: Basic WTgzcHNkcFdqY3J0Vml5eHVveTNyWGp2OWpzMjV3aUs6WTgzcHNkcFdqY3J0Vml5eHVveTNyWGp2OWpzMjV3aUs= \nxxx-Signature: t=1574130344,v=cJKgD/EpqNVnITR7yZ8BIev5j1E0ub0VbG4uGA69gR4T1FFc7NzqbiBoDEOBvkQtJXytQd7dY+WDo0Qm0c6gCnRHqIEyBen6SnBk/PjhIn7H93sHMyUEbesJqB6NAzOHA4uVj+8aTfREQWxKaizkDTT1dnrBUZ7KPxz4KKzRXtZ6tEh48HKsA5xqviedc+kpilaFbFSaoJmFj760TV8FB+mKCkZSrvX1Y+4x0bqTVBXAt2kE2Z8vCH16BDtlWGLZRSlWtZWyvpz6F0a/VWYVhoBEmgNFevnYDeAMGB6VEDBE1pZLMnhxfLfz6yu/p1pv1c2N2Yk5YSahQw4lLLiqQQ== \nAccept: */* \nCache-Control: no-cache \nContent-Length: 18 \nConnection: keep-alive \n\n{&quot;currency&quot;:&quot;USD&quot;} </code></pre><h3 id=\"请求结果签名验证\"><a href=\"#请求结果签名验证\" class=\"headerlink\" title=\"请求结果签名验证\"></a>请求结果签名验证</h3><ul>\n<li>若请求成功返回200，包体格式查看具体接口，对响应包体使用连连支付的RSA私钥用SHA256WithRSA做签名并用Base64编码，生成的签名字符串放入HTTP包头xxx-Signature标签中，格式为xxx-Signature: t = response_epoch, v = signature。<br>其中：</li>\n<li>t=响应时间戳(格林威治时间1970年01月01日00时00分00秒起至现在的总秒数)</li>\n<li>v=BASE64_ENCODE(SHA256WithRSA(RESPONSE_EPOCH&amp;RESPONSE_BODY, LLPAY_RSA_PRIVATE_KEY))</li>\n</ul>\n<p><strong>第一步:</strong> 确定 <code>payload</code></p>\n<p>如下字段创建<code>payload</code>用 <code>&amp;</code> 做连接</p>\n<ul>\n<li>Response Timestamp: 响应时间戳(格林威治时间1970年01月01日00时00分00秒起至现在的总秒数)</li>\n<li>Response Payload: 响应包体，指定为JSON字符串如： <code>{&quot;currency&quot;:&quot;USD&quot;}</code></li>\n</ul>\n<p><code>payload</code>示例:</p>\n<pre><code>19879234&amp;{&quot;currency&quot;:&quot;USD&quot;}</code></pre><p><strong>第二部:</strong> 使用连连的RSA公钥校验签名的有效性</p>\n<pre><code>SHA256WithRSA.verify(xxx-Signature, &apos;19879234&amp;{&quot; currency&quot;:&quot;USD&quot;}&apos;,  LLPAY_RSA_PRIVATE_KEY)</code></pre><h1 id=\"响应结果\"><a href=\"#响应结果\" class=\"headerlink\" title=\"响应结果\"></a>响应结果</h1><p><strong>成功返回结果示例</strong></p>\n<p>连连通过http状态码来判断请求的结果，一个成功的请求的http状态码为2XX，请求结果为相应的objects对象，例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP&#x2F;1.1 200 </span><br><span class=\"line\">status: 200 </span><br><span class=\"line\">Content-Type: application&#x2F;json </span><br><span class=\"line\">Content-Length: 61</span><br><span class=\"line\">Connection: keep-alive </span><br><span class=\"line\">xxx-Signature:t&#x3D;1574130398,v&#x3D;b0VbG4uGA69gR4T1FFc7NzqbiBoDEOBvkQtJXytQd7dY+WDo0QmgR4T1FFc7NzqbiBoDEOBvkQtJXytQpzMjV3aUs6R4T1FFc7NzqbiBoDEOBvWTgzcHNkcFdqY3J0Vml5eHVc6gCnRHqIEyBen6SnBk&#x2F;PjhIn7H93sHMyUEbesJqB6NAzOHA4uVj+8aTfREQWxKaizkDTT1dnrBUZ7KPxz4KKzRXtZ6tEh48HKsA5xqWGLZRSlWtZWyvpz6F0a&#x2F;VWYVhoBEmgNFevkE2Z8vCH16VEDBE1pZ6VEDBE1pZ6BDBE1pZ6VEDBE1DtlWGLnYviedc+kpilaFbFSaoJmFj76&#x3D;&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;currency&quot;:&quot;USD&quot;,&quot;balance&quot;:&quot;12.25&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Errors\"><a href=\"#Errors\" class=\"headerlink\" title=\"Errors\"></a>Errors</h4><p>一个失败的请求会收到4XX类的http状态码表示已知错误内容（具体错误码API文档给出），5XX的状态码表示未知的错误类型：</p>\n<h4 id=\"Attributes\"><a href=\"#Attributes\" class=\"headerlink\" title=\"Attributes\"></a>Attributes</h4><p><strong><em>code</em></strong> <em>number</em><br>失败码类型，数字类型，用于快速定位错误类型</p>\n<p><strong><em>message</em></strong> <em>string</em><br>失败描述</p>\n<p><strong>失败返回结果示例</strong></p>\n<pre><code>HTTP/1.1 400\nstatus: 400\nDate: Tue, 19 Nov 2019 02:26:38 GMT\nContent-Type: application/json\nContent-Length: 77\nConnection: keep-alive\n\n{&quot;code&quot;:&quot;999995&quot;,&quot;message&quot;:&quot;[holderType] is invalid&quot;}</code></pre><h3 id=\"HTTP状态码一览表\"><a href=\"#HTTP状态码一览表\" class=\"headerlink\" title=\"HTTP状态码一览表\"></a>HTTP状态码一览表</h3><table>\n<thead>\n<tr>\n<th>CODE</th>\n<th>DESCRIPTION</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>400</td>\n<td>请求错误，例如：参数错误</td>\n</tr>\n<tr>\n<td>401</td>\n<td>授权认证失败或者是签名认证失败</td>\n</tr>\n<tr>\n<td>403</td>\n<td>请求未授权</td>\n</tr>\n<tr>\n<td>404</td>\n<td>资源未找到，这里的资源指的是实际的Objects对象</td>\n</tr>\n<tr>\n<td>500, 502, 503, 504</td>\n<td>系统错误</td>\n</tr>\n</tbody></table>\n<h1 id=\"请求幂等保证\"><a href=\"#请求幂等保证\" class=\"headerlink\" title=\"请求幂等保证\"></a>请求幂等保证</h1><p>实际运行场景中，由于网络原因或者其他原因导致的网络中断是不可避免的，所以连连这边特意设计了请求幂等保证操作，所有的POST、PUT、DELETE请求都可以做幂等校验，幂等请求认证成功之后，会返回最初的请求结果（5XX未知异常类型的错误除外）。</p>\n<p>你需要在http头加入<code>Idempotency-Key</code>以便让系统失败你的幂等请求：</p>\n<pre><code>Idempotency-Key:&amp;lt;&amp;lt;unique id for client &amp;gt;&amp;gt;</code></pre><h1 id=\"Request-IDs\"><a href=\"#Request-IDs\" class=\"headerlink\" title=\"Request IDs\"></a>Request IDs</h1><p>每个API请求都有一个关联的请求标识符。您可以响应头找到<code>Request-Id</code>下这个键值。</p>\n<h1 id=\"字段命名规范\"><a href=\"#字段命名规范\" class=\"headerlink\" title=\"字段命名规范\"></a>字段命名规范</h1><p>连连所有的字段命名规范为驼峰式:</p>\n<pre><code>https://api...com/resource/?filterBy=&quot;filter&quot;\n\n{\n  &quot;storeName&quot;: &quot;My Store&quot;,\n  &quot;kycStatus&quot;: &quot;success&quot;\n}</code></pre><h1 id=\"Webhook\"><a href=\"#Webhook\" class=\"headerlink\" title=\"Webhook\"></a>Webhook</h1><p>你可以配置webhook地址来接收连连这边的回调信息（<code>event</code>），具体的回调信息（<code>event</code>）在相应的接口中定义</p>\n<h1 id=\"对象关系模型\"><a href=\"#对象关系模型\" class=\"headerlink\" title=\"对象关系模型\"></a>对象关系模型</h1><p><img src=\"/images/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B.png\" alt=\"对象关系模型\"></p>\n"},{"title":"MySQL-InnoDB-MVCC多版本并发控制","date":"2020-07-02T13:15:46.000Z","_content":"\n### 前言\n\n最近正在啃《高性能MySQL》这本书, 当看到事务相关知识时,决定对该知识点稍微深入一下, 《高性能MySQL》中在介绍事务相关知识点时, 显然不是特别深入, 很多比较底层的知识点并没有太多的深入, 当然此处并不是要对本书做什么评判,言归正传, 这里主要先说一下本人在啃相关知识点时的曲折之路:\n\n1. 首先是事务相关ACID特性, 之前已经有相关笔记进行过介绍, 这里不再重复;\n2. 接下来是高并发事务相关的问题, 像是 `脏读`, `不可重复读`, `幻读`, `更新丢失`等问题之前也有相关笔记;\n3. 再下来就是MySQL应对高并发事务是如何给出解决方案的(其中包含各个隔离级别的简介);\n4. 然后就是各个隔离级别的具体介绍及与锁的关系, 也就是在这部分知识点, 发现了之前并没有过多关心的知识点 `MVCC多版本并发控制`, 然后一发不可收拾了...\n\n### 入题\n\n下面先引用一些前辈们比较优秀的文章:\n\n阿里数据库内核'2017/12'月报中对MVCC的解释是:\n**多版本控制**: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。\n\n<*高性能MySQL*>中对MVCC的部分介绍\n\n- MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。基于提升并发性能的考虑, 它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL, 包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC, 但各自的实现机制不尽相同, 因为MVCC没有一个统一的实现标准。\n\n- 可以认为MVCC是行级锁的一个变种, 但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。\n- MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。\n- MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。\n\n**从书中可以了解到:**\n\n- MVCC是被Mysql中 事务型存储引擎InnoDB 所支持的;\n- 应对高并发事务, MVCC比单纯的加锁更高效;\n- MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;\n- MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;\n- 各数据库中MVCC实现并不统一\n- 但是书中提到 \"InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的\"(网上也有很多此类观点), 但其实并不准确, 可以参考MySQL官方文档, 可以看到, InnoDB存储引擎在数据库每行数据的后面添加了三个字段, 不是两个!!\n\n### 相关概念\n\n1.`read view`, `快照snapshot`\n\n*淘宝数据库内核月报/2017/10/01/*\n此文虽然是以PostgreSQL进行的说明, 但并不影响理解, 在\"事务快照的实现\"该部分有细节需要注意:\n事务快照是用来存储数据库的事务运行情况。一个事务快照的创建过程可以概括为：\n查看当前所有的未提交并活跃的事务，存储在数组中\n选取未提交并活跃的事务中最小的XID，记录在快照的xmin中\n**选取所有已提交事务中最大的XID，加1后记录在xmax中**\n\n**注意**: *上文中在PostgreSQL中snapshot的概念, 对应MySQL中, 其实就是你在网上看到的read view,快照这些概念;*\n*比如何登成就有关于Read view的介绍;*\n*而 此文 却仍是使用快照来介绍;*\n\n2.`read view` 主要是用来做可见性判断的, 比较普遍的解释便是\"本事务不可见的当前其他活跃事务\", 但正是该解释, 可能会造成一节理解上的误区, 所以此处提供两个参考, 供给大家**避开理解误区**:\n\n```\nread view中的`高水位low_limit_id`可以参考 https://github.com/zhangyachen/zhangyachen.github.io/issues/68, https://www.zhihu.com/question/66320138其实上面第1点中加粗部分也是相关高水位的介绍( 注意进行了+1 )\n```\n\n\n3.另外, 对于read view快照的生成时机, 也非常关键, **正是因为生成时机的不同, 造成了RC,RR两种隔离级别的不同可见性;**\n\n- 在innodb中(默认repeatable read级别), 事务在begin/start transaction之后的第一条select读操作后, 会创建一个快照(read view), 将当前系统中活跃的其他事务记录记录起来;\n\n- 在innodb中(默认repeatable committed级别), 事务中每条select语句都会创建一个快照(read view);\n- 参考\n\n```\nWith REPEATABLE READ isolation level, the snapshot is based on the time when the first read operation is performed.\n 使用REPEATABLE READ隔离级别，快照是基于执行第一个读操作的时间。\nWith READ COMMITTED isolation level, the snapshot is reset to the time of each consistent read operation.\n使用READ COMMITTED隔离级别，快照被重置为每个一致的读取操作的时间。\n```\n\n\n4.undo-log\n\n- Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。\n  Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作（例如bug#69812）。\n  大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo\n  另外, 在回滚段中的undo logs分为: insert undo log 和 update undo log\n\n- insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。\n  update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。\n\n5.InnoDB存储引擎在数据库每行数据的后面添加了三个字段\n\n- 6字节的事务ID(DB_TRX_ID)字段: 用来标识最近一次对本行记录做修改(insert|update)的事务的标识符, 即最后一次修改(insert|update)本行记录的事务id。\n- 至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted, 并非真正删除。\n- 7字节的回滚指针(DB_ROLL_PTR)字段: 指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。\n- 如果一行记录被更新, 则 undo log record 包含 '重建该行记录被更新之前内容' 所必须的信息。\n- 6字节的DB_ROW_ID字段: 包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。\n- 结合聚簇索引的相关知识点, 我的理解是, 如果我们的表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 但聚簇索引会使用DB_ROW_ID的值来作为主键; 如果我们有自己的主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID 了 。\n- 关于聚簇索引, 《高性能MySQL》中的篇幅对我来说已经够用了, 稍后会整理一下以前的学习笔记, 然后更新上来。\n\n6.可见性比较算法（这里每个比较算法后面的描述是建立在rr级别下，rc级别也是使用该比较算法,此处未做描述）\n设要读取的行的最后提交事务id(即当前数据行的稳定事务id)为 trx_id_current\n当前新开事务id为 new_id\n当前新开事务创建的快照read view 中最早的事务id为up_limit_id, 最迟的事务id为low_limit_id(注意这个low_limit_id=未开启的事务id=当前最大事务id+1)\n比较:\n\n- 1.trx_id_current < up_limit_id, 这种情况比较好理解, 表示, 新事务在读取该行记录时, 该行记录的稳定事务ID是小于, 系统当前所有活跃的事务, 所以当前行稳定数据对新事务可见, 跳到步骤5.\n- 2.trx_id_current >= trx_id_last, 这种情况也比较好理解, 表示, 该行记录的稳定事务id是在本次新事务创建之后才开启的, 但是却在本次新事务执行第二个select前就commit了，所以该行记录的当前值不可见, 跳到步骤4。\n- 3.trx_id_current <= trx_id_current <= trx_id_last, 表示: 该行记录所在事务在本次新事务创建的时候处于活动状态，从up_limit_id到low_limit_id进行遍历，如果trx_id_current等于他们之中的某个事务id的话，那么不可见, 调到步骤4,否则表示可见。\n- 4.从该行记录的 DB_ROLL_PTR 指针所指向的回滚段中取出最新的undo-log的版本号, 将它赋值该 trx_id_current，然后跳到步骤1重新开始判断。\n- 5.将该可见行的值返回。\n\n### 案例分析\n\n下面是一个非常简版的演示事务对某行记录的更新过程, 当然, InnoDB引擎在内部要做的工作非常多:\n\n![clipboard.png](/images/bV1IKzdae.png)\n\n下面是一套比较算法的应用过程, 比较长\n\n![preview](/images/uasyderdi.png)\n\n### 当前读和快照读\n\n1.MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读), 是通过 \"行排他锁+MVCC\" 一起实现的, 不仅可以保证可重复读, 还可以部分防止幻读, 而非完全防止;\n\n2.为什么是部分防止幻读, 而不是完全防止?\n\n- 效果: 在如果事务B在事务A执行中, insert了一条数据并提交, 事务A再次查询, 虽然读取的是undo中的旧版本数据(防止了部分幻读), 但是事务A中执行update或者delete都是可以成功的!!\n\n- 因为在innodb中的操作可以分为当前读(current read)和快照读(snapshot read):\n\n3.快照读(snapshot read)\n\n```\n简单的select操作(当然不包括 select ... lock in share mode, select ... for update)\n```\n\n\n4.当前读(current read) 官网文档 Locking Reads\n\n- select ... lock in share mode\n\n- select ... for update\n- insert\n- update\n- delete\n\n在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。\ninnodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读!!!\n\n### 小结\n![MVCC多版本并发控制](/images/MVCC多版本并发控制.png)\n1. 一般我们认为MVCC有下面几个特点：\n\n- 每行数据都存在一个版本，每次数据更新时都更新该版本\n\n- 修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰\n- 保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)\n- 就是每行都有版本号，保存时根据版本号决定是否成功，**听起来含有乐观锁的味道, 因为这看起来正是，在提交的时候才能知道到底能否提交成功**\n\n2. 而InnoDB实现MVCC的方式是:\n\n- 事务以排他锁的形式修改原始数据\n- 把修改前的数据存放于undo log，通过回滚指针与主数据关联\n- 修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）\n\n3. **二者最本质的区别是**: 当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？\n\n\n\n- Innodb的实现真算不上MVCC, 因为并没有实现核心的多版本共存, undo log 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的MVCC是难以实现的, 当事务仅修改一行记录使用理想的MVCC模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。\n- 比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败, 此时需要回滚Row1, 但因为Row1没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。 这也正是所谓的 第一类更新丢失 的情况。\n- 也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。","source":"_posts/sql/MySQL-InnoDB-MVCC多版本并发控制.md","raw":"---\ntitle: MySQL-InnoDB-MVCC多版本并发控制\ntags:\n  - 数据库\n  - MySql\n  - MVCC多版本并发控制\ncategories:\n  - 数据库\n  - MySql\n  - MVCC多版本并发控制\ndate: 2020-07-02 21:15:46\n---\n\n### 前言\n\n最近正在啃《高性能MySQL》这本书, 当看到事务相关知识时,决定对该知识点稍微深入一下, 《高性能MySQL》中在介绍事务相关知识点时, 显然不是特别深入, 很多比较底层的知识点并没有太多的深入, 当然此处并不是要对本书做什么评判,言归正传, 这里主要先说一下本人在啃相关知识点时的曲折之路:\n\n1. 首先是事务相关ACID特性, 之前已经有相关笔记进行过介绍, 这里不再重复;\n2. 接下来是高并发事务相关的问题, 像是 `脏读`, `不可重复读`, `幻读`, `更新丢失`等问题之前也有相关笔记;\n3. 再下来就是MySQL应对高并发事务是如何给出解决方案的(其中包含各个隔离级别的简介);\n4. 然后就是各个隔离级别的具体介绍及与锁的关系, 也就是在这部分知识点, 发现了之前并没有过多关心的知识点 `MVCC多版本并发控制`, 然后一发不可收拾了...\n\n### 入题\n\n下面先引用一些前辈们比较优秀的文章:\n\n阿里数据库内核'2017/12'月报中对MVCC的解释是:\n**多版本控制**: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。\n\n<*高性能MySQL*>中对MVCC的部分介绍\n\n- MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。基于提升并发性能的考虑, 它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL, 包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC, 但各自的实现机制不尽相同, 因为MVCC没有一个统一的实现标准。\n\n- 可以认为MVCC是行级锁的一个变种, 但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。\n- MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。\n- MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。\n\n**从书中可以了解到:**\n\n- MVCC是被Mysql中 事务型存储引擎InnoDB 所支持的;\n- 应对高并发事务, MVCC比单纯的加锁更高效;\n- MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;\n- MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;\n- 各数据库中MVCC实现并不统一\n- 但是书中提到 \"InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的\"(网上也有很多此类观点), 但其实并不准确, 可以参考MySQL官方文档, 可以看到, InnoDB存储引擎在数据库每行数据的后面添加了三个字段, 不是两个!!\n\n### 相关概念\n\n1.`read view`, `快照snapshot`\n\n*淘宝数据库内核月报/2017/10/01/*\n此文虽然是以PostgreSQL进行的说明, 但并不影响理解, 在\"事务快照的实现\"该部分有细节需要注意:\n事务快照是用来存储数据库的事务运行情况。一个事务快照的创建过程可以概括为：\n查看当前所有的未提交并活跃的事务，存储在数组中\n选取未提交并活跃的事务中最小的XID，记录在快照的xmin中\n**选取所有已提交事务中最大的XID，加1后记录在xmax中**\n\n**注意**: *上文中在PostgreSQL中snapshot的概念, 对应MySQL中, 其实就是你在网上看到的read view,快照这些概念;*\n*比如何登成就有关于Read view的介绍;*\n*而 此文 却仍是使用快照来介绍;*\n\n2.`read view` 主要是用来做可见性判断的, 比较普遍的解释便是\"本事务不可见的当前其他活跃事务\", 但正是该解释, 可能会造成一节理解上的误区, 所以此处提供两个参考, 供给大家**避开理解误区**:\n\n```\nread view中的`高水位low_limit_id`可以参考 https://github.com/zhangyachen/zhangyachen.github.io/issues/68, https://www.zhihu.com/question/66320138其实上面第1点中加粗部分也是相关高水位的介绍( 注意进行了+1 )\n```\n\n\n3.另外, 对于read view快照的生成时机, 也非常关键, **正是因为生成时机的不同, 造成了RC,RR两种隔离级别的不同可见性;**\n\n- 在innodb中(默认repeatable read级别), 事务在begin/start transaction之后的第一条select读操作后, 会创建一个快照(read view), 将当前系统中活跃的其他事务记录记录起来;\n\n- 在innodb中(默认repeatable committed级别), 事务中每条select语句都会创建一个快照(read view);\n- 参考\n\n```\nWith REPEATABLE READ isolation level, the snapshot is based on the time when the first read operation is performed.\n 使用REPEATABLE READ隔离级别，快照是基于执行第一个读操作的时间。\nWith READ COMMITTED isolation level, the snapshot is reset to the time of each consistent read operation.\n使用READ COMMITTED隔离级别，快照被重置为每个一致的读取操作的时间。\n```\n\n\n4.undo-log\n\n- Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。\n  Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作（例如bug#69812）。\n  大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo\n  另外, 在回滚段中的undo logs分为: insert undo log 和 update undo log\n\n- insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。\n  update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。\n\n5.InnoDB存储引擎在数据库每行数据的后面添加了三个字段\n\n- 6字节的事务ID(DB_TRX_ID)字段: 用来标识最近一次对本行记录做修改(insert|update)的事务的标识符, 即最后一次修改(insert|update)本行记录的事务id。\n- 至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted, 并非真正删除。\n- 7字节的回滚指针(DB_ROLL_PTR)字段: 指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。\n- 如果一行记录被更新, 则 undo log record 包含 '重建该行记录被更新之前内容' 所必须的信息。\n- 6字节的DB_ROW_ID字段: 包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。\n- 结合聚簇索引的相关知识点, 我的理解是, 如果我们的表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 但聚簇索引会使用DB_ROW_ID的值来作为主键; 如果我们有自己的主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID 了 。\n- 关于聚簇索引, 《高性能MySQL》中的篇幅对我来说已经够用了, 稍后会整理一下以前的学习笔记, 然后更新上来。\n\n6.可见性比较算法（这里每个比较算法后面的描述是建立在rr级别下，rc级别也是使用该比较算法,此处未做描述）\n设要读取的行的最后提交事务id(即当前数据行的稳定事务id)为 trx_id_current\n当前新开事务id为 new_id\n当前新开事务创建的快照read view 中最早的事务id为up_limit_id, 最迟的事务id为low_limit_id(注意这个low_limit_id=未开启的事务id=当前最大事务id+1)\n比较:\n\n- 1.trx_id_current < up_limit_id, 这种情况比较好理解, 表示, 新事务在读取该行记录时, 该行记录的稳定事务ID是小于, 系统当前所有活跃的事务, 所以当前行稳定数据对新事务可见, 跳到步骤5.\n- 2.trx_id_current >= trx_id_last, 这种情况也比较好理解, 表示, 该行记录的稳定事务id是在本次新事务创建之后才开启的, 但是却在本次新事务执行第二个select前就commit了，所以该行记录的当前值不可见, 跳到步骤4。\n- 3.trx_id_current <= trx_id_current <= trx_id_last, 表示: 该行记录所在事务在本次新事务创建的时候处于活动状态，从up_limit_id到low_limit_id进行遍历，如果trx_id_current等于他们之中的某个事务id的话，那么不可见, 调到步骤4,否则表示可见。\n- 4.从该行记录的 DB_ROLL_PTR 指针所指向的回滚段中取出最新的undo-log的版本号, 将它赋值该 trx_id_current，然后跳到步骤1重新开始判断。\n- 5.将该可见行的值返回。\n\n### 案例分析\n\n下面是一个非常简版的演示事务对某行记录的更新过程, 当然, InnoDB引擎在内部要做的工作非常多:\n\n![clipboard.png](/images/bV1IKzdae.png)\n\n下面是一套比较算法的应用过程, 比较长\n\n![preview](/images/uasyderdi.png)\n\n### 当前读和快照读\n\n1.MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读), 是通过 \"行排他锁+MVCC\" 一起实现的, 不仅可以保证可重复读, 还可以部分防止幻读, 而非完全防止;\n\n2.为什么是部分防止幻读, 而不是完全防止?\n\n- 效果: 在如果事务B在事务A执行中, insert了一条数据并提交, 事务A再次查询, 虽然读取的是undo中的旧版本数据(防止了部分幻读), 但是事务A中执行update或者delete都是可以成功的!!\n\n- 因为在innodb中的操作可以分为当前读(current read)和快照读(snapshot read):\n\n3.快照读(snapshot read)\n\n```\n简单的select操作(当然不包括 select ... lock in share mode, select ... for update)\n```\n\n\n4.当前读(current read) 官网文档 Locking Reads\n\n- select ... lock in share mode\n\n- select ... for update\n- insert\n- update\n- delete\n\n在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。\ninnodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读!!!\n\n### 小结\n![MVCC多版本并发控制](/images/MVCC多版本并发控制.png)\n1. 一般我们认为MVCC有下面几个特点：\n\n- 每行数据都存在一个版本，每次数据更新时都更新该版本\n\n- 修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰\n- 保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)\n- 就是每行都有版本号，保存时根据版本号决定是否成功，**听起来含有乐观锁的味道, 因为这看起来正是，在提交的时候才能知道到底能否提交成功**\n\n2. 而InnoDB实现MVCC的方式是:\n\n- 事务以排他锁的形式修改原始数据\n- 把修改前的数据存放于undo log，通过回滚指针与主数据关联\n- 修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）\n\n3. **二者最本质的区别是**: 当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？\n\n\n\n- Innodb的实现真算不上MVCC, 因为并没有实现核心的多版本共存, undo log 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的MVCC是难以实现的, 当事务仅修改一行记录使用理想的MVCC模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。\n- 比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败, 此时需要回滚Row1, 但因为Row1没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。 这也正是所谓的 第一类更新丢失 的情况。\n- 也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。","slug":"sql/MySQL-InnoDB-MVCC多版本并发控制","published":1,"updated":"2020-07-07T02:02:26.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7lj004pvgjacuwm20a3","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近正在啃《高性能MySQL》这本书, 当看到事务相关知识时,决定对该知识点稍微深入一下, 《高性能MySQL》中在介绍事务相关知识点时, 显然不是特别深入, 很多比较底层的知识点并没有太多的深入, 当然此处并不是要对本书做什么评判,言归正传, 这里主要先说一下本人在啃相关知识点时的曲折之路:</p>\n<ol>\n<li>首先是事务相关ACID特性, 之前已经有相关笔记进行过介绍, 这里不再重复;</li>\n<li>接下来是高并发事务相关的问题, 像是 <code>脏读</code>, <code>不可重复读</code>, <code>幻读</code>, <code>更新丢失</code>等问题之前也有相关笔记;</li>\n<li>再下来就是MySQL应对高并发事务是如何给出解决方案的(其中包含各个隔离级别的简介);</li>\n<li>然后就是各个隔离级别的具体介绍及与锁的关系, 也就是在这部分知识点, 发现了之前并没有过多关心的知识点 <code>MVCC多版本并发控制</code>, 然后一发不可收拾了…</li>\n</ol>\n<h3 id=\"入题\"><a href=\"#入题\" class=\"headerlink\" title=\"入题\"></a>入题</h3><p>下面先引用一些前辈们比较优秀的文章:</p>\n<p>阿里数据库内核’2017/12’月报中对MVCC的解释是:<br><strong>多版本控制</strong>: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p>\n<p>&lt;<em>高性能MySQL</em>&gt;中对MVCC的部分介绍</p>\n<ul>\n<li><p>MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。基于提升并发性能的考虑, 它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL, 包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC, 但各自的实现机制不尽相同, 因为MVCC没有一个统一的实现标准。</p>\n</li>\n<li><p>可以认为MVCC是行级锁的一个变种, 但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p>\n</li>\n<li><p>MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。</p>\n</li>\n<li><p>MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。</p>\n</li>\n</ul>\n<p><strong>从书中可以了解到:</strong></p>\n<ul>\n<li>MVCC是被Mysql中 事务型存储引擎InnoDB 所支持的;</li>\n<li>应对高并发事务, MVCC比单纯的加锁更高效;</li>\n<li>MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;</li>\n<li>MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;</li>\n<li>各数据库中MVCC实现并不统一</li>\n<li>但是书中提到 “InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的”(网上也有很多此类观点), 但其实并不准确, 可以参考MySQL官方文档, 可以看到, InnoDB存储引擎在数据库每行数据的后面添加了三个字段, 不是两个!!</li>\n</ul>\n<h3 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h3><p>1.<code>read view</code>, <code>快照snapshot</code></p>\n<p><em>淘宝数据库内核月报/2017/10/01/</em><br>此文虽然是以PostgreSQL进行的说明, 但并不影响理解, 在”事务快照的实现”该部分有细节需要注意:<br>事务快照是用来存储数据库的事务运行情况。一个事务快照的创建过程可以概括为：<br>查看当前所有的未提交并活跃的事务，存储在数组中<br>选取未提交并活跃的事务中最小的XID，记录在快照的xmin中<br><strong>选取所有已提交事务中最大的XID，加1后记录在xmax中</strong></p>\n<p><strong>注意</strong>: <em>上文中在PostgreSQL中snapshot的概念, 对应MySQL中, 其实就是你在网上看到的read view,快照这些概念;</em><br><em>比如何登成就有关于Read view的介绍;</em><br><em>而 此文 却仍是使用快照来介绍;</em></p>\n<p>2.<code>read view</code> 主要是用来做可见性判断的, 比较普遍的解释便是”本事务不可见的当前其他活跃事务”, 但正是该解释, 可能会造成一节理解上的误区, 所以此处提供两个参考, 供给大家<strong>避开理解误区</strong>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read view中的&#96;高水位low_limit_id&#96;可以参考 https:&#x2F;&#x2F;github.com&#x2F;zhangyachen&#x2F;zhangyachen.github.io&#x2F;issues&#x2F;68, https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;66320138其实上面第1点中加粗部分也是相关高水位的介绍( 注意进行了+1 )</span><br></pre></td></tr></table></figure>\n\n\n<p>3.另外, 对于read view快照的生成时机, 也非常关键, <strong>正是因为生成时机的不同, 造成了RC,RR两种隔离级别的不同可见性;</strong></p>\n<ul>\n<li><p>在innodb中(默认repeatable read级别), 事务在begin/start transaction之后的第一条select读操作后, 会创建一个快照(read view), 将当前系统中活跃的其他事务记录记录起来;</p>\n</li>\n<li><p>在innodb中(默认repeatable committed级别), 事务中每条select语句都会创建一个快照(read view);</p>\n</li>\n<li><p>参考</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">With REPEATABLE READ isolation level, the snapshot is based on the time when the first read operation is performed.</span><br><span class=\"line\"> 使用REPEATABLE READ隔离级别，快照是基于执行第一个读操作的时间。</span><br><span class=\"line\">With READ COMMITTED isolation level, the snapshot is reset to the time of each consistent read operation.</span><br><span class=\"line\">使用READ COMMITTED隔离级别，快照被重置为每个一致的读取操作的时间。</span><br></pre></td></tr></table></figure>\n\n\n<p>4.undo-log</p>\n<ul>\n<li><p>Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。<br>Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作（例如bug#69812）。<br>大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo<br>另外, 在回滚段中的undo logs分为: insert undo log 和 update undo log</p>\n</li>\n<li><p>insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。<br>update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。</p>\n</li>\n</ul>\n<p>5.InnoDB存储引擎在数据库每行数据的后面添加了三个字段</p>\n<ul>\n<li>6字节的事务ID(DB_TRX_ID)字段: 用来标识最近一次对本行记录做修改(insert|update)的事务的标识符, 即最后一次修改(insert|update)本行记录的事务id。</li>\n<li>至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted, 并非真正删除。</li>\n<li>7字节的回滚指针(DB_ROLL_PTR)字段: 指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。</li>\n<li>如果一行记录被更新, 则 undo log record 包含 ‘重建该行记录被更新之前内容’ 所必须的信息。</li>\n<li>6字节的DB_ROW_ID字段: 包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。</li>\n<li>结合聚簇索引的相关知识点, 我的理解是, 如果我们的表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 但聚簇索引会使用DB_ROW_ID的值来作为主键; 如果我们有自己的主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID 了 。</li>\n<li>关于聚簇索引, 《高性能MySQL》中的篇幅对我来说已经够用了, 稍后会整理一下以前的学习笔记, 然后更新上来。</li>\n</ul>\n<p>6.可见性比较算法（这里每个比较算法后面的描述是建立在rr级别下，rc级别也是使用该比较算法,此处未做描述）<br>设要读取的行的最后提交事务id(即当前数据行的稳定事务id)为 trx_id_current<br>当前新开事务id为 new_id<br>当前新开事务创建的快照read view 中最早的事务id为up_limit_id, 最迟的事务id为low_limit_id(注意这个low_limit_id=未开启的事务id=当前最大事务id+1)<br>比较:</p>\n<ul>\n<li>1.trx_id_current &lt; up_limit_id, 这种情况比较好理解, 表示, 新事务在读取该行记录时, 该行记录的稳定事务ID是小于, 系统当前所有活跃的事务, 所以当前行稳定数据对新事务可见, 跳到步骤5.</li>\n<li>2.trx_id_current &gt;= trx_id_last, 这种情况也比较好理解, 表示, 该行记录的稳定事务id是在本次新事务创建之后才开启的, 但是却在本次新事务执行第二个select前就commit了，所以该行记录的当前值不可见, 跳到步骤4。</li>\n<li>3.trx_id_current &lt;= trx_id_current &lt;= trx_id_last, 表示: 该行记录所在事务在本次新事务创建的时候处于活动状态，从up_limit_id到low_limit_id进行遍历，如果trx_id_current等于他们之中的某个事务id的话，那么不可见, 调到步骤4,否则表示可见。</li>\n<li>4.从该行记录的 DB_ROLL_PTR 指针所指向的回滚段中取出最新的undo-log的版本号, 将它赋值该 trx_id_current，然后跳到步骤1重新开始判断。</li>\n<li>5.将该可见行的值返回。</li>\n</ul>\n<h3 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h3><p>下面是一个非常简版的演示事务对某行记录的更新过程, 当然, InnoDB引擎在内部要做的工作非常多:</p>\n<p><img src=\"/images/bV1IKzdae.png\" alt=\"clipboard.png\"></p>\n<p>下面是一套比较算法的应用过程, 比较长</p>\n<p><img src=\"/images/uasyderdi.png\" alt=\"preview\"></p>\n<h3 id=\"当前读和快照读\"><a href=\"#当前读和快照读\" class=\"headerlink\" title=\"当前读和快照读\"></a>当前读和快照读</h3><p>1.MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读), 是通过 “行排他锁+MVCC” 一起实现的, 不仅可以保证可重复读, 还可以部分防止幻读, 而非完全防止;</p>\n<p>2.为什么是部分防止幻读, 而不是完全防止?</p>\n<ul>\n<li><p>效果: 在如果事务B在事务A执行中, insert了一条数据并提交, 事务A再次查询, 虽然读取的是undo中的旧版本数据(防止了部分幻读), 但是事务A中执行update或者delete都是可以成功的!!</p>\n</li>\n<li><p>因为在innodb中的操作可以分为当前读(current read)和快照读(snapshot read):</p>\n</li>\n</ul>\n<p>3.快照读(snapshot read)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单的select操作(当然不包括 select ... lock in share mode, select ... for update)</span><br></pre></td></tr></table></figure>\n\n\n<p>4.当前读(current read) 官网文档 Locking Reads</p>\n<ul>\n<li><p>select … lock in share mode</p>\n</li>\n<li><p>select … for update</p>\n</li>\n<li><p>insert</p>\n</li>\n<li><p>update</p>\n</li>\n<li><p>delete</p>\n</li>\n</ul>\n<p>在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。<br>innodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读!!!</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p><img src=\"/images/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6.png\" alt=\"MVCC多版本并发控制\"></p>\n<ol>\n<li>一般我们认为MVCC有下面几个特点：</li>\n</ol>\n<ul>\n<li><p>每行数据都存在一个版本，每次数据更新时都更新该版本</p>\n</li>\n<li><p>修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰</p>\n</li>\n<li><p>保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)</p>\n</li>\n<li><p>就是每行都有版本号，保存时根据版本号决定是否成功，<strong>听起来含有乐观锁的味道, 因为这看起来正是，在提交的时候才能知道到底能否提交成功</strong></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>而InnoDB实现MVCC的方式是:</li>\n</ol>\n<ul>\n<li>事务以排他锁的形式修改原始数据</li>\n<li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li>\n<li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li>\n</ul>\n<ol start=\"3\">\n<li><strong>二者最本质的区别是</strong>: 当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？</li>\n</ol>\n<ul>\n<li>Innodb的实现真算不上MVCC, 因为并没有实现核心的多版本共存, undo log 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的MVCC是难以实现的, 当事务仅修改一行记录使用理想的MVCC模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。</li>\n<li>比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败, 此时需要回滚Row1, 但因为Row1没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。 这也正是所谓的 第一类更新丢失 的情况。</li>\n<li>也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>最近正在啃《高性能MySQL》这本书, 当看到事务相关知识时,决定对该知识点稍微深入一下, 《高性能MySQL》中在介绍事务相关知识点时, 显然不是特别深入, 很多比较底层的知识点并没有太多的深入, 当然此处并不是要对本书做什么评判,言归正传, 这里主要先说一下本人在啃相关知识点时的曲折之路:</p>\n<ol>\n<li>首先是事务相关ACID特性, 之前已经有相关笔记进行过介绍, 这里不再重复;</li>\n<li>接下来是高并发事务相关的问题, 像是 <code>脏读</code>, <code>不可重复读</code>, <code>幻读</code>, <code>更新丢失</code>等问题之前也有相关笔记;</li>\n<li>再下来就是MySQL应对高并发事务是如何给出解决方案的(其中包含各个隔离级别的简介);</li>\n<li>然后就是各个隔离级别的具体介绍及与锁的关系, 也就是在这部分知识点, 发现了之前并没有过多关心的知识点 <code>MVCC多版本并发控制</code>, 然后一发不可收拾了…</li>\n</ol>\n<h3 id=\"入题\"><a href=\"#入题\" class=\"headerlink\" title=\"入题\"></a>入题</h3><p>下面先引用一些前辈们比较优秀的文章:</p>\n<p>阿里数据库内核’2017/12’月报中对MVCC的解释是:<br><strong>多版本控制</strong>: 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p>\n<p>&lt;<em>高性能MySQL</em>&gt;中对MVCC的部分介绍</p>\n<ul>\n<li><p>MySQL的大多数事务型存储引擎实现的其实都不是简单的行级锁。基于提升并发性能的考虑, 它们一般都同时实现了多版本并发控制(MVCC)。不仅是MySQL, 包括Oracle,PostgreSQL等其他数据库系统也都实现了MVCC, 但各自的实现机制不尽相同, 因为MVCC没有一个统一的实现标准。</p>\n</li>\n<li><p>可以认为MVCC是行级锁的一个变种, 但是它在很多情况下避免了加锁操作, 因此开销更低。虽然实现机制有所不同, 但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p>\n</li>\n<li><p>MVCC的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。</p>\n</li>\n<li><p>MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。</p>\n</li>\n</ul>\n<p><strong>从书中可以了解到:</strong></p>\n<ul>\n<li>MVCC是被Mysql中 事务型存储引擎InnoDB 所支持的;</li>\n<li>应对高并发事务, MVCC比单纯的加锁更高效;</li>\n<li>MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;</li>\n<li>MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;</li>\n<li>各数据库中MVCC实现并不统一</li>\n<li>但是书中提到 “InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的”(网上也有很多此类观点), 但其实并不准确, 可以参考MySQL官方文档, 可以看到, InnoDB存储引擎在数据库每行数据的后面添加了三个字段, 不是两个!!</li>\n</ul>\n<h3 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h3><p>1.<code>read view</code>, <code>快照snapshot</code></p>\n<p><em>淘宝数据库内核月报/2017/10/01/</em><br>此文虽然是以PostgreSQL进行的说明, 但并不影响理解, 在”事务快照的实现”该部分有细节需要注意:<br>事务快照是用来存储数据库的事务运行情况。一个事务快照的创建过程可以概括为：<br>查看当前所有的未提交并活跃的事务，存储在数组中<br>选取未提交并活跃的事务中最小的XID，记录在快照的xmin中<br><strong>选取所有已提交事务中最大的XID，加1后记录在xmax中</strong></p>\n<p><strong>注意</strong>: <em>上文中在PostgreSQL中snapshot的概念, 对应MySQL中, 其实就是你在网上看到的read view,快照这些概念;</em><br><em>比如何登成就有关于Read view的介绍;</em><br><em>而 此文 却仍是使用快照来介绍;</em></p>\n<p>2.<code>read view</code> 主要是用来做可见性判断的, 比较普遍的解释便是”本事务不可见的当前其他活跃事务”, 但正是该解释, 可能会造成一节理解上的误区, 所以此处提供两个参考, 供给大家<strong>避开理解误区</strong>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read view中的&#96;高水位low_limit_id&#96;可以参考 https:&#x2F;&#x2F;github.com&#x2F;zhangyachen&#x2F;zhangyachen.github.io&#x2F;issues&#x2F;68, https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;66320138其实上面第1点中加粗部分也是相关高水位的介绍( 注意进行了+1 )</span><br></pre></td></tr></table></figure>\n\n\n<p>3.另外, 对于read view快照的生成时机, 也非常关键, <strong>正是因为生成时机的不同, 造成了RC,RR两种隔离级别的不同可见性;</strong></p>\n<ul>\n<li><p>在innodb中(默认repeatable read级别), 事务在begin/start transaction之后的第一条select读操作后, 会创建一个快照(read view), 将当前系统中活跃的其他事务记录记录起来;</p>\n</li>\n<li><p>在innodb中(默认repeatable committed级别), 事务中每条select语句都会创建一个快照(read view);</p>\n</li>\n<li><p>参考</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">With REPEATABLE READ isolation level, the snapshot is based on the time when the first read operation is performed.</span><br><span class=\"line\"> 使用REPEATABLE READ隔离级别，快照是基于执行第一个读操作的时间。</span><br><span class=\"line\">With READ COMMITTED isolation level, the snapshot is reset to the time of each consistent read operation.</span><br><span class=\"line\">使用READ COMMITTED隔离级别，快照被重置为每个一致的读取操作的时间。</span><br></pre></td></tr></table></figure>\n\n\n<p>4.undo-log</p>\n<ul>\n<li><p>Undo log是InnoDB MVCC事务特性的重要组成部分。当我们对记录做了变更操作时就会产生undo记录，Undo记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。<br>Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作（例如bug#69812）。<br>大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo<br>另外, 在回滚段中的undo logs分为: insert undo log 和 update undo log</p>\n</li>\n<li><p>insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。<br>update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。</p>\n</li>\n</ul>\n<p>5.InnoDB存储引擎在数据库每行数据的后面添加了三个字段</p>\n<ul>\n<li>6字节的事务ID(DB_TRX_ID)字段: 用来标识最近一次对本行记录做修改(insert|update)的事务的标识符, 即最后一次修改(insert|update)本行记录的事务id。</li>\n<li>至于delete操作，在innodb看来也不过是一次update操作，更新行中的一个特殊位将行表示为deleted, 并非真正删除。</li>\n<li>7字节的回滚指针(DB_ROLL_PTR)字段: 指写入回滚段(rollback segment)的 undo log record (撤销日志记录记录)。</li>\n<li>如果一行记录被更新, 则 undo log record 包含 ‘重建该行记录被更新之前内容’ 所必须的信息。</li>\n<li>6字节的DB_ROW_ID字段: 包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。</li>\n<li>结合聚簇索引的相关知识点, 我的理解是, 如果我们的表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 但聚簇索引会使用DB_ROW_ID的值来作为主键; 如果我们有自己的主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID 了 。</li>\n<li>关于聚簇索引, 《高性能MySQL》中的篇幅对我来说已经够用了, 稍后会整理一下以前的学习笔记, 然后更新上来。</li>\n</ul>\n<p>6.可见性比较算法（这里每个比较算法后面的描述是建立在rr级别下，rc级别也是使用该比较算法,此处未做描述）<br>设要读取的行的最后提交事务id(即当前数据行的稳定事务id)为 trx_id_current<br>当前新开事务id为 new_id<br>当前新开事务创建的快照read view 中最早的事务id为up_limit_id, 最迟的事务id为low_limit_id(注意这个low_limit_id=未开启的事务id=当前最大事务id+1)<br>比较:</p>\n<ul>\n<li>1.trx_id_current &lt; up_limit_id, 这种情况比较好理解, 表示, 新事务在读取该行记录时, 该行记录的稳定事务ID是小于, 系统当前所有活跃的事务, 所以当前行稳定数据对新事务可见, 跳到步骤5.</li>\n<li>2.trx_id_current &gt;= trx_id_last, 这种情况也比较好理解, 表示, 该行记录的稳定事务id是在本次新事务创建之后才开启的, 但是却在本次新事务执行第二个select前就commit了，所以该行记录的当前值不可见, 跳到步骤4。</li>\n<li>3.trx_id_current &lt;= trx_id_current &lt;= trx_id_last, 表示: 该行记录所在事务在本次新事务创建的时候处于活动状态，从up_limit_id到low_limit_id进行遍历，如果trx_id_current等于他们之中的某个事务id的话，那么不可见, 调到步骤4,否则表示可见。</li>\n<li>4.从该行记录的 DB_ROLL_PTR 指针所指向的回滚段中取出最新的undo-log的版本号, 将它赋值该 trx_id_current，然后跳到步骤1重新开始判断。</li>\n<li>5.将该可见行的值返回。</li>\n</ul>\n<h3 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h3><p>下面是一个非常简版的演示事务对某行记录的更新过程, 当然, InnoDB引擎在内部要做的工作非常多:</p>\n<p><img src=\"/images/bV1IKzdae.png\" alt=\"clipboard.png\"></p>\n<p>下面是一套比较算法的应用过程, 比较长</p>\n<p><img src=\"/images/uasyderdi.png\" alt=\"preview\"></p>\n<h3 id=\"当前读和快照读\"><a href=\"#当前读和快照读\" class=\"headerlink\" title=\"当前读和快照读\"></a>当前读和快照读</h3><p>1.MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读), 是通过 “行排他锁+MVCC” 一起实现的, 不仅可以保证可重复读, 还可以部分防止幻读, 而非完全防止;</p>\n<p>2.为什么是部分防止幻读, 而不是完全防止?</p>\n<ul>\n<li><p>效果: 在如果事务B在事务A执行中, insert了一条数据并提交, 事务A再次查询, 虽然读取的是undo中的旧版本数据(防止了部分幻读), 但是事务A中执行update或者delete都是可以成功的!!</p>\n</li>\n<li><p>因为在innodb中的操作可以分为当前读(current read)和快照读(snapshot read):</p>\n</li>\n</ul>\n<p>3.快照读(snapshot read)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">简单的select操作(当然不包括 select ... lock in share mode, select ... for update)</span><br></pre></td></tr></table></figure>\n\n\n<p>4.当前读(current read) 官网文档 Locking Reads</p>\n<ul>\n<li><p>select … lock in share mode</p>\n</li>\n<li><p>select … for update</p>\n</li>\n<li><p>insert</p>\n</li>\n<li><p>update</p>\n</li>\n<li><p>delete</p>\n</li>\n</ul>\n<p>在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。<br>innodb在快照读的情况下并没有真正的避免幻读, 但是在当前读的情况下避免了不可重复读和幻读!!!</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p><img src=\"/images/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6.png\" alt=\"MVCC多版本并发控制\"></p>\n<ol>\n<li>一般我们认为MVCC有下面几个特点：</li>\n</ol>\n<ul>\n<li><p>每行数据都存在一个版本，每次数据更新时都更新该版本</p>\n</li>\n<li><p>修改时Copy出当前版本, 然后随意修改，各个事务之间无干扰</p>\n</li>\n<li><p>保存时比较版本号，如果成功(commit)，则覆盖原记录, 失败则放弃copy(rollback)</p>\n</li>\n<li><p>就是每行都有版本号，保存时根据版本号决定是否成功，<strong>听起来含有乐观锁的味道, 因为这看起来正是，在提交的时候才能知道到底能否提交成功</strong></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>而InnoDB实现MVCC的方式是:</li>\n</ol>\n<ul>\n<li>事务以排他锁的形式修改原始数据</li>\n<li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li>\n<li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li>\n</ul>\n<ol start=\"3\">\n<li><strong>二者最本质的区别是</strong>: 当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？</li>\n</ol>\n<ul>\n<li>Innodb的实现真算不上MVCC, 因为并没有实现核心的多版本共存, undo log 中的内容只是串行化的结果, 记录了多个事务的过程, 不属于多版本共存。但理想的MVCC是难以实现的, 当事务仅修改一行记录使用理想的MVCC模式是没有问题的, 可以通过比较版本号进行回滚, 但当事务影响到多行数据时, 理想的MVCC就无能为力了。</li>\n<li>比如, 如果事务A执行理想的MVCC, 修改Row1成功, 而修改Row2失败, 此时需要回滚Row1, 但因为Row1没有被锁定, 其数据可能又被事务B所修改, 如果此时回滚Row1的内容，则会破坏事务B的修改结果，导致事务B违反ACID。 这也正是所谓的 第一类更新丢失 的情况。</li>\n<li>也正是因为InnoDB使用的MVCC中结合了排他锁, 不是纯的MVCC, 所以第一类更新丢失是不会出现了, 一般说更新丢失都是指第二类丢失更新。</li>\n</ul>\n"},{"title":"Java IO/NIO 对比","date":"2020-05-20T08:19:27.000Z","_content":"# Java NIO Buffer, Channel 及 Selector\n\n## Java IO VS NIO\n\n- JDK 1.4 之前，java.io 包，\n\n  面向流的I/O系统\n\n  （字节流或者字符流）\n\n  - 系统一次处理一个字节\n  - 速度慢\n\n- JDK 1.4 提供，java.nio 包，\n\n  面向块的I/O系统\n\n  - 系统一次处理一个块\n  - 速度快\n\n  ​\n\n  NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区),Selector。\n\n  ​       传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。\n\n  NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。\n\n## Buffer 缓冲区\n\n缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组。\n在 NIO 库中，所有数据都是用缓冲区处理的：\n\n- 在读取数据时，它是直接读到缓冲区中的；\n- 在写入数据时，它也是写入到缓冲区中的；\n\n在 NIO 中，所有的缓冲区类型都继承于抽象类 Buffer。常见的缓冲区 Buffer 包括：\n\n- ByteBuffer 存储了字节数组 `final byte[] hb;`\n\n- CharBuffer \n\n  ```java\n  final char[] hb;\n  ```\n\n  - **ByteBuffer 与 CharBuffer 之间的转换需要使用字符集 Charset**\n  - Charset 具体使用，参见 [Java Charset 字符集](https://www.jianshu.com/p/1c61e001b609)\n\n- ShortBuffer `final short[] hb;`\n\n- IntBuffer `final int[] hb;`\n\n- LongBuffer `final long[] hb;`\n\n- FloatBuffer `final float[] hb;`\n\n- DoubleBuffer `final double[] hb;`\n\nBuffer 类的属性：\n\n- `private int mark = -1;` 记录一个标记位置\n- `private int position = 0;`\n\n> A buffer's <i>position</i> is the index of the next element to be read or written.  A buffer's position is never negative and is never greater than its limit.\n> 当前操作的位置\n\n- `private int limit;`\n\n> A buffer's <i>limit</i> is the index of the first element that should not be read or written.  A buffer's limit is never negative and is never greater than its capacity.\n> 可以存放的元素的个数\n\n- `private int capacity;`\n\n> A buffer's <i>capacity</i> is the number of elements it contains.  The capacity of a buffer is never negative and never changes.\n> 数组容量\n\n- 大小关系：**mark <= position <= limit <= capacity**\n\nBuffer 类的方法：\n\n- `allocate(int capacity)` 分配一个缓冲区，默认 limit = capacity\n- `put()` 在当前位置添加元素\n- `get()` 得到当前位置的元素\n- `clear()` 将 Buffer 从 读模式 切换到 写模式 （该方法实际不会清空原 Buffer 的内容）\n\n```java\npublic final Buffer clear() {\n    position = 0;\n    limit = capacity;\n    mark = -1;\n    return this;\n}\n```\n\n- `flip()`  将 Buffer 从 写模式 切换到 读模式\n\n```java\npublic final Buffer flip() {\n    limit = position;\n    position = 0;\n    mark = -1;\n    return this;\n}\n```\n\n** `clear()` VS `flip()`**：\n\n- 在写模式下，Buffer 的 limit 表示你最多能往 Buffer 里写多少数据。\n  - 因此写之前，调用 `clear()`，使得 `limit = capacity;`\n- 在读模式时，Buffer 的 limit 表示你最多能从 Buffer 里读多少数据。\n  - 因此读之前，调用 `flip()`，使得 `limit = position;`\n\nIntBuffer 的使用：\n\n```java\npublic static void main(String[] args) throws Exception {\n    // 创建 int 缓冲区 capacity 为 4\n    // 默认 limit = capacity\n    IntBuffer buffer = IntBuffer.allocate(4);\n    System.out.println(\"Capacity & Limit: \" + buffer.capacity() + \" \" + buffer.limit());\n\n    // 往 Buffer 中写数据\n    buffer.put(11);\n    buffer.put(22);\n    buffer.put(33);\n    buffer.put(44);\n\n    System.out.println(\"Position: \" + buffer.position());\n\n    // 在从 Buffer 中读数据之前，调用 flip()\n    buffer.flip();\n\n    while (buffer.hasRemaining()) {\n        System.out.print(buffer.get() + \"  \");\n    }\n}\n```\n\n输出：\n\n> Capacity & Limit: 4 4\n> Position: 4\n> 11  22  33  44\n\n## Channel 通道\n\n- Java NIO 的核心概念，表示的是对支持 I/O 操作的实体的一个连接\n- 通过它可以读取和写入数据（并不是直接操作，而是通过 Buffer 来处理）\n- 双向的\n\n常用的 Channel 包括：\n\n- FileChannel 从文件中读写数据\n- DatagramChannel 从 UDP 中读写数据\n- SocketChannel 从 TCP 中读写数据\n- ServerSocketChannel 监听新进来的 TCP 连接，每一个新进来的连接都会创建一个 SocketChannel。\n\n### FileChannel 连接到文件的通道\n\n**FileChannel 无法设置为非阻塞模式，只能运行在阻塞模式下**\n常用方法：\n\n- `int read(ByteBuffer dst)` 从 Channel 中读取数据，写入 Buffer\n- `int write(ByteBuffer src)` 从 Buffer 中读取数据，写入 Channel\n- `long size()` 得到 Channel 中文件的大小\n- `long position()` 得到 Channel 中文件的当前操作位置\n- `FileChannel position(long newPosition)` 设置 Channel 中文件的当前操作位置\n\n使用 FileChannel 来复制文件的例子：\n\n```java\npublic static void main(String[] args) throws Exception {\n    // 通过 InputStream 或者 OutputStream 来构造 FileChannel\n    FileChannel in = new FileInputStream(\"a.txt\").getChannel();\n    FileChannel out = new FileOutputStream(\"b.txt\").getChannel();\n\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n    // 调用 channel 的 read 方法往 Buffer 中写数据\n    while(in.read(buffer) != -1) {\n        // 在从 Buffer 中读数据之前，调用 flip()\n        buffer.flip();\n        // 从 Buffer 中读数据，写入到 channel\n        out.write(buffer);\n        // 在往 Buffer 中写数据之前，调用 clear()\n        buffer.clear();\n    }\n\n    // 或者使用如下代码\n    // out.transferFrom(in, 0, in.size());\n}\n```\n\n### SocketChannel 连接到 TCP 套接字的通道\n\n**SocketChannel 可以设置为阻塞模式或非阻塞模式**\n使用 SocketChannel 来建立 TCP 连接，发送并接收数据，默认使用 **阻塞模式**：\n\n```java\npublic static void main(String[] args) throws Exception {\n    // 打开 SocketChannel\n    SocketChannel channel = SocketChannel.open();\n    // connect 方法会阻塞，直至连接建立成功\n    channel.connect(new InetSocketAddress(\"127.0.0.1\", 8080));\n\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n    // 发送数据\n    String msg = \"This is client.\";\n    // 在往 Buffer 中写数据之前，调用 clear()\n    buffer.clear();\n    buffer.put(msg.getBytes());\n\n    // 在从 Buffer 中读数据之前，调用 flip()\n    buffer.flip();\n    channel.write(buffer);\n\n    // 接收数据\n    // 在往 Buffer 中写数据之前，调用 clear()\n    buffer.clear();\n\n    // 调用 channel 的 read 方法往 Buffer 中写数据\n    channel.read(buffer);\n\n    // 在从 Buffer 中读数据之前，调用 flip()\n    buffer.flip();\n\n    // 从 Buffer 中读数据\n    while (buffer.hasRemaining()) {\n        System.out.print(buffer.get());\n    }\n}\n```\n\n使用 SocketChannel 的 **非阻塞模式** 来建立 TCP 连接，发送并接收数据：\n\n```java\npublic static void main(String[] args) throws Exception {\n    // 打开 SocketChannel\n    SocketChannel channel = SocketChannel.open();\n\n    channel.configureBlocking(false);\n    channel.connect(new InetSocketAddress(\"127.0.0.1\", 8080));\n\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n    while (!channel.finishConnect()) {\n        // 发送数据\n        String msg = \"This is client.\";\n        // 在往 Buffer 中写数据之前，调用 clear()\n        buffer.clear();\n        buffer.put(msg.getBytes());\n\n        // 在从 Buffer 中读数据之前，调用 flip()\n        buffer.flip();\n        channel.write(buffer);\n\n        // 接收数据\n        // 在往 Buffer 中写数据之前，调用 clear()\n        buffer.clear();\n\n        // 调用 channel 的 read 方法往 Buffer 中写数据\n        channel.read(buffer);\n\n        // 在从 Buffer 中读数据之前，调用 flip()\n        buffer.flip();\n\n        // 从 Buffer 中读数据\n        while (buffer.hasRemaining()) {\n            System.out.print(buffer.get());\n        }\n    }\n}\n```\n\n### ServerSocketChannel 监听 TCP 连接的通道\n\n**ServerSocketChannel 可以设置为阻塞模式或非阻塞模式**\n使用 ServerSocketChannel 来监听 TCP 连接，默认使用 **阻塞模式**：\n\n```java\npublic static void main(String[] args) throws Exception {\n    // 打开 SocketChannel\n    ServerSocketChannel channel = ServerSocketChannel.open();\n    // 绑定端口\n    channel.socket().bind(new InetSocketAddress(8080));\n\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n    while (true) {\n        // accept 方法会阻塞，直至监听到 TCP 连接\n        SocketChannel socketChannel = channel.accept();\n        System.out.println(\"A new connection...\");\n\n        // 接收数据\n        // 在往 Buffer 中写数据之前，调用 clear()\n        buffer.clear();\n\n        // 调用 channel 的 read 方法往 Buffer 中写数据\n        socketChannel.read(buffer);\n\n        // 在从 Buffer 中读数据之前，调用 flip()\n        buffer.flip();\n\n        // 从 Buffer 中读数据\n        while (buffer.hasRemaining()) {\n            System.out.print(buffer.get());\n        }\n\n        // 在往 Buffer 中写数据之前，调用 clear()\n        // 发送数据\n        String msg = \"This is server.\";\n        // 在往 Buffer 中写数据之前，调用 clear()\n        buffer.clear();\n        buffer.put(msg.getBytes());\n\n        // 在从 Buffer 中读数据之前，调用 flip()\n        buffer.flip();\n        socketChannel.write(buffer);\n    }\n}\n```\n\n## Selector 选择器\n\n**Selector 允许单个进程可以同时处理多个网络连接的 IO，即监听多个端口的 Channel**。\n\n**关于 IO 模式，参见 Linux IO 模型 中对多路复用 IO Multiplexing IO 的说明。**\n\n引用：\n\n------\n\n## 多路复用 IO Multiplexing IO\n\n- **单个进程可以同时处理多个网络连接的 IO，即监听多个端口的 IO**\n- 适用于连接数很高的情况\n- 实现方式：select，poll，epoll 系统调用\n  - 注册多个端口的监听 Socket，比如 8080，8081\n  - 当用户进程调用 select 方法后，整个用户进程被阻塞，OS 内核会监听所有注册的 Socket\n  - 当任何一个端口的 Socket 中的数据准备好了（ 8080 或者 8081），select 方法就会返回\n  - 随后用户进程再调用 read 操作，将数据从 OS 内核缓存区拷贝到应用程序的地址空间。\n- 多路复用 IO 类似于 多线程结合阻塞 IO\n  - 要实现监听多个端口的 IO，还可以通过多线程的方式，每一个线程负责监听一个端口的 IO\n  - 如果处理的连接数不是很高的话，使用 多路复用 IO 不一定比使用 **多线程结合阻塞 IO** 的服务器性能更好，可能延迟还更大\n  - 多路复用 IO 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接\n\n------\n\n**Selector 使用步骤：**\n\n- **创建 Selector**\n\n- **创建 Channel**，可以创建多个 Channel，即监听多个端口，比如 8080，8081\n\n- 将 Channel 注册到 Selector 中\n\n  - 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的, 即 `channel.configureBlocking(false);`\n\n  - 因此 FileChannel 是不能够使用 Selector 的, 因为 FileChannel 都是阻塞的\n\n  - 注册时，需要指定了对 Channel 的什么事件感兴趣，包括：\n\n    - SelectionKey.OP_CONNECT：TCP 连接 `static final int OP_CONNECT = 1 << 3;`\n    - SelectionKey.OP_ACCEPT：确认 `static final int OP_ACCEPT = 1 << 4;`\n    - SelectionKey.OP_READ：读 `static final int OP_READ = 1 << 0;`\n    - SelectionKey.OP_WRITE：写 `static final int OP_WRITE = 1 << 2;`\n    - 可以使用或运算 **|** 来组合，例如 `SelectionKey.OP_READ | SelectionKey.OP_WRITE`\n\n  - register 方法返回一个 SelectionKey 对象，包括：\n\n    - `int interestOps()`：调用 register 注册 channel 时所设置的 interest set.\n\n    - ```java\n      int readyOps()\n      ```\n\n      ：Channel 所准备好了的操作\n\n      - `selectionKey.isAcceptable();`\n      - `selectionKey.isConnectable();`\n      - `selectionKey.isReadable();`\n      - `selectionKey.isWritable();`\n\n    - `public abstract SelectableChannel channel();`： 得到 Channel\n\n    - `public abstract Selector selector();`：得到 Selector\n\n    - `public final Object attachment`：得到附加对象\n\n- 不断重复：\n\n  - 调用 Selector 对象的 select() 方法，**该方法会阻塞，直至注册的事件发生**\n  - **事件发生**，调用 Selector 对象的 selectedKeys() 方法获取 selected keys\n  - 遍历每个 selected key:\n    - 从 selected key 中获取对应的 Channel 并处理\n    - 在 OP_ACCEPT 事件中, 从 key.channel() 返回的是 ServerSocketChannel\n    - 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel\n\n- **关闭 Selector**\n\n示例：\n\n```java\npublic static void main(String args[]) throws Exception {\n    // 创建 Selector\n    Selector selector = Selector.open();\n\n    // 创建 Server Socket，监听端口 8080\n    ServerSocketChannel serverChannel1 = ServerSocketChannel.open();\n    serverChannel1.socket().bind(new InetSocketAddress(8080));\n    // 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的\n    serverChannel1.configureBlocking(false);\n\n    // 创建 Server Socket，监听端口 8081\n    ServerSocketChannel serverChannel2 = ServerSocketChannel.open();\n    serverChannel2.socket().bind(new InetSocketAddress(8081));\n    // 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的\n    serverChannel2.configureBlocking(false);\n\n    // 将 Channel 注册到 Selector 中\n    serverChannel1.register(selector, SelectionKey.OP_ACCEPT);\n    serverChannel2.register(selector, SelectionKey.OP_ACCEPT);\n\n    // 不断重复\n    while (true) {\n        // 调用 Selector 对象的 select() 方法，该方法会阻塞，直至注册的事件发生\n        selector.select();\n\n        // 事件发生，调用 Selector 对象的 selectedKeys() 方法获取 selected keys\n        Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n\n        // 遍历每个 selected key:\n        while (it.hasNext()) {\n            SelectionKey key = it.next();\n\n            if (key.isAcceptable()) {\n                // 在 OP_ACCEPT 事件中, 从 key.channel() 返回的是 ServerSocketChannel\n                ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n\n                // 调用 accept 方法获取 TCP 连接 SocketChanne\n                SocketChannel clientChannel = serverChannel.accept();\n                clientChannel.configureBlocking(false);\n\n                // 注册 SocketChannel\n                clientChannel.register(key.selector(), SelectionKey.OP_READ | SelectionKey.OP_WRITE);\n\n                System.out.println(\"Accept event\");\n            }\n\n            if (key.isReadable()) {\n                // 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel\n                SocketChannel clientChannel = (SocketChannel) key.channel();\n                System.out.println(\"Read event\");\n                // 可以从 clientChannel 中读数据，通过 ByteBuffer\n                // TO DO\n            }\n\n            if (key.isWritable()) {\n                // 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel\n                SocketChannel clientChannel = (SocketChannel) key.channel();\n                System.out.println(\"Write event\");\n                // 可以向 clientChannel 中写数据，通过 ByteBuffer\n                // TO DO\n            }\n        }\n    }\n}\n```","source":"_posts/java/IO-NIO.md","raw":"---\ntitle: Java IO/NIO 对比\ndate: 2020-05-20 16:19:27\ntags:\n    - java\n    - io\n    - nio\ncategories:\n    - java\n    - IO/NIO\n---\n# Java NIO Buffer, Channel 及 Selector\n\n## Java IO VS NIO\n\n- JDK 1.4 之前，java.io 包，\n\n  面向流的I/O系统\n\n  （字节流或者字符流）\n\n  - 系统一次处理一个字节\n  - 速度慢\n\n- JDK 1.4 提供，java.nio 包，\n\n  面向块的I/O系统\n\n  - 系统一次处理一个块\n  - 速度快\n\n  ​\n\n  NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区),Selector。\n\n  ​       传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。\n\n  NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。\n\n## Buffer 缓冲区\n\n缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组。\n在 NIO 库中，所有数据都是用缓冲区处理的：\n\n- 在读取数据时，它是直接读到缓冲区中的；\n- 在写入数据时，它也是写入到缓冲区中的；\n\n在 NIO 中，所有的缓冲区类型都继承于抽象类 Buffer。常见的缓冲区 Buffer 包括：\n\n- ByteBuffer 存储了字节数组 `final byte[] hb;`\n\n- CharBuffer \n\n  ```java\n  final char[] hb;\n  ```\n\n  - **ByteBuffer 与 CharBuffer 之间的转换需要使用字符集 Charset**\n  - Charset 具体使用，参见 [Java Charset 字符集](https://www.jianshu.com/p/1c61e001b609)\n\n- ShortBuffer `final short[] hb;`\n\n- IntBuffer `final int[] hb;`\n\n- LongBuffer `final long[] hb;`\n\n- FloatBuffer `final float[] hb;`\n\n- DoubleBuffer `final double[] hb;`\n\nBuffer 类的属性：\n\n- `private int mark = -1;` 记录一个标记位置\n- `private int position = 0;`\n\n> A buffer's <i>position</i> is the index of the next element to be read or written.  A buffer's position is never negative and is never greater than its limit.\n> 当前操作的位置\n\n- `private int limit;`\n\n> A buffer's <i>limit</i> is the index of the first element that should not be read or written.  A buffer's limit is never negative and is never greater than its capacity.\n> 可以存放的元素的个数\n\n- `private int capacity;`\n\n> A buffer's <i>capacity</i> is the number of elements it contains.  The capacity of a buffer is never negative and never changes.\n> 数组容量\n\n- 大小关系：**mark <= position <= limit <= capacity**\n\nBuffer 类的方法：\n\n- `allocate(int capacity)` 分配一个缓冲区，默认 limit = capacity\n- `put()` 在当前位置添加元素\n- `get()` 得到当前位置的元素\n- `clear()` 将 Buffer 从 读模式 切换到 写模式 （该方法实际不会清空原 Buffer 的内容）\n\n```java\npublic final Buffer clear() {\n    position = 0;\n    limit = capacity;\n    mark = -1;\n    return this;\n}\n```\n\n- `flip()`  将 Buffer 从 写模式 切换到 读模式\n\n```java\npublic final Buffer flip() {\n    limit = position;\n    position = 0;\n    mark = -1;\n    return this;\n}\n```\n\n** `clear()` VS `flip()`**：\n\n- 在写模式下，Buffer 的 limit 表示你最多能往 Buffer 里写多少数据。\n  - 因此写之前，调用 `clear()`，使得 `limit = capacity;`\n- 在读模式时，Buffer 的 limit 表示你最多能从 Buffer 里读多少数据。\n  - 因此读之前，调用 `flip()`，使得 `limit = position;`\n\nIntBuffer 的使用：\n\n```java\npublic static void main(String[] args) throws Exception {\n    // 创建 int 缓冲区 capacity 为 4\n    // 默认 limit = capacity\n    IntBuffer buffer = IntBuffer.allocate(4);\n    System.out.println(\"Capacity & Limit: \" + buffer.capacity() + \" \" + buffer.limit());\n\n    // 往 Buffer 中写数据\n    buffer.put(11);\n    buffer.put(22);\n    buffer.put(33);\n    buffer.put(44);\n\n    System.out.println(\"Position: \" + buffer.position());\n\n    // 在从 Buffer 中读数据之前，调用 flip()\n    buffer.flip();\n\n    while (buffer.hasRemaining()) {\n        System.out.print(buffer.get() + \"  \");\n    }\n}\n```\n\n输出：\n\n> Capacity & Limit: 4 4\n> Position: 4\n> 11  22  33  44\n\n## Channel 通道\n\n- Java NIO 的核心概念，表示的是对支持 I/O 操作的实体的一个连接\n- 通过它可以读取和写入数据（并不是直接操作，而是通过 Buffer 来处理）\n- 双向的\n\n常用的 Channel 包括：\n\n- FileChannel 从文件中读写数据\n- DatagramChannel 从 UDP 中读写数据\n- SocketChannel 从 TCP 中读写数据\n- ServerSocketChannel 监听新进来的 TCP 连接，每一个新进来的连接都会创建一个 SocketChannel。\n\n### FileChannel 连接到文件的通道\n\n**FileChannel 无法设置为非阻塞模式，只能运行在阻塞模式下**\n常用方法：\n\n- `int read(ByteBuffer dst)` 从 Channel 中读取数据，写入 Buffer\n- `int write(ByteBuffer src)` 从 Buffer 中读取数据，写入 Channel\n- `long size()` 得到 Channel 中文件的大小\n- `long position()` 得到 Channel 中文件的当前操作位置\n- `FileChannel position(long newPosition)` 设置 Channel 中文件的当前操作位置\n\n使用 FileChannel 来复制文件的例子：\n\n```java\npublic static void main(String[] args) throws Exception {\n    // 通过 InputStream 或者 OutputStream 来构造 FileChannel\n    FileChannel in = new FileInputStream(\"a.txt\").getChannel();\n    FileChannel out = new FileOutputStream(\"b.txt\").getChannel();\n\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n    // 调用 channel 的 read 方法往 Buffer 中写数据\n    while(in.read(buffer) != -1) {\n        // 在从 Buffer 中读数据之前，调用 flip()\n        buffer.flip();\n        // 从 Buffer 中读数据，写入到 channel\n        out.write(buffer);\n        // 在往 Buffer 中写数据之前，调用 clear()\n        buffer.clear();\n    }\n\n    // 或者使用如下代码\n    // out.transferFrom(in, 0, in.size());\n}\n```\n\n### SocketChannel 连接到 TCP 套接字的通道\n\n**SocketChannel 可以设置为阻塞模式或非阻塞模式**\n使用 SocketChannel 来建立 TCP 连接，发送并接收数据，默认使用 **阻塞模式**：\n\n```java\npublic static void main(String[] args) throws Exception {\n    // 打开 SocketChannel\n    SocketChannel channel = SocketChannel.open();\n    // connect 方法会阻塞，直至连接建立成功\n    channel.connect(new InetSocketAddress(\"127.0.0.1\", 8080));\n\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n    // 发送数据\n    String msg = \"This is client.\";\n    // 在往 Buffer 中写数据之前，调用 clear()\n    buffer.clear();\n    buffer.put(msg.getBytes());\n\n    // 在从 Buffer 中读数据之前，调用 flip()\n    buffer.flip();\n    channel.write(buffer);\n\n    // 接收数据\n    // 在往 Buffer 中写数据之前，调用 clear()\n    buffer.clear();\n\n    // 调用 channel 的 read 方法往 Buffer 中写数据\n    channel.read(buffer);\n\n    // 在从 Buffer 中读数据之前，调用 flip()\n    buffer.flip();\n\n    // 从 Buffer 中读数据\n    while (buffer.hasRemaining()) {\n        System.out.print(buffer.get());\n    }\n}\n```\n\n使用 SocketChannel 的 **非阻塞模式** 来建立 TCP 连接，发送并接收数据：\n\n```java\npublic static void main(String[] args) throws Exception {\n    // 打开 SocketChannel\n    SocketChannel channel = SocketChannel.open();\n\n    channel.configureBlocking(false);\n    channel.connect(new InetSocketAddress(\"127.0.0.1\", 8080));\n\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n    while (!channel.finishConnect()) {\n        // 发送数据\n        String msg = \"This is client.\";\n        // 在往 Buffer 中写数据之前，调用 clear()\n        buffer.clear();\n        buffer.put(msg.getBytes());\n\n        // 在从 Buffer 中读数据之前，调用 flip()\n        buffer.flip();\n        channel.write(buffer);\n\n        // 接收数据\n        // 在往 Buffer 中写数据之前，调用 clear()\n        buffer.clear();\n\n        // 调用 channel 的 read 方法往 Buffer 中写数据\n        channel.read(buffer);\n\n        // 在从 Buffer 中读数据之前，调用 flip()\n        buffer.flip();\n\n        // 从 Buffer 中读数据\n        while (buffer.hasRemaining()) {\n            System.out.print(buffer.get());\n        }\n    }\n}\n```\n\n### ServerSocketChannel 监听 TCP 连接的通道\n\n**ServerSocketChannel 可以设置为阻塞模式或非阻塞模式**\n使用 ServerSocketChannel 来监听 TCP 连接，默认使用 **阻塞模式**：\n\n```java\npublic static void main(String[] args) throws Exception {\n    // 打开 SocketChannel\n    ServerSocketChannel channel = ServerSocketChannel.open();\n    // 绑定端口\n    channel.socket().bind(new InetSocketAddress(8080));\n\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n\n    while (true) {\n        // accept 方法会阻塞，直至监听到 TCP 连接\n        SocketChannel socketChannel = channel.accept();\n        System.out.println(\"A new connection...\");\n\n        // 接收数据\n        // 在往 Buffer 中写数据之前，调用 clear()\n        buffer.clear();\n\n        // 调用 channel 的 read 方法往 Buffer 中写数据\n        socketChannel.read(buffer);\n\n        // 在从 Buffer 中读数据之前，调用 flip()\n        buffer.flip();\n\n        // 从 Buffer 中读数据\n        while (buffer.hasRemaining()) {\n            System.out.print(buffer.get());\n        }\n\n        // 在往 Buffer 中写数据之前，调用 clear()\n        // 发送数据\n        String msg = \"This is server.\";\n        // 在往 Buffer 中写数据之前，调用 clear()\n        buffer.clear();\n        buffer.put(msg.getBytes());\n\n        // 在从 Buffer 中读数据之前，调用 flip()\n        buffer.flip();\n        socketChannel.write(buffer);\n    }\n}\n```\n\n## Selector 选择器\n\n**Selector 允许单个进程可以同时处理多个网络连接的 IO，即监听多个端口的 Channel**。\n\n**关于 IO 模式，参见 Linux IO 模型 中对多路复用 IO Multiplexing IO 的说明。**\n\n引用：\n\n------\n\n## 多路复用 IO Multiplexing IO\n\n- **单个进程可以同时处理多个网络连接的 IO，即监听多个端口的 IO**\n- 适用于连接数很高的情况\n- 实现方式：select，poll，epoll 系统调用\n  - 注册多个端口的监听 Socket，比如 8080，8081\n  - 当用户进程调用 select 方法后，整个用户进程被阻塞，OS 内核会监听所有注册的 Socket\n  - 当任何一个端口的 Socket 中的数据准备好了（ 8080 或者 8081），select 方法就会返回\n  - 随后用户进程再调用 read 操作，将数据从 OS 内核缓存区拷贝到应用程序的地址空间。\n- 多路复用 IO 类似于 多线程结合阻塞 IO\n  - 要实现监听多个端口的 IO，还可以通过多线程的方式，每一个线程负责监听一个端口的 IO\n  - 如果处理的连接数不是很高的话，使用 多路复用 IO 不一定比使用 **多线程结合阻塞 IO** 的服务器性能更好，可能延迟还更大\n  - 多路复用 IO 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接\n\n------\n\n**Selector 使用步骤：**\n\n- **创建 Selector**\n\n- **创建 Channel**，可以创建多个 Channel，即监听多个端口，比如 8080，8081\n\n- 将 Channel 注册到 Selector 中\n\n  - 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的, 即 `channel.configureBlocking(false);`\n\n  - 因此 FileChannel 是不能够使用 Selector 的, 因为 FileChannel 都是阻塞的\n\n  - 注册时，需要指定了对 Channel 的什么事件感兴趣，包括：\n\n    - SelectionKey.OP_CONNECT：TCP 连接 `static final int OP_CONNECT = 1 << 3;`\n    - SelectionKey.OP_ACCEPT：确认 `static final int OP_ACCEPT = 1 << 4;`\n    - SelectionKey.OP_READ：读 `static final int OP_READ = 1 << 0;`\n    - SelectionKey.OP_WRITE：写 `static final int OP_WRITE = 1 << 2;`\n    - 可以使用或运算 **|** 来组合，例如 `SelectionKey.OP_READ | SelectionKey.OP_WRITE`\n\n  - register 方法返回一个 SelectionKey 对象，包括：\n\n    - `int interestOps()`：调用 register 注册 channel 时所设置的 interest set.\n\n    - ```java\n      int readyOps()\n      ```\n\n      ：Channel 所准备好了的操作\n\n      - `selectionKey.isAcceptable();`\n      - `selectionKey.isConnectable();`\n      - `selectionKey.isReadable();`\n      - `selectionKey.isWritable();`\n\n    - `public abstract SelectableChannel channel();`： 得到 Channel\n\n    - `public abstract Selector selector();`：得到 Selector\n\n    - `public final Object attachment`：得到附加对象\n\n- 不断重复：\n\n  - 调用 Selector 对象的 select() 方法，**该方法会阻塞，直至注册的事件发生**\n  - **事件发生**，调用 Selector 对象的 selectedKeys() 方法获取 selected keys\n  - 遍历每个 selected key:\n    - 从 selected key 中获取对应的 Channel 并处理\n    - 在 OP_ACCEPT 事件中, 从 key.channel() 返回的是 ServerSocketChannel\n    - 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel\n\n- **关闭 Selector**\n\n示例：\n\n```java\npublic static void main(String args[]) throws Exception {\n    // 创建 Selector\n    Selector selector = Selector.open();\n\n    // 创建 Server Socket，监听端口 8080\n    ServerSocketChannel serverChannel1 = ServerSocketChannel.open();\n    serverChannel1.socket().bind(new InetSocketAddress(8080));\n    // 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的\n    serverChannel1.configureBlocking(false);\n\n    // 创建 Server Socket，监听端口 8081\n    ServerSocketChannel serverChannel2 = ServerSocketChannel.open();\n    serverChannel2.socket().bind(new InetSocketAddress(8081));\n    // 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的\n    serverChannel2.configureBlocking(false);\n\n    // 将 Channel 注册到 Selector 中\n    serverChannel1.register(selector, SelectionKey.OP_ACCEPT);\n    serverChannel2.register(selector, SelectionKey.OP_ACCEPT);\n\n    // 不断重复\n    while (true) {\n        // 调用 Selector 对象的 select() 方法，该方法会阻塞，直至注册的事件发生\n        selector.select();\n\n        // 事件发生，调用 Selector 对象的 selectedKeys() 方法获取 selected keys\n        Iterator<SelectionKey> it = selector.selectedKeys().iterator();\n\n        // 遍历每个 selected key:\n        while (it.hasNext()) {\n            SelectionKey key = it.next();\n\n            if (key.isAcceptable()) {\n                // 在 OP_ACCEPT 事件中, 从 key.channel() 返回的是 ServerSocketChannel\n                ServerSocketChannel serverChannel = (ServerSocketChannel) key.channel();\n\n                // 调用 accept 方法获取 TCP 连接 SocketChanne\n                SocketChannel clientChannel = serverChannel.accept();\n                clientChannel.configureBlocking(false);\n\n                // 注册 SocketChannel\n                clientChannel.register(key.selector(), SelectionKey.OP_READ | SelectionKey.OP_WRITE);\n\n                System.out.println(\"Accept event\");\n            }\n\n            if (key.isReadable()) {\n                // 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel\n                SocketChannel clientChannel = (SocketChannel) key.channel();\n                System.out.println(\"Read event\");\n                // 可以从 clientChannel 中读数据，通过 ByteBuffer\n                // TO DO\n            }\n\n            if (key.isWritable()) {\n                // 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel\n                SocketChannel clientChannel = (SocketChannel) key.channel();\n                System.out.println(\"Write event\");\n                // 可以向 clientChannel 中写数据，通过 ByteBuffer\n                // TO DO\n            }\n        }\n    }\n}\n```","slug":"java/IO-NIO","published":1,"updated":"2020-05-20T08:45:30.726Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7lq005mvgja8vv73jz7","content":"<h1 id=\"Java-NIO-Buffer-Channel-及-Selector\"><a href=\"#Java-NIO-Buffer-Channel-及-Selector\" class=\"headerlink\" title=\"Java NIO Buffer, Channel 及 Selector\"></a>Java NIO Buffer, Channel 及 Selector</h1><h2 id=\"Java-IO-VS-NIO\"><a href=\"#Java-IO-VS-NIO\" class=\"headerlink\" title=\"Java IO VS NIO\"></a>Java IO VS NIO</h2><ul>\n<li><p>JDK 1.4 之前，java.io 包，</p>\n<p>面向流的I/O系统</p>\n<p>（字节流或者字符流）</p>\n<ul>\n<li>系统一次处理一个字节</li>\n<li>速度慢</li>\n</ul>\n</li>\n<li><p>JDK 1.4 提供，java.nio 包，</p>\n<p>面向块的I/O系统</p>\n<ul>\n<li>系统一次处理一个块</li>\n<li>速度快</li>\n</ul>\n<p>​</p>\n<p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区),Selector。</p>\n<p>​       传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p>\n<p>NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。</p>\n</li>\n</ul>\n<h2 id=\"Buffer-缓冲区\"><a href=\"#Buffer-缓冲区\" class=\"headerlink\" title=\"Buffer 缓冲区\"></a>Buffer 缓冲区</h2><p>缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组。<br>在 NIO 库中，所有数据都是用缓冲区处理的：</p>\n<ul>\n<li>在读取数据时，它是直接读到缓冲区中的；</li>\n<li>在写入数据时，它也是写入到缓冲区中的；</li>\n</ul>\n<p>在 NIO 中，所有的缓冲区类型都继承于抽象类 Buffer。常见的缓冲区 Buffer 包括：</p>\n<ul>\n<li><p>ByteBuffer 存储了字节数组 <code>final byte[] hb;</code></p>\n</li>\n<li><p>CharBuffer </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] hb;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>ByteBuffer 与 CharBuffer 之间的转换需要使用字符集 Charset</strong></li>\n<li>Charset 具体使用，参见 <a href=\"https://www.jianshu.com/p/1c61e001b609\" target=\"_blank\" rel=\"noopener\">Java Charset 字符集</a></li>\n</ul>\n</li>\n<li><p>ShortBuffer <code>final short[] hb;</code></p>\n</li>\n<li><p>IntBuffer <code>final int[] hb;</code></p>\n</li>\n<li><p>LongBuffer <code>final long[] hb;</code></p>\n</li>\n<li><p>FloatBuffer <code>final float[] hb;</code></p>\n</li>\n<li><p>DoubleBuffer <code>final double[] hb;</code></p>\n</li>\n</ul>\n<p>Buffer 类的属性：</p>\n<ul>\n<li><code>private int mark = -1;</code> 记录一个标记位置</li>\n<li><code>private int position = 0;</code></li>\n</ul>\n<blockquote>\n<p>A buffer’s <i>position</i> is the index of the next element to be read or written.  A buffer’s position is never negative and is never greater than its limit.<br>当前操作的位置</p>\n</blockquote>\n<ul>\n<li><code>private int limit;</code></li>\n</ul>\n<blockquote>\n<p>A buffer’s <i>limit</i> is the index of the first element that should not be read or written.  A buffer’s limit is never negative and is never greater than its capacity.<br>可以存放的元素的个数</p>\n</blockquote>\n<ul>\n<li><code>private int capacity;</code></li>\n</ul>\n<blockquote>\n<p>A buffer’s <i>capacity</i> is the number of elements it contains.  The capacity of a buffer is never negative and never changes.<br>数组容量</p>\n</blockquote>\n<ul>\n<li>大小关系：<strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></li>\n</ul>\n<p>Buffer 类的方法：</p>\n<ul>\n<li><code>allocate(int capacity)</code> 分配一个缓冲区，默认 limit = capacity</li>\n<li><code>put()</code> 在当前位置添加元素</li>\n<li><code>get()</code> 得到当前位置的元素</li>\n<li><code>clear()</code> 将 Buffer 从 读模式 切换到 写模式 （该方法实际不会清空原 Buffer 的内容）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    limit = capacity;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>flip()</code>  将 Buffer 从 写模式 切换到 读模式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">flip</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    limit = position;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>** <code>clear()</code> VS <code>flip()</code>**：</p>\n<ul>\n<li>在写模式下，Buffer 的 limit 表示你最多能往 Buffer 里写多少数据。<ul>\n<li>因此写之前，调用 <code>clear()</code>，使得 <code>limit = capacity;</code></li>\n</ul>\n</li>\n<li>在读模式时，Buffer 的 limit 表示你最多能从 Buffer 里读多少数据。<ul>\n<li>因此读之前，调用 <code>flip()</code>，使得 <code>limit = position;</code></li>\n</ul>\n</li>\n</ul>\n<p>IntBuffer 的使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建 int 缓冲区 capacity 为 4</span></span><br><span class=\"line\">    <span class=\"comment\">// 默认 limit = capacity</span></span><br><span class=\"line\">    IntBuffer buffer = IntBuffer.allocate(<span class=\"number\">4</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Capacity &amp; Limit: \"</span> + buffer.capacity() + <span class=\"string\">\" \"</span> + buffer.limit());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 往 Buffer 中写数据</span></span><br><span class=\"line\">    buffer.put(<span class=\"number\">11</span>);</span><br><span class=\"line\">    buffer.put(<span class=\"number\">22</span>);</span><br><span class=\"line\">    buffer.put(<span class=\"number\">33</span>);</span><br><span class=\"line\">    buffer.put(<span class=\"number\">44</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Position: \"</span> + buffer.position());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">    buffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (buffer.hasRemaining()) &#123;</span><br><span class=\"line\">        System.out.print(buffer.get() + <span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<blockquote>\n<p>Capacity &amp; Limit: 4 4<br>Position: 4<br>11  22  33  44</p>\n</blockquote>\n<h2 id=\"Channel-通道\"><a href=\"#Channel-通道\" class=\"headerlink\" title=\"Channel 通道\"></a>Channel 通道</h2><ul>\n<li>Java NIO 的核心概念，表示的是对支持 I/O 操作的实体的一个连接</li>\n<li>通过它可以读取和写入数据（并不是直接操作，而是通过 Buffer 来处理）</li>\n<li>双向的</li>\n</ul>\n<p>常用的 Channel 包括：</p>\n<ul>\n<li>FileChannel 从文件中读写数据</li>\n<li>DatagramChannel 从 UDP 中读写数据</li>\n<li>SocketChannel 从 TCP 中读写数据</li>\n<li>ServerSocketChannel 监听新进来的 TCP 连接，每一个新进来的连接都会创建一个 SocketChannel。</li>\n</ul>\n<h3 id=\"FileChannel-连接到文件的通道\"><a href=\"#FileChannel-连接到文件的通道\" class=\"headerlink\" title=\"FileChannel 连接到文件的通道\"></a>FileChannel 连接到文件的通道</h3><p><strong>FileChannel 无法设置为非阻塞模式，只能运行在阻塞模式下</strong><br>常用方法：</p>\n<ul>\n<li><code>int read(ByteBuffer dst)</code> 从 Channel 中读取数据，写入 Buffer</li>\n<li><code>int write(ByteBuffer src)</code> 从 Buffer 中读取数据，写入 Channel</li>\n<li><code>long size()</code> 得到 Channel 中文件的大小</li>\n<li><code>long position()</code> 得到 Channel 中文件的当前操作位置</li>\n<li><code>FileChannel position(long newPosition)</code> 设置 Channel 中文件的当前操作位置</li>\n</ul>\n<p>使用 FileChannel 来复制文件的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 InputStream 或者 OutputStream 来构造 FileChannel</span></span><br><span class=\"line\">    FileChannel in = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"a.txt\"</span>).getChannel();</span><br><span class=\"line\">    FileChannel out = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"b.txt\"</span>).getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">    ByteBuffer buffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用 channel 的 read 方法往 Buffer 中写数据</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(in.read(buffer) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\">        <span class=\"comment\">// 从 Buffer 中读数据，写入到 channel</span></span><br><span class=\"line\">        out.write(buffer);</span><br><span class=\"line\">        <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 或者使用如下代码</span></span><br><span class=\"line\">    <span class=\"comment\">// out.transferFrom(in, 0, in.size());</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SocketChannel-连接到-TCP-套接字的通道\"><a href=\"#SocketChannel-连接到-TCP-套接字的通道\" class=\"headerlink\" title=\"SocketChannel 连接到 TCP 套接字的通道\"></a>SocketChannel 连接到 TCP 套接字的通道</h3><p><strong>SocketChannel 可以设置为阻塞模式或非阻塞模式</strong><br>使用 SocketChannel 来建立 TCP 连接，发送并接收数据，默认使用 <strong>阻塞模式</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 打开 SocketChannel</span></span><br><span class=\"line\">    SocketChannel channel = SocketChannel.open();</span><br><span class=\"line\">    <span class=\"comment\">// connect 方法会阻塞，直至连接建立成功</span></span><br><span class=\"line\">    channel.connect(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">\"127.0.0.1\"</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ByteBuffer buffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送数据</span></span><br><span class=\"line\">    String msg = <span class=\"string\">\"This is client.\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">    buffer.clear();</span><br><span class=\"line\">    buffer.put(msg.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">    buffer.flip();</span><br><span class=\"line\">    channel.write(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 接收数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">    buffer.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用 channel 的 read 方法往 Buffer 中写数据</span></span><br><span class=\"line\">    channel.read(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">    buffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从 Buffer 中读数据</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (buffer.hasRemaining()) &#123;</span><br><span class=\"line\">        System.out.print(buffer.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 SocketChannel 的 <strong>非阻塞模式</strong> 来建立 TCP 连接，发送并接收数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 打开 SocketChannel</span></span><br><span class=\"line\">    SocketChannel channel = SocketChannel.open();</span><br><span class=\"line\"></span><br><span class=\"line\">    channel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    channel.connect(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">\"127.0.0.1\"</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ByteBuffer buffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!channel.finishConnect()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发送数据</span></span><br><span class=\"line\">        String msg = <span class=\"string\">\"This is client.\"</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\">        buffer.put(msg.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\">        channel.write(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收数据</span></span><br><span class=\"line\">        <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 channel 的 read 方法往 Buffer 中写数据</span></span><br><span class=\"line\">        channel.read(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从 Buffer 中读数据</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (buffer.hasRemaining()) &#123;</span><br><span class=\"line\">            System.out.print(buffer.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ServerSocketChannel-监听-TCP-连接的通道\"><a href=\"#ServerSocketChannel-监听-TCP-连接的通道\" class=\"headerlink\" title=\"ServerSocketChannel 监听 TCP 连接的通道\"></a>ServerSocketChannel 监听 TCP 连接的通道</h3><p><strong>ServerSocketChannel 可以设置为阻塞模式或非阻塞模式</strong><br>使用 ServerSocketChannel 来监听 TCP 连接，默认使用 <strong>阻塞模式</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 打开 SocketChannel</span></span><br><span class=\"line\">    ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class=\"line\">    <span class=\"comment\">// 绑定端口</span></span><br><span class=\"line\">    channel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ByteBuffer buffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// accept 方法会阻塞，直至监听到 TCP 连接</span></span><br><span class=\"line\">        SocketChannel socketChannel = channel.accept();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"A new connection...\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收数据</span></span><br><span class=\"line\">        <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 channel 的 read 方法往 Buffer 中写数据</span></span><br><span class=\"line\">        socketChannel.read(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从 Buffer 中读数据</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (buffer.hasRemaining()) &#123;</span><br><span class=\"line\">            System.out.print(buffer.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">        <span class=\"comment\">// 发送数据</span></span><br><span class=\"line\">        String msg = <span class=\"string\">\"This is server.\"</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\">        buffer.put(msg.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\">        socketChannel.write(buffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Selector-选择器\"><a href=\"#Selector-选择器\" class=\"headerlink\" title=\"Selector 选择器\"></a>Selector 选择器</h2><p><strong>Selector 允许单个进程可以同时处理多个网络连接的 IO，即监听多个端口的 Channel</strong>。</p>\n<p><strong>关于 IO 模式，参见 Linux IO 模型 中对多路复用 IO Multiplexing IO 的说明。</strong></p>\n<p>引用：</p>\n<hr>\n<h2 id=\"多路复用-IO-Multiplexing-IO\"><a href=\"#多路复用-IO-Multiplexing-IO\" class=\"headerlink\" title=\"多路复用 IO Multiplexing IO\"></a>多路复用 IO Multiplexing IO</h2><ul>\n<li><strong>单个进程可以同时处理多个网络连接的 IO，即监听多个端口的 IO</strong></li>\n<li>适用于连接数很高的情况</li>\n<li>实现方式：select，poll，epoll 系统调用<ul>\n<li>注册多个端口的监听 Socket，比如 8080，8081</li>\n<li>当用户进程调用 select 方法后，整个用户进程被阻塞，OS 内核会监听所有注册的 Socket</li>\n<li>当任何一个端口的 Socket 中的数据准备好了（ 8080 或者 8081），select 方法就会返回</li>\n<li>随后用户进程再调用 read 操作，将数据从 OS 内核缓存区拷贝到应用程序的地址空间。</li>\n</ul>\n</li>\n<li>多路复用 IO 类似于 多线程结合阻塞 IO<ul>\n<li>要实现监听多个端口的 IO，还可以通过多线程的方式，每一个线程负责监听一个端口的 IO</li>\n<li>如果处理的连接数不是很高的话，使用 多路复用 IO 不一定比使用 <strong>多线程结合阻塞 IO</strong> 的服务器性能更好，可能延迟还更大</li>\n<li>多路复用 IO 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Selector 使用步骤：</strong></p>\n<ul>\n<li><p><strong>创建 Selector</strong></p>\n</li>\n<li><p><strong>创建 Channel</strong>，可以创建多个 Channel，即监听多个端口，比如 8080，8081</p>\n</li>\n<li><p>将 Channel 注册到 Selector 中</p>\n<ul>\n<li><p>如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的, 即 <code>channel.configureBlocking(false);</code></p>\n</li>\n<li><p>因此 FileChannel 是不能够使用 Selector 的, 因为 FileChannel 都是阻塞的</p>\n</li>\n<li><p>注册时，需要指定了对 Channel 的什么事件感兴趣，包括：</p>\n<ul>\n<li>SelectionKey.OP_CONNECT：TCP 连接 <code>static final int OP_CONNECT = 1 &lt;&lt; 3;</code></li>\n<li>SelectionKey.OP_ACCEPT：确认 <code>static final int OP_ACCEPT = 1 &lt;&lt; 4;</code></li>\n<li>SelectionKey.OP_READ：读 <code>static final int OP_READ = 1 &lt;&lt; 0;</code></li>\n<li>SelectionKey.OP_WRITE：写 <code>static final int OP_WRITE = 1 &lt;&lt; 2;</code></li>\n<li>可以使用或运算 <strong>|</strong> 来组合，例如 <code>SelectionKey.OP_READ | SelectionKey.OP_WRITE</code></li>\n</ul>\n</li>\n<li><p>register 方法返回一个 SelectionKey 对象，包括：</p>\n<ul>\n<li><p><code>int interestOps()</code>：调用 register 注册 channel 时所设置的 interest set.</p>\n</li>\n<li><p>```java<br>int readyOps()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">      ：Channel 所准备好了的操作</span><br><span class=\"line\"></span><br><span class=\"line\">      - &#96;selectionKey.isAcceptable();&#96;</span><br><span class=\"line\">      - &#96;selectionKey.isConnectable();&#96;</span><br><span class=\"line\">      - &#96;selectionKey.isReadable();&#96;</span><br><span class=\"line\">      - &#96;selectionKey.isWritable();&#96;</span><br><span class=\"line\"></span><br><span class=\"line\">    - &#96;public abstract SelectableChannel channel();&#96;： 得到 Channel</span><br><span class=\"line\"></span><br><span class=\"line\">    - &#96;public abstract Selector selector();&#96;：得到 Selector</span><br><span class=\"line\"></span><br><span class=\"line\">    - &#96;public final Object attachment&#96;：得到附加对象</span><br><span class=\"line\"></span><br><span class=\"line\">- 不断重复：</span><br><span class=\"line\"></span><br><span class=\"line\">  - 调用 Selector 对象的 select() 方法，**该方法会阻塞，直至注册的事件发生**</span><br><span class=\"line\">  - **事件发生**，调用 Selector 对象的 selectedKeys() 方法获取 selected keys</span><br><span class=\"line\">  - 遍历每个 selected key:</span><br><span class=\"line\">    - 从 selected key 中获取对应的 Channel 并处理</span><br><span class=\"line\">    - 在 OP_ACCEPT 事件中, 从 key.channel() 返回的是 ServerSocketChannel</span><br><span class=\"line\">    - 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel</span><br><span class=\"line\"></span><br><span class=\"line\">- **关闭 Selector**</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;java</span><br><span class=\"line\">public static void main(String args[]) throws Exception &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Selector</span><br><span class=\"line\">    Selector selector &#x3D; Selector.open();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Server Socket，监听端口 8080</span><br><span class=\"line\">    ServerSocketChannel serverChannel1 &#x3D; ServerSocketChannel.open();</span><br><span class=\"line\">    serverChannel1.socket().bind(new InetSocketAddress(8080));</span><br><span class=\"line\">    &#x2F;&#x2F; 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的</span><br><span class=\"line\">    serverChannel1.configureBlocking(false);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Server Socket，监听端口 8081</span><br><span class=\"line\">    ServerSocketChannel serverChannel2 &#x3D; ServerSocketChannel.open();</span><br><span class=\"line\">    serverChannel2.socket().bind(new InetSocketAddress(8081));</span><br><span class=\"line\">    &#x2F;&#x2F; 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的</span><br><span class=\"line\">    serverChannel2.configureBlocking(false);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 将 Channel 注册到 Selector 中</span><br><span class=\"line\">    serverChannel1.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">    serverChannel2.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 不断重复</span><br><span class=\"line\">    while (true) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 调用 Selector 对象的 select() 方法，该方法会阻塞，直至注册的事件发生</span><br><span class=\"line\">        selector.select();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 事件发生，调用 Selector 对象的 selectedKeys() 方法获取 selected keys</span><br><span class=\"line\">        Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 遍历每个 selected key:</span><br><span class=\"line\">        while (it.hasNext()) &#123;</span><br><span class=\"line\">            SelectionKey key &#x3D; it.next();</span><br><span class=\"line\"></span><br><span class=\"line\">            if (key.isAcceptable()) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 在 OP_ACCEPT 事件中, 从 key.channel() 返回的是 ServerSocketChannel</span><br><span class=\"line\">                ServerSocketChannel serverChannel &#x3D; (ServerSocketChannel) key.channel();</span><br><span class=\"line\"></span><br><span class=\"line\">                &#x2F;&#x2F; 调用 accept 方法获取 TCP 连接 SocketChanne</span><br><span class=\"line\">                SocketChannel clientChannel &#x3D; serverChannel.accept();</span><br><span class=\"line\">                clientChannel.configureBlocking(false);</span><br><span class=\"line\"></span><br><span class=\"line\">                &#x2F;&#x2F; 注册 SocketChannel</span><br><span class=\"line\">                clientChannel.register(key.selector(), SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(&quot;Accept event&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (key.isReadable()) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel</span><br><span class=\"line\">                SocketChannel clientChannel &#x3D; (SocketChannel) key.channel();</span><br><span class=\"line\">                System.out.println(&quot;Read event&quot;);</span><br><span class=\"line\">                &#x2F;&#x2F; 可以从 clientChannel 中读数据，通过 ByteBuffer</span><br><span class=\"line\">                &#x2F;&#x2F; TO DO</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (key.isWritable()) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel</span><br><span class=\"line\">                SocketChannel clientChannel &#x3D; (SocketChannel) key.channel();</span><br><span class=\"line\">                System.out.println(&quot;Write event&quot;);</span><br><span class=\"line\">                &#x2F;&#x2F; 可以向 clientChannel 中写数据，通过 ByteBuffer</span><br><span class=\"line\">                &#x2F;&#x2F; TO DO</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java-NIO-Buffer-Channel-及-Selector\"><a href=\"#Java-NIO-Buffer-Channel-及-Selector\" class=\"headerlink\" title=\"Java NIO Buffer, Channel 及 Selector\"></a>Java NIO Buffer, Channel 及 Selector</h1><h2 id=\"Java-IO-VS-NIO\"><a href=\"#Java-IO-VS-NIO\" class=\"headerlink\" title=\"Java IO VS NIO\"></a>Java IO VS NIO</h2><ul>\n<li><p>JDK 1.4 之前，java.io 包，</p>\n<p>面向流的I/O系统</p>\n<p>（字节流或者字符流）</p>\n<ul>\n<li>系统一次处理一个字节</li>\n<li>速度慢</li>\n</ul>\n</li>\n<li><p>JDK 1.4 提供，java.nio 包，</p>\n<p>面向块的I/O系统</p>\n<ul>\n<li>系统一次处理一个块</li>\n<li>速度快</li>\n</ul>\n<p>​</p>\n<p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区),Selector。</p>\n<p>​       传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p>\n<p>NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。</p>\n</li>\n</ul>\n<h2 id=\"Buffer-缓冲区\"><a href=\"#Buffer-缓冲区\" class=\"headerlink\" title=\"Buffer 缓冲区\"></a>Buffer 缓冲区</h2><p>缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组。<br>在 NIO 库中，所有数据都是用缓冲区处理的：</p>\n<ul>\n<li>在读取数据时，它是直接读到缓冲区中的；</li>\n<li>在写入数据时，它也是写入到缓冲区中的；</li>\n</ul>\n<p>在 NIO 中，所有的缓冲区类型都继承于抽象类 Buffer。常见的缓冲区 Buffer 包括：</p>\n<ul>\n<li><p>ByteBuffer 存储了字节数组 <code>final byte[] hb;</code></p>\n</li>\n<li><p>CharBuffer </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] hb;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>ByteBuffer 与 CharBuffer 之间的转换需要使用字符集 Charset</strong></li>\n<li>Charset 具体使用，参见 <a href=\"https://www.jianshu.com/p/1c61e001b609\" target=\"_blank\" rel=\"noopener\">Java Charset 字符集</a></li>\n</ul>\n</li>\n<li><p>ShortBuffer <code>final short[] hb;</code></p>\n</li>\n<li><p>IntBuffer <code>final int[] hb;</code></p>\n</li>\n<li><p>LongBuffer <code>final long[] hb;</code></p>\n</li>\n<li><p>FloatBuffer <code>final float[] hb;</code></p>\n</li>\n<li><p>DoubleBuffer <code>final double[] hb;</code></p>\n</li>\n</ul>\n<p>Buffer 类的属性：</p>\n<ul>\n<li><code>private int mark = -1;</code> 记录一个标记位置</li>\n<li><code>private int position = 0;</code></li>\n</ul>\n<blockquote>\n<p>A buffer’s <i>position</i> is the index of the next element to be read or written.  A buffer’s position is never negative and is never greater than its limit.<br>当前操作的位置</p>\n</blockquote>\n<ul>\n<li><code>private int limit;</code></li>\n</ul>\n<blockquote>\n<p>A buffer’s <i>limit</i> is the index of the first element that should not be read or written.  A buffer’s limit is never negative and is never greater than its capacity.<br>可以存放的元素的个数</p>\n</blockquote>\n<ul>\n<li><code>private int capacity;</code></li>\n</ul>\n<blockquote>\n<p>A buffer’s <i>capacity</i> is the number of elements it contains.  The capacity of a buffer is never negative and never changes.<br>数组容量</p>\n</blockquote>\n<ul>\n<li>大小关系：<strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></li>\n</ul>\n<p>Buffer 类的方法：</p>\n<ul>\n<li><code>allocate(int capacity)</code> 分配一个缓冲区，默认 limit = capacity</li>\n<li><code>put()</code> 在当前位置添加元素</li>\n<li><code>get()</code> 得到当前位置的元素</li>\n<li><code>clear()</code> 将 Buffer 从 读模式 切换到 写模式 （该方法实际不会清空原 Buffer 的内容）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    limit = capacity;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>flip()</code>  将 Buffer 从 写模式 切换到 读模式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">flip</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    limit = position;</span><br><span class=\"line\">    position = <span class=\"number\">0</span>;</span><br><span class=\"line\">    mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>** <code>clear()</code> VS <code>flip()</code>**：</p>\n<ul>\n<li>在写模式下，Buffer 的 limit 表示你最多能往 Buffer 里写多少数据。<ul>\n<li>因此写之前，调用 <code>clear()</code>，使得 <code>limit = capacity;</code></li>\n</ul>\n</li>\n<li>在读模式时，Buffer 的 limit 表示你最多能从 Buffer 里读多少数据。<ul>\n<li>因此读之前，调用 <code>flip()</code>，使得 <code>limit = position;</code></li>\n</ul>\n</li>\n</ul>\n<p>IntBuffer 的使用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建 int 缓冲区 capacity 为 4</span></span><br><span class=\"line\">    <span class=\"comment\">// 默认 limit = capacity</span></span><br><span class=\"line\">    IntBuffer buffer = IntBuffer.allocate(<span class=\"number\">4</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Capacity &amp; Limit: \"</span> + buffer.capacity() + <span class=\"string\">\" \"</span> + buffer.limit());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 往 Buffer 中写数据</span></span><br><span class=\"line\">    buffer.put(<span class=\"number\">11</span>);</span><br><span class=\"line\">    buffer.put(<span class=\"number\">22</span>);</span><br><span class=\"line\">    buffer.put(<span class=\"number\">33</span>);</span><br><span class=\"line\">    buffer.put(<span class=\"number\">44</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Position: \"</span> + buffer.position());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">    buffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (buffer.hasRemaining()) &#123;</span><br><span class=\"line\">        System.out.print(buffer.get() + <span class=\"string\">\"  \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<blockquote>\n<p>Capacity &amp; Limit: 4 4<br>Position: 4<br>11  22  33  44</p>\n</blockquote>\n<h2 id=\"Channel-通道\"><a href=\"#Channel-通道\" class=\"headerlink\" title=\"Channel 通道\"></a>Channel 通道</h2><ul>\n<li>Java NIO 的核心概念，表示的是对支持 I/O 操作的实体的一个连接</li>\n<li>通过它可以读取和写入数据（并不是直接操作，而是通过 Buffer 来处理）</li>\n<li>双向的</li>\n</ul>\n<p>常用的 Channel 包括：</p>\n<ul>\n<li>FileChannel 从文件中读写数据</li>\n<li>DatagramChannel 从 UDP 中读写数据</li>\n<li>SocketChannel 从 TCP 中读写数据</li>\n<li>ServerSocketChannel 监听新进来的 TCP 连接，每一个新进来的连接都会创建一个 SocketChannel。</li>\n</ul>\n<h3 id=\"FileChannel-连接到文件的通道\"><a href=\"#FileChannel-连接到文件的通道\" class=\"headerlink\" title=\"FileChannel 连接到文件的通道\"></a>FileChannel 连接到文件的通道</h3><p><strong>FileChannel 无法设置为非阻塞模式，只能运行在阻塞模式下</strong><br>常用方法：</p>\n<ul>\n<li><code>int read(ByteBuffer dst)</code> 从 Channel 中读取数据，写入 Buffer</li>\n<li><code>int write(ByteBuffer src)</code> 从 Buffer 中读取数据，写入 Channel</li>\n<li><code>long size()</code> 得到 Channel 中文件的大小</li>\n<li><code>long position()</code> 得到 Channel 中文件的当前操作位置</li>\n<li><code>FileChannel position(long newPosition)</code> 设置 Channel 中文件的当前操作位置</li>\n</ul>\n<p>使用 FileChannel 来复制文件的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 通过 InputStream 或者 OutputStream 来构造 FileChannel</span></span><br><span class=\"line\">    FileChannel in = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"a.txt\"</span>).getChannel();</span><br><span class=\"line\">    FileChannel out = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"b.txt\"</span>).getChannel();</span><br><span class=\"line\"></span><br><span class=\"line\">    ByteBuffer buffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用 channel 的 read 方法往 Buffer 中写数据</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(in.read(buffer) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\">        <span class=\"comment\">// 从 Buffer 中读数据，写入到 channel</span></span><br><span class=\"line\">        out.write(buffer);</span><br><span class=\"line\">        <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 或者使用如下代码</span></span><br><span class=\"line\">    <span class=\"comment\">// out.transferFrom(in, 0, in.size());</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"SocketChannel-连接到-TCP-套接字的通道\"><a href=\"#SocketChannel-连接到-TCP-套接字的通道\" class=\"headerlink\" title=\"SocketChannel 连接到 TCP 套接字的通道\"></a>SocketChannel 连接到 TCP 套接字的通道</h3><p><strong>SocketChannel 可以设置为阻塞模式或非阻塞模式</strong><br>使用 SocketChannel 来建立 TCP 连接，发送并接收数据，默认使用 <strong>阻塞模式</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 打开 SocketChannel</span></span><br><span class=\"line\">    SocketChannel channel = SocketChannel.open();</span><br><span class=\"line\">    <span class=\"comment\">// connect 方法会阻塞，直至连接建立成功</span></span><br><span class=\"line\">    channel.connect(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">\"127.0.0.1\"</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ByteBuffer buffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送数据</span></span><br><span class=\"line\">    String msg = <span class=\"string\">\"This is client.\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">    buffer.clear();</span><br><span class=\"line\">    buffer.put(msg.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">    buffer.flip();</span><br><span class=\"line\">    channel.write(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 接收数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">    buffer.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用 channel 的 read 方法往 Buffer 中写数据</span></span><br><span class=\"line\">    channel.read(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">    buffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从 Buffer 中读数据</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (buffer.hasRemaining()) &#123;</span><br><span class=\"line\">        System.out.print(buffer.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 SocketChannel 的 <strong>非阻塞模式</strong> 来建立 TCP 连接，发送并接收数据：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 打开 SocketChannel</span></span><br><span class=\"line\">    SocketChannel channel = SocketChannel.open();</span><br><span class=\"line\"></span><br><span class=\"line\">    channel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    channel.connect(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">\"127.0.0.1\"</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ByteBuffer buffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!channel.finishConnect()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发送数据</span></span><br><span class=\"line\">        String msg = <span class=\"string\">\"This is client.\"</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\">        buffer.put(msg.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\">        channel.write(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收数据</span></span><br><span class=\"line\">        <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 channel 的 read 方法往 Buffer 中写数据</span></span><br><span class=\"line\">        channel.read(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从 Buffer 中读数据</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (buffer.hasRemaining()) &#123;</span><br><span class=\"line\">            System.out.print(buffer.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ServerSocketChannel-监听-TCP-连接的通道\"><a href=\"#ServerSocketChannel-监听-TCP-连接的通道\" class=\"headerlink\" title=\"ServerSocketChannel 监听 TCP 连接的通道\"></a>ServerSocketChannel 监听 TCP 连接的通道</h3><p><strong>ServerSocketChannel 可以设置为阻塞模式或非阻塞模式</strong><br>使用 ServerSocketChannel 来监听 TCP 连接，默认使用 <strong>阻塞模式</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 打开 SocketChannel</span></span><br><span class=\"line\">    ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class=\"line\">    <span class=\"comment\">// 绑定端口</span></span><br><span class=\"line\">    channel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    ByteBuffer buffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// accept 方法会阻塞，直至监听到 TCP 连接</span></span><br><span class=\"line\">        SocketChannel socketChannel = channel.accept();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"A new connection...\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 接收数据</span></span><br><span class=\"line\">        <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用 channel 的 read 方法往 Buffer 中写数据</span></span><br><span class=\"line\">        socketChannel.read(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 从 Buffer 中读数据</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (buffer.hasRemaining()) &#123;</span><br><span class=\"line\">            System.out.print(buffer.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">        <span class=\"comment\">// 发送数据</span></span><br><span class=\"line\">        String msg = <span class=\"string\">\"This is server.\"</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\">        buffer.put(msg.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\">        socketChannel.write(buffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Selector-选择器\"><a href=\"#Selector-选择器\" class=\"headerlink\" title=\"Selector 选择器\"></a>Selector 选择器</h2><p><strong>Selector 允许单个进程可以同时处理多个网络连接的 IO，即监听多个端口的 Channel</strong>。</p>\n<p><strong>关于 IO 模式，参见 Linux IO 模型 中对多路复用 IO Multiplexing IO 的说明。</strong></p>\n<p>引用：</p>\n<hr>\n<h2 id=\"多路复用-IO-Multiplexing-IO\"><a href=\"#多路复用-IO-Multiplexing-IO\" class=\"headerlink\" title=\"多路复用 IO Multiplexing IO\"></a>多路复用 IO Multiplexing IO</h2><ul>\n<li><strong>单个进程可以同时处理多个网络连接的 IO，即监听多个端口的 IO</strong></li>\n<li>适用于连接数很高的情况</li>\n<li>实现方式：select，poll，epoll 系统调用<ul>\n<li>注册多个端口的监听 Socket，比如 8080，8081</li>\n<li>当用户进程调用 select 方法后，整个用户进程被阻塞，OS 内核会监听所有注册的 Socket</li>\n<li>当任何一个端口的 Socket 中的数据准备好了（ 8080 或者 8081），select 方法就会返回</li>\n<li>随后用户进程再调用 read 操作，将数据从 OS 内核缓存区拷贝到应用程序的地址空间。</li>\n</ul>\n</li>\n<li>多路复用 IO 类似于 多线程结合阻塞 IO<ul>\n<li>要实现监听多个端口的 IO，还可以通过多线程的方式，每一个线程负责监听一个端口的 IO</li>\n<li>如果处理的连接数不是很高的话，使用 多路复用 IO 不一定比使用 <strong>多线程结合阻塞 IO</strong> 的服务器性能更好，可能延迟还更大</li>\n<li>多路复用 IO 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p><strong>Selector 使用步骤：</strong></p>\n<ul>\n<li><p><strong>创建 Selector</strong></p>\n</li>\n<li><p><strong>创建 Channel</strong>，可以创建多个 Channel，即监听多个端口，比如 8080，8081</p>\n</li>\n<li><p>将 Channel 注册到 Selector 中</p>\n<ul>\n<li><p>如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的, 即 <code>channel.configureBlocking(false);</code></p>\n</li>\n<li><p>因此 FileChannel 是不能够使用 Selector 的, 因为 FileChannel 都是阻塞的</p>\n</li>\n<li><p>注册时，需要指定了对 Channel 的什么事件感兴趣，包括：</p>\n<ul>\n<li>SelectionKey.OP_CONNECT：TCP 连接 <code>static final int OP_CONNECT = 1 &lt;&lt; 3;</code></li>\n<li>SelectionKey.OP_ACCEPT：确认 <code>static final int OP_ACCEPT = 1 &lt;&lt; 4;</code></li>\n<li>SelectionKey.OP_READ：读 <code>static final int OP_READ = 1 &lt;&lt; 0;</code></li>\n<li>SelectionKey.OP_WRITE：写 <code>static final int OP_WRITE = 1 &lt;&lt; 2;</code></li>\n<li>可以使用或运算 <strong>|</strong> 来组合，例如 <code>SelectionKey.OP_READ | SelectionKey.OP_WRITE</code></li>\n</ul>\n</li>\n<li><p>register 方法返回一个 SelectionKey 对象，包括：</p>\n<ul>\n<li><p><code>int interestOps()</code>：调用 register 注册 channel 时所设置的 interest set.</p>\n</li>\n<li><p>```java<br>int readyOps()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">      ：Channel 所准备好了的操作</span><br><span class=\"line\"></span><br><span class=\"line\">      - &#96;selectionKey.isAcceptable();&#96;</span><br><span class=\"line\">      - &#96;selectionKey.isConnectable();&#96;</span><br><span class=\"line\">      - &#96;selectionKey.isReadable();&#96;</span><br><span class=\"line\">      - &#96;selectionKey.isWritable();&#96;</span><br><span class=\"line\"></span><br><span class=\"line\">    - &#96;public abstract SelectableChannel channel();&#96;： 得到 Channel</span><br><span class=\"line\"></span><br><span class=\"line\">    - &#96;public abstract Selector selector();&#96;：得到 Selector</span><br><span class=\"line\"></span><br><span class=\"line\">    - &#96;public final Object attachment&#96;：得到附加对象</span><br><span class=\"line\"></span><br><span class=\"line\">- 不断重复：</span><br><span class=\"line\"></span><br><span class=\"line\">  - 调用 Selector 对象的 select() 方法，**该方法会阻塞，直至注册的事件发生**</span><br><span class=\"line\">  - **事件发生**，调用 Selector 对象的 selectedKeys() 方法获取 selected keys</span><br><span class=\"line\">  - 遍历每个 selected key:</span><br><span class=\"line\">    - 从 selected key 中获取对应的 Channel 并处理</span><br><span class=\"line\">    - 在 OP_ACCEPT 事件中, 从 key.channel() 返回的是 ServerSocketChannel</span><br><span class=\"line\">    - 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel</span><br><span class=\"line\"></span><br><span class=\"line\">- **关闭 Selector**</span><br><span class=\"line\"></span><br><span class=\"line\">示例：</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;java</span><br><span class=\"line\">public static void main(String args[]) throws Exception &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Selector</span><br><span class=\"line\">    Selector selector &#x3D; Selector.open();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Server Socket，监听端口 8080</span><br><span class=\"line\">    ServerSocketChannel serverChannel1 &#x3D; ServerSocketChannel.open();</span><br><span class=\"line\">    serverChannel1.socket().bind(new InetSocketAddress(8080));</span><br><span class=\"line\">    &#x2F;&#x2F; 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的</span><br><span class=\"line\">    serverChannel1.configureBlocking(false);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 创建 Server Socket，监听端口 8081</span><br><span class=\"line\">    ServerSocketChannel serverChannel2 &#x3D; ServerSocketChannel.open();</span><br><span class=\"line\">    serverChannel2.socket().bind(new InetSocketAddress(8081));</span><br><span class=\"line\">    &#x2F;&#x2F; 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的</span><br><span class=\"line\">    serverChannel2.configureBlocking(false);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 将 Channel 注册到 Selector 中</span><br><span class=\"line\">    serverChannel1.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">    serverChannel2.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 不断重复</span><br><span class=\"line\">    while (true) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 调用 Selector 对象的 select() 方法，该方法会阻塞，直至注册的事件发生</span><br><span class=\"line\">        selector.select();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 事件发生，调用 Selector 对象的 selectedKeys() 方法获取 selected keys</span><br><span class=\"line\">        Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 遍历每个 selected key:</span><br><span class=\"line\">        while (it.hasNext()) &#123;</span><br><span class=\"line\">            SelectionKey key &#x3D; it.next();</span><br><span class=\"line\"></span><br><span class=\"line\">            if (key.isAcceptable()) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 在 OP_ACCEPT 事件中, 从 key.channel() 返回的是 ServerSocketChannel</span><br><span class=\"line\">                ServerSocketChannel serverChannel &#x3D; (ServerSocketChannel) key.channel();</span><br><span class=\"line\"></span><br><span class=\"line\">                &#x2F;&#x2F; 调用 accept 方法获取 TCP 连接 SocketChanne</span><br><span class=\"line\">                SocketChannel clientChannel &#x3D; serverChannel.accept();</span><br><span class=\"line\">                clientChannel.configureBlocking(false);</span><br><span class=\"line\"></span><br><span class=\"line\">                &#x2F;&#x2F; 注册 SocketChannel</span><br><span class=\"line\">                clientChannel.register(key.selector(), SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class=\"line\"></span><br><span class=\"line\">                System.out.println(&quot;Accept event&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (key.isReadable()) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel</span><br><span class=\"line\">                SocketChannel clientChannel &#x3D; (SocketChannel) key.channel();</span><br><span class=\"line\">                System.out.println(&quot;Read event&quot;);</span><br><span class=\"line\">                &#x2F;&#x2F; 可以从 clientChannel 中读数据，通过 ByteBuffer</span><br><span class=\"line\">                &#x2F;&#x2F; TO DO</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (key.isWritable()) &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel</span><br><span class=\"line\">                SocketChannel clientChannel &#x3D; (SocketChannel) key.channel();</span><br><span class=\"line\">                System.out.println(&quot;Write event&quot;);</span><br><span class=\"line\">                &#x2F;&#x2F; 可以向 clientChannel 中写数据，通过 ByteBuffer</span><br><span class=\"line\">                &#x2F;&#x2F; TO DO</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"schedule","date":"2020-04-27T05:47:12.000Z","_content":"\n并发编程领域中**定时器** 相关内容经常被一些介绍并发编程书籍所遗忘，属于并发编程学习优先级较低的知识点。在JDK源码中有两种定时器实现，一种是JDK1.3引入的**\\*Timer**类*，它是一种基于单线程操作的简单任务调度器，虽然存在较多设计缺陷，但仍有很多应用场景和使用案例；另一种JDK1.5引入的**ScheduledThreadPoolExecutor**类，是一种基于线程池操作的较复杂任务调度器，同时也是官方推荐的任务调度器实现。\n\n定时器Timer，也称简单任务调度器。它由以下四个类组成，\n\n- 定时任务（TimerTask类）\n- 任务队列（TaskQueue类）\n- 定时线程（TimerThread类）\n- 定时器（Timer类）\n\n## **定时任务**\n\n```\npublic abstract class TimerTask implements Runnable {\n    final Object lock = new Object();\n\n    //任务状态\n    int state = VIRGIN;\n    static final int VIRGIN = 0;\n    static final int SCHEDULED   = 1;\n    static final int EXECUTED    = 2;\n    static final int CANCELLED   = 3;\n    \n    //下次执行时间\n    long nextExecutionTime;\n    //调度至执行间隔时间\n    long period = 0;\n}\n```\n\n抽象类TimerTask实现Runnable接口，表明该类作为定时任务模版，用户可以根据业务场景定义具体任务。TimerTask类要维护**任务状态** (state)、**任务下次执行时间**（nextExecutionTime）和**任务调度至执行的间隔时间**（period）。\n\n> 任务状态\n\n定时器任务生命周期中可能处于下表所示的4种不同的状态，在给定的时刻定时器任务只能处于其中一种状态。\n\n![timer task](/images/java_time_task.png)\n\n> 执行任务\n\nTimerTask类的抽象方法run来自Runnable接口，TimerTask并未实现该接口，延迟至子类实现。用户可在派生类中自定义任务逻辑。\n\n```\npublic abstract void run();\n```\n\n抽象类TimerTask的run方法并不一定要来源于Runnable接口，它并未接受线程调度，而是由TimerThread线程从TimerQueue中消费任务，然后直接调用TimerTask.run()执行任务。基于这种理解，TimerTask类完全可以像这样定义：\n\n```\npublic abstract class TimerTask {  // 舍去implement Runnable\n\n    //由抽象类自己定义,而非来自Runnable接口\n    public abstract void run();\n}\n```\n\nTimerTask类这种写法可以理解为被**过度设计**了，读者可思之。\n\n> 取消任务\n\n如果当前任务正处于SCHEDULED状态，允许撤销当前任务，置任务为CANCELLED状态，返回true表示任务撤销成功；若任务处于其它状态，也置任务为CANCELLED状态，并返回false表示任务撤销失败。\n\n```\npublic boolean cancel() {\n    synchronized(lock) {\n        boolean result = (state == SCHEDULED);\n        //实际上所有任务都能被取消\n        state = CANCELLED;\n        return result;\n    }\n}\n```\n\n调用TimerTask.cancel()，虽然对不同状态有不同的返回值，但不管什么状态都能够被取消。设计逻辑匪夷所思，我认为这种**设计不合理**，读者可思之。\n\n> 调度执行时间\n\nscheduledExecutionTime方法获取任务被调度后最近的开始执行时间点，保证调度时间在下次执行时间之前。\n\n```\npublic long scheduledExecutionTime() {\n    synchronized(lock) {\n        return (period < 0 ? \n            nextExecutionTime + period : nextExecutionTime - period);\n    }\n}\n```\n\n## **定时线程**\n\n从优先级队列里异步消费任务的操作由单线程完成。TimerThread是单线程，因此需要mainLoop循环逻辑来轮询消费任务队列。\n\n```\nclass TimerThread extends Thread {\n\n    boolean newTasksMayBeScheduled = true;\n\n    //内部维护一个队列\n    private TaskQueue queue;\n\n    TimerThread(TaskQueue queue) {\n        this.queue = queue;\n    }\n}\n```\n\n> 轮询任务\n\n```\n@Override\npublic void run() {\n    try {\n        //循环执行逻辑\n        mainLoop();\n    } finally {\n        synchronized(queue) {\n            newTasksMayBeScheduled = false;\n            //清空任务队列. 在结束循环后可能仍有任务被加入到队列,因此需要清空.\n            queue.clear();\n        }\n    }\n}\n\nprivate void mainLoop() {\n    while (true) {\n        try {\n            TimerTask task;\n            boolean taskFired;\n            synchronized(queue) {  \n                //若队列为空且定时器未被撤销,则挂起定时线程直至被唤醒       \n                while (queue.isEmpty() && newTasksMayBeScheduled) {                     \n                    queue.wait();\n                }\n                //若线程被唤醒后队列仍为空,则结束循环. 说明此时定时器被撤销.\n                if (queue.isEmpty()) {\n                    break;            \n                }    \n  \n                long currentTime, executionTime;\n                //获取最近执行时间任务\n                task = queue.getMin();\n                synchronized(task.lock) {\n                    //任务若被取消,则从队列中移除,并继续轮询\n                    if (task.state == TimerTask.CANCELLED) {\n                        queue.removeMin();\n                        continue;\n                    }\n\n                    currentTime = System.currentTimeMillis();\n                    executionTime = task.nextExecutionTime;\n                    //任务最近要执行\n                    if (taskFired = (executionTime<=currentTime)) {\n                        //若为非重复执行任务,从队列中移除该任务,并设置该任务状态为已执行\n                        if (task.period == 0) {\n                            queue.removeMin();\n                            task.state = TimerTask.EXECUTED;\n                        } else {\n                            //若为重复执行任务,则在指定时刻重新调度该任务\n                            queue.rescheduleMin(\n                                task.period<0 ? currentTime-task.period\n                                    : executionTime + task.period);                      \n                        }\n                    }\n                    //若最近无任务要执行,则等待至要执行任务的指定时刻\n                    if (!taskFired) {\n                        queue.wait(executionTime - currentTime);\n                    }\n                }\n            }\n                \n            //任务已释放,运行任务\n            if (taskFired) { \n                task.run();\n            }\n        } catch(InterruptedException e) {\n        }\n    }\n}\n```\n\n## **任务队列**\n\n任务队列是基于完全二叉树实现的小顶堆。队列初始容量为128，由于0位置不存储任务，因此实际初始容量为127，size表示队列的任务数。\n\n```\nclass TaskQueue {\n\n    //基于顺序表实现的定时任务队列\n    private TimerTask[] queue = new TimerTask[128];\n\n    //队列任务数\n    private int size = 0;\n}\n```\n\n> 查询容量\n\n查询队列任务数和判断队列是否为空都直接使用任务队列内部维护的size属性，因此这两个操作的时间复杂度为O(1)。\n\n```\n/** 队列任务数 */\nint size() { return size; }\n\n/** 队列是否为空 */\nboolean isEmpty() { return size==0; }\n```\n\n> 添加任务\n\n主线程向任务队列中注入新任务。如果当前任务队列容量已达极限，则在原容量基础上扩容一倍，并在任务队列末尾追加新任务，并根据任务执行时间作为优先级调整新任务在任务队列中的位置。\n\n```\n/** 新增任务并调整小顶堆 */\nvoid add(TimerTask task) {\n    //任务数达到队列最大容量,则扩容一倍\n    if (size + 1 == queue.length) {\n        queue = Arrays.copyOf(queue, 2*queue.length);\n    }\n    //添加任务\n    queue[++size] = task;\n    //向上调整任务\n    fixUp(size);\n}\n```\n\n![img](https://pic3.zhimg.com/80/v2-3e64d663f2d599d0c7b40a7464dd0072_720w.jpg)\n\n> 获取任务\n\n从任务队列中获取最近将要执行任务的时间复杂度为O(1)；获得指定位置任务的时间复杂度也是O(1)。\n\n```\n/** 获得下次执行时间最小的任务,即最小堆根结点 */\nTimerTask getMin() { return queue[1]; }\n\n/** 获得指定位置的任务 */\nTimerTask get(int i) { return queue[i]; }\n```\n\n![img](images/getmint_20200427144736.png)\n\n> 移除任务\n\n```\n/** 移除下次执行时间最小的任务,即移除堆顶任务 */\nvoid removeMin() {\n    queue[1] = queue[size];\n    queue[size--] = null;\n    fixDown(1);\n}\n```\n\n![img](https://pic4.zhimg.com/80/v2-d0a23892cf5a8aaef780bf8f0e6f0e33_720w.jpg)\n\n```\n/** 快速移除指定位置处任务 */\nvoid quickRemove(int i) {\n    assert i <= size;  //assert生效需要编译器开启断言功能\n    \n    //指定位置元素直接用最后元素代替,不需要向下调整\n    queue[i] = queue[size];\n    queue[size--] = null;\n}\n```\n\n![img](https://pic1.zhimg.com/80/v2-d72f08b8ae0fbaaa9a3da508f9e64b54_720w.jpg)\n\n```\n/** 清空任务队列 */\nvoid clear() {\n    for (int i=1; i<=size; i++)\n        queue[i] = null;\n    size = 0;\n}\n```\n\n> 重新调度任务\n\n重新调度任务不删除堆顶任务，而是将堆顶任务的nextExecutionTime加上period后得到新的nextExecutionTime值，然后根据任务优先级向下调整。\n\n```\nvoid rescheduleMin(long newTime) {\n    queue[1].nextExecutionTime = newTime;\n    fixDown(1);\n}\n```\n\n![img](https://pic3.zhimg.com/80/v2-26395bd09d3fc3d4fd4990a3707aa34a_720w.jpg)\n\n> 基础算法\n\n任务队列是优先级队列，基于顺序结构完全二叉树实现的小顶堆。优先级的依据是任务下次执行时间。\n\n![img](https://pic2.zhimg.com/80/v2-7dbfc6a56603dfc301213dd0ba8cfa0d_720w.jpg)\n\n```\n/** 提升优先级 */\nprivate void fixUp(int k) {\n    while (k > 1) {\n        //父结点位置\n        int j = k >> 1;\n        //如果父结点的下次任务执行时间小于当前结点下次任务执行时间,结束调整操作\n        if (queue[j].nextExecutionTime <= queue[k].nextExecutionTime) {\n            break;\n        }\n\n        //调整任务在任务队列中的位置\n        TimerTask tmp = queue[j];  \n        queue[j] = queue[k]; \n        queue[k] = tmp;\n        k = j;\n    }\n}\n```\n\n```\n/** 降低优先级 */\nprivate void fixDown(int k) {\n    int j;\n    while ((j = k << 1) <= size && j > 0) {\n        //选择左右两侧子结点,选择更小的交换位置\n        if (j < size && \n            queue[j].nextExecutionTime > queue[j+1].nextExecutionTime) {\n            j++; \n        }\n        if (queue[k].nextExecutionTime <= queue[j].nextExecutionTime) {\n            break;\n        }\n\n        //调整任务在任务队列中的位置\n        TimerTask tmp = queue[j];  \n        queue[j] = queue[k]; \n        queue[k] = tmp;\n        k = j;\n    }\n}\n```\n\n调整当前完全二叉树为最小堆。\n\n```\n/** 堆化 */\nvoid heapify() {\n    for (int i = size/2; i >= 1; i--) {\n        fixDown(i);\n    }\n}\n```\n\n## **定时器**\n\n一个定时器内部维护一个任务队列和一个定时线程。在Main线程往任务队列注入任务后，由定时线程异步轮询处理任务队列，这种处理方式实质上是异步串行方式，任务处理并发度为1。\n\n```\npublic class Timer {\n\n    /** 任务队列 */\n    private final TaskQueue queue = new TaskQueue();\n\n    /** 定时线程 */\n    private final TimerThread thread = new TimerThread(queue);\n}\n```\n\n> 构造器\n\n新建Timer实例，同时也新建了任务队列和定时线程，并启动定时线程。启动定时线程前可指定定时线程的名称，以及指定为后台线程。\n\n```\npublic Timer() {\n    this(\"Timer-\" + serialNumber());\n}\npublic Timer(boolean isDaemon) {\n    this(\"Timer-\" + serialNumber(), isDaemon);\n}\npublic Timer(String name) {\n    thread.setName(name);\n    thread.start();\n}\npublic Timer(String name, boolean isDaemon) {\n    thread.setName(name); \n    thread.setDaemon(isDaemon);\n    thread.start();\n}\n\n//单机序列号生成\nprivate final static AtomicInteger nextSerialNumber = new AtomicInteger(0);\nprivate static int serialNumber() {\n    return nextSerialNumber.getAndIncrement();\n}\n```\n\n> 定间隔调度\n\n```\n/** 延迟调度 */\npublic void schedule(TimerTask task, long delay) {\n    if (delay < 0)\n        throw new IllegalArgumentException(\"Negative delay.\");\n\n    //从当前时间开始延时delay毫秒后调度\n    sched(task, System.currentTimeMillis()+delay, 0);\n}\n\n/** 定时调度 */\npublic void schedule(TimerTask task, Date time) {\n\n    //从指定时刻出开始调度\n    sched(task, time.getTime(), 0);\n}\n\n/** 延时周期性调度 */\npublic void schedule(TimerTask task, long delay, long period) {\n    if (delay < 0)\n        throw new IllegalArgumentException(\"Negative delay.\");\n    if (period <= 0)\n        throw new IllegalArgumentException(\"Non-positive period.\");\n    sched(task, System.currentTimeMillis()+delay, -period);\n}\n\n/** 定时周期性调度 */\npublic void schedule(TimerTask task, Date firstTime, long period) {\n    if (period <= 0)\n        throw new IllegalArgumentException(\"Non-positive period.\");\n    sched(task, firstTime.getTime(), -period);\n}\n```\n\nTimer.schedule()侧重period时间的一致性，保证执行任务的间隔时间相同。\n\n![img](https://pic3.zhimg.com/80/v2-367f6ca013b337ab1d2f2547ed871766_720w.png)\n\n> 定频率调度\n\n```\n/** 延时周期性定速调度 */\npublic void scheduleAtFixedRate(TimerTask task, long delay, long period) {\n    if (delay < 0)\n        throw new IllegalArgumentException(\"Negative delay.\");\n    if (period <= 0)\n        throw new IllegalArgumentException(\"Non-positive period.\");\n    sched(task, System.currentTimeMillis()+delay, period);\n}\n\n/** 定时周期性定速调度 */\npublic void scheduleAtFixedRate(TimerTask task, Date firstTime, long period) {\n    if (period <= 0)\n        throw new IllegalArgumentException(\"Non-positive period.\");\n    sched(task, firstTime.getTime(), period);\n}\n```\n\nTimer.scheduleAtFixedRate()侧重执行频率的一致性，任务执行时间加period时间的和相等。\n\n![img](https://pic4.zhimg.com/80/v2-493048111335ad7f57c1f51a29b37753_720w.png)\n\n> 核心调度算法\n\n```\nprivate void sched(TimerTask task, long time, long period) {\n    if (time < 0)\n        throw new IllegalArgumentException(\"Illegal execution time.\");      \n    if (Math.abs(period) > (Long.MAX_VALUE >> 1))\n        period >>= 1;\n\n    synchronized(queue) {\n\n        //保证定时器未被取消\n        if (!thread.newTasksMayBeScheduled) {\n            throw new IllegalStateException(\"Timer already cancelled.\");\n        }\n\n        synchronized(task.lock) {\n            //保证任务最初处于未使用状态\n            if (task.state != TimerTask.VIRGIN) {\n                throw new IllegalStateException(\n                    \"Task already scheduled or cancelled\");\n            }\n\n            //下次任务执行时间\n            task.nextExecutionTime = time;\n            //任务执行周期\n            task.period = period;\n            //设置任务状态为已调度\n            task.state = TimerTask.SCHEDULED;\n        }\n\n        //往任务队列中添加任务\n        queue.add(task);\n\n        //如果队列中该任务为最近要执行的任务,则立即唤醒定时线程处理\n        if (queue.getMin() == task) {\n            queue.notify();\n        }\n    }\n}\n```\n\n> 撤销定时器\n\n```\npublic void cancel() {\n    synchronized(queue) {\n        //撤销定时器\n        thread.newTasksMayBeScheduled = false;\n        //清空任务队列\n        queue.clear();\n        //唤醒定时线程\n        queue.notify();\n    }\n}\n```\n\n> 清理取消状态的任务\n\n```\npublic int purge() {\n    //从队列中移除的任务数\n    int result = 0;\n    synchronized(queue) {\n        for (int i = queue.size(); i > 0; i--) {\n            //从队列中移除取消状态任务\n            if (queue.get(i).state == TimerTask.CANCELLED) {\n                queue.quickRemove(i);\n                result++;\n            }\n        }\n        //如果仍有非取消任务,队列重新堆化\n        if (result != 0)\n            queue.heapify();\n    }\n    return result;\n}\n```\n\n## **总结**\n\n读完源码后总结如下，\n\n> 数据结构\n\n小顶堆实现优先级队列，优先级标准是任务下次执行时间。\n\n> 任务状态转换\n\n![img](https://pic3.zhimg.com/80/v2-ad4c978cc45c7a22464335345f525932_720w.jpg)\n\n> 定时器架构图\n\n![img](https://pic3.zhimg.com/80/v2-08da55ef92a07ae0f90a07f18521bb8e_720w.jpg)\n\n> 架构缺陷\n\n单线程串行消费任务，前置任务消费延迟或失败会直接影响后续任务的消费。如果消费前置任务时抛出异常，线程退出，队列中的任务无法被继续消费，定时器失效。","source":"_posts/java/schedule.md","raw":"---\ntitle: schedule\ntags:\n  - java\n  - schedule\ncategories:\n  - java\n  - schedule\ndate: 2020-04-27 13:47:12\n---\n\n并发编程领域中**定时器** 相关内容经常被一些介绍并发编程书籍所遗忘，属于并发编程学习优先级较低的知识点。在JDK源码中有两种定时器实现，一种是JDK1.3引入的**\\*Timer**类*，它是一种基于单线程操作的简单任务调度器，虽然存在较多设计缺陷，但仍有很多应用场景和使用案例；另一种JDK1.5引入的**ScheduledThreadPoolExecutor**类，是一种基于线程池操作的较复杂任务调度器，同时也是官方推荐的任务调度器实现。\n\n定时器Timer，也称简单任务调度器。它由以下四个类组成，\n\n- 定时任务（TimerTask类）\n- 任务队列（TaskQueue类）\n- 定时线程（TimerThread类）\n- 定时器（Timer类）\n\n## **定时任务**\n\n```\npublic abstract class TimerTask implements Runnable {\n    final Object lock = new Object();\n\n    //任务状态\n    int state = VIRGIN;\n    static final int VIRGIN = 0;\n    static final int SCHEDULED   = 1;\n    static final int EXECUTED    = 2;\n    static final int CANCELLED   = 3;\n    \n    //下次执行时间\n    long nextExecutionTime;\n    //调度至执行间隔时间\n    long period = 0;\n}\n```\n\n抽象类TimerTask实现Runnable接口，表明该类作为定时任务模版，用户可以根据业务场景定义具体任务。TimerTask类要维护**任务状态** (state)、**任务下次执行时间**（nextExecutionTime）和**任务调度至执行的间隔时间**（period）。\n\n> 任务状态\n\n定时器任务生命周期中可能处于下表所示的4种不同的状态，在给定的时刻定时器任务只能处于其中一种状态。\n\n![timer task](/images/java_time_task.png)\n\n> 执行任务\n\nTimerTask类的抽象方法run来自Runnable接口，TimerTask并未实现该接口，延迟至子类实现。用户可在派生类中自定义任务逻辑。\n\n```\npublic abstract void run();\n```\n\n抽象类TimerTask的run方法并不一定要来源于Runnable接口，它并未接受线程调度，而是由TimerThread线程从TimerQueue中消费任务，然后直接调用TimerTask.run()执行任务。基于这种理解，TimerTask类完全可以像这样定义：\n\n```\npublic abstract class TimerTask {  // 舍去implement Runnable\n\n    //由抽象类自己定义,而非来自Runnable接口\n    public abstract void run();\n}\n```\n\nTimerTask类这种写法可以理解为被**过度设计**了，读者可思之。\n\n> 取消任务\n\n如果当前任务正处于SCHEDULED状态，允许撤销当前任务，置任务为CANCELLED状态，返回true表示任务撤销成功；若任务处于其它状态，也置任务为CANCELLED状态，并返回false表示任务撤销失败。\n\n```\npublic boolean cancel() {\n    synchronized(lock) {\n        boolean result = (state == SCHEDULED);\n        //实际上所有任务都能被取消\n        state = CANCELLED;\n        return result;\n    }\n}\n```\n\n调用TimerTask.cancel()，虽然对不同状态有不同的返回值，但不管什么状态都能够被取消。设计逻辑匪夷所思，我认为这种**设计不合理**，读者可思之。\n\n> 调度执行时间\n\nscheduledExecutionTime方法获取任务被调度后最近的开始执行时间点，保证调度时间在下次执行时间之前。\n\n```\npublic long scheduledExecutionTime() {\n    synchronized(lock) {\n        return (period < 0 ? \n            nextExecutionTime + period : nextExecutionTime - period);\n    }\n}\n```\n\n## **定时线程**\n\n从优先级队列里异步消费任务的操作由单线程完成。TimerThread是单线程，因此需要mainLoop循环逻辑来轮询消费任务队列。\n\n```\nclass TimerThread extends Thread {\n\n    boolean newTasksMayBeScheduled = true;\n\n    //内部维护一个队列\n    private TaskQueue queue;\n\n    TimerThread(TaskQueue queue) {\n        this.queue = queue;\n    }\n}\n```\n\n> 轮询任务\n\n```\n@Override\npublic void run() {\n    try {\n        //循环执行逻辑\n        mainLoop();\n    } finally {\n        synchronized(queue) {\n            newTasksMayBeScheduled = false;\n            //清空任务队列. 在结束循环后可能仍有任务被加入到队列,因此需要清空.\n            queue.clear();\n        }\n    }\n}\n\nprivate void mainLoop() {\n    while (true) {\n        try {\n            TimerTask task;\n            boolean taskFired;\n            synchronized(queue) {  \n                //若队列为空且定时器未被撤销,则挂起定时线程直至被唤醒       \n                while (queue.isEmpty() && newTasksMayBeScheduled) {                     \n                    queue.wait();\n                }\n                //若线程被唤醒后队列仍为空,则结束循环. 说明此时定时器被撤销.\n                if (queue.isEmpty()) {\n                    break;            \n                }    \n  \n                long currentTime, executionTime;\n                //获取最近执行时间任务\n                task = queue.getMin();\n                synchronized(task.lock) {\n                    //任务若被取消,则从队列中移除,并继续轮询\n                    if (task.state == TimerTask.CANCELLED) {\n                        queue.removeMin();\n                        continue;\n                    }\n\n                    currentTime = System.currentTimeMillis();\n                    executionTime = task.nextExecutionTime;\n                    //任务最近要执行\n                    if (taskFired = (executionTime<=currentTime)) {\n                        //若为非重复执行任务,从队列中移除该任务,并设置该任务状态为已执行\n                        if (task.period == 0) {\n                            queue.removeMin();\n                            task.state = TimerTask.EXECUTED;\n                        } else {\n                            //若为重复执行任务,则在指定时刻重新调度该任务\n                            queue.rescheduleMin(\n                                task.period<0 ? currentTime-task.period\n                                    : executionTime + task.period);                      \n                        }\n                    }\n                    //若最近无任务要执行,则等待至要执行任务的指定时刻\n                    if (!taskFired) {\n                        queue.wait(executionTime - currentTime);\n                    }\n                }\n            }\n                \n            //任务已释放,运行任务\n            if (taskFired) { \n                task.run();\n            }\n        } catch(InterruptedException e) {\n        }\n    }\n}\n```\n\n## **任务队列**\n\n任务队列是基于完全二叉树实现的小顶堆。队列初始容量为128，由于0位置不存储任务，因此实际初始容量为127，size表示队列的任务数。\n\n```\nclass TaskQueue {\n\n    //基于顺序表实现的定时任务队列\n    private TimerTask[] queue = new TimerTask[128];\n\n    //队列任务数\n    private int size = 0;\n}\n```\n\n> 查询容量\n\n查询队列任务数和判断队列是否为空都直接使用任务队列内部维护的size属性，因此这两个操作的时间复杂度为O(1)。\n\n```\n/** 队列任务数 */\nint size() { return size; }\n\n/** 队列是否为空 */\nboolean isEmpty() { return size==0; }\n```\n\n> 添加任务\n\n主线程向任务队列中注入新任务。如果当前任务队列容量已达极限，则在原容量基础上扩容一倍，并在任务队列末尾追加新任务，并根据任务执行时间作为优先级调整新任务在任务队列中的位置。\n\n```\n/** 新增任务并调整小顶堆 */\nvoid add(TimerTask task) {\n    //任务数达到队列最大容量,则扩容一倍\n    if (size + 1 == queue.length) {\n        queue = Arrays.copyOf(queue, 2*queue.length);\n    }\n    //添加任务\n    queue[++size] = task;\n    //向上调整任务\n    fixUp(size);\n}\n```\n\n![img](https://pic3.zhimg.com/80/v2-3e64d663f2d599d0c7b40a7464dd0072_720w.jpg)\n\n> 获取任务\n\n从任务队列中获取最近将要执行任务的时间复杂度为O(1)；获得指定位置任务的时间复杂度也是O(1)。\n\n```\n/** 获得下次执行时间最小的任务,即最小堆根结点 */\nTimerTask getMin() { return queue[1]; }\n\n/** 获得指定位置的任务 */\nTimerTask get(int i) { return queue[i]; }\n```\n\n![img](images/getmint_20200427144736.png)\n\n> 移除任务\n\n```\n/** 移除下次执行时间最小的任务,即移除堆顶任务 */\nvoid removeMin() {\n    queue[1] = queue[size];\n    queue[size--] = null;\n    fixDown(1);\n}\n```\n\n![img](https://pic4.zhimg.com/80/v2-d0a23892cf5a8aaef780bf8f0e6f0e33_720w.jpg)\n\n```\n/** 快速移除指定位置处任务 */\nvoid quickRemove(int i) {\n    assert i <= size;  //assert生效需要编译器开启断言功能\n    \n    //指定位置元素直接用最后元素代替,不需要向下调整\n    queue[i] = queue[size];\n    queue[size--] = null;\n}\n```\n\n![img](https://pic1.zhimg.com/80/v2-d72f08b8ae0fbaaa9a3da508f9e64b54_720w.jpg)\n\n```\n/** 清空任务队列 */\nvoid clear() {\n    for (int i=1; i<=size; i++)\n        queue[i] = null;\n    size = 0;\n}\n```\n\n> 重新调度任务\n\n重新调度任务不删除堆顶任务，而是将堆顶任务的nextExecutionTime加上period后得到新的nextExecutionTime值，然后根据任务优先级向下调整。\n\n```\nvoid rescheduleMin(long newTime) {\n    queue[1].nextExecutionTime = newTime;\n    fixDown(1);\n}\n```\n\n![img](https://pic3.zhimg.com/80/v2-26395bd09d3fc3d4fd4990a3707aa34a_720w.jpg)\n\n> 基础算法\n\n任务队列是优先级队列，基于顺序结构完全二叉树实现的小顶堆。优先级的依据是任务下次执行时间。\n\n![img](https://pic2.zhimg.com/80/v2-7dbfc6a56603dfc301213dd0ba8cfa0d_720w.jpg)\n\n```\n/** 提升优先级 */\nprivate void fixUp(int k) {\n    while (k > 1) {\n        //父结点位置\n        int j = k >> 1;\n        //如果父结点的下次任务执行时间小于当前结点下次任务执行时间,结束调整操作\n        if (queue[j].nextExecutionTime <= queue[k].nextExecutionTime) {\n            break;\n        }\n\n        //调整任务在任务队列中的位置\n        TimerTask tmp = queue[j];  \n        queue[j] = queue[k]; \n        queue[k] = tmp;\n        k = j;\n    }\n}\n```\n\n```\n/** 降低优先级 */\nprivate void fixDown(int k) {\n    int j;\n    while ((j = k << 1) <= size && j > 0) {\n        //选择左右两侧子结点,选择更小的交换位置\n        if (j < size && \n            queue[j].nextExecutionTime > queue[j+1].nextExecutionTime) {\n            j++; \n        }\n        if (queue[k].nextExecutionTime <= queue[j].nextExecutionTime) {\n            break;\n        }\n\n        //调整任务在任务队列中的位置\n        TimerTask tmp = queue[j];  \n        queue[j] = queue[k]; \n        queue[k] = tmp;\n        k = j;\n    }\n}\n```\n\n调整当前完全二叉树为最小堆。\n\n```\n/** 堆化 */\nvoid heapify() {\n    for (int i = size/2; i >= 1; i--) {\n        fixDown(i);\n    }\n}\n```\n\n## **定时器**\n\n一个定时器内部维护一个任务队列和一个定时线程。在Main线程往任务队列注入任务后，由定时线程异步轮询处理任务队列，这种处理方式实质上是异步串行方式，任务处理并发度为1。\n\n```\npublic class Timer {\n\n    /** 任务队列 */\n    private final TaskQueue queue = new TaskQueue();\n\n    /** 定时线程 */\n    private final TimerThread thread = new TimerThread(queue);\n}\n```\n\n> 构造器\n\n新建Timer实例，同时也新建了任务队列和定时线程，并启动定时线程。启动定时线程前可指定定时线程的名称，以及指定为后台线程。\n\n```\npublic Timer() {\n    this(\"Timer-\" + serialNumber());\n}\npublic Timer(boolean isDaemon) {\n    this(\"Timer-\" + serialNumber(), isDaemon);\n}\npublic Timer(String name) {\n    thread.setName(name);\n    thread.start();\n}\npublic Timer(String name, boolean isDaemon) {\n    thread.setName(name); \n    thread.setDaemon(isDaemon);\n    thread.start();\n}\n\n//单机序列号生成\nprivate final static AtomicInteger nextSerialNumber = new AtomicInteger(0);\nprivate static int serialNumber() {\n    return nextSerialNumber.getAndIncrement();\n}\n```\n\n> 定间隔调度\n\n```\n/** 延迟调度 */\npublic void schedule(TimerTask task, long delay) {\n    if (delay < 0)\n        throw new IllegalArgumentException(\"Negative delay.\");\n\n    //从当前时间开始延时delay毫秒后调度\n    sched(task, System.currentTimeMillis()+delay, 0);\n}\n\n/** 定时调度 */\npublic void schedule(TimerTask task, Date time) {\n\n    //从指定时刻出开始调度\n    sched(task, time.getTime(), 0);\n}\n\n/** 延时周期性调度 */\npublic void schedule(TimerTask task, long delay, long period) {\n    if (delay < 0)\n        throw new IllegalArgumentException(\"Negative delay.\");\n    if (period <= 0)\n        throw new IllegalArgumentException(\"Non-positive period.\");\n    sched(task, System.currentTimeMillis()+delay, -period);\n}\n\n/** 定时周期性调度 */\npublic void schedule(TimerTask task, Date firstTime, long period) {\n    if (period <= 0)\n        throw new IllegalArgumentException(\"Non-positive period.\");\n    sched(task, firstTime.getTime(), -period);\n}\n```\n\nTimer.schedule()侧重period时间的一致性，保证执行任务的间隔时间相同。\n\n![img](https://pic3.zhimg.com/80/v2-367f6ca013b337ab1d2f2547ed871766_720w.png)\n\n> 定频率调度\n\n```\n/** 延时周期性定速调度 */\npublic void scheduleAtFixedRate(TimerTask task, long delay, long period) {\n    if (delay < 0)\n        throw new IllegalArgumentException(\"Negative delay.\");\n    if (period <= 0)\n        throw new IllegalArgumentException(\"Non-positive period.\");\n    sched(task, System.currentTimeMillis()+delay, period);\n}\n\n/** 定时周期性定速调度 */\npublic void scheduleAtFixedRate(TimerTask task, Date firstTime, long period) {\n    if (period <= 0)\n        throw new IllegalArgumentException(\"Non-positive period.\");\n    sched(task, firstTime.getTime(), period);\n}\n```\n\nTimer.scheduleAtFixedRate()侧重执行频率的一致性，任务执行时间加period时间的和相等。\n\n![img](https://pic4.zhimg.com/80/v2-493048111335ad7f57c1f51a29b37753_720w.png)\n\n> 核心调度算法\n\n```\nprivate void sched(TimerTask task, long time, long period) {\n    if (time < 0)\n        throw new IllegalArgumentException(\"Illegal execution time.\");      \n    if (Math.abs(period) > (Long.MAX_VALUE >> 1))\n        period >>= 1;\n\n    synchronized(queue) {\n\n        //保证定时器未被取消\n        if (!thread.newTasksMayBeScheduled) {\n            throw new IllegalStateException(\"Timer already cancelled.\");\n        }\n\n        synchronized(task.lock) {\n            //保证任务最初处于未使用状态\n            if (task.state != TimerTask.VIRGIN) {\n                throw new IllegalStateException(\n                    \"Task already scheduled or cancelled\");\n            }\n\n            //下次任务执行时间\n            task.nextExecutionTime = time;\n            //任务执行周期\n            task.period = period;\n            //设置任务状态为已调度\n            task.state = TimerTask.SCHEDULED;\n        }\n\n        //往任务队列中添加任务\n        queue.add(task);\n\n        //如果队列中该任务为最近要执行的任务,则立即唤醒定时线程处理\n        if (queue.getMin() == task) {\n            queue.notify();\n        }\n    }\n}\n```\n\n> 撤销定时器\n\n```\npublic void cancel() {\n    synchronized(queue) {\n        //撤销定时器\n        thread.newTasksMayBeScheduled = false;\n        //清空任务队列\n        queue.clear();\n        //唤醒定时线程\n        queue.notify();\n    }\n}\n```\n\n> 清理取消状态的任务\n\n```\npublic int purge() {\n    //从队列中移除的任务数\n    int result = 0;\n    synchronized(queue) {\n        for (int i = queue.size(); i > 0; i--) {\n            //从队列中移除取消状态任务\n            if (queue.get(i).state == TimerTask.CANCELLED) {\n                queue.quickRemove(i);\n                result++;\n            }\n        }\n        //如果仍有非取消任务,队列重新堆化\n        if (result != 0)\n            queue.heapify();\n    }\n    return result;\n}\n```\n\n## **总结**\n\n读完源码后总结如下，\n\n> 数据结构\n\n小顶堆实现优先级队列，优先级标准是任务下次执行时间。\n\n> 任务状态转换\n\n![img](https://pic3.zhimg.com/80/v2-ad4c978cc45c7a22464335345f525932_720w.jpg)\n\n> 定时器架构图\n\n![img](https://pic3.zhimg.com/80/v2-08da55ef92a07ae0f90a07f18521bb8e_720w.jpg)\n\n> 架构缺陷\n\n单线程串行消费任务，前置任务消费延迟或失败会直接影响后续任务的消费。如果消费前置任务时抛出异常，线程退出，队列中的任务无法被继续消费，定时器失效。","slug":"java/schedule","published":1,"updated":"2020-04-27T06:48:21.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7lr005nvgjad9ex18l8","content":"<p>并发编程领域中<strong>定时器</strong> 相关内容经常被一些介绍并发编程书籍所遗忘，属于并发编程学习优先级较低的知识点。在JDK源码中有两种定时器实现，一种是JDK1.3引入的<strong>*Timer</strong>类<em>，它是一种基于单线程操作的简单任务调度器，虽然存在较多设计缺陷，但仍有很多应用场景和使用案例；另一种JDK1.5引入的*</em>ScheduledThreadPoolExecutor**类，是一种基于线程池操作的较复杂任务调度器，同时也是官方推荐的任务调度器实现。</p>\n<p>定时器Timer，也称简单任务调度器。它由以下四个类组成，</p>\n<ul>\n<li>定时任务（TimerTask类）</li>\n<li>任务队列（TaskQueue类）</li>\n<li>定时线程（TimerThread类）</li>\n<li>定时器（Timer类）</li>\n</ul>\n<h2 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a><strong>定时任务</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class TimerTask implements Runnable &#123;</span><br><span class=\"line\">    final Object lock &#x3D; new Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;任务状态</span><br><span class=\"line\">    int state &#x3D; VIRGIN;</span><br><span class=\"line\">    static final int VIRGIN &#x3D; 0;</span><br><span class=\"line\">    static final int SCHEDULED   &#x3D; 1;</span><br><span class=\"line\">    static final int EXECUTED    &#x3D; 2;</span><br><span class=\"line\">    static final int CANCELLED   &#x3D; 3;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F;下次执行时间</span><br><span class=\"line\">    long nextExecutionTime;</span><br><span class=\"line\">    &#x2F;&#x2F;调度至执行间隔时间</span><br><span class=\"line\">    long period &#x3D; 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>抽象类TimerTask实现Runnable接口，表明该类作为定时任务模版，用户可以根据业务场景定义具体任务。TimerTask类要维护<strong>任务状态</strong> (state)、<strong>任务下次执行时间</strong>（nextExecutionTime）和<strong>任务调度至执行的间隔时间</strong>（period）。</p>\n<blockquote>\n<p>任务状态</p>\n</blockquote>\n<p>定时器任务生命周期中可能处于下表所示的4种不同的状态，在给定的时刻定时器任务只能处于其中一种状态。</p>\n<p><img src=\"/images/java_time_task.png\" alt=\"timer task\"></p>\n<blockquote>\n<p>执行任务</p>\n</blockquote>\n<p>TimerTask类的抽象方法run来自Runnable接口，TimerTask并未实现该接口，延迟至子类实现。用户可在派生类中自定义任务逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract void run();</span><br></pre></td></tr></table></figure>\n\n<p>抽象类TimerTask的run方法并不一定要来源于Runnable接口，它并未接受线程调度，而是由TimerThread线程从TimerQueue中消费任务，然后直接调用TimerTask.run()执行任务。基于这种理解，TimerTask类完全可以像这样定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class TimerTask &#123;  &#x2F;&#x2F; 舍去implement Runnable</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;由抽象类自己定义,而非来自Runnable接口</span><br><span class=\"line\">    public abstract void run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TimerTask类这种写法可以理解为被<strong>过度设计</strong>了，读者可思之。</p>\n<blockquote>\n<p>取消任务</p>\n</blockquote>\n<p>如果当前任务正处于SCHEDULED状态，允许撤销当前任务，置任务为CANCELLED状态，返回true表示任务撤销成功；若任务处于其它状态，也置任务为CANCELLED状态，并返回false表示任务撤销失败。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean cancel() &#123;</span><br><span class=\"line\">    synchronized(lock) &#123;</span><br><span class=\"line\">        boolean result &#x3D; (state &#x3D;&#x3D; SCHEDULED);</span><br><span class=\"line\">        &#x2F;&#x2F;实际上所有任务都能被取消</span><br><span class=\"line\">        state &#x3D; CANCELLED;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用TimerTask.cancel()，虽然对不同状态有不同的返回值，但不管什么状态都能够被取消。设计逻辑匪夷所思，我认为这种<strong>设计不合理</strong>，读者可思之。</p>\n<blockquote>\n<p>调度执行时间</p>\n</blockquote>\n<p>scheduledExecutionTime方法获取任务被调度后最近的开始执行时间点，保证调度时间在下次执行时间之前。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public long scheduledExecutionTime() &#123;</span><br><span class=\"line\">    synchronized(lock) &#123;</span><br><span class=\"line\">        return (period &lt; 0 ? </span><br><span class=\"line\">            nextExecutionTime + period : nextExecutionTime - period);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定时线程\"><a href=\"#定时线程\" class=\"headerlink\" title=\"定时线程\"></a><strong>定时线程</strong></h2><p>从优先级队列里异步消费任务的操作由单线程完成。TimerThread是单线程，因此需要mainLoop循环逻辑来轮询消费任务队列。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TimerThread extends Thread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean newTasksMayBeScheduled &#x3D; true;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;内部维护一个队列</span><br><span class=\"line\">    private TaskQueue queue;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimerThread(TaskQueue queue) &#123;</span><br><span class=\"line\">        this.queue &#x3D; queue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>轮询任务</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;循环执行逻辑</span><br><span class=\"line\">        mainLoop();</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        synchronized(queue) &#123;</span><br><span class=\"line\">            newTasksMayBeScheduled &#x3D; false;</span><br><span class=\"line\">            &#x2F;&#x2F;清空任务队列. 在结束循环后可能仍有任务被加入到队列,因此需要清空.</span><br><span class=\"line\">            queue.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void mainLoop() &#123;</span><br><span class=\"line\">    while (true) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            TimerTask task;</span><br><span class=\"line\">            boolean taskFired;</span><br><span class=\"line\">            synchronized(queue) &#123;  </span><br><span class=\"line\">                &#x2F;&#x2F;若队列为空且定时器未被撤销,则挂起定时线程直至被唤醒       </span><br><span class=\"line\">                while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled) &#123;                     </span><br><span class=\"line\">                    queue.wait();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                &#x2F;&#x2F;若线程被唤醒后队列仍为空,则结束循环. 说明此时定时器被撤销.</span><br><span class=\"line\">                if (queue.isEmpty()) &#123;</span><br><span class=\"line\">                    break;            </span><br><span class=\"line\">                &#125;    </span><br><span class=\"line\">  </span><br><span class=\"line\">                long currentTime, executionTime;</span><br><span class=\"line\">                &#x2F;&#x2F;获取最近执行时间任务</span><br><span class=\"line\">                task &#x3D; queue.getMin();</span><br><span class=\"line\">                synchronized(task.lock) &#123;</span><br><span class=\"line\">                    &#x2F;&#x2F;任务若被取消,则从队列中移除,并继续轮询</span><br><span class=\"line\">                    if (task.state &#x3D;&#x3D; TimerTask.CANCELLED) &#123;</span><br><span class=\"line\">                        queue.removeMin();</span><br><span class=\"line\">                        continue;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    currentTime &#x3D; System.currentTimeMillis();</span><br><span class=\"line\">                    executionTime &#x3D; task.nextExecutionTime;</span><br><span class=\"line\">                    &#x2F;&#x2F;任务最近要执行</span><br><span class=\"line\">                    if (taskFired &#x3D; (executionTime&lt;&#x3D;currentTime)) &#123;</span><br><span class=\"line\">                        &#x2F;&#x2F;若为非重复执行任务,从队列中移除该任务,并设置该任务状态为已执行</span><br><span class=\"line\">                        if (task.period &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">                            queue.removeMin();</span><br><span class=\"line\">                            task.state &#x3D; TimerTask.EXECUTED;</span><br><span class=\"line\">                        &#125; else &#123;</span><br><span class=\"line\">                            &#x2F;&#x2F;若为重复执行任务,则在指定时刻重新调度该任务</span><br><span class=\"line\">                            queue.rescheduleMin(</span><br><span class=\"line\">                                task.period&lt;0 ? currentTime-task.period</span><br><span class=\"line\">                                    : executionTime + task.period);                      </span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    &#x2F;&#x2F;若最近无任务要执行,则等待至要执行任务的指定时刻</span><br><span class=\"line\">                    if (!taskFired) &#123;</span><br><span class=\"line\">                        queue.wait(executionTime - currentTime);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#x2F;&#x2F;任务已释放,运行任务</span><br><span class=\"line\">            if (taskFired) &#123; </span><br><span class=\"line\">                task.run();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch(InterruptedException e) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a><strong>任务队列</strong></h2><p>任务队列是基于完全二叉树实现的小顶堆。队列初始容量为128，由于0位置不存储任务，因此实际初始容量为127，size表示队列的任务数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaskQueue &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;基于顺序表实现的定时任务队列</span><br><span class=\"line\">    private TimerTask[] queue &#x3D; new TimerTask[128];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;队列任务数</span><br><span class=\"line\">    private int size &#x3D; 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>查询容量</p>\n</blockquote>\n<p>查询队列任务数和判断队列是否为空都直接使用任务队列内部维护的size属性，因此这两个操作的时间复杂度为O(1)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 队列任务数 *&#x2F;</span><br><span class=\"line\">int size() &#123; return size; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 队列是否为空 *&#x2F;</span><br><span class=\"line\">boolean isEmpty() &#123; return size&#x3D;&#x3D;0; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>添加任务</p>\n</blockquote>\n<p>主线程向任务队列中注入新任务。如果当前任务队列容量已达极限，则在原容量基础上扩容一倍，并在任务队列末尾追加新任务，并根据任务执行时间作为优先级调整新任务在任务队列中的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 新增任务并调整小顶堆 *&#x2F;</span><br><span class=\"line\">void add(TimerTask task) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;任务数达到队列最大容量,则扩容一倍</span><br><span class=\"line\">    if (size + 1 &#x3D;&#x3D; queue.length) &#123;</span><br><span class=\"line\">        queue &#x3D; Arrays.copyOf(queue, 2*queue.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;添加任务</span><br><span class=\"line\">    queue[++size] &#x3D; task;</span><br><span class=\"line\">    &#x2F;&#x2F;向上调整任务</span><br><span class=\"line\">    fixUp(size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic3.zhimg.com/80/v2-3e64d663f2d599d0c7b40a7464dd0072_720w.jpg\" alt=\"img\"></p>\n<blockquote>\n<p>获取任务</p>\n</blockquote>\n<p>从任务队列中获取最近将要执行任务的时间复杂度为O(1)；获得指定位置任务的时间复杂度也是O(1)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 获得下次执行时间最小的任务,即最小堆根结点 *&#x2F;</span><br><span class=\"line\">TimerTask getMin() &#123; return queue[1]; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 获得指定位置的任务 *&#x2F;</span><br><span class=\"line\">TimerTask get(int i) &#123; return queue[i]; &#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"images/getmint_20200427144736.png\" alt=\"img\"></p>\n<blockquote>\n<p>移除任务</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 移除下次执行时间最小的任务,即移除堆顶任务 *&#x2F;</span><br><span class=\"line\">void removeMin() &#123;</span><br><span class=\"line\">    queue[1] &#x3D; queue[size];</span><br><span class=\"line\">    queue[size--] &#x3D; null;</span><br><span class=\"line\">    fixDown(1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic4.zhimg.com/80/v2-d0a23892cf5a8aaef780bf8f0e6f0e33_720w.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 快速移除指定位置处任务 *&#x2F;</span><br><span class=\"line\">void quickRemove(int i) &#123;</span><br><span class=\"line\">    assert i &lt;&#x3D; size;  &#x2F;&#x2F;assert生效需要编译器开启断言功能</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F;指定位置元素直接用最后元素代替,不需要向下调整</span><br><span class=\"line\">    queue[i] &#x3D; queue[size];</span><br><span class=\"line\">    queue[size--] &#x3D; null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic1.zhimg.com/80/v2-d72f08b8ae0fbaaa9a3da508f9e64b54_720w.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 清空任务队列 *&#x2F;</span><br><span class=\"line\">void clear() &#123;</span><br><span class=\"line\">    for (int i&#x3D;1; i&lt;&#x3D;size; i++)</span><br><span class=\"line\">        queue[i] &#x3D; null;</span><br><span class=\"line\">    size &#x3D; 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重新调度任务</p>\n</blockquote>\n<p>重新调度任务不删除堆顶任务，而是将堆顶任务的nextExecutionTime加上period后得到新的nextExecutionTime值，然后根据任务优先级向下调整。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void rescheduleMin(long newTime) &#123;</span><br><span class=\"line\">    queue[1].nextExecutionTime &#x3D; newTime;</span><br><span class=\"line\">    fixDown(1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic3.zhimg.com/80/v2-26395bd09d3fc3d4fd4990a3707aa34a_720w.jpg\" alt=\"img\"></p>\n<blockquote>\n<p>基础算法</p>\n</blockquote>\n<p>任务队列是优先级队列，基于顺序结构完全二叉树实现的小顶堆。优先级的依据是任务下次执行时间。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-7dbfc6a56603dfc301213dd0ba8cfa0d_720w.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 提升优先级 *&#x2F;</span><br><span class=\"line\">private void fixUp(int k) &#123;</span><br><span class=\"line\">    while (k &gt; 1) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;父结点位置</span><br><span class=\"line\">        int j &#x3D; k &gt;&gt; 1;</span><br><span class=\"line\">        &#x2F;&#x2F;如果父结点的下次任务执行时间小于当前结点下次任务执行时间,结束调整操作</span><br><span class=\"line\">        if (queue[j].nextExecutionTime &lt;&#x3D; queue[k].nextExecutionTime) &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;调整任务在任务队列中的位置</span><br><span class=\"line\">        TimerTask tmp &#x3D; queue[j];  </span><br><span class=\"line\">        queue[j] &#x3D; queue[k]; </span><br><span class=\"line\">        queue[k] &#x3D; tmp;</span><br><span class=\"line\">        k &#x3D; j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 降低优先级 *&#x2F;</span><br><span class=\"line\">private void fixDown(int k) &#123;</span><br><span class=\"line\">    int j;</span><br><span class=\"line\">    while ((j &#x3D; k &lt;&lt; 1) &lt;&#x3D; size &amp;&amp; j &gt; 0) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;选择左右两侧子结点,选择更小的交换位置</span><br><span class=\"line\">        if (j &lt; size &amp;&amp; </span><br><span class=\"line\">            queue[j].nextExecutionTime &gt; queue[j+1].nextExecutionTime) &#123;</span><br><span class=\"line\">            j++; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (queue[k].nextExecutionTime &lt;&#x3D; queue[j].nextExecutionTime) &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;调整任务在任务队列中的位置</span><br><span class=\"line\">        TimerTask tmp &#x3D; queue[j];  </span><br><span class=\"line\">        queue[j] &#x3D; queue[k]; </span><br><span class=\"line\">        queue[k] &#x3D; tmp;</span><br><span class=\"line\">        k &#x3D; j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调整当前完全二叉树为最小堆。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 堆化 *&#x2F;</span><br><span class=\"line\">void heapify() &#123;</span><br><span class=\"line\">    for (int i &#x3D; size&#x2F;2; i &gt;&#x3D; 1; i--) &#123;</span><br><span class=\"line\">        fixDown(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a><strong>定时器</strong></h2><p>一个定时器内部维护一个任务队列和一个定时线程。在Main线程往任务队列注入任务后，由定时线程异步轮询处理任务队列，这种处理方式实质上是异步串行方式，任务处理并发度为1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Timer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;** 任务队列 *&#x2F;</span><br><span class=\"line\">    private final TaskQueue queue &#x3D; new TaskQueue();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;** 定时线程 *&#x2F;</span><br><span class=\"line\">    private final TimerThread thread &#x3D; new TimerThread(queue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>构造器</p>\n</blockquote>\n<p>新建Timer实例，同时也新建了任务队列和定时线程，并启动定时线程。启动定时线程前可指定定时线程的名称，以及指定为后台线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Timer() &#123;</span><br><span class=\"line\">    this(&quot;Timer-&quot; + serialNumber());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public Timer(boolean isDaemon) &#123;</span><br><span class=\"line\">    this(&quot;Timer-&quot; + serialNumber(), isDaemon);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public Timer(String name) &#123;</span><br><span class=\"line\">    thread.setName(name);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public Timer(String name, boolean isDaemon) &#123;</span><br><span class=\"line\">    thread.setName(name); </span><br><span class=\"line\">    thread.setDaemon(isDaemon);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;单机序列号生成</span><br><span class=\"line\">private final static AtomicInteger nextSerialNumber &#x3D; new AtomicInteger(0);</span><br><span class=\"line\">private static int serialNumber() &#123;</span><br><span class=\"line\">    return nextSerialNumber.getAndIncrement();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>定间隔调度</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 延迟调度 *&#x2F;</span><br><span class=\"line\">public void schedule(TimerTask task, long delay) &#123;</span><br><span class=\"line\">    if (delay &lt; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;从当前时间开始延时delay毫秒后调度</span><br><span class=\"line\">    sched(task, System.currentTimeMillis()+delay, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 定时调度 *&#x2F;</span><br><span class=\"line\">public void schedule(TimerTask task, Date time) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;从指定时刻出开始调度</span><br><span class=\"line\">    sched(task, time.getTime(), 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 延时周期性调度 *&#x2F;</span><br><span class=\"line\">public void schedule(TimerTask task, long delay, long period) &#123;</span><br><span class=\"line\">    if (delay &lt; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span><br><span class=\"line\">    if (period &lt;&#x3D; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class=\"line\">    sched(task, System.currentTimeMillis()+delay, -period);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 定时周期性调度 *&#x2F;</span><br><span class=\"line\">public void schedule(TimerTask task, Date firstTime, long period) &#123;</span><br><span class=\"line\">    if (period &lt;&#x3D; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class=\"line\">    sched(task, firstTime.getTime(), -period);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Timer.schedule()侧重period时间的一致性，保证执行任务的间隔时间相同。</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-367f6ca013b337ab1d2f2547ed871766_720w.png\" alt=\"img\"></p>\n<blockquote>\n<p>定频率调度</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 延时周期性定速调度 *&#x2F;</span><br><span class=\"line\">public void scheduleAtFixedRate(TimerTask task, long delay, long period) &#123;</span><br><span class=\"line\">    if (delay &lt; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span><br><span class=\"line\">    if (period &lt;&#x3D; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class=\"line\">    sched(task, System.currentTimeMillis()+delay, period);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 定时周期性定速调度 *&#x2F;</span><br><span class=\"line\">public void scheduleAtFixedRate(TimerTask task, Date firstTime, long period) &#123;</span><br><span class=\"line\">    if (period &lt;&#x3D; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class=\"line\">    sched(task, firstTime.getTime(), period);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Timer.scheduleAtFixedRate()侧重执行频率的一致性，任务执行时间加period时间的和相等。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-493048111335ad7f57c1f51a29b37753_720w.png\" alt=\"img\"></p>\n<blockquote>\n<p>核心调度算法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void sched(TimerTask task, long time, long period) &#123;</span><br><span class=\"line\">    if (time &lt; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Illegal execution time.&quot;);      </span><br><span class=\"line\">    if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1))</span><br><span class=\"line\">        period &gt;&gt;&#x3D; 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    synchronized(queue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;保证定时器未被取消</span><br><span class=\"line\">        if (!thread.newTasksMayBeScheduled) &#123;</span><br><span class=\"line\">            throw new IllegalStateException(&quot;Timer already cancelled.&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        synchronized(task.lock) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;保证任务最初处于未使用状态</span><br><span class=\"line\">            if (task.state !&#x3D; TimerTask.VIRGIN) &#123;</span><br><span class=\"line\">                throw new IllegalStateException(</span><br><span class=\"line\">                    &quot;Task already scheduled or cancelled&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;下次任务执行时间</span><br><span class=\"line\">            task.nextExecutionTime &#x3D; time;</span><br><span class=\"line\">            &#x2F;&#x2F;任务执行周期</span><br><span class=\"line\">            task.period &#x3D; period;</span><br><span class=\"line\">            &#x2F;&#x2F;设置任务状态为已调度</span><br><span class=\"line\">            task.state &#x3D; TimerTask.SCHEDULED;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;往任务队列中添加任务</span><br><span class=\"line\">        queue.add(task);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;如果队列中该任务为最近要执行的任务,则立即唤醒定时线程处理</span><br><span class=\"line\">        if (queue.getMin() &#x3D;&#x3D; task) &#123;</span><br><span class=\"line\">            queue.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>撤销定时器</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void cancel() &#123;</span><br><span class=\"line\">    synchronized(queue) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;撤销定时器</span><br><span class=\"line\">        thread.newTasksMayBeScheduled &#x3D; false;</span><br><span class=\"line\">        &#x2F;&#x2F;清空任务队列</span><br><span class=\"line\">        queue.clear();</span><br><span class=\"line\">        &#x2F;&#x2F;唤醒定时线程</span><br><span class=\"line\">        queue.notify();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>清理取消状态的任务</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int purge() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;从队列中移除的任务数</span><br><span class=\"line\">    int result &#x3D; 0;</span><br><span class=\"line\">    synchronized(queue) &#123;</span><br><span class=\"line\">        for (int i &#x3D; queue.size(); i &gt; 0; i--) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;从队列中移除取消状态任务</span><br><span class=\"line\">            if (queue.get(i).state &#x3D;&#x3D; TimerTask.CANCELLED) &#123;</span><br><span class=\"line\">                queue.quickRemove(i);</span><br><span class=\"line\">                result++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;如果仍有非取消任务,队列重新堆化</span><br><span class=\"line\">        if (result !&#x3D; 0)</span><br><span class=\"line\">            queue.heapify();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>读完源码后总结如下，</p>\n<blockquote>\n<p>数据结构</p>\n</blockquote>\n<p>小顶堆实现优先级队列，优先级标准是任务下次执行时间。</p>\n<blockquote>\n<p>任务状态转换</p>\n</blockquote>\n<p><img src=\"https://pic3.zhimg.com/80/v2-ad4c978cc45c7a22464335345f525932_720w.jpg\" alt=\"img\"></p>\n<blockquote>\n<p>定时器架构图</p>\n</blockquote>\n<p><img src=\"https://pic3.zhimg.com/80/v2-08da55ef92a07ae0f90a07f18521bb8e_720w.jpg\" alt=\"img\"></p>\n<blockquote>\n<p>架构缺陷</p>\n</blockquote>\n<p>单线程串行消费任务，前置任务消费延迟或失败会直接影响后续任务的消费。如果消费前置任务时抛出异常，线程退出，队列中的任务无法被继续消费，定时器失效。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>并发编程领域中<strong>定时器</strong> 相关内容经常被一些介绍并发编程书籍所遗忘，属于并发编程学习优先级较低的知识点。在JDK源码中有两种定时器实现，一种是JDK1.3引入的<strong>*Timer</strong>类<em>，它是一种基于单线程操作的简单任务调度器，虽然存在较多设计缺陷，但仍有很多应用场景和使用案例；另一种JDK1.5引入的*</em>ScheduledThreadPoolExecutor**类，是一种基于线程池操作的较复杂任务调度器，同时也是官方推荐的任务调度器实现。</p>\n<p>定时器Timer，也称简单任务调度器。它由以下四个类组成，</p>\n<ul>\n<li>定时任务（TimerTask类）</li>\n<li>任务队列（TaskQueue类）</li>\n<li>定时线程（TimerThread类）</li>\n<li>定时器（Timer类）</li>\n</ul>\n<h2 id=\"定时任务\"><a href=\"#定时任务\" class=\"headerlink\" title=\"定时任务\"></a><strong>定时任务</strong></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class TimerTask implements Runnable &#123;</span><br><span class=\"line\">    final Object lock &#x3D; new Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;任务状态</span><br><span class=\"line\">    int state &#x3D; VIRGIN;</span><br><span class=\"line\">    static final int VIRGIN &#x3D; 0;</span><br><span class=\"line\">    static final int SCHEDULED   &#x3D; 1;</span><br><span class=\"line\">    static final int EXECUTED    &#x3D; 2;</span><br><span class=\"line\">    static final int CANCELLED   &#x3D; 3;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F;下次执行时间</span><br><span class=\"line\">    long nextExecutionTime;</span><br><span class=\"line\">    &#x2F;&#x2F;调度至执行间隔时间</span><br><span class=\"line\">    long period &#x3D; 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>抽象类TimerTask实现Runnable接口，表明该类作为定时任务模版，用户可以根据业务场景定义具体任务。TimerTask类要维护<strong>任务状态</strong> (state)、<strong>任务下次执行时间</strong>（nextExecutionTime）和<strong>任务调度至执行的间隔时间</strong>（period）。</p>\n<blockquote>\n<p>任务状态</p>\n</blockquote>\n<p>定时器任务生命周期中可能处于下表所示的4种不同的状态，在给定的时刻定时器任务只能处于其中一种状态。</p>\n<p><img src=\"/images/java_time_task.png\" alt=\"timer task\"></p>\n<blockquote>\n<p>执行任务</p>\n</blockquote>\n<p>TimerTask类的抽象方法run来自Runnable接口，TimerTask并未实现该接口，延迟至子类实现。用户可在派生类中自定义任务逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract void run();</span><br></pre></td></tr></table></figure>\n\n<p>抽象类TimerTask的run方法并不一定要来源于Runnable接口，它并未接受线程调度，而是由TimerThread线程从TimerQueue中消费任务，然后直接调用TimerTask.run()执行任务。基于这种理解，TimerTask类完全可以像这样定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class TimerTask &#123;  &#x2F;&#x2F; 舍去implement Runnable</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;由抽象类自己定义,而非来自Runnable接口</span><br><span class=\"line\">    public abstract void run();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>TimerTask类这种写法可以理解为被<strong>过度设计</strong>了，读者可思之。</p>\n<blockquote>\n<p>取消任务</p>\n</blockquote>\n<p>如果当前任务正处于SCHEDULED状态，允许撤销当前任务，置任务为CANCELLED状态，返回true表示任务撤销成功；若任务处于其它状态，也置任务为CANCELLED状态，并返回false表示任务撤销失败。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean cancel() &#123;</span><br><span class=\"line\">    synchronized(lock) &#123;</span><br><span class=\"line\">        boolean result &#x3D; (state &#x3D;&#x3D; SCHEDULED);</span><br><span class=\"line\">        &#x2F;&#x2F;实际上所有任务都能被取消</span><br><span class=\"line\">        state &#x3D; CANCELLED;</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用TimerTask.cancel()，虽然对不同状态有不同的返回值，但不管什么状态都能够被取消。设计逻辑匪夷所思，我认为这种<strong>设计不合理</strong>，读者可思之。</p>\n<blockquote>\n<p>调度执行时间</p>\n</blockquote>\n<p>scheduledExecutionTime方法获取任务被调度后最近的开始执行时间点，保证调度时间在下次执行时间之前。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public long scheduledExecutionTime() &#123;</span><br><span class=\"line\">    synchronized(lock) &#123;</span><br><span class=\"line\">        return (period &lt; 0 ? </span><br><span class=\"line\">            nextExecutionTime + period : nextExecutionTime - period);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定时线程\"><a href=\"#定时线程\" class=\"headerlink\" title=\"定时线程\"></a><strong>定时线程</strong></h2><p>从优先级队列里异步消费任务的操作由单线程完成。TimerThread是单线程，因此需要mainLoop循环逻辑来轮询消费任务队列。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TimerThread extends Thread &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    boolean newTasksMayBeScheduled &#x3D; true;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;内部维护一个队列</span><br><span class=\"line\">    private TaskQueue queue;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimerThread(TaskQueue queue) &#123;</span><br><span class=\"line\">        this.queue &#x3D; queue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>轮询任务</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;循环执行逻辑</span><br><span class=\"line\">        mainLoop();</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        synchronized(queue) &#123;</span><br><span class=\"line\">            newTasksMayBeScheduled &#x3D; false;</span><br><span class=\"line\">            &#x2F;&#x2F;清空任务队列. 在结束循环后可能仍有任务被加入到队列,因此需要清空.</span><br><span class=\"line\">            queue.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void mainLoop() &#123;</span><br><span class=\"line\">    while (true) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            TimerTask task;</span><br><span class=\"line\">            boolean taskFired;</span><br><span class=\"line\">            synchronized(queue) &#123;  </span><br><span class=\"line\">                &#x2F;&#x2F;若队列为空且定时器未被撤销,则挂起定时线程直至被唤醒       </span><br><span class=\"line\">                while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled) &#123;                     </span><br><span class=\"line\">                    queue.wait();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                &#x2F;&#x2F;若线程被唤醒后队列仍为空,则结束循环. 说明此时定时器被撤销.</span><br><span class=\"line\">                if (queue.isEmpty()) &#123;</span><br><span class=\"line\">                    break;            </span><br><span class=\"line\">                &#125;    </span><br><span class=\"line\">  </span><br><span class=\"line\">                long currentTime, executionTime;</span><br><span class=\"line\">                &#x2F;&#x2F;获取最近执行时间任务</span><br><span class=\"line\">                task &#x3D; queue.getMin();</span><br><span class=\"line\">                synchronized(task.lock) &#123;</span><br><span class=\"line\">                    &#x2F;&#x2F;任务若被取消,则从队列中移除,并继续轮询</span><br><span class=\"line\">                    if (task.state &#x3D;&#x3D; TimerTask.CANCELLED) &#123;</span><br><span class=\"line\">                        queue.removeMin();</span><br><span class=\"line\">                        continue;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    currentTime &#x3D; System.currentTimeMillis();</span><br><span class=\"line\">                    executionTime &#x3D; task.nextExecutionTime;</span><br><span class=\"line\">                    &#x2F;&#x2F;任务最近要执行</span><br><span class=\"line\">                    if (taskFired &#x3D; (executionTime&lt;&#x3D;currentTime)) &#123;</span><br><span class=\"line\">                        &#x2F;&#x2F;若为非重复执行任务,从队列中移除该任务,并设置该任务状态为已执行</span><br><span class=\"line\">                        if (task.period &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">                            queue.removeMin();</span><br><span class=\"line\">                            task.state &#x3D; TimerTask.EXECUTED;</span><br><span class=\"line\">                        &#125; else &#123;</span><br><span class=\"line\">                            &#x2F;&#x2F;若为重复执行任务,则在指定时刻重新调度该任务</span><br><span class=\"line\">                            queue.rescheduleMin(</span><br><span class=\"line\">                                task.period&lt;0 ? currentTime-task.period</span><br><span class=\"line\">                                    : executionTime + task.period);                      </span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    &#x2F;&#x2F;若最近无任务要执行,则等待至要执行任务的指定时刻</span><br><span class=\"line\">                    if (!taskFired) &#123;</span><br><span class=\"line\">                        queue.wait(executionTime - currentTime);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#x2F;&#x2F;任务已释放,运行任务</span><br><span class=\"line\">            if (taskFired) &#123; </span><br><span class=\"line\">                task.run();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch(InterruptedException e) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"任务队列\"><a href=\"#任务队列\" class=\"headerlink\" title=\"任务队列\"></a><strong>任务队列</strong></h2><p>任务队列是基于完全二叉树实现的小顶堆。队列初始容量为128，由于0位置不存储任务，因此实际初始容量为127，size表示队列的任务数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TaskQueue &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;基于顺序表实现的定时任务队列</span><br><span class=\"line\">    private TimerTask[] queue &#x3D; new TimerTask[128];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;队列任务数</span><br><span class=\"line\">    private int size &#x3D; 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>查询容量</p>\n</blockquote>\n<p>查询队列任务数和判断队列是否为空都直接使用任务队列内部维护的size属性，因此这两个操作的时间复杂度为O(1)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 队列任务数 *&#x2F;</span><br><span class=\"line\">int size() &#123; return size; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 队列是否为空 *&#x2F;</span><br><span class=\"line\">boolean isEmpty() &#123; return size&#x3D;&#x3D;0; &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>添加任务</p>\n</blockquote>\n<p>主线程向任务队列中注入新任务。如果当前任务队列容量已达极限，则在原容量基础上扩容一倍，并在任务队列末尾追加新任务，并根据任务执行时间作为优先级调整新任务在任务队列中的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 新增任务并调整小顶堆 *&#x2F;</span><br><span class=\"line\">void add(TimerTask task) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;任务数达到队列最大容量,则扩容一倍</span><br><span class=\"line\">    if (size + 1 &#x3D;&#x3D; queue.length) &#123;</span><br><span class=\"line\">        queue &#x3D; Arrays.copyOf(queue, 2*queue.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;添加任务</span><br><span class=\"line\">    queue[++size] &#x3D; task;</span><br><span class=\"line\">    &#x2F;&#x2F;向上调整任务</span><br><span class=\"line\">    fixUp(size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic3.zhimg.com/80/v2-3e64d663f2d599d0c7b40a7464dd0072_720w.jpg\" alt=\"img\"></p>\n<blockquote>\n<p>获取任务</p>\n</blockquote>\n<p>从任务队列中获取最近将要执行任务的时间复杂度为O(1)；获得指定位置任务的时间复杂度也是O(1)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 获得下次执行时间最小的任务,即最小堆根结点 *&#x2F;</span><br><span class=\"line\">TimerTask getMin() &#123; return queue[1]; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 获得指定位置的任务 *&#x2F;</span><br><span class=\"line\">TimerTask get(int i) &#123; return queue[i]; &#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"images/getmint_20200427144736.png\" alt=\"img\"></p>\n<blockquote>\n<p>移除任务</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 移除下次执行时间最小的任务,即移除堆顶任务 *&#x2F;</span><br><span class=\"line\">void removeMin() &#123;</span><br><span class=\"line\">    queue[1] &#x3D; queue[size];</span><br><span class=\"line\">    queue[size--] &#x3D; null;</span><br><span class=\"line\">    fixDown(1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic4.zhimg.com/80/v2-d0a23892cf5a8aaef780bf8f0e6f0e33_720w.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 快速移除指定位置处任务 *&#x2F;</span><br><span class=\"line\">void quickRemove(int i) &#123;</span><br><span class=\"line\">    assert i &lt;&#x3D; size;  &#x2F;&#x2F;assert生效需要编译器开启断言功能</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F;指定位置元素直接用最后元素代替,不需要向下调整</span><br><span class=\"line\">    queue[i] &#x3D; queue[size];</span><br><span class=\"line\">    queue[size--] &#x3D; null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic1.zhimg.com/80/v2-d72f08b8ae0fbaaa9a3da508f9e64b54_720w.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 清空任务队列 *&#x2F;</span><br><span class=\"line\">void clear() &#123;</span><br><span class=\"line\">    for (int i&#x3D;1; i&lt;&#x3D;size; i++)</span><br><span class=\"line\">        queue[i] &#x3D; null;</span><br><span class=\"line\">    size &#x3D; 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重新调度任务</p>\n</blockquote>\n<p>重新调度任务不删除堆顶任务，而是将堆顶任务的nextExecutionTime加上period后得到新的nextExecutionTime值，然后根据任务优先级向下调整。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void rescheduleMin(long newTime) &#123;</span><br><span class=\"line\">    queue[1].nextExecutionTime &#x3D; newTime;</span><br><span class=\"line\">    fixDown(1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://pic3.zhimg.com/80/v2-26395bd09d3fc3d4fd4990a3707aa34a_720w.jpg\" alt=\"img\"></p>\n<blockquote>\n<p>基础算法</p>\n</blockquote>\n<p>任务队列是优先级队列，基于顺序结构完全二叉树实现的小顶堆。优先级的依据是任务下次执行时间。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-7dbfc6a56603dfc301213dd0ba8cfa0d_720w.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 提升优先级 *&#x2F;</span><br><span class=\"line\">private void fixUp(int k) &#123;</span><br><span class=\"line\">    while (k &gt; 1) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;父结点位置</span><br><span class=\"line\">        int j &#x3D; k &gt;&gt; 1;</span><br><span class=\"line\">        &#x2F;&#x2F;如果父结点的下次任务执行时间小于当前结点下次任务执行时间,结束调整操作</span><br><span class=\"line\">        if (queue[j].nextExecutionTime &lt;&#x3D; queue[k].nextExecutionTime) &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;调整任务在任务队列中的位置</span><br><span class=\"line\">        TimerTask tmp &#x3D; queue[j];  </span><br><span class=\"line\">        queue[j] &#x3D; queue[k]; </span><br><span class=\"line\">        queue[k] &#x3D; tmp;</span><br><span class=\"line\">        k &#x3D; j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 降低优先级 *&#x2F;</span><br><span class=\"line\">private void fixDown(int k) &#123;</span><br><span class=\"line\">    int j;</span><br><span class=\"line\">    while ((j &#x3D; k &lt;&lt; 1) &lt;&#x3D; size &amp;&amp; j &gt; 0) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;选择左右两侧子结点,选择更小的交换位置</span><br><span class=\"line\">        if (j &lt; size &amp;&amp; </span><br><span class=\"line\">            queue[j].nextExecutionTime &gt; queue[j+1].nextExecutionTime) &#123;</span><br><span class=\"line\">            j++; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (queue[k].nextExecutionTime &lt;&#x3D; queue[j].nextExecutionTime) &#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;调整任务在任务队列中的位置</span><br><span class=\"line\">        TimerTask tmp &#x3D; queue[j];  </span><br><span class=\"line\">        queue[j] &#x3D; queue[k]; </span><br><span class=\"line\">        queue[k] &#x3D; tmp;</span><br><span class=\"line\">        k &#x3D; j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调整当前完全二叉树为最小堆。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 堆化 *&#x2F;</span><br><span class=\"line\">void heapify() &#123;</span><br><span class=\"line\">    for (int i &#x3D; size&#x2F;2; i &gt;&#x3D; 1; i--) &#123;</span><br><span class=\"line\">        fixDown(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a><strong>定时器</strong></h2><p>一个定时器内部维护一个任务队列和一个定时线程。在Main线程往任务队列注入任务后，由定时线程异步轮询处理任务队列，这种处理方式实质上是异步串行方式，任务处理并发度为1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Timer &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;** 任务队列 *&#x2F;</span><br><span class=\"line\">    private final TaskQueue queue &#x3D; new TaskQueue();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;** 定时线程 *&#x2F;</span><br><span class=\"line\">    private final TimerThread thread &#x3D; new TimerThread(queue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>构造器</p>\n</blockquote>\n<p>新建Timer实例，同时也新建了任务队列和定时线程，并启动定时线程。启动定时线程前可指定定时线程的名称，以及指定为后台线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Timer() &#123;</span><br><span class=\"line\">    this(&quot;Timer-&quot; + serialNumber());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public Timer(boolean isDaemon) &#123;</span><br><span class=\"line\">    this(&quot;Timer-&quot; + serialNumber(), isDaemon);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public Timer(String name) &#123;</span><br><span class=\"line\">    thread.setName(name);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public Timer(String name, boolean isDaemon) &#123;</span><br><span class=\"line\">    thread.setName(name); </span><br><span class=\"line\">    thread.setDaemon(isDaemon);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;单机序列号生成</span><br><span class=\"line\">private final static AtomicInteger nextSerialNumber &#x3D; new AtomicInteger(0);</span><br><span class=\"line\">private static int serialNumber() &#123;</span><br><span class=\"line\">    return nextSerialNumber.getAndIncrement();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>定间隔调度</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 延迟调度 *&#x2F;</span><br><span class=\"line\">public void schedule(TimerTask task, long delay) &#123;</span><br><span class=\"line\">    if (delay &lt; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;从当前时间开始延时delay毫秒后调度</span><br><span class=\"line\">    sched(task, System.currentTimeMillis()+delay, 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 定时调度 *&#x2F;</span><br><span class=\"line\">public void schedule(TimerTask task, Date time) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;从指定时刻出开始调度</span><br><span class=\"line\">    sched(task, time.getTime(), 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 延时周期性调度 *&#x2F;</span><br><span class=\"line\">public void schedule(TimerTask task, long delay, long period) &#123;</span><br><span class=\"line\">    if (delay &lt; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span><br><span class=\"line\">    if (period &lt;&#x3D; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class=\"line\">    sched(task, System.currentTimeMillis()+delay, -period);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 定时周期性调度 *&#x2F;</span><br><span class=\"line\">public void schedule(TimerTask task, Date firstTime, long period) &#123;</span><br><span class=\"line\">    if (period &lt;&#x3D; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class=\"line\">    sched(task, firstTime.getTime(), -period);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Timer.schedule()侧重period时间的一致性，保证执行任务的间隔时间相同。</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-367f6ca013b337ab1d2f2547ed871766_720w.png\" alt=\"img\"></p>\n<blockquote>\n<p>定频率调度</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 延时周期性定速调度 *&#x2F;</span><br><span class=\"line\">public void scheduleAtFixedRate(TimerTask task, long delay, long period) &#123;</span><br><span class=\"line\">    if (delay &lt; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span><br><span class=\"line\">    if (period &lt;&#x3D; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class=\"line\">    sched(task, System.currentTimeMillis()+delay, period);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 定时周期性定速调度 *&#x2F;</span><br><span class=\"line\">public void scheduleAtFixedRate(TimerTask task, Date firstTime, long period) &#123;</span><br><span class=\"line\">    if (period &lt;&#x3D; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class=\"line\">    sched(task, firstTime.getTime(), period);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Timer.scheduleAtFixedRate()侧重执行频率的一致性，任务执行时间加period时间的和相等。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-493048111335ad7f57c1f51a29b37753_720w.png\" alt=\"img\"></p>\n<blockquote>\n<p>核心调度算法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void sched(TimerTask task, long time, long period) &#123;</span><br><span class=\"line\">    if (time &lt; 0)</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;Illegal execution time.&quot;);      </span><br><span class=\"line\">    if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1))</span><br><span class=\"line\">        period &gt;&gt;&#x3D; 1;</span><br><span class=\"line\"></span><br><span class=\"line\">    synchronized(queue) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;保证定时器未被取消</span><br><span class=\"line\">        if (!thread.newTasksMayBeScheduled) &#123;</span><br><span class=\"line\">            throw new IllegalStateException(&quot;Timer already cancelled.&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        synchronized(task.lock) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;保证任务最初处于未使用状态</span><br><span class=\"line\">            if (task.state !&#x3D; TimerTask.VIRGIN) &#123;</span><br><span class=\"line\">                throw new IllegalStateException(</span><br><span class=\"line\">                    &quot;Task already scheduled or cancelled&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#x2F;&#x2F;下次任务执行时间</span><br><span class=\"line\">            task.nextExecutionTime &#x3D; time;</span><br><span class=\"line\">            &#x2F;&#x2F;任务执行周期</span><br><span class=\"line\">            task.period &#x3D; period;</span><br><span class=\"line\">            &#x2F;&#x2F;设置任务状态为已调度</span><br><span class=\"line\">            task.state &#x3D; TimerTask.SCHEDULED;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;往任务队列中添加任务</span><br><span class=\"line\">        queue.add(task);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;如果队列中该任务为最近要执行的任务,则立即唤醒定时线程处理</span><br><span class=\"line\">        if (queue.getMin() &#x3D;&#x3D; task) &#123;</span><br><span class=\"line\">            queue.notify();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>撤销定时器</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void cancel() &#123;</span><br><span class=\"line\">    synchronized(queue) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;撤销定时器</span><br><span class=\"line\">        thread.newTasksMayBeScheduled &#x3D; false;</span><br><span class=\"line\">        &#x2F;&#x2F;清空任务队列</span><br><span class=\"line\">        queue.clear();</span><br><span class=\"line\">        &#x2F;&#x2F;唤醒定时线程</span><br><span class=\"line\">        queue.notify();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>清理取消状态的任务</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int purge() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;从队列中移除的任务数</span><br><span class=\"line\">    int result &#x3D; 0;</span><br><span class=\"line\">    synchronized(queue) &#123;</span><br><span class=\"line\">        for (int i &#x3D; queue.size(); i &gt; 0; i--) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;从队列中移除取消状态任务</span><br><span class=\"line\">            if (queue.get(i).state &#x3D;&#x3D; TimerTask.CANCELLED) &#123;</span><br><span class=\"line\">                queue.quickRemove(i);</span><br><span class=\"line\">                result++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;如果仍有非取消任务,队列重新堆化</span><br><span class=\"line\">        if (result !&#x3D; 0)</span><br><span class=\"line\">            queue.heapify();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>读完源码后总结如下，</p>\n<blockquote>\n<p>数据结构</p>\n</blockquote>\n<p>小顶堆实现优先级队列，优先级标准是任务下次执行时间。</p>\n<blockquote>\n<p>任务状态转换</p>\n</blockquote>\n<p><img src=\"https://pic3.zhimg.com/80/v2-ad4c978cc45c7a22464335345f525932_720w.jpg\" alt=\"img\"></p>\n<blockquote>\n<p>定时器架构图</p>\n</blockquote>\n<p><img src=\"https://pic3.zhimg.com/80/v2-08da55ef92a07ae0f90a07f18521bb8e_720w.jpg\" alt=\"img\"></p>\n<blockquote>\n<p>架构缺陷</p>\n</blockquote>\n<p>单线程串行消费任务，前置任务消费延迟或失败会直接影响后续任务的消费。如果消费前置任务时抛出异常，线程退出，队列中的任务无法被继续消费，定时器失效。</p>\n"},{"title":"认识MySQL","date":"2020-04-15T12:05:46.000Z","_content":"### 什么是MySQL?\n\nMySQL 是一种关系型数据库，在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。阿里巴巴数据库系统也大量用到了 MySQL，因此它的稳定性是有保障的。MySQL是开放源代码的，因此任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL的默认端口号是**3306**。\n\n### 存储引擎\n\n#### 一些常用命令\n\n**查看MySQL提供的所有存储引擎**\n\n```\nmysql> show engines;\n```\n\n![查看MySQL提供的所有存储引擎](/images/96e65732e706e67.png)\n\n从上图我们可以查看出 MySQL 当前默认的存储引擎是InnoDB,并且在5.7版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。\n\n**查看MySQL当前默认的存储引擎**\n\n我们也可以通过下面的命令查看默认的存储引擎。\n\n```\nmysql> show variables like '%storage_engine%';\n```\n\n**查看表的存储引擎**\n\n```\nshow table status like \"table_name\" ;\n```\n\n![查看表的存储引擎](/images/20200702382545352.png)\n\n#### MyISAM和InnoDB区别\n\nMyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。\n\n大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。\n\n**两者的对比：**\n\n1. **是否支持行级锁** : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。\n2. **是否支持事务和崩溃后的安全恢复： MyISAM** 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是**InnoDB** 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。\n3. **是否支持外键：** MyISAM不支持，而InnoDB支持。\n4. **是否支持MVCC** ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。推荐阅读：[MySQL-InnoDB-MVCC多版本并发控制](https://segmentfault.com/a/1190000012650596)\n5. ......\n\n《MySQL高性能》上面有一句话这样写到:\n\n> 不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。\n\n一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。\n\n### 字符集及校对规则\n\n字符集指的是一种从二进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。MySQL中每一种字符集都会对应一系列的校对规则。\n\nMySQL采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集） PS：整理自《Java工程师修炼之道》\n\n详细内容可以参考： [MySQL字符集及校对规则的理解](https://www.cnblogs.com/geaozhang/p/6724393.html#MySQLyuzifuji)\n\n### 索引\n\nMySQL索引使用的数据结构主要有**BTree索引** 和 **哈希索引** 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。\n\nMySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。\n\n- **MyISAM:** B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。\n- **InnoDB:** 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。**在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。** **因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。** PS：整理自《Java工程师修炼之道》\n\n**更多关于索引的内容可以查看文档首页MySQL目录下关于索引的详细总结。**\n\n### 查询缓存的使用\n\n> 执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用\n\nmy.cnf加入以下配置，重启MySQL开启查询缓存\n\n```\nquery_cache_type=1\nquery_cache_size=600000\n```\n\nMySQL执行以下命令也可以开启查询缓存\n\n```\nset global  query_cache_type=1;\nset global  query_cache_size=600000;\n```\n\n如上，**开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果**。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。\n\n缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。\n\n**缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。** 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，**还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存：**\n\n```\nselect sql_no_cache count(*) from usr;\n```\n\n### 什么是事务?\n\n**事务是逻辑上的一组操作，要么都执行，要么都不执行。**\n\n事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。\n\n### 事物的四大特性(ACID)\n\n\n\n![事物的特性](/images/125453725.png)\n\n1. **原子性（Atomicity）：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；\n2. **一致性（Consistency）：** 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；\n3. **隔离性（Isolation）：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；\n4. **持久性（Durability）：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。\n\n### 并发事务带来哪些问题?\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n\n- **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。\n- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。\n- **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。\n- **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n**不可重复读和幻读区别：**\n\n不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。\n\n### 事务隔离级别有哪些?MySQL的默认隔离级别是?\n\n**SQL 标准定义了四个隔离级别：**\n\n- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。\n- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。\n- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。\n- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。\n\n------\n\n| 隔离级别         | 脏读 | 不可重复读 | 幻影读 |\n| ---------------- | ---- | ---------- | ------ |\n| READ-UNCOMMITTED | √    | √          | √      |\n| READ-COMMITTED   | ×    | √          | √      |\n| REPEATABLE-READ  | ×    | ×          | √      |\n| SERIALIZABLE     | ×    | ×          | ×      |\n\nMySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。我们可以通过`SELECT @@tx_isolation;`命令来查看\n\n```\nmysql> SELECT @@tx_isolation;\n+-----------------+\n| @@tx_isolation  |\n+-----------------+\n| REPEATABLE-READ |\n+-----------------+\n```\n\n这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ（可重读）** 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 **SERIALIZABLE(可串行化)** 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ-COMMITTED(读取提交内容)** ，但是你要知道的是InnoDB 存储引擎默认使用 **REPEAaTABLE-READ（可重读）** 并不会有任何性能损失。\n\nInnoDB 存储引擎在 **分布式事务** 的情况下一般会用到 **SERIALIZABLE(可串行化)** 隔离级别。\n\n### 锁机制与InnoDB锁算法\n\n**MyISAM和InnoDB存储引擎使用的锁：**\n\n- MyISAM采用表级锁(table-level locking)。\n- InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁\n\n**表级锁和行级锁对比：**\n\n- **表级锁：** MySQL中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。\n- **行级锁：** MySQL中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。\n\n详细内容可以参考： MySQL锁机制简单了解一下：<https://blog.csdn.net/qq_34337272/article/details/80611486>\n\n**InnoDB存储引擎的锁的算法有三种：**\n\n- Record lock：单个行记录上的锁\n- Gap lock：间隙锁，锁定一个范围，不包括记录本身\n- Next-key lock：record+gap 锁定一个范围，包含记录本身\n\n**相关知识点：**\n\n1. innodb对于行的查询使用next-key lock\n2. Next-locking keying为了解决Phantom Problem幻读问题\n3. 当查询的索引含有唯一属性时，将next-key lock降级为record key\n4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生\n5. 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1\n\n### 大表优化\n\n当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：\n\n#### 1. 限定数据的范围\n\n务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；\n\n#### 2. 读/写分离\n\n经典的数据库拆分方案，主库负责写，从库负责读；\n\n#### 3. 垂直分区\n\n**根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。\n\n**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大家应该就更容易理解了。\n\n![数据库垂直分区](/images/25453525.png)\n\n- **垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。\n- **垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；\n\n#### 4. 水平分区\n\n**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。**\n\n水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。\n\n![数据库水平拆分](/images/525453525.png)\n\n水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 。\n\n水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。\n\n**下面补充一下数据库分片的两种常见方案：**\n\n- **客户端代理：** **分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。** 当当网的 **Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。\n- **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。\n\n详细内容可以参考： MySQL大表优化方案: <https://segmentfault.com/a/1190000006158186>\n\n### 解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?\n\n池化设计应该不是一个新名词。我们常见的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。就好比你去食堂打饭，打饭的大妈会先把饭盛好几份放那里，你来了就直接拿着饭盒加菜即可，不用再临时又盛饭又打菜，效率就高了。除了初始化资源，池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。这篇文章对[池化设计思想](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485679&idx=1&sn=57dbca8c9ad49e1f3968ecff04a4f735&chksm=cea24724f9d5ce3212292fac291234a760c99c0960b5430d714269efe33554730b5f71208582&token=1141994790&lang=zh_CN#rd)介绍的还不错，直接复制过来，避免重复造轮子了。\n\n数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的 所以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。**在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中**。 连接池还减少了用户必须等待建立与数据库的连接的时间。\n\n### 分库分表之后,id 主键如何处理？\n\n因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。\n\n生成全局 id 有下面这几种方式：\n\n- **UUID**：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。\n- **数据库自增 id** : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。\n- **利用 redis 生成 id :** 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。\n- **Twitter的snowflake算法** ：Github 地址：[https://github.com/twitter-archive/snowflake。](https://github.com/twitter-archive/snowflake%E3%80%82)\n- **美团的Leaf分布式ID生成系统** ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章：<https://tech.meituan.com/2017/04/21/mt-leaf.html> 。\n- ......\n\n### 一条SQL语句在MySQL中如何执行的\n\n[一条SQL语句在MySQL中如何执行的](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd)\n\n### MySQL高性能优化规范建议\n\n[MySQL高性能优化规范建议](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd)\n\n### 一条SQL语句执行得很慢的原因有哪些？\n\n[腾讯面试：一条SQL语句执行得很慢的原因有哪些？---不看后悔系列](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd)","source":"_posts/sql/认识MYSQL.md","raw":"---\ntitle: 认识MySQL\ntags:\n  - 数据库\n  - MySQL\ncategories:\n  - 数据库\n  - MySQL\ndate: 2020-04-15 20:05:46\n---\n### 什么是MySQL?\n\nMySQL 是一种关系型数据库，在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。阿里巴巴数据库系统也大量用到了 MySQL，因此它的稳定性是有保障的。MySQL是开放源代码的，因此任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL的默认端口号是**3306**。\n\n### 存储引擎\n\n#### 一些常用命令\n\n**查看MySQL提供的所有存储引擎**\n\n```\nmysql> show engines;\n```\n\n![查看MySQL提供的所有存储引擎](/images/96e65732e706e67.png)\n\n从上图我们可以查看出 MySQL 当前默认的存储引擎是InnoDB,并且在5.7版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。\n\n**查看MySQL当前默认的存储引擎**\n\n我们也可以通过下面的命令查看默认的存储引擎。\n\n```\nmysql> show variables like '%storage_engine%';\n```\n\n**查看表的存储引擎**\n\n```\nshow table status like \"table_name\" ;\n```\n\n![查看表的存储引擎](/images/20200702382545352.png)\n\n#### MyISAM和InnoDB区别\n\nMyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。\n\n大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。\n\n**两者的对比：**\n\n1. **是否支持行级锁** : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。\n2. **是否支持事务和崩溃后的安全恢复： MyISAM** 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是**InnoDB** 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。\n3. **是否支持外键：** MyISAM不支持，而InnoDB支持。\n4. **是否支持MVCC** ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 `READ COMMITTED` 和 `REPEATABLE READ` 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。推荐阅读：[MySQL-InnoDB-MVCC多版本并发控制](https://segmentfault.com/a/1190000012650596)\n5. ......\n\n《MySQL高性能》上面有一句话这样写到:\n\n> 不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。\n\n一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。\n\n### 字符集及校对规则\n\n字符集指的是一种从二进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。MySQL中每一种字符集都会对应一系列的校对规则。\n\nMySQL采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集） PS：整理自《Java工程师修炼之道》\n\n详细内容可以参考： [MySQL字符集及校对规则的理解](https://www.cnblogs.com/geaozhang/p/6724393.html#MySQLyuzifuji)\n\n### 索引\n\nMySQL索引使用的数据结构主要有**BTree索引** 和 **哈希索引** 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。\n\nMySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。\n\n- **MyISAM:** B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。\n- **InnoDB:** 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。**在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。** **因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。** PS：整理自《Java工程师修炼之道》\n\n**更多关于索引的内容可以查看文档首页MySQL目录下关于索引的详细总结。**\n\n### 查询缓存的使用\n\n> 执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用\n\nmy.cnf加入以下配置，重启MySQL开启查询缓存\n\n```\nquery_cache_type=1\nquery_cache_size=600000\n```\n\nMySQL执行以下命令也可以开启查询缓存\n\n```\nset global  query_cache_type=1;\nset global  query_cache_size=600000;\n```\n\n如上，**开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果**。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。\n\n缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。\n\n**缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。** 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，**还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存：**\n\n```\nselect sql_no_cache count(*) from usr;\n```\n\n### 什么是事务?\n\n**事务是逻辑上的一组操作，要么都执行，要么都不执行。**\n\n事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。\n\n### 事物的四大特性(ACID)\n\n\n\n![事物的特性](/images/125453725.png)\n\n1. **原子性（Atomicity）：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；\n2. **一致性（Consistency）：** 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；\n3. **隔离性（Isolation）：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；\n4. **持久性（Durability）：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。\n\n### 并发事务带来哪些问题?\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n\n- **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。\n- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。\n- **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。\n- **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n\n**不可重复读和幻读区别：**\n\n不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。\n\n### 事务隔离级别有哪些?MySQL的默认隔离级别是?\n\n**SQL 标准定义了四个隔离级别：**\n\n- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。\n- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。\n- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。\n- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。\n\n------\n\n| 隔离级别         | 脏读 | 不可重复读 | 幻影读 |\n| ---------------- | ---- | ---------- | ------ |\n| READ-UNCOMMITTED | √    | √          | √      |\n| READ-COMMITTED   | ×    | √          | √      |\n| REPEATABLE-READ  | ×    | ×          | √      |\n| SERIALIZABLE     | ×    | ×          | ×      |\n\nMySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。我们可以通过`SELECT @@tx_isolation;`命令来查看\n\n```\nmysql> SELECT @@tx_isolation;\n+-----------------+\n| @@tx_isolation  |\n+-----------------+\n| REPEATABLE-READ |\n+-----------------+\n```\n\n这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ（可重读）** 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 **SERIALIZABLE(可串行化)** 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ-COMMITTED(读取提交内容)** ，但是你要知道的是InnoDB 存储引擎默认使用 **REPEAaTABLE-READ（可重读）** 并不会有任何性能损失。\n\nInnoDB 存储引擎在 **分布式事务** 的情况下一般会用到 **SERIALIZABLE(可串行化)** 隔离级别。\n\n### 锁机制与InnoDB锁算法\n\n**MyISAM和InnoDB存储引擎使用的锁：**\n\n- MyISAM采用表级锁(table-level locking)。\n- InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁\n\n**表级锁和行级锁对比：**\n\n- **表级锁：** MySQL中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。\n- **行级锁：** MySQL中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。\n\n详细内容可以参考： MySQL锁机制简单了解一下：<https://blog.csdn.net/qq_34337272/article/details/80611486>\n\n**InnoDB存储引擎的锁的算法有三种：**\n\n- Record lock：单个行记录上的锁\n- Gap lock：间隙锁，锁定一个范围，不包括记录本身\n- Next-key lock：record+gap 锁定一个范围，包含记录本身\n\n**相关知识点：**\n\n1. innodb对于行的查询使用next-key lock\n2. Next-locking keying为了解决Phantom Problem幻读问题\n3. 当查询的索引含有唯一属性时，将next-key lock降级为record key\n4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生\n5. 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1\n\n### 大表优化\n\n当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：\n\n#### 1. 限定数据的范围\n\n务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；\n\n#### 2. 读/写分离\n\n经典的数据库拆分方案，主库负责写，从库负责读；\n\n#### 3. 垂直分区\n\n**根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。\n\n**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大家应该就更容易理解了。\n\n![数据库垂直分区](/images/25453525.png)\n\n- **垂直拆分的优点：** 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。\n- **垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；\n\n#### 4. 水平分区\n\n**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。**\n\n水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。\n\n![数据库水平拆分](/images/525453525.png)\n\n水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 。\n\n水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。\n\n**下面补充一下数据库分片的两种常见方案：**\n\n- **客户端代理：** **分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。** 当当网的 **Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。\n- **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。\n\n详细内容可以参考： MySQL大表优化方案: <https://segmentfault.com/a/1190000006158186>\n\n### 解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?\n\n池化设计应该不是一个新名词。我们常见的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。就好比你去食堂打饭，打饭的大妈会先把饭盛好几份放那里，你来了就直接拿着饭盒加菜即可，不用再临时又盛饭又打菜，效率就高了。除了初始化资源，池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。这篇文章对[池化设计思想](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485679&idx=1&sn=57dbca8c9ad49e1f3968ecff04a4f735&chksm=cea24724f9d5ce3212292fac291234a760c99c0960b5430d714269efe33554730b5f71208582&token=1141994790&lang=zh_CN#rd)介绍的还不错，直接复制过来，避免重复造轮子了。\n\n数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的 所以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。**在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中**。 连接池还减少了用户必须等待建立与数据库的连接的时间。\n\n### 分库分表之后,id 主键如何处理？\n\n因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。\n\n生成全局 id 有下面这几种方式：\n\n- **UUID**：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。\n- **数据库自增 id** : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。\n- **利用 redis 生成 id :** 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。\n- **Twitter的snowflake算法** ：Github 地址：[https://github.com/twitter-archive/snowflake。](https://github.com/twitter-archive/snowflake%E3%80%82)\n- **美团的Leaf分布式ID生成系统** ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章：<https://tech.meituan.com/2017/04/21/mt-leaf.html> 。\n- ......\n\n### 一条SQL语句在MySQL中如何执行的\n\n[一条SQL语句在MySQL中如何执行的](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd)\n\n### MySQL高性能优化规范建议\n\n[MySQL高性能优化规范建议](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd)\n\n### 一条SQL语句执行得很慢的原因有哪些？\n\n[腾讯面试：一条SQL语句执行得很慢的原因有哪些？---不看后悔系列](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd)","slug":"sql/认识MYSQL","published":1,"updated":"2020-07-06T02:00:26.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7ls005pvgja5k1x7s5j","content":"<h3 id=\"什么是MySQL\"><a href=\"#什么是MySQL\" class=\"headerlink\" title=\"什么是MySQL?\"></a>什么是MySQL?</h3><p>MySQL 是一种关系型数据库，在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。阿里巴巴数据库系统也大量用到了 MySQL，因此它的稳定性是有保障的。MySQL是开放源代码的，因此任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL的默认端口号是<strong>3306</strong>。</p>\n<h3 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h3><h4 id=\"一些常用命令\"><a href=\"#一些常用命令\" class=\"headerlink\" title=\"一些常用命令\"></a>一些常用命令</h4><p><strong>查看MySQL提供的所有存储引擎</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show engines;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/96e65732e706e67.png\" alt=\"查看MySQL提供的所有存储引擎\"></p>\n<p>从上图我们可以查看出 MySQL 当前默认的存储引擎是InnoDB,并且在5.7版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p>\n<p><strong>查看MySQL当前默认的存储引擎</strong></p>\n<p>我们也可以通过下面的命令查看默认的存储引擎。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#39;%storage_engine%&#39;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查看表的存储引擎</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show table status like &quot;table_name&quot; ;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/20200702382545352.png\" alt=\"查看表的存储引擎\"></p>\n<h4 id=\"MyISAM和InnoDB区别\"><a href=\"#MyISAM和InnoDB区别\" class=\"headerlink\" title=\"MyISAM和InnoDB区别\"></a>MyISAM和InnoDB区别</h4><p>MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。</p>\n<p>大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。</p>\n<p><strong>两者的对比：</strong></p>\n<ol>\n<li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>\n<li><strong>是否支持事务和崩溃后的安全恢复： MyISAM</strong> 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是<strong>InnoDB</strong> 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>\n<li><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</li>\n<li><strong>是否支持MVCC</strong> ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。推荐阅读：<a href=\"https://segmentfault.com/a/1190000012650596\" target=\"_blank\" rel=\"noopener\">MySQL-InnoDB-MVCC多版本并发控制</a></li>\n<li>……</li>\n</ol>\n<p>《MySQL高性能》上面有一句话这样写到:</p>\n<blockquote>\n<p>不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p>\n</blockquote>\n<p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p>\n<h3 id=\"字符集及校对规则\"><a href=\"#字符集及校对规则\" class=\"headerlink\" title=\"字符集及校对规则\"></a>字符集及校对规则</h3><p>字符集指的是一种从二进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。MySQL中每一种字符集都会对应一系列的校对规则。</p>\n<p>MySQL采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集） PS：整理自《Java工程师修炼之道》</p>\n<p>详细内容可以参考： <a href=\"https://www.cnblogs.com/geaozhang/p/6724393.html#MySQLyuzifuji\" target=\"_blank\" rel=\"noopener\">MySQL字符集及校对规则的理解</a></p>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>\n<p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>\n<ul>\n<li><strong>MyISAM:</strong> B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li>\n<li><strong>InnoDB:</strong> 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</strong> <strong>因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong> PS：整理自《Java工程师修炼之道》</li>\n</ul>\n<p><strong>更多关于索引的内容可以查看文档首页MySQL目录下关于索引的详细总结。</strong></p>\n<h3 id=\"查询缓存的使用\"><a href=\"#查询缓存的使用\" class=\"headerlink\" title=\"查询缓存的使用\"></a>查询缓存的使用</h3><blockquote>\n<p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用</p>\n</blockquote>\n<p>my.cnf加入以下配置，重启MySQL开启查询缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">query_cache_type&#x3D;1</span><br><span class=\"line\">query_cache_size&#x3D;600000</span><br></pre></td></tr></table></figure>\n\n<p>MySQL执行以下命令也可以开启查询缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set global  query_cache_type&#x3D;1;</span><br><span class=\"line\">set global  query_cache_size&#x3D;600000;</span><br></pre></td></tr></table></figure>\n\n<p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。</p>\n<p>缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p>\n<p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，<strong>还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select sql_no_cache count(*) from usr;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"什么是事务\"><a href=\"#什么是事务\" class=\"headerlink\" title=\"什么是事务?\"></a>什么是事务?</h3><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>\n<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>\n<h3 id=\"事物的四大特性-ACID\"><a href=\"#事物的四大特性-ACID\" class=\"headerlink\" title=\"事物的四大特性(ACID)\"></a>事物的四大特性(ACID)</h3><p><img src=\"/images/125453725.png\" alt=\"事物的特性\"></p>\n<ol>\n<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>\n<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>\n<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ol>\n<h3 id=\"并发事务带来哪些问题\"><a href=\"#并发事务带来哪些问题\" class=\"headerlink\" title=\"并发事务带来哪些问题?\"></a>并发事务带来哪些问题?</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<ul>\n<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>\n<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>\n<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>\n<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>\n</ul>\n<p><strong>不可重复读和幻读区别：</strong></p>\n<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>\n<h3 id=\"事务隔离级别有哪些-MySQL的默认隔离级别是\"><a href=\"#事务隔离级别有哪些-MySQL的默认隔离级别是\" class=\"headerlink\" title=\"事务隔离级别有哪些?MySQL的默认隔离级别是?\"></a>事务隔离级别有哪些?MySQL的默认隔离级别是?</h3><p><strong>SQL 标准定义了四个隔离级别：</strong></p>\n<ul>\n<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>\n<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>\n<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>\n<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>\n</ul>\n<hr>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻影读</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>READ-UNCOMMITTED</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>READ-COMMITTED</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>REPEATABLE-READ</td>\n<td>×</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td>SERIALIZABLE</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody></table>\n<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT @@tx_isolation;</span><br><span class=\"line\">+-----------------+</span><br><span class=\"line\">| @@tx_isolation  |</span><br><span class=\"line\">+-----------------+</span><br><span class=\"line\">| REPEATABLE-READ |</span><br><span class=\"line\">+-----------------+</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEAaTABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>\n<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>\n<h3 id=\"锁机制与InnoDB锁算法\"><a href=\"#锁机制与InnoDB锁算法\" class=\"headerlink\" title=\"锁机制与InnoDB锁算法\"></a>锁机制与InnoDB锁算法</h3><p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p>\n<ul>\n<li>MyISAM采用表级锁(table-level locking)。</li>\n<li>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</li>\n</ul>\n<p><strong>表级锁和行级锁对比：</strong></p>\n<ul>\n<li><strong>表级锁：</strong> MySQL中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li>\n<li><strong>行级锁：</strong> MySQL中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>\n</ul>\n<p>详细内容可以参考： MySQL锁机制简单了解一下：<a href=\"https://blog.csdn.net/qq_34337272/article/details/80611486\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_34337272/article/details/80611486</a></p>\n<p><strong>InnoDB存储引擎的锁的算法有三种：</strong></p>\n<ul>\n<li>Record lock：单个行记录上的锁</li>\n<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>\n<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>\n</ul>\n<p><strong>相关知识点：</strong></p>\n<ol>\n<li>innodb对于行的查询使用next-key lock</li>\n<li>Next-locking keying为了解决Phantom Problem幻读问题</li>\n<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>\n<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>\n<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>\n</ol>\n<h3 id=\"大表优化\"><a href=\"#大表优化\" class=\"headerlink\" title=\"大表优化\"></a>大表优化</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>\n<h4 id=\"1-限定数据的范围\"><a href=\"#1-限定数据的范围\" class=\"headerlink\" title=\"1. 限定数据的范围\"></a>1. 限定数据的范围</h4><p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p>\n<h4 id=\"2-读-写分离\"><a href=\"#2-读-写分离\" class=\"headerlink\" title=\"2. 读/写分离\"></a>2. 读/写分离</h4><p>经典的数据库拆分方案，主库负责写，从库负责读；</p>\n<h4 id=\"3-垂直分区\"><a href=\"#3-垂直分区\" class=\"headerlink\" title=\"3. 垂直分区\"></a>3. 垂直分区</h4><p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>\n<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</p>\n<p><img src=\"/images/25453525.png\" alt=\"数据库垂直分区\"></p>\n<ul>\n<li><strong>垂直拆分的优点：</strong> 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li>\n<li><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li>\n</ul>\n<h4 id=\"4-水平分区\"><a href=\"#4-水平分区\" class=\"headerlink\" title=\"4. 水平分区\"></a>4. 水平分区</h4><p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>\n<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>\n<p><img src=\"/images/525453525.png\" alt=\"数据库水平拆分\"></p>\n<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p>\n<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>\n<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>\n<ul>\n<li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>\n<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>\n</ul>\n<p>详细内容可以参考： MySQL大表优化方案: <a href=\"https://segmentfault.com/a/1190000006158186\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000006158186</a></p>\n<h3 id=\"解释一下什么是池化设计思想。什么是数据库连接池-为什么需要数据库连接池\"><a href=\"#解释一下什么是池化设计思想。什么是数据库连接池-为什么需要数据库连接池\" class=\"headerlink\" title=\"解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?\"></a>解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?</h3><p>池化设计应该不是一个新名词。我们常见的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。就好比你去食堂打饭，打饭的大妈会先把饭盛好几份放那里，你来了就直接拿着饭盒加菜即可，不用再临时又盛饭又打菜，效率就高了。除了初始化资源，池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。这篇文章对<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485679&idx=1&sn=57dbca8c9ad49e1f3968ecff04a4f735&chksm=cea24724f9d5ce3212292fac291234a760c99c0960b5430d714269efe33554730b5f71208582&token=1141994790&lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener\">池化设计思想</a>介绍的还不错，直接复制过来，避免重复造轮子了。</p>\n<p>数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的 所以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。<strong>在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中</strong>。 连接池还减少了用户必须等待建立与数据库的连接的时间。</p>\n<h3 id=\"分库分表之后-id-主键如何处理？\"><a href=\"#分库分表之后-id-主键如何处理？\" class=\"headerlink\" title=\"分库分表之后,id 主键如何处理？\"></a>分库分表之后,id 主键如何处理？</h3><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。</p>\n<p>生成全局 id 有下面这几种方式：</p>\n<ul>\n<li><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。</li>\n<li><strong>数据库自增 id</strong> : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li>\n<li><strong>利用 redis 生成 id :</strong> 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</li>\n<li><strong>Twitter的snowflake算法</strong> ：Github 地址：<a href=\"https://github.com/twitter-archive/snowflake%E3%80%82\" target=\"_blank\" rel=\"noopener\">https://github.com/twitter-archive/snowflake。</a></li>\n<li><strong>美团的Leaf分布式ID生成系统</strong> ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章：<a href=\"https://tech.meituan.com/2017/04/21/mt-leaf.html\" target=\"_blank\" rel=\"noopener\">https://tech.meituan.com/2017/04/21/mt-leaf.html</a> 。</li>\n<li>……</li>\n</ul>\n<h3 id=\"一条SQL语句在MySQL中如何执行的\"><a href=\"#一条SQL语句在MySQL中如何执行的\" class=\"headerlink\" title=\"一条SQL语句在MySQL中如何执行的\"></a>一条SQL语句在MySQL中如何执行的</h3><p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener\">一条SQL语句在MySQL中如何执行的</a></p>\n<h3 id=\"MySQL高性能优化规范建议\"><a href=\"#MySQL高性能优化规范建议\" class=\"headerlink\" title=\"MySQL高性能优化规范建议\"></a>MySQL高性能优化规范建议</h3><p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener\">MySQL高性能优化规范建议</a></p>\n<h3 id=\"一条SQL语句执行得很慢的原因有哪些？\"><a href=\"#一条SQL语句执行得很慢的原因有哪些？\" class=\"headerlink\" title=\"一条SQL语句执行得很慢的原因有哪些？\"></a>一条SQL语句执行得很慢的原因有哪些？</h3><p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener\">腾讯面试：一条SQL语句执行得很慢的原因有哪些？—不看后悔系列</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是MySQL\"><a href=\"#什么是MySQL\" class=\"headerlink\" title=\"什么是MySQL?\"></a>什么是MySQL?</h3><p>MySQL 是一种关系型数据库，在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。阿里巴巴数据库系统也大量用到了 MySQL，因此它的稳定性是有保障的。MySQL是开放源代码的，因此任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL的默认端口号是<strong>3306</strong>。</p>\n<h3 id=\"存储引擎\"><a href=\"#存储引擎\" class=\"headerlink\" title=\"存储引擎\"></a>存储引擎</h3><h4 id=\"一些常用命令\"><a href=\"#一些常用命令\" class=\"headerlink\" title=\"一些常用命令\"></a>一些常用命令</h4><p><strong>查看MySQL提供的所有存储引擎</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show engines;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/96e65732e706e67.png\" alt=\"查看MySQL提供的所有存储引擎\"></p>\n<p>从上图我们可以查看出 MySQL 当前默认的存储引擎是InnoDB,并且在5.7版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p>\n<p><strong>查看MySQL当前默认的存储引擎</strong></p>\n<p>我们也可以通过下面的命令查看默认的存储引擎。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show variables like &#39;%storage_engine%&#39;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>查看表的存储引擎</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show table status like &quot;table_name&quot; ;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/20200702382545352.png\" alt=\"查看表的存储引擎\"></p>\n<h4 id=\"MyISAM和InnoDB区别\"><a href=\"#MyISAM和InnoDB区别\" class=\"headerlink\" title=\"MyISAM和InnoDB区别\"></a>MyISAM和InnoDB区别</h4><p>MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。</p>\n<p>大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。</p>\n<p><strong>两者的对比：</strong></p>\n<ol>\n<li><strong>是否支持行级锁</strong> : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>\n<li><strong>是否支持事务和崩溃后的安全恢复： MyISAM</strong> 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是<strong>InnoDB</strong> 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>\n<li><strong>是否支持外键：</strong> MyISAM不支持，而InnoDB支持。</li>\n<li><strong>是否支持MVCC</strong> ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。推荐阅读：<a href=\"https://segmentfault.com/a/1190000012650596\" target=\"_blank\" rel=\"noopener\">MySQL-InnoDB-MVCC多版本并发控制</a></li>\n<li>……</li>\n</ol>\n<p>《MySQL高性能》上面有一句话这样写到:</p>\n<blockquote>\n<p>不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p>\n</blockquote>\n<p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p>\n<h3 id=\"字符集及校对规则\"><a href=\"#字符集及校对规则\" class=\"headerlink\" title=\"字符集及校对规则\"></a>字符集及校对规则</h3><p>字符集指的是一种从二进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。MySQL中每一种字符集都会对应一系列的校对规则。</p>\n<p>MySQL采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集） PS：整理自《Java工程师修炼之道》</p>\n<p>详细内容可以参考： <a href=\"https://www.cnblogs.com/geaozhang/p/6724393.html#MySQLyuzifuji\" target=\"_blank\" rel=\"noopener\">MySQL字符集及校对规则的理解</a></p>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>MySQL索引使用的数据结构主要有<strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>\n<p>MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>\n<ul>\n<li><strong>MyISAM:</strong> B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li>\n<li><strong>InnoDB:</strong> 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</strong> <strong>因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong> PS：整理自《Java工程师修炼之道》</li>\n</ul>\n<p><strong>更多关于索引的内容可以查看文档首页MySQL目录下关于索引的详细总结。</strong></p>\n<h3 id=\"查询缓存的使用\"><a href=\"#查询缓存的使用\" class=\"headerlink\" title=\"查询缓存的使用\"></a>查询缓存的使用</h3><blockquote>\n<p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用</p>\n</blockquote>\n<p>my.cnf加入以下配置，重启MySQL开启查询缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">query_cache_type&#x3D;1</span><br><span class=\"line\">query_cache_size&#x3D;600000</span><br></pre></td></tr></table></figure>\n\n<p>MySQL执行以下命令也可以开启查询缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set global  query_cache_type&#x3D;1;</span><br><span class=\"line\">set global  query_cache_size&#x3D;600000;</span><br></pre></td></tr></table></figure>\n\n<p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。</p>\n<p>缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p>\n<p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，<strong>还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select sql_no_cache count(*) from usr;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"什么是事务\"><a href=\"#什么是事务\" class=\"headerlink\" title=\"什么是事务?\"></a>什么是事务?</h3><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>\n<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>\n<h3 id=\"事物的四大特性-ACID\"><a href=\"#事物的四大特性-ACID\" class=\"headerlink\" title=\"事物的四大特性(ACID)\"></a>事物的四大特性(ACID)</h3><p><img src=\"/images/125453725.png\" alt=\"事物的特性\"></p>\n<ol>\n<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>\n<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>\n<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>\n<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ol>\n<h3 id=\"并发事务带来哪些问题\"><a href=\"#并发事务带来哪些问题\" class=\"headerlink\" title=\"并发事务带来哪些问题?\"></a>并发事务带来哪些问题?</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<ul>\n<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>\n<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>\n<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>\n<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>\n</ul>\n<p><strong>不可重复读和幻读区别：</strong></p>\n<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>\n<h3 id=\"事务隔离级别有哪些-MySQL的默认隔离级别是\"><a href=\"#事务隔离级别有哪些-MySQL的默认隔离级别是\" class=\"headerlink\" title=\"事务隔离级别有哪些?MySQL的默认隔离级别是?\"></a>事务隔离级别有哪些?MySQL的默认隔离级别是?</h3><p><strong>SQL 标准定义了四个隔离级别：</strong></p>\n<ul>\n<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>\n<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>\n<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>\n<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>\n</ul>\n<hr>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻影读</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>READ-UNCOMMITTED</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>READ-COMMITTED</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>REPEATABLE-READ</td>\n<td>×</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td>SERIALIZABLE</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody></table>\n<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SELECT @@tx_isolation;</span><br><span class=\"line\">+-----------------+</span><br><span class=\"line\">| @@tx_isolation  |</span><br><span class=\"line\">+-----------------+</span><br><span class=\"line\">| REPEATABLE-READ |</span><br><span class=\"line\">+-----------------+</span><br></pre></td></tr></table></figure>\n\n<p>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEAaTABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>\n<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>\n<h3 id=\"锁机制与InnoDB锁算法\"><a href=\"#锁机制与InnoDB锁算法\" class=\"headerlink\" title=\"锁机制与InnoDB锁算法\"></a>锁机制与InnoDB锁算法</h3><p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p>\n<ul>\n<li>MyISAM采用表级锁(table-level locking)。</li>\n<li>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</li>\n</ul>\n<p><strong>表级锁和行级锁对比：</strong></p>\n<ul>\n<li><strong>表级锁：</strong> MySQL中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li>\n<li><strong>行级锁：</strong> MySQL中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>\n</ul>\n<p>详细内容可以参考： MySQL锁机制简单了解一下：<a href=\"https://blog.csdn.net/qq_34337272/article/details/80611486\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_34337272/article/details/80611486</a></p>\n<p><strong>InnoDB存储引擎的锁的算法有三种：</strong></p>\n<ul>\n<li>Record lock：单个行记录上的锁</li>\n<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>\n<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>\n</ul>\n<p><strong>相关知识点：</strong></p>\n<ol>\n<li>innodb对于行的查询使用next-key lock</li>\n<li>Next-locking keying为了解决Phantom Problem幻读问题</li>\n<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>\n<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>\n<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>\n</ol>\n<h3 id=\"大表优化\"><a href=\"#大表优化\" class=\"headerlink\" title=\"大表优化\"></a>大表优化</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>\n<h4 id=\"1-限定数据的范围\"><a href=\"#1-限定数据的范围\" class=\"headerlink\" title=\"1. 限定数据的范围\"></a>1. 限定数据的范围</h4><p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p>\n<h4 id=\"2-读-写分离\"><a href=\"#2-读-写分离\" class=\"headerlink\" title=\"2. 读/写分离\"></a>2. 读/写分离</h4><p>经典的数据库拆分方案，主库负责写，从库负责读；</p>\n<h4 id=\"3-垂直分区\"><a href=\"#3-垂直分区\" class=\"headerlink\" title=\"3. 垂直分区\"></a>3. 垂直分区</h4><p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>\n<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</p>\n<p><img src=\"/images/25453525.png\" alt=\"数据库垂直分区\"></p>\n<ul>\n<li><strong>垂直拆分的优点：</strong> 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li>\n<li><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li>\n</ul>\n<h4 id=\"4-水平分区\"><a href=\"#4-水平分区\" class=\"headerlink\" title=\"4. 水平分区\"></a>4. 水平分区</h4><p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>\n<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>\n<p><img src=\"/images/525453525.png\" alt=\"数据库水平拆分\"></p>\n<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p>\n<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>\n<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>\n<ul>\n<li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>\n<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>\n</ul>\n<p>详细内容可以参考： MySQL大表优化方案: <a href=\"https://segmentfault.com/a/1190000006158186\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000006158186</a></p>\n<h3 id=\"解释一下什么是池化设计思想。什么是数据库连接池-为什么需要数据库连接池\"><a href=\"#解释一下什么是池化设计思想。什么是数据库连接池-为什么需要数据库连接池\" class=\"headerlink\" title=\"解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?\"></a>解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?</h3><p>池化设计应该不是一个新名词。我们常见的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。就好比你去食堂打饭，打饭的大妈会先把饭盛好几份放那里，你来了就直接拿着饭盒加菜即可，不用再临时又盛饭又打菜，效率就高了。除了初始化资源，池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。这篇文章对<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485679&idx=1&sn=57dbca8c9ad49e1f3968ecff04a4f735&chksm=cea24724f9d5ce3212292fac291234a760c99c0960b5430d714269efe33554730b5f71208582&token=1141994790&lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener\">池化设计思想</a>介绍的还不错，直接复制过来，避免重复造轮子了。</p>\n<p>数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的 所以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。<strong>在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中</strong>。 连接池还减少了用户必须等待建立与数据库的连接的时间。</p>\n<h3 id=\"分库分表之后-id-主键如何处理？\"><a href=\"#分库分表之后-id-主键如何处理？\" class=\"headerlink\" title=\"分库分表之后,id 主键如何处理？\"></a>分库分表之后,id 主键如何处理？</h3><p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。</p>\n<p>生成全局 id 有下面这几种方式：</p>\n<ul>\n<li><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。</li>\n<li><strong>数据库自增 id</strong> : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li>\n<li><strong>利用 redis 生成 id :</strong> 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</li>\n<li><strong>Twitter的snowflake算法</strong> ：Github 地址：<a href=\"https://github.com/twitter-archive/snowflake%E3%80%82\" target=\"_blank\" rel=\"noopener\">https://github.com/twitter-archive/snowflake。</a></li>\n<li><strong>美团的Leaf分布式ID生成系统</strong> ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章：<a href=\"https://tech.meituan.com/2017/04/21/mt-leaf.html\" target=\"_blank\" rel=\"noopener\">https://tech.meituan.com/2017/04/21/mt-leaf.html</a> 。</li>\n<li>……</li>\n</ul>\n<h3 id=\"一条SQL语句在MySQL中如何执行的\"><a href=\"#一条SQL语句在MySQL中如何执行的\" class=\"headerlink\" title=\"一条SQL语句在MySQL中如何执行的\"></a>一条SQL语句在MySQL中如何执行的</h3><p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener\">一条SQL语句在MySQL中如何执行的</a></p>\n<h3 id=\"MySQL高性能优化规范建议\"><a href=\"#MySQL高性能优化规范建议\" class=\"headerlink\" title=\"MySQL高性能优化规范建议\"></a>MySQL高性能优化规范建议</h3><p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener\">MySQL高性能优化规范建议</a></p>\n<h3 id=\"一条SQL语句执行得很慢的原因有哪些？\"><a href=\"#一条SQL语句执行得很慢的原因有哪些？\" class=\"headerlink\" title=\"一条SQL语句执行得很慢的原因有哪些？\"></a>一条SQL语句执行得很慢的原因有哪些？</h3><p><a href=\"https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener\">腾讯面试：一条SQL语句执行得很慢的原因有哪些？—不看后悔系列</a></p>\n"},{"title":"disruptor","date":"2020-04-27T07:34:37.000Z","_content":"## 背景\n\nDisruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级）。基于Disruptor开发的系统单线程能支撑每秒600万订单，2010年在QCon演讲后，获得了业界关注。2011年，企业应用软件专家Martin Fowler专门撰写长文介绍。同年它还获得了Oracle官方的Duke大奖。\n\n目前，包括Apache Storm、Camel、Log4j 2在内的很多知名项目都应用了Disruptor以获取高性能。在美团技术团队它也有不少应用，有的项目架构借鉴了它的设计机制。本文从实战角度剖析了Disruptor的实现原理。\n\n需要特别指出的是，这里所说的队列是系统内部的内存队列，而不是Kafka这样的分布式队列。另外，本文所描述的Disruptor特性限于3.3.4。\n\n## Java内置队列\n\n介绍Disruptor之前，我们先来看一看常用的线程安全的内置队列有什么问题。Java的内置队列如下表所示。\n\n| 队列                  | 有界性             | 锁   | 数据结构   |\n| --------------------- | ------------------ | ---- | ---------- |\n| ArrayBlockingQueue    | bounded            | 加锁 | arraylist  |\n| LinkedBlockingQueue   | optionally-bounded | 加锁 | linkedlist |\n| ConcurrentLinkedQueue | unbounded          | 无锁 | linkedlist |\n| LinkedTransferQueue   | unbounded          | 无锁 | linkedlist |\n| PriorityBlockingQueue | unbounded          | 加锁 | heap       |\n| DelayQueue            | unbounded          | 加锁 | heap       |\n\n队列的底层一般分成三种：数组、链表和堆。其中，堆一般情况下是为了实现带有优先级特性的队列，暂且不考虑。\n\n我们就从数组和链表两种数据结构来看，基于数组线程安全的队列，比较典型的是ArrayBlockingQueue，它主要通过加锁的方式来保证线程安全；基于链表的线程安全队列分成LinkedBlockingQueue和ConcurrentLinkedQueue两大类，前者也通过锁的方式来实现线程安全，而后者以及上面表格中的LinkedTransferQueue都是通过原子变量compare and swap（以下简称“CAS”）这种不加锁的方式来实现的。\n\n通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在确定的范围内）；而加锁的方式，可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列；同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array/heap格式的数据结构。这样筛选下来，符合条件的队列就只有ArrayBlockingQueue。\n\n## ArrayBlockingQueue的问题\n\nArrayBlockingQueue在实际使用过程中，会因为加锁和伪共享等出现严重的性能问题，我们下面来分析一下。\n\n### 加锁\n\n现实编程过程中，加锁通常会严重地影响性能。线程会因为竞争不到锁而被挂起，等锁被释放的时候，线程又会被恢复，这个过程中存在着很大的开销，并且通常会有较长时间的中断，因为当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，例如发生了缺页错误、调度延迟或者其它类似情况，那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，就会发生优先级反转。\n\nDisruptor论文中讲述了一个实验：\n\n- 这个测试程序调用了一个函数，该函数会对一个64位的计数器循环自增5亿次。\n- 机器环境：2.4G 6核\n- 运算： 64位的计数器累加5亿次\n\n|Method | Time (ms) | |— | —| |Single thread | 300| |Single thread with CAS | 5,700| |Single thread with lock | 10,000| |Single thread with volatile write | 4,700| |Two threads with CAS | 30,000| |Two threads with lock | 224,000|\n\nCAS操作比单线程无锁慢了1个数量级；有锁且多线程并发的情况下，速度比单线程无锁慢3个数量级。可见无锁速度最快。\n\n单线程情况下，不加锁的性能 > CAS操作的性能 > 加锁的性能。\n\n在多线程情况下，为了保证线程安全，必须使用CAS或锁，这种情况下，CAS的性能超过锁的性能，前者大约是后者的8倍。\n\n综上可知，加锁的性能是最差的。\n\n**关于锁和CAS**\n\n保证线程安全一般分成两种方式：锁和原子变量。\n\n**锁**\n\n![图1 通过加锁的方式实现线程安全](https://p1.meituan.net/travelcube/9b6a41f7d8527df9730b7832b38ec4d5180025.png)\n\n图1 通过加锁的方式实现线程安全\n\n采取加锁的方式，默认线程会冲突，访问数据时，先加上锁再访问，访问之后再解锁。通过锁界定一个临界区，同时只有一个线程进入。如上图所示，Thread2访问Entry的时候，加了锁，Thread1就不能再执行访问Entry的代码，从而保证线程安全。\n\n下面是ArrayBlockingQueue通过加锁的方式实现的offer方法，保证线程安全。\n\n```\npublic boolean offer(E e) {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        if (count == items.length)\n            return false;\n        else {\n            insert(e);\n            return true;\n        }\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n**原子变量**\n\n原子变量能够保证原子性的操作，意思是某个任务在执行过程中，要么全部成功，要么全部失败回滚，恢复到执行之前的初态，不存在初态和成功之间的中间状态。例如CAS操作，要么比较并交换成功，要么比较并交换失败。由CPU保证原子性。\n\n通过原子变量可以实现线程安全。执行某个任务的时候，先假定不会有冲突，若不发生冲突，则直接执行成功；当发生冲突的时候，则执行失败，回滚再重新操作，直到不发生冲突。\n\n![图2 通过原子变量CAS实现线程安全](https://p0.meituan.net/travelcube/de0ced42337014947e7466db4d8f2d4d158395.png)\n\n图2 通过原子变量CAS实现线程安全\n\n如图所示，Thread1和Thread2都要把Entry加1。若不加锁，也不使用CAS，有可能Thread1取到了myValue=1，Thread2也取到了myValue=1，然后相加，Entry中的value值为2。这与预期不相符，我们预期的是Entry的值经过两次相加后等于3。\n\nCAS会先把Entry现在的value跟线程当初读出的值相比较，若相同，则赋值；若不相同，则赋值执行失败。一般会通过while/for循环来重新执行，直到赋值成功。\n\n代码示例是AtomicInteger的getAndAdd方法。CAS是CPU的一个指令，由CPU保证原子性。\n\n```\n/**\n * Atomically adds the given value to the current value.\n *\n * @param delta the value to add\n * @return the previous value\n */\npublic final int getAndAdd(int delta) {\n    for (;;) {\n        int current = get();\n        int next = current + delta;\n        if (compareAndSet(current, next))\n            return current;\n    }\n}\n  \n/**\n * Atomically sets the value to the given updated value\n * if the current value {@code ==} the expected value.\n *\n * @param expect the expected value\n * @param update the new value\n * @return true if successful. False return indicates that\n * the actual value was not equal to the expected value.\n */\npublic final boolean compareAndSet(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n} \n```\n\n在高度竞争的情况下，锁的性能将超过原子变量的性能，但是更真实的竞争情况下，原子变量的性能将超过锁的性能。同时原子变量不会有死锁等活跃性问题。\n\n### 伪共享\n\n**什么是共享**\n\n下图是计算的基本结构。L1、L2、L3分别表示一级缓存、二级缓存、三级缓存，越靠近CPU的缓存，速度越快，容量也越小。所以L1缓存很小但很快，并且紧靠着在使用它的CPU内核；L2大一些，也慢一些，并且仍然只能被一个单独的CPU核使用；L3更大、更慢，并且被单个插槽上的所有CPU核共享；最后是主存，由全部插槽上的所有CPU核共享。\n\n![图3 计算机CPU与缓存示意图](https://p1.meituan.net/travelcube/69ce8ffbe7a4ebee01c377dac174842d433755.png)\n\n图3 计算机CPU与缓存示意图\n\n当CPU执行运算的时候，它先去L1查找所需的数据、再去L2、然后是L3，如果最后这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要尽量确保数据在L1缓存中。\n\n另外，线程之间共享一份数据的时候，需要一个线程把数据写回主存，而另一个线程访问主存中相应的数据。\n\n下面是从CPU访问不同层级数据的时间概念:\n\n| 从CPU到                                  | 大约需要的CPU周期 | 大约需要的时间 |\n| ---------------------------------------- | ----------------- | -------------- |\n| 主存                                     | -                 | 约60-80ns      |\n| QPI 总线传输(between sockets, not drawn) | -                 | 约20ns         |\n| L3 cache                                 | 约40-45 cycles    | 约15ns         |\n| L2 cache                                 | 约10 cycles       | 约3ns          |\n| L1 cache                                 | 约3-4 cycles      | 约1ns          |\n| 寄存器                                   | 1 cycle           | -              |\n\n可见CPU读取主存中的数据会比从L1中读取慢了近2个数量级。\n\n**缓存行**\n\nCache是由很多个cache line组成的。每个cache line通常是64字节，并且它有效地引用主内存中的一块儿地址。一个Java的long类型变量是8字节，因此在一个缓存行中可以存8个long类型的变量。\n\nCPU每次从主存中拉取数据时，会把相邻的数据也存入同一个cache line。\n\n在访问一个long数组的时候，如果数组中的一个值被加载到缓存中，它会自动加载另外7个。因此你能非常快的遍历这个数组。事实上，你可以非常快速的遍历在连续内存块中分配的任意数据结构。\n\n下面的例子是测试利用cache line的特性和不利用cache line的特性的效果对比。\n\n```\npackage com.meituan.FalseSharing;\n \n/**\n * @author gongming\n * @description\n * @date 16/6/4\n */\npublic class CacheLineEffect {\n    //考虑一般缓存行大小是64字节，一个 long 类型占8字节\n    static  long[][] arr;\n \n    public static void main(String[] args) {\n        arr = new long[1024 * 1024][];\n        for (int i = 0; i < 1024 * 1024; i++) {\n            arr[i] = new long[8];\n            for (int j = 0; j < 8; j++) {\n                arr[i][j] = 0L;\n            }\n        }\n        long sum = 0L;\n        long marked = System.currentTimeMillis();\n        for (int i = 0; i < 1024 * 1024; i+=1) {\n            for(int j =0; j< 8;j++){\n                sum = arr[i][j];\n            }\n        }\n        System.out.println(\"Loop times:\" + (System.currentTimeMillis() - marked) + \"ms\");\n \n        marked = System.currentTimeMillis();\n        for (int i = 0; i < 8; i+=1) {\n            for(int j =0; j< 1024 * 1024;j++){\n                sum = arr[j][i];\n            }\n        }\n        System.out.println(\"Loop times:\" + (System.currentTimeMillis() - marked) + \"ms\");\n    }\n}\n```\n\n在2G Hz、2核、8G内存的运行环境中测试，速度差一倍。\n\n结果：\n\nLoop times:30ms Loop times:65ms\n\n**什么是伪共享**\n\nArrayBlockingQueue有三个成员变量： - takeIndex：需要被取走的元素下标 - putIndex：可被元素插入的位置的下标 - count：队列中元素的数量\n\n这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。\n\n![图4 ArrayBlockingQueue伪共享示意图](https://p0.meituan.net/travelcube/192e9b87b7a5b68cac352fdeb81dc93b161543.png)\n\n图4 ArrayBlockingQueue伪共享示意图\n\n如上图所示，当生产者线程put一个元素到ArrayBlockingQueue时，putIndex会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。\n\n这种无法充分使用缓存行特性的现象，称为伪共享。\n\n对于伪共享，一般的解决方案是，增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上，以空间换时间。\n\n```\npackage com.meituan.FalseSharing;\n \npublic class FalseSharing implements Runnable{\n        public final static long ITERATIONS = 500L * 1000L * 100L;\n        private int arrayIndex = 0;\n \n        private static ValuePadding[] longs;\n        public FalseSharing(final int arrayIndex) {\n            this.arrayIndex = arrayIndex;\n        }\n \n        public static void main(final String[] args) throws Exception {\n            for(int i=1;i<10;i++){\n                System.gc();\n                final long start = System.currentTimeMillis();\n                runTest(i);\n                System.out.println(\"Thread num \"+i+\" duration = \" + (System.currentTimeMillis() - start));\n            }\n \n        }\n \n        private static void runTest(int NUM_THREADS) throws InterruptedException {\n            Thread[] threads = new Thread[NUM_THREADS];\n            longs = new ValuePadding[NUM_THREADS];\n            for (int i = 0; i < longs.length; i++) {\n                longs[i] = new ValuePadding();\n            }\n            for (int i = 0; i < threads.length; i++) {\n                threads[i] = new Thread(new FalseSharing(i));\n            }\n \n            for (Thread t : threads) {\n                t.start();\n            }\n \n            for (Thread t : threads) {\n                t.join();\n            }\n        }\n \n        public void run() {\n            long i = ITERATIONS + 1;\n            while (0 != --i) {\n                longs[arrayIndex].value = 0L;\n            }\n        }\n \n        public final static class ValuePadding {\n            protected long p1, p2, p3, p4, p5, p6, p7;\n            protected volatile long value = 0L;\n            protected long p9, p10, p11, p12, p13, p14;\n            protected long p15;\n        }\n        public final static class ValueNoPadding {\n            // protected long p1, p2, p3, p4, p5, p6, p7;\n            protected volatile long value = 0L;\n            // protected long p9, p10, p11, p12, p13, p14, p15;\n        }\n}\n```\n\n在2G Hz，2核，8G内存, jdk 1.7.0_45 的运行环境下，使用了共享机制比没有使用共享机制，速度快了4倍左右。\n\n结果：\n\n- Thread num 1 duration = 447\n- Thread num 2 duration = 463\n- Thread num 3 duration = 454\n- Thread num 4 duration = 464\n- Thread num 5 duration = 561\n- Thread num 6 duration = 606\n- Thread num 7 duration = 684\n- Thread num 8 duration = 870\n- Thread num 9 duration = 823\n\n把代码中ValuePadding都替换为ValueNoPadding后的结果：\n\n- Thread num 1 duration = 446\n- Thread num 2 duration = 2549\n- Thread num 3 duration = 2898\n- Thread num 4 duration = 3931\n- Thread num 5 duration = 4716\n- Thread num 6 duration = 5424\n- Thread num 7 duration = 4868\n- Thread num 8 duration = 4595\n- Thread num 9 duration = 4540\n\n备注：在jdk1.8中，有专门的注解@Contended来避免伪共享，更优雅地解决问题。\n\n## Disruptor的设计方案\n\nDisruptor通过以下设计来解决队列速度慢的问题：\n\n- 环形数组结构\n\n为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。\n\n- 元素位置定位\n\n数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。\n\n- 无锁设计\n\n每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。\n\n下面忽略数组的环形结构，介绍一下如何实现无锁设计。整个过程通过原子变量CAS，保证操作的线程安全。\n\n### 一个生产者\n\n**写数据**\n\n生产者单线程写数据的流程比较简单：\n\n1. 申请写入m个元素；\n2. 若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素；\n3. 若是返回的正确，则生产者开始写入元素。\n\n![图5 单个生产者生产过程示意图](https://p1.meituan.net/travelcube/e71c1449273361ec413fffc7b0bf5507208689.png)\n\n图5 单个生产者生产过程示意图\n\n## 多个生产者\n\n多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor的解决方法是，每个线程获取不同的一段数组空间进行操作。这个通过CAS很容易达到。只需要在分配元素的时候，通过CAS判断一下这段空间是否已经分配出去即可。\n\n但是会遇到一个新问题：如何防止读取的时候，读到还未写的元素。Disruptor在多个生产者的情况下，引入了一个与Ring Buffer大小相同的buffer：available Buffer。当某个位置写入成功的时候，便把availble Buffer相应的位置置位，标记为写入成功。读取的时候，会遍历available Buffer，来判断元素是否已经就绪。\n\n下面分读数据和写数据两种情况介绍。\n\n### 读数据\n\n生产者多线程写入的情况会复杂很多：\n\n1. 申请读取到序号n；\n2. 若writer cursor >= n，这时仍然无法确定连续可读的最大下标。从reader cursor开始读取available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；\n3. 消费者读取元素。\n\n如下图所示，读线程读到下标为2的元素，三个线程Writer1/Writer2/Writer3正在向RingBuffer相应位置写数据，写线程被分配到的最大元素下标是11。\n\n读线程申请读取到下标从3到11的元素，判断writer cursor>=11。然后开始读取availableBuffer，从3开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。\n\n然后，消费者读取下标从3到6共计4个元素。\n\n![图6 多个生产者情况下，消费者消费过程示意图](https://p0.meituan.net/travelcube/99c603494ea90c9535e165579daf340a161527.png)\n\n图6 多个生产者情况下，消费者消费过程示意图\n\n### 写数据\n\n多个生产者写入的时候：\n\n1. 申请写入m个元素；\n2. 若是有m个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；\n3. 生产者写入元素，写入元素的同时设置available Buffer里面相应的位置，以标记自己哪些位置是已经写入成功的。\n\n如下图所示，Writer1和Writer2两个线程写入数组，都申请可写的数组空间。Writer1被分配了下标3到下表5的空间，Writer2被分配了下标6到下标9的空间。\n\nWriter1写入下标3位置的元素，同时把available Buffer相应位置置位，标记已经写入成功，往后移一位，开始写下标4位置的元素。Writer2同样的方式。最终都写入完成。\n\n![图7 多个生产者情况下，生产者生产过程示意图](https://p1.meituan.net/travelcube/5e06841b1bba4dcf1d3fac169734ba36133983.png)\n\n图7 多个生产者情况下，生产者生产过程示意图\n\n防止不同生产者对同一段空间写入的代码，如下所示：\n\n```\npublic long tryNext(int n) throws InsufficientCapacityException\n{\n    if (n < 1)\n    {\n        throw new IllegalArgumentException(\"n must be > 0\");\n    }\n \n    long current;\n    long next;\n \n    do\n    {\n        current = cursor.get();\n        next = current + n;\n \n        if (!hasAvailableCapacity(gatingSequences, n, current))\n        {\n            throw InsufficientCapacityException.INSTANCE;\n        }\n    }\n    while (!cursor.compareAndSet(current, next));\n \n    return next;\n}\n```\n\n通过do/while循环的条件cursor.compareAndSet(current, next)，来判断每次申请的空间是否已经被其他生产者占据。假如已经被占据，该函数会返回失败，While循环重新执行，申请写入空间。\n\n消费者的流程与生产者非常类似，这儿就不多描述了。\n\n### 总结\n\nDisruptor通过精巧的无锁设计实现了在高并发情形下的高性能。\n\n在美团内部，很多高并发场景借鉴了Disruptor的设计，减少竞争的强度。其设计思想可以扩展到分布式场景，通过无锁设计，来提升服务性能。\n\n使用Disruptor比使用ArrayBlockingQueue略微复杂，为方便读者上手，增加代码样例。\n\n代码实现的功能：每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端。详细逻辑请细读代码。\n\n以下代码基于3.3.4版本的Disruptor包。\n\n```\npackage com.meituan.Disruptor;\n\n/**\n * @description disruptor代码样例。每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端\n */\nimport com.lmax.disruptor.*;\nimport com.lmax.disruptor.dsl.Disruptor;\nimport com.lmax.disruptor.dsl.ProducerType;\n\nimport java.util.concurrent.ThreadFactory;\n\n\npublic class DisruptorMain\n{\n    public static void main(String[] args) throws Exception\n    {\n        // 队列中的元素\n        class Element {\n\n            private int value;\n\n            public int get(){\n                return value;\n            }\n\n            public void set(int value){\n                this.value= value;\n            }\n\n        }\n\n        // 生产者的线程工厂\n        ThreadFactory threadFactory = new ThreadFactory(){\n            @Override\n            public Thread newThread(Runnable r) {\n                return new Thread(r, \"simpleThread\");\n            }\n        };\n\n        // RingBuffer生产工厂,初始化RingBuffer的时候使用\n        EventFactory<Element> factory = new EventFactory<Element>() {\n            @Override\n            public Element newInstance() {\n                return new Element();\n            }\n        };\n\n        // 处理Event的handler\n        EventHandler<Element> handler = new EventHandler<Element>(){\n            @Override\n            public void onEvent(Element element, long sequence, boolean endOfBatch)\n            {\n                System.out.println(\"Element: \" + element.get());\n            }\n        };\n\n        // 阻塞策略\n        BlockingWaitStrategy strategy = new BlockingWaitStrategy();\n\n        // 指定RingBuffer的大小\n        int bufferSize = 16;\n\n        // 创建disruptor，采用单生产者模式\n        Disruptor<Element> disruptor = new Disruptor(factory, bufferSize, threadFactory, ProducerType.SINGLE, strategy);\n\n        // 设置EventHandler\n        disruptor.handleEventsWith(handler);\n\n        // 启动disruptor的线程\n        disruptor.start();\n\n        RingBuffer<Element> ringBuffer = disruptor.getRingBuffer();\n\n        for (int l = 0; true; l++)\n        {\n            // 获取下一个可用位置的下标\n            long sequence = ringBuffer.next();  \n            try\n            {\n                // 返回可用位置的元素\n                Element event = ringBuffer.get(sequence); \n                // 设置该位置元素的值\n                event.set(l); \n            }\n            finally\n            {\n                ringBuffer.publish(sequence);\n            }\n            Thread.sleep(10);\n        }\n    }\n}\n```\n\n## 性能\n\n以下面这些模式测试性能:\n\n![img](https://p1.meituan.net/travelcube/ada37da4ad62709ab67d7a32147cb19a306409.png)\n\n吞吐量测试数据（每秒的数量）如下。\n\n环境： - CPU:Intel Core i7 860 @ 2.8 GHz without HT - JVM:Java 1.6.0_25 64-bit - OS:Windows 7\n\n| -                  | ABQ       | Disruptor  |\n| ------------------ | --------- | ---------- |\n| Unicast: 1P – 1C   | 5,339,256 | 25,998,336 |\n| Pipeline: 1P – 3C  | 2,128,918 | 16,806,157 |\n| Sequencer: 3P – 1C | 5,539,531 | 13,403,268 |\n| Multicast: 1P – 3C | 1,077,384 | 9,377,871  |\n| Diamond: 1P – 3C   | 2,113,941 | 16,143,613 |\n\n环境：\n\n- CPU:Intel Core i7-2720QM\n- JVM:Java 1.6.0_25 64-bit\n- OS:Ubuntu 11.04\n\n| -                  | ABQ       | Disruptor  |\n| ------------------ | --------- | ---------- |\n| Unicast: 1P – 1C   | 4,057,453 | 22,381,378 |\n| Pipeline: 1P – 3C  | 2,006,903 | 15,857,913 |\n| Sequencer: 3P – 1C | 2,056,118 | 14,540,519 |\n| Multicast: 1P – 3C | 260,733   | 10,860,121 |\n| Diamond: 1P – 3C   | 2,082,725 | 15,295,197 |\n\n依据并发竞争的激烈程度的不同，Disruptor比ArrayBlockingQueue吞吐量快4~7倍。\n\n按照Pipeline: 1P – 3C的连接模式测试延迟，生产者两次写入之间的延迟为1ms。\n\n运行环境：\n\n- CPU:2.2GHz Core i7-2720QM\n- Java: 1.6.0_25 64-bit\n- OS:Ubuntu 11.04.\n\n| -                             | Array Blocking Queue (ns) | Disruptor (ns) |\n| ----------------------------- | ------------------------- | -------------- |\n| 99% observations less than    | 2,097,152                 | 128            |\n| 99.99% observations less than | 4,194,304                 | 8,192          |\n| Max Latency                   | 5,069,086                 | 175,567        |\n| Mean Latency                  | 32,757                    | 52             |\n| Min Latency                   | 145                       | 29             |\n\n可见，平均延迟差了3个数量级。\n\n## 等待策略\n\n### 生产者的等待策略\n\n暂时只有休眠1ns。\n\n```\nLockSupport.parkNanos(1);\n```\n\n### 消费者的等待策略\n\n| 名称                        | 措施                      | 适用场景                                                     |\n| --------------------------- | ------------------------- | ------------------------------------------------------------ |\n| BlockingWaitStrategy        | 加锁                      | CPU资源紧缺，吞吐量和延迟并不重要的场景                      |\n| BusySpinWaitStrategy        | 自旋                      | 通过不断重试，减少切换线程导致的系统调用，而降低延迟。推荐在线程绑定到固定的CPU的场景下使用 |\n| PhasedBackoffWaitStrategy   | 自旋 + yield + 自定义策略 | CPU资源紧缺，吞吐量和延迟并不重要的场景                      |\n| SleepingWaitStrategy        | 自旋 + yield + sleep      | 性能和CPU资源之间有很好的折中。延迟不均匀                    |\n| TimeoutBlockingWaitStrategy | 加锁，有超时限制          | CPU资源紧缺，吞吐量和延迟并不重要的场景                      |\n| YieldingWaitStrategy        | 自旋 + yield + 自旋       | 性能和CPU资源之间有很好的折中。延迟比较均匀                  |\n\n## Log4j 2应用场景\n\nLog4j 2相对于Log4j 1最大的优势在于多线程并发场景下性能更优。该特性源自于Log4j 2的异步模式采用了Disruptor来处理。 在Log4j 2的配置文件中可以配置WaitStrategy，默认是Timeout策略。下面是Log4j 2中对WaitStrategy的配置官方文档：\n\n| System Property          | Default Value | Description                                                  |\n| ------------------------ | ------------- | ------------------------------------------------------------ |\n| AsyncLogger.WaitStrategy | Timeout       | Valid values: Block, Timeout, Sleep, Yield. Block is a strategy that uses a lock and condition variable for the I/O thread waiting for log events. Block can be used when throughput and low-latency are not as important as CPU resource. Recommended for resource constrained/virtualised environments. Timeout is a variation of the Block strategy that will periodically wake up from the lock condition await() call. This ensures that if a notification is missed somehow the consumer thread is not stuck but will recover with a small latency delay (default 10ms). Sleep is a strategy that initially spins, then uses a Thread.yield(), and eventually parks for the minimum number of nanos the OS and JVM will allow while the I/O thread is waiting for log events. Sleep is a good compromise between performance and CPU resource. This strategy has very low impact on the application thread, in exchange for some additional latency for actually getting the message logged. Yield is a strategy that uses a Thread.yield() for waiting for log events after an initially spinning. Yield is a good compromise between performance and CPU resource, but may use more CPU than Sleep in order to get the message logged to disk sooner. |\n\n### 性能差异\n\nloggers all async采用的是Disruptor，而Async Appender采用的是ArrayBlockingQueue队列。\n\n由图可见，单线程情况下，loggers all async与Async Appender吞吐量相差不大，但是在64个线程的时候，loggers all async的吞吐量比Async Appender增加了12倍，是Sync模式的68倍。\n\n![图8 Log4j 2各个模式性能比较](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/ad04b8bd.png)\n\n图8 Log4j 2各个模式性能比较\n\n美团在公司内部统一推行日志接入规范，要求必须使用Log4j 2，使普通单机QPS的上限不再只停留在几千，极高地提升了服务性能。\n\n## 参考文档\n\n1. <http://brokendreams.iteye.com/blog/2255720>\n2. <http://ifeve.com/dissecting-disruptor-whats-so-special/>\n3. <https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results>\n4. <https://lmax-exchange.github.io/disruptor/>\n5. <https://logging.apache.org/log4j/2.x/manual/async.html>","source":"_posts/java/disruptor.md","raw":"---\ntitle: disruptor\ntags:\n  - java\n  - collection\n  - disruptor\n  - 队列\ncategories:\n  - java\n  - collection\n  - queue\n  - disruptor\ndate: 2020-04-27 15:34:37\n---\n## 背景\n\nDisruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级）。基于Disruptor开发的系统单线程能支撑每秒600万订单，2010年在QCon演讲后，获得了业界关注。2011年，企业应用软件专家Martin Fowler专门撰写长文介绍。同年它还获得了Oracle官方的Duke大奖。\n\n目前，包括Apache Storm、Camel、Log4j 2在内的很多知名项目都应用了Disruptor以获取高性能。在美团技术团队它也有不少应用，有的项目架构借鉴了它的设计机制。本文从实战角度剖析了Disruptor的实现原理。\n\n需要特别指出的是，这里所说的队列是系统内部的内存队列，而不是Kafka这样的分布式队列。另外，本文所描述的Disruptor特性限于3.3.4。\n\n## Java内置队列\n\n介绍Disruptor之前，我们先来看一看常用的线程安全的内置队列有什么问题。Java的内置队列如下表所示。\n\n| 队列                  | 有界性             | 锁   | 数据结构   |\n| --------------------- | ------------------ | ---- | ---------- |\n| ArrayBlockingQueue    | bounded            | 加锁 | arraylist  |\n| LinkedBlockingQueue   | optionally-bounded | 加锁 | linkedlist |\n| ConcurrentLinkedQueue | unbounded          | 无锁 | linkedlist |\n| LinkedTransferQueue   | unbounded          | 无锁 | linkedlist |\n| PriorityBlockingQueue | unbounded          | 加锁 | heap       |\n| DelayQueue            | unbounded          | 加锁 | heap       |\n\n队列的底层一般分成三种：数组、链表和堆。其中，堆一般情况下是为了实现带有优先级特性的队列，暂且不考虑。\n\n我们就从数组和链表两种数据结构来看，基于数组线程安全的队列，比较典型的是ArrayBlockingQueue，它主要通过加锁的方式来保证线程安全；基于链表的线程安全队列分成LinkedBlockingQueue和ConcurrentLinkedQueue两大类，前者也通过锁的方式来实现线程安全，而后者以及上面表格中的LinkedTransferQueue都是通过原子变量compare and swap（以下简称“CAS”）这种不加锁的方式来实现的。\n\n通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在确定的范围内）；而加锁的方式，可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列；同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array/heap格式的数据结构。这样筛选下来，符合条件的队列就只有ArrayBlockingQueue。\n\n## ArrayBlockingQueue的问题\n\nArrayBlockingQueue在实际使用过程中，会因为加锁和伪共享等出现严重的性能问题，我们下面来分析一下。\n\n### 加锁\n\n现实编程过程中，加锁通常会严重地影响性能。线程会因为竞争不到锁而被挂起，等锁被释放的时候，线程又会被恢复，这个过程中存在着很大的开销，并且通常会有较长时间的中断，因为当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，例如发生了缺页错误、调度延迟或者其它类似情况，那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，就会发生优先级反转。\n\nDisruptor论文中讲述了一个实验：\n\n- 这个测试程序调用了一个函数，该函数会对一个64位的计数器循环自增5亿次。\n- 机器环境：2.4G 6核\n- 运算： 64位的计数器累加5亿次\n\n|Method | Time (ms) | |— | —| |Single thread | 300| |Single thread with CAS | 5,700| |Single thread with lock | 10,000| |Single thread with volatile write | 4,700| |Two threads with CAS | 30,000| |Two threads with lock | 224,000|\n\nCAS操作比单线程无锁慢了1个数量级；有锁且多线程并发的情况下，速度比单线程无锁慢3个数量级。可见无锁速度最快。\n\n单线程情况下，不加锁的性能 > CAS操作的性能 > 加锁的性能。\n\n在多线程情况下，为了保证线程安全，必须使用CAS或锁，这种情况下，CAS的性能超过锁的性能，前者大约是后者的8倍。\n\n综上可知，加锁的性能是最差的。\n\n**关于锁和CAS**\n\n保证线程安全一般分成两种方式：锁和原子变量。\n\n**锁**\n\n![图1 通过加锁的方式实现线程安全](https://p1.meituan.net/travelcube/9b6a41f7d8527df9730b7832b38ec4d5180025.png)\n\n图1 通过加锁的方式实现线程安全\n\n采取加锁的方式，默认线程会冲突，访问数据时，先加上锁再访问，访问之后再解锁。通过锁界定一个临界区，同时只有一个线程进入。如上图所示，Thread2访问Entry的时候，加了锁，Thread1就不能再执行访问Entry的代码，从而保证线程安全。\n\n下面是ArrayBlockingQueue通过加锁的方式实现的offer方法，保证线程安全。\n\n```\npublic boolean offer(E e) {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        if (count == items.length)\n            return false;\n        else {\n            insert(e);\n            return true;\n        }\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n**原子变量**\n\n原子变量能够保证原子性的操作，意思是某个任务在执行过程中，要么全部成功，要么全部失败回滚，恢复到执行之前的初态，不存在初态和成功之间的中间状态。例如CAS操作，要么比较并交换成功，要么比较并交换失败。由CPU保证原子性。\n\n通过原子变量可以实现线程安全。执行某个任务的时候，先假定不会有冲突，若不发生冲突，则直接执行成功；当发生冲突的时候，则执行失败，回滚再重新操作，直到不发生冲突。\n\n![图2 通过原子变量CAS实现线程安全](https://p0.meituan.net/travelcube/de0ced42337014947e7466db4d8f2d4d158395.png)\n\n图2 通过原子变量CAS实现线程安全\n\n如图所示，Thread1和Thread2都要把Entry加1。若不加锁，也不使用CAS，有可能Thread1取到了myValue=1，Thread2也取到了myValue=1，然后相加，Entry中的value值为2。这与预期不相符，我们预期的是Entry的值经过两次相加后等于3。\n\nCAS会先把Entry现在的value跟线程当初读出的值相比较，若相同，则赋值；若不相同，则赋值执行失败。一般会通过while/for循环来重新执行，直到赋值成功。\n\n代码示例是AtomicInteger的getAndAdd方法。CAS是CPU的一个指令，由CPU保证原子性。\n\n```\n/**\n * Atomically adds the given value to the current value.\n *\n * @param delta the value to add\n * @return the previous value\n */\npublic final int getAndAdd(int delta) {\n    for (;;) {\n        int current = get();\n        int next = current + delta;\n        if (compareAndSet(current, next))\n            return current;\n    }\n}\n  \n/**\n * Atomically sets the value to the given updated value\n * if the current value {@code ==} the expected value.\n *\n * @param expect the expected value\n * @param update the new value\n * @return true if successful. False return indicates that\n * the actual value was not equal to the expected value.\n */\npublic final boolean compareAndSet(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n} \n```\n\n在高度竞争的情况下，锁的性能将超过原子变量的性能，但是更真实的竞争情况下，原子变量的性能将超过锁的性能。同时原子变量不会有死锁等活跃性问题。\n\n### 伪共享\n\n**什么是共享**\n\n下图是计算的基本结构。L1、L2、L3分别表示一级缓存、二级缓存、三级缓存，越靠近CPU的缓存，速度越快，容量也越小。所以L1缓存很小但很快，并且紧靠着在使用它的CPU内核；L2大一些，也慢一些，并且仍然只能被一个单独的CPU核使用；L3更大、更慢，并且被单个插槽上的所有CPU核共享；最后是主存，由全部插槽上的所有CPU核共享。\n\n![图3 计算机CPU与缓存示意图](https://p1.meituan.net/travelcube/69ce8ffbe7a4ebee01c377dac174842d433755.png)\n\n图3 计算机CPU与缓存示意图\n\n当CPU执行运算的时候，它先去L1查找所需的数据、再去L2、然后是L3，如果最后这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要尽量确保数据在L1缓存中。\n\n另外，线程之间共享一份数据的时候，需要一个线程把数据写回主存，而另一个线程访问主存中相应的数据。\n\n下面是从CPU访问不同层级数据的时间概念:\n\n| 从CPU到                                  | 大约需要的CPU周期 | 大约需要的时间 |\n| ---------------------------------------- | ----------------- | -------------- |\n| 主存                                     | -                 | 约60-80ns      |\n| QPI 总线传输(between sockets, not drawn) | -                 | 约20ns         |\n| L3 cache                                 | 约40-45 cycles    | 约15ns         |\n| L2 cache                                 | 约10 cycles       | 约3ns          |\n| L1 cache                                 | 约3-4 cycles      | 约1ns          |\n| 寄存器                                   | 1 cycle           | -              |\n\n可见CPU读取主存中的数据会比从L1中读取慢了近2个数量级。\n\n**缓存行**\n\nCache是由很多个cache line组成的。每个cache line通常是64字节，并且它有效地引用主内存中的一块儿地址。一个Java的long类型变量是8字节，因此在一个缓存行中可以存8个long类型的变量。\n\nCPU每次从主存中拉取数据时，会把相邻的数据也存入同一个cache line。\n\n在访问一个long数组的时候，如果数组中的一个值被加载到缓存中，它会自动加载另外7个。因此你能非常快的遍历这个数组。事实上，你可以非常快速的遍历在连续内存块中分配的任意数据结构。\n\n下面的例子是测试利用cache line的特性和不利用cache line的特性的效果对比。\n\n```\npackage com.meituan.FalseSharing;\n \n/**\n * @author gongming\n * @description\n * @date 16/6/4\n */\npublic class CacheLineEffect {\n    //考虑一般缓存行大小是64字节，一个 long 类型占8字节\n    static  long[][] arr;\n \n    public static void main(String[] args) {\n        arr = new long[1024 * 1024][];\n        for (int i = 0; i < 1024 * 1024; i++) {\n            arr[i] = new long[8];\n            for (int j = 0; j < 8; j++) {\n                arr[i][j] = 0L;\n            }\n        }\n        long sum = 0L;\n        long marked = System.currentTimeMillis();\n        for (int i = 0; i < 1024 * 1024; i+=1) {\n            for(int j =0; j< 8;j++){\n                sum = arr[i][j];\n            }\n        }\n        System.out.println(\"Loop times:\" + (System.currentTimeMillis() - marked) + \"ms\");\n \n        marked = System.currentTimeMillis();\n        for (int i = 0; i < 8; i+=1) {\n            for(int j =0; j< 1024 * 1024;j++){\n                sum = arr[j][i];\n            }\n        }\n        System.out.println(\"Loop times:\" + (System.currentTimeMillis() - marked) + \"ms\");\n    }\n}\n```\n\n在2G Hz、2核、8G内存的运行环境中测试，速度差一倍。\n\n结果：\n\nLoop times:30ms Loop times:65ms\n\n**什么是伪共享**\n\nArrayBlockingQueue有三个成员变量： - takeIndex：需要被取走的元素下标 - putIndex：可被元素插入的位置的下标 - count：队列中元素的数量\n\n这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。\n\n![图4 ArrayBlockingQueue伪共享示意图](https://p0.meituan.net/travelcube/192e9b87b7a5b68cac352fdeb81dc93b161543.png)\n\n图4 ArrayBlockingQueue伪共享示意图\n\n如上图所示，当生产者线程put一个元素到ArrayBlockingQueue时，putIndex会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。\n\n这种无法充分使用缓存行特性的现象，称为伪共享。\n\n对于伪共享，一般的解决方案是，增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上，以空间换时间。\n\n```\npackage com.meituan.FalseSharing;\n \npublic class FalseSharing implements Runnable{\n        public final static long ITERATIONS = 500L * 1000L * 100L;\n        private int arrayIndex = 0;\n \n        private static ValuePadding[] longs;\n        public FalseSharing(final int arrayIndex) {\n            this.arrayIndex = arrayIndex;\n        }\n \n        public static void main(final String[] args) throws Exception {\n            for(int i=1;i<10;i++){\n                System.gc();\n                final long start = System.currentTimeMillis();\n                runTest(i);\n                System.out.println(\"Thread num \"+i+\" duration = \" + (System.currentTimeMillis() - start));\n            }\n \n        }\n \n        private static void runTest(int NUM_THREADS) throws InterruptedException {\n            Thread[] threads = new Thread[NUM_THREADS];\n            longs = new ValuePadding[NUM_THREADS];\n            for (int i = 0; i < longs.length; i++) {\n                longs[i] = new ValuePadding();\n            }\n            for (int i = 0; i < threads.length; i++) {\n                threads[i] = new Thread(new FalseSharing(i));\n            }\n \n            for (Thread t : threads) {\n                t.start();\n            }\n \n            for (Thread t : threads) {\n                t.join();\n            }\n        }\n \n        public void run() {\n            long i = ITERATIONS + 1;\n            while (0 != --i) {\n                longs[arrayIndex].value = 0L;\n            }\n        }\n \n        public final static class ValuePadding {\n            protected long p1, p2, p3, p4, p5, p6, p7;\n            protected volatile long value = 0L;\n            protected long p9, p10, p11, p12, p13, p14;\n            protected long p15;\n        }\n        public final static class ValueNoPadding {\n            // protected long p1, p2, p3, p4, p5, p6, p7;\n            protected volatile long value = 0L;\n            // protected long p9, p10, p11, p12, p13, p14, p15;\n        }\n}\n```\n\n在2G Hz，2核，8G内存, jdk 1.7.0_45 的运行环境下，使用了共享机制比没有使用共享机制，速度快了4倍左右。\n\n结果：\n\n- Thread num 1 duration = 447\n- Thread num 2 duration = 463\n- Thread num 3 duration = 454\n- Thread num 4 duration = 464\n- Thread num 5 duration = 561\n- Thread num 6 duration = 606\n- Thread num 7 duration = 684\n- Thread num 8 duration = 870\n- Thread num 9 duration = 823\n\n把代码中ValuePadding都替换为ValueNoPadding后的结果：\n\n- Thread num 1 duration = 446\n- Thread num 2 duration = 2549\n- Thread num 3 duration = 2898\n- Thread num 4 duration = 3931\n- Thread num 5 duration = 4716\n- Thread num 6 duration = 5424\n- Thread num 7 duration = 4868\n- Thread num 8 duration = 4595\n- Thread num 9 duration = 4540\n\n备注：在jdk1.8中，有专门的注解@Contended来避免伪共享，更优雅地解决问题。\n\n## Disruptor的设计方案\n\nDisruptor通过以下设计来解决队列速度慢的问题：\n\n- 环形数组结构\n\n为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。\n\n- 元素位置定位\n\n数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。\n\n- 无锁设计\n\n每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。\n\n下面忽略数组的环形结构，介绍一下如何实现无锁设计。整个过程通过原子变量CAS，保证操作的线程安全。\n\n### 一个生产者\n\n**写数据**\n\n生产者单线程写数据的流程比较简单：\n\n1. 申请写入m个元素；\n2. 若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素；\n3. 若是返回的正确，则生产者开始写入元素。\n\n![图5 单个生产者生产过程示意图](https://p1.meituan.net/travelcube/e71c1449273361ec413fffc7b0bf5507208689.png)\n\n图5 单个生产者生产过程示意图\n\n## 多个生产者\n\n多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor的解决方法是，每个线程获取不同的一段数组空间进行操作。这个通过CAS很容易达到。只需要在分配元素的时候，通过CAS判断一下这段空间是否已经分配出去即可。\n\n但是会遇到一个新问题：如何防止读取的时候，读到还未写的元素。Disruptor在多个生产者的情况下，引入了一个与Ring Buffer大小相同的buffer：available Buffer。当某个位置写入成功的时候，便把availble Buffer相应的位置置位，标记为写入成功。读取的时候，会遍历available Buffer，来判断元素是否已经就绪。\n\n下面分读数据和写数据两种情况介绍。\n\n### 读数据\n\n生产者多线程写入的情况会复杂很多：\n\n1. 申请读取到序号n；\n2. 若writer cursor >= n，这时仍然无法确定连续可读的最大下标。从reader cursor开始读取available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；\n3. 消费者读取元素。\n\n如下图所示，读线程读到下标为2的元素，三个线程Writer1/Writer2/Writer3正在向RingBuffer相应位置写数据，写线程被分配到的最大元素下标是11。\n\n读线程申请读取到下标从3到11的元素，判断writer cursor>=11。然后开始读取availableBuffer，从3开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。\n\n然后，消费者读取下标从3到6共计4个元素。\n\n![图6 多个生产者情况下，消费者消费过程示意图](https://p0.meituan.net/travelcube/99c603494ea90c9535e165579daf340a161527.png)\n\n图6 多个生产者情况下，消费者消费过程示意图\n\n### 写数据\n\n多个生产者写入的时候：\n\n1. 申请写入m个元素；\n2. 若是有m个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；\n3. 生产者写入元素，写入元素的同时设置available Buffer里面相应的位置，以标记自己哪些位置是已经写入成功的。\n\n如下图所示，Writer1和Writer2两个线程写入数组，都申请可写的数组空间。Writer1被分配了下标3到下表5的空间，Writer2被分配了下标6到下标9的空间。\n\nWriter1写入下标3位置的元素，同时把available Buffer相应位置置位，标记已经写入成功，往后移一位，开始写下标4位置的元素。Writer2同样的方式。最终都写入完成。\n\n![图7 多个生产者情况下，生产者生产过程示意图](https://p1.meituan.net/travelcube/5e06841b1bba4dcf1d3fac169734ba36133983.png)\n\n图7 多个生产者情况下，生产者生产过程示意图\n\n防止不同生产者对同一段空间写入的代码，如下所示：\n\n```\npublic long tryNext(int n) throws InsufficientCapacityException\n{\n    if (n < 1)\n    {\n        throw new IllegalArgumentException(\"n must be > 0\");\n    }\n \n    long current;\n    long next;\n \n    do\n    {\n        current = cursor.get();\n        next = current + n;\n \n        if (!hasAvailableCapacity(gatingSequences, n, current))\n        {\n            throw InsufficientCapacityException.INSTANCE;\n        }\n    }\n    while (!cursor.compareAndSet(current, next));\n \n    return next;\n}\n```\n\n通过do/while循环的条件cursor.compareAndSet(current, next)，来判断每次申请的空间是否已经被其他生产者占据。假如已经被占据，该函数会返回失败，While循环重新执行，申请写入空间。\n\n消费者的流程与生产者非常类似，这儿就不多描述了。\n\n### 总结\n\nDisruptor通过精巧的无锁设计实现了在高并发情形下的高性能。\n\n在美团内部，很多高并发场景借鉴了Disruptor的设计，减少竞争的强度。其设计思想可以扩展到分布式场景，通过无锁设计，来提升服务性能。\n\n使用Disruptor比使用ArrayBlockingQueue略微复杂，为方便读者上手，增加代码样例。\n\n代码实现的功能：每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端。详细逻辑请细读代码。\n\n以下代码基于3.3.4版本的Disruptor包。\n\n```\npackage com.meituan.Disruptor;\n\n/**\n * @description disruptor代码样例。每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端\n */\nimport com.lmax.disruptor.*;\nimport com.lmax.disruptor.dsl.Disruptor;\nimport com.lmax.disruptor.dsl.ProducerType;\n\nimport java.util.concurrent.ThreadFactory;\n\n\npublic class DisruptorMain\n{\n    public static void main(String[] args) throws Exception\n    {\n        // 队列中的元素\n        class Element {\n\n            private int value;\n\n            public int get(){\n                return value;\n            }\n\n            public void set(int value){\n                this.value= value;\n            }\n\n        }\n\n        // 生产者的线程工厂\n        ThreadFactory threadFactory = new ThreadFactory(){\n            @Override\n            public Thread newThread(Runnable r) {\n                return new Thread(r, \"simpleThread\");\n            }\n        };\n\n        // RingBuffer生产工厂,初始化RingBuffer的时候使用\n        EventFactory<Element> factory = new EventFactory<Element>() {\n            @Override\n            public Element newInstance() {\n                return new Element();\n            }\n        };\n\n        // 处理Event的handler\n        EventHandler<Element> handler = new EventHandler<Element>(){\n            @Override\n            public void onEvent(Element element, long sequence, boolean endOfBatch)\n            {\n                System.out.println(\"Element: \" + element.get());\n            }\n        };\n\n        // 阻塞策略\n        BlockingWaitStrategy strategy = new BlockingWaitStrategy();\n\n        // 指定RingBuffer的大小\n        int bufferSize = 16;\n\n        // 创建disruptor，采用单生产者模式\n        Disruptor<Element> disruptor = new Disruptor(factory, bufferSize, threadFactory, ProducerType.SINGLE, strategy);\n\n        // 设置EventHandler\n        disruptor.handleEventsWith(handler);\n\n        // 启动disruptor的线程\n        disruptor.start();\n\n        RingBuffer<Element> ringBuffer = disruptor.getRingBuffer();\n\n        for (int l = 0; true; l++)\n        {\n            // 获取下一个可用位置的下标\n            long sequence = ringBuffer.next();  \n            try\n            {\n                // 返回可用位置的元素\n                Element event = ringBuffer.get(sequence); \n                // 设置该位置元素的值\n                event.set(l); \n            }\n            finally\n            {\n                ringBuffer.publish(sequence);\n            }\n            Thread.sleep(10);\n        }\n    }\n}\n```\n\n## 性能\n\n以下面这些模式测试性能:\n\n![img](https://p1.meituan.net/travelcube/ada37da4ad62709ab67d7a32147cb19a306409.png)\n\n吞吐量测试数据（每秒的数量）如下。\n\n环境： - CPU:Intel Core i7 860 @ 2.8 GHz without HT - JVM:Java 1.6.0_25 64-bit - OS:Windows 7\n\n| -                  | ABQ       | Disruptor  |\n| ------------------ | --------- | ---------- |\n| Unicast: 1P – 1C   | 5,339,256 | 25,998,336 |\n| Pipeline: 1P – 3C  | 2,128,918 | 16,806,157 |\n| Sequencer: 3P – 1C | 5,539,531 | 13,403,268 |\n| Multicast: 1P – 3C | 1,077,384 | 9,377,871  |\n| Diamond: 1P – 3C   | 2,113,941 | 16,143,613 |\n\n环境：\n\n- CPU:Intel Core i7-2720QM\n- JVM:Java 1.6.0_25 64-bit\n- OS:Ubuntu 11.04\n\n| -                  | ABQ       | Disruptor  |\n| ------------------ | --------- | ---------- |\n| Unicast: 1P – 1C   | 4,057,453 | 22,381,378 |\n| Pipeline: 1P – 3C  | 2,006,903 | 15,857,913 |\n| Sequencer: 3P – 1C | 2,056,118 | 14,540,519 |\n| Multicast: 1P – 3C | 260,733   | 10,860,121 |\n| Diamond: 1P – 3C   | 2,082,725 | 15,295,197 |\n\n依据并发竞争的激烈程度的不同，Disruptor比ArrayBlockingQueue吞吐量快4~7倍。\n\n按照Pipeline: 1P – 3C的连接模式测试延迟，生产者两次写入之间的延迟为1ms。\n\n运行环境：\n\n- CPU:2.2GHz Core i7-2720QM\n- Java: 1.6.0_25 64-bit\n- OS:Ubuntu 11.04.\n\n| -                             | Array Blocking Queue (ns) | Disruptor (ns) |\n| ----------------------------- | ------------------------- | -------------- |\n| 99% observations less than    | 2,097,152                 | 128            |\n| 99.99% observations less than | 4,194,304                 | 8,192          |\n| Max Latency                   | 5,069,086                 | 175,567        |\n| Mean Latency                  | 32,757                    | 52             |\n| Min Latency                   | 145                       | 29             |\n\n可见，平均延迟差了3个数量级。\n\n## 等待策略\n\n### 生产者的等待策略\n\n暂时只有休眠1ns。\n\n```\nLockSupport.parkNanos(1);\n```\n\n### 消费者的等待策略\n\n| 名称                        | 措施                      | 适用场景                                                     |\n| --------------------------- | ------------------------- | ------------------------------------------------------------ |\n| BlockingWaitStrategy        | 加锁                      | CPU资源紧缺，吞吐量和延迟并不重要的场景                      |\n| BusySpinWaitStrategy        | 自旋                      | 通过不断重试，减少切换线程导致的系统调用，而降低延迟。推荐在线程绑定到固定的CPU的场景下使用 |\n| PhasedBackoffWaitStrategy   | 自旋 + yield + 自定义策略 | CPU资源紧缺，吞吐量和延迟并不重要的场景                      |\n| SleepingWaitStrategy        | 自旋 + yield + sleep      | 性能和CPU资源之间有很好的折中。延迟不均匀                    |\n| TimeoutBlockingWaitStrategy | 加锁，有超时限制          | CPU资源紧缺，吞吐量和延迟并不重要的场景                      |\n| YieldingWaitStrategy        | 自旋 + yield + 自旋       | 性能和CPU资源之间有很好的折中。延迟比较均匀                  |\n\n## Log4j 2应用场景\n\nLog4j 2相对于Log4j 1最大的优势在于多线程并发场景下性能更优。该特性源自于Log4j 2的异步模式采用了Disruptor来处理。 在Log4j 2的配置文件中可以配置WaitStrategy，默认是Timeout策略。下面是Log4j 2中对WaitStrategy的配置官方文档：\n\n| System Property          | Default Value | Description                                                  |\n| ------------------------ | ------------- | ------------------------------------------------------------ |\n| AsyncLogger.WaitStrategy | Timeout       | Valid values: Block, Timeout, Sleep, Yield. Block is a strategy that uses a lock and condition variable for the I/O thread waiting for log events. Block can be used when throughput and low-latency are not as important as CPU resource. Recommended for resource constrained/virtualised environments. Timeout is a variation of the Block strategy that will periodically wake up from the lock condition await() call. This ensures that if a notification is missed somehow the consumer thread is not stuck but will recover with a small latency delay (default 10ms). Sleep is a strategy that initially spins, then uses a Thread.yield(), and eventually parks for the minimum number of nanos the OS and JVM will allow while the I/O thread is waiting for log events. Sleep is a good compromise between performance and CPU resource. This strategy has very low impact on the application thread, in exchange for some additional latency for actually getting the message logged. Yield is a strategy that uses a Thread.yield() for waiting for log events after an initially spinning. Yield is a good compromise between performance and CPU resource, but may use more CPU than Sleep in order to get the message logged to disk sooner. |\n\n### 性能差异\n\nloggers all async采用的是Disruptor，而Async Appender采用的是ArrayBlockingQueue队列。\n\n由图可见，单线程情况下，loggers all async与Async Appender吞吐量相差不大，但是在64个线程的时候，loggers all async的吞吐量比Async Appender增加了12倍，是Sync模式的68倍。\n\n![图8 Log4j 2各个模式性能比较](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/ad04b8bd.png)\n\n图8 Log4j 2各个模式性能比较\n\n美团在公司内部统一推行日志接入规范，要求必须使用Log4j 2，使普通单机QPS的上限不再只停留在几千，极高地提升了服务性能。\n\n## 参考文档\n\n1. <http://brokendreams.iteye.com/blog/2255720>\n2. <http://ifeve.com/dissecting-disruptor-whats-so-special/>\n3. <https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results>\n4. <https://lmax-exchange.github.io/disruptor/>\n5. <https://logging.apache.org/log4j/2.x/manual/async.html>","slug":"java/disruptor","published":1,"updated":"2020-04-27T08:08:12.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7m00066vgja98e20ofs","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级）。基于Disruptor开发的系统单线程能支撑每秒600万订单，2010年在QCon演讲后，获得了业界关注。2011年，企业应用软件专家Martin Fowler专门撰写长文介绍。同年它还获得了Oracle官方的Duke大奖。</p>\n<p>目前，包括Apache Storm、Camel、Log4j 2在内的很多知名项目都应用了Disruptor以获取高性能。在美团技术团队它也有不少应用，有的项目架构借鉴了它的设计机制。本文从实战角度剖析了Disruptor的实现原理。</p>\n<p>需要特别指出的是，这里所说的队列是系统内部的内存队列，而不是Kafka这样的分布式队列。另外，本文所描述的Disruptor特性限于3.3.4。</p>\n<h2 id=\"Java内置队列\"><a href=\"#Java内置队列\" class=\"headerlink\" title=\"Java内置队列\"></a>Java内置队列</h2><p>介绍Disruptor之前，我们先来看一看常用的线程安全的内置队列有什么问题。Java的内置队列如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>队列</th>\n<th>有界性</th>\n<th>锁</th>\n<th>数据结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayBlockingQueue</td>\n<td>bounded</td>\n<td>加锁</td>\n<td>arraylist</td>\n</tr>\n<tr>\n<td>LinkedBlockingQueue</td>\n<td>optionally-bounded</td>\n<td>加锁</td>\n<td>linkedlist</td>\n</tr>\n<tr>\n<td>ConcurrentLinkedQueue</td>\n<td>unbounded</td>\n<td>无锁</td>\n<td>linkedlist</td>\n</tr>\n<tr>\n<td>LinkedTransferQueue</td>\n<td>unbounded</td>\n<td>无锁</td>\n<td>linkedlist</td>\n</tr>\n<tr>\n<td>PriorityBlockingQueue</td>\n<td>unbounded</td>\n<td>加锁</td>\n<td>heap</td>\n</tr>\n<tr>\n<td>DelayQueue</td>\n<td>unbounded</td>\n<td>加锁</td>\n<td>heap</td>\n</tr>\n</tbody></table>\n<p>队列的底层一般分成三种：数组、链表和堆。其中，堆一般情况下是为了实现带有优先级特性的队列，暂且不考虑。</p>\n<p>我们就从数组和链表两种数据结构来看，基于数组线程安全的队列，比较典型的是ArrayBlockingQueue，它主要通过加锁的方式来保证线程安全；基于链表的线程安全队列分成LinkedBlockingQueue和ConcurrentLinkedQueue两大类，前者也通过锁的方式来实现线程安全，而后者以及上面表格中的LinkedTransferQueue都是通过原子变量compare and swap（以下简称“CAS”）这种不加锁的方式来实现的。</p>\n<p>通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在确定的范围内）；而加锁的方式，可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列；同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array/heap格式的数据结构。这样筛选下来，符合条件的队列就只有ArrayBlockingQueue。</p>\n<h2 id=\"ArrayBlockingQueue的问题\"><a href=\"#ArrayBlockingQueue的问题\" class=\"headerlink\" title=\"ArrayBlockingQueue的问题\"></a>ArrayBlockingQueue的问题</h2><p>ArrayBlockingQueue在实际使用过程中，会因为加锁和伪共享等出现严重的性能问题，我们下面来分析一下。</p>\n<h3 id=\"加锁\"><a href=\"#加锁\" class=\"headerlink\" title=\"加锁\"></a>加锁</h3><p>现实编程过程中，加锁通常会严重地影响性能。线程会因为竞争不到锁而被挂起，等锁被释放的时候，线程又会被恢复，这个过程中存在着很大的开销，并且通常会有较长时间的中断，因为当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，例如发生了缺页错误、调度延迟或者其它类似情况，那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，就会发生优先级反转。</p>\n<p>Disruptor论文中讲述了一个实验：</p>\n<ul>\n<li>这个测试程序调用了一个函数，该函数会对一个64位的计数器循环自增5亿次。</li>\n<li>机器环境：2.4G 6核</li>\n<li>运算： 64位的计数器累加5亿次</li>\n</ul>\n<p>|Method | Time (ms) | |— | —| |Single thread | 300| |Single thread with CAS | 5,700| |Single thread with lock | 10,000| |Single thread with volatile write | 4,700| |Two threads with CAS | 30,000| |Two threads with lock | 224,000|</p>\n<p>CAS操作比单线程无锁慢了1个数量级；有锁且多线程并发的情况下，速度比单线程无锁慢3个数量级。可见无锁速度最快。</p>\n<p>单线程情况下，不加锁的性能 &gt; CAS操作的性能 &gt; 加锁的性能。</p>\n<p>在多线程情况下，为了保证线程安全，必须使用CAS或锁，这种情况下，CAS的性能超过锁的性能，前者大约是后者的8倍。</p>\n<p>综上可知，加锁的性能是最差的。</p>\n<p><strong>关于锁和CAS</strong></p>\n<p>保证线程安全一般分成两种方式：锁和原子变量。</p>\n<p><strong>锁</strong></p>\n<p><img src=\"https://p1.meituan.net/travelcube/9b6a41f7d8527df9730b7832b38ec4d5180025.png\" alt=\"图1 通过加锁的方式实现线程安全\"></p>\n<p>图1 通过加锁的方式实现线程安全</p>\n<p>采取加锁的方式，默认线程会冲突，访问数据时，先加上锁再访问，访问之后再解锁。通过锁界定一个临界区，同时只有一个线程进入。如上图所示，Thread2访问Entry的时候，加了锁，Thread1就不能再执行访问Entry的代码，从而保证线程安全。</p>\n<p>下面是ArrayBlockingQueue通过加锁的方式实现的offer方法，保证线程安全。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean offer(E e) &#123;</span><br><span class=\"line\">    checkNotNull(e);</span><br><span class=\"line\">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        if (count &#x3D;&#x3D; items.length)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            insert(e);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>原子变量</strong></p>\n<p>原子变量能够保证原子性的操作，意思是某个任务在执行过程中，要么全部成功，要么全部失败回滚，恢复到执行之前的初态，不存在初态和成功之间的中间状态。例如CAS操作，要么比较并交换成功，要么比较并交换失败。由CPU保证原子性。</p>\n<p>通过原子变量可以实现线程安全。执行某个任务的时候，先假定不会有冲突，若不发生冲突，则直接执行成功；当发生冲突的时候，则执行失败，回滚再重新操作，直到不发生冲突。</p>\n<p><img src=\"https://p0.meituan.net/travelcube/de0ced42337014947e7466db4d8f2d4d158395.png\" alt=\"图2 通过原子变量CAS实现线程安全\"></p>\n<p>图2 通过原子变量CAS实现线程安全</p>\n<p>如图所示，Thread1和Thread2都要把Entry加1。若不加锁，也不使用CAS，有可能Thread1取到了myValue=1，Thread2也取到了myValue=1，然后相加，Entry中的value值为2。这与预期不相符，我们预期的是Entry的值经过两次相加后等于3。</p>\n<p>CAS会先把Entry现在的value跟线程当初读出的值相比较，若相同，则赋值；若不相同，则赋值执行失败。一般会通过while/for循环来重新执行，直到赋值成功。</p>\n<p>代码示例是AtomicInteger的getAndAdd方法。CAS是CPU的一个指令，由CPU保证原子性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Atomically adds the given value to the current value.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param delta the value to add</span><br><span class=\"line\"> * @return the previous value</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public final int getAndAdd(int delta) &#123;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        int current &#x3D; get();</span><br><span class=\"line\">        int next &#x3D; current + delta;</span><br><span class=\"line\">        if (compareAndSet(current, next))</span><br><span class=\"line\">            return current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Atomically sets the value to the given updated value</span><br><span class=\"line\"> * if the current value &#123;@code &#x3D;&#x3D;&#125; the expected value.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param expect the expected value</span><br><span class=\"line\"> * @param update the new value</span><br><span class=\"line\"> * @return true if successful. False return indicates that</span><br><span class=\"line\"> * the actual value was not equal to the expected value.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class=\"line\">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在高度竞争的情况下，锁的性能将超过原子变量的性能，但是更真实的竞争情况下，原子变量的性能将超过锁的性能。同时原子变量不会有死锁等活跃性问题。</p>\n<h3 id=\"伪共享\"><a href=\"#伪共享\" class=\"headerlink\" title=\"伪共享\"></a>伪共享</h3><p><strong>什么是共享</strong></p>\n<p>下图是计算的基本结构。L1、L2、L3分别表示一级缓存、二级缓存、三级缓存，越靠近CPU的缓存，速度越快，容量也越小。所以L1缓存很小但很快，并且紧靠着在使用它的CPU内核；L2大一些，也慢一些，并且仍然只能被一个单独的CPU核使用；L3更大、更慢，并且被单个插槽上的所有CPU核共享；最后是主存，由全部插槽上的所有CPU核共享。</p>\n<p><img src=\"https://p1.meituan.net/travelcube/69ce8ffbe7a4ebee01c377dac174842d433755.png\" alt=\"图3 计算机CPU与缓存示意图\"></p>\n<p>图3 计算机CPU与缓存示意图</p>\n<p>当CPU执行运算的时候，它先去L1查找所需的数据、再去L2、然后是L3，如果最后这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要尽量确保数据在L1缓存中。</p>\n<p>另外，线程之间共享一份数据的时候，需要一个线程把数据写回主存，而另一个线程访问主存中相应的数据。</p>\n<p>下面是从CPU访问不同层级数据的时间概念:</p>\n<table>\n<thead>\n<tr>\n<th>从CPU到</th>\n<th>大约需要的CPU周期</th>\n<th>大约需要的时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>主存</td>\n<td>-</td>\n<td>约60-80ns</td>\n</tr>\n<tr>\n<td>QPI 总线传输(between sockets, not drawn)</td>\n<td>-</td>\n<td>约20ns</td>\n</tr>\n<tr>\n<td>L3 cache</td>\n<td>约40-45 cycles</td>\n<td>约15ns</td>\n</tr>\n<tr>\n<td>L2 cache</td>\n<td>约10 cycles</td>\n<td>约3ns</td>\n</tr>\n<tr>\n<td>L1 cache</td>\n<td>约3-4 cycles</td>\n<td>约1ns</td>\n</tr>\n<tr>\n<td>寄存器</td>\n<td>1 cycle</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<p>可见CPU读取主存中的数据会比从L1中读取慢了近2个数量级。</p>\n<p><strong>缓存行</strong></p>\n<p>Cache是由很多个cache line组成的。每个cache line通常是64字节，并且它有效地引用主内存中的一块儿地址。一个Java的long类型变量是8字节，因此在一个缓存行中可以存8个long类型的变量。</p>\n<p>CPU每次从主存中拉取数据时，会把相邻的数据也存入同一个cache line。</p>\n<p>在访问一个long数组的时候，如果数组中的一个值被加载到缓存中，它会自动加载另外7个。因此你能非常快的遍历这个数组。事实上，你可以非常快速的遍历在连续内存块中分配的任意数据结构。</p>\n<p>下面的例子是测试利用cache line的特性和不利用cache line的特性的效果对比。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.meituan.FalseSharing;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @author gongming</span><br><span class=\"line\"> * @description</span><br><span class=\"line\"> * @date 16&#x2F;6&#x2F;4</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public class CacheLineEffect &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;考虑一般缓存行大小是64字节，一个 long 类型占8字节</span><br><span class=\"line\">    static  long[][] arr;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        arr &#x3D; new long[1024 * 1024][];</span><br><span class=\"line\">        for (int i &#x3D; 0; i &lt; 1024 * 1024; i++) &#123;</span><br><span class=\"line\">            arr[i] &#x3D; new long[8];</span><br><span class=\"line\">            for (int j &#x3D; 0; j &lt; 8; j++) &#123;</span><br><span class=\"line\">                arr[i][j] &#x3D; 0L;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        long sum &#x3D; 0L;</span><br><span class=\"line\">        long marked &#x3D; System.currentTimeMillis();</span><br><span class=\"line\">        for (int i &#x3D; 0; i &lt; 1024 * 1024; i+&#x3D;1) &#123;</span><br><span class=\"line\">            for(int j &#x3D;0; j&lt; 8;j++)&#123;</span><br><span class=\"line\">                sum &#x3D; arr[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;Loop times:&quot; + (System.currentTimeMillis() - marked) + &quot;ms&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">        marked &#x3D; System.currentTimeMillis();</span><br><span class=\"line\">        for (int i &#x3D; 0; i &lt; 8; i+&#x3D;1) &#123;</span><br><span class=\"line\">            for(int j &#x3D;0; j&lt; 1024 * 1024;j++)&#123;</span><br><span class=\"line\">                sum &#x3D; arr[j][i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;Loop times:&quot; + (System.currentTimeMillis() - marked) + &quot;ms&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在2G Hz、2核、8G内存的运行环境中测试，速度差一倍。</p>\n<p>结果：</p>\n<p>Loop times:30ms Loop times:65ms</p>\n<p><strong>什么是伪共享</strong></p>\n<p>ArrayBlockingQueue有三个成员变量： - takeIndex：需要被取走的元素下标 - putIndex：可被元素插入的位置的下标 - count：队列中元素的数量</p>\n<p>这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。</p>\n<p><img src=\"https://p0.meituan.net/travelcube/192e9b87b7a5b68cac352fdeb81dc93b161543.png\" alt=\"图4 ArrayBlockingQueue伪共享示意图\"></p>\n<p>图4 ArrayBlockingQueue伪共享示意图</p>\n<p>如上图所示，当生产者线程put一个元素到ArrayBlockingQueue时，putIndex会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。</p>\n<p>这种无法充分使用缓存行特性的现象，称为伪共享。</p>\n<p>对于伪共享，一般的解决方案是，增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上，以空间换时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.meituan.FalseSharing;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class FalseSharing implements Runnable&#123;</span><br><span class=\"line\">        public final static long ITERATIONS &#x3D; 500L * 1000L * 100L;</span><br><span class=\"line\">        private int arrayIndex &#x3D; 0;</span><br><span class=\"line\"> </span><br><span class=\"line\">        private static ValuePadding[] longs;</span><br><span class=\"line\">        public FalseSharing(final int arrayIndex) &#123;</span><br><span class=\"line\">            this.arrayIndex &#x3D; arrayIndex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        public static void main(final String[] args) throws Exception &#123;</span><br><span class=\"line\">            for(int i&#x3D;1;i&lt;10;i++)&#123;</span><br><span class=\"line\">                System.gc();</span><br><span class=\"line\">                final long start &#x3D; System.currentTimeMillis();</span><br><span class=\"line\">                runTest(i);</span><br><span class=\"line\">                System.out.println(&quot;Thread num &quot;+i+&quot; duration &#x3D; &quot; + (System.currentTimeMillis() - start));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        private static void runTest(int NUM_THREADS) throws InterruptedException &#123;</span><br><span class=\"line\">            Thread[] threads &#x3D; new Thread[NUM_THREADS];</span><br><span class=\"line\">            longs &#x3D; new ValuePadding[NUM_THREADS];</span><br><span class=\"line\">            for (int i &#x3D; 0; i &lt; longs.length; i++) &#123;</span><br><span class=\"line\">                longs[i] &#x3D; new ValuePadding();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for (int i &#x3D; 0; i &lt; threads.length; i++) &#123;</span><br><span class=\"line\">                threads[i] &#x3D; new Thread(new FalseSharing(i));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            for (Thread t : threads) &#123;</span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            for (Thread t : threads) &#123;</span><br><span class=\"line\">                t.join();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            long i &#x3D; ITERATIONS + 1;</span><br><span class=\"line\">            while (0 !&#x3D; --i) &#123;</span><br><span class=\"line\">                longs[arrayIndex].value &#x3D; 0L;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        public final static class ValuePadding &#123;</span><br><span class=\"line\">            protected long p1, p2, p3, p4, p5, p6, p7;</span><br><span class=\"line\">            protected volatile long value &#x3D; 0L;</span><br><span class=\"line\">            protected long p9, p10, p11, p12, p13, p14;</span><br><span class=\"line\">            protected long p15;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public final static class ValueNoPadding &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; protected long p1, p2, p3, p4, p5, p6, p7;</span><br><span class=\"line\">            protected volatile long value &#x3D; 0L;</span><br><span class=\"line\">            &#x2F;&#x2F; protected long p9, p10, p11, p12, p13, p14, p15;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在2G Hz，2核，8G内存, jdk 1.7.0_45 的运行环境下，使用了共享机制比没有使用共享机制，速度快了4倍左右。</p>\n<p>结果：</p>\n<ul>\n<li>Thread num 1 duration = 447</li>\n<li>Thread num 2 duration = 463</li>\n<li>Thread num 3 duration = 454</li>\n<li>Thread num 4 duration = 464</li>\n<li>Thread num 5 duration = 561</li>\n<li>Thread num 6 duration = 606</li>\n<li>Thread num 7 duration = 684</li>\n<li>Thread num 8 duration = 870</li>\n<li>Thread num 9 duration = 823</li>\n</ul>\n<p>把代码中ValuePadding都替换为ValueNoPadding后的结果：</p>\n<ul>\n<li>Thread num 1 duration = 446</li>\n<li>Thread num 2 duration = 2549</li>\n<li>Thread num 3 duration = 2898</li>\n<li>Thread num 4 duration = 3931</li>\n<li>Thread num 5 duration = 4716</li>\n<li>Thread num 6 duration = 5424</li>\n<li>Thread num 7 duration = 4868</li>\n<li>Thread num 8 duration = 4595</li>\n<li>Thread num 9 duration = 4540</li>\n</ul>\n<p>备注：在jdk1.8中，有专门的注解@Contended来避免伪共享，更优雅地解决问题。</p>\n<h2 id=\"Disruptor的设计方案\"><a href=\"#Disruptor的设计方案\" class=\"headerlink\" title=\"Disruptor的设计方案\"></a>Disruptor的设计方案</h2><p>Disruptor通过以下设计来解决队列速度慢的问题：</p>\n<ul>\n<li>环形数组结构</li>\n</ul>\n<p>为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。</p>\n<ul>\n<li>元素位置定位</li>\n</ul>\n<p>数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</p>\n<ul>\n<li>无锁设计</li>\n</ul>\n<p>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</p>\n<p>下面忽略数组的环形结构，介绍一下如何实现无锁设计。整个过程通过原子变量CAS，保证操作的线程安全。</p>\n<h3 id=\"一个生产者\"><a href=\"#一个生产者\" class=\"headerlink\" title=\"一个生产者\"></a>一个生产者</h3><p><strong>写数据</strong></p>\n<p>生产者单线程写数据的流程比较简单：</p>\n<ol>\n<li>申请写入m个元素；</li>\n<li>若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素；</li>\n<li>若是返回的正确，则生产者开始写入元素。</li>\n</ol>\n<p><img src=\"https://p1.meituan.net/travelcube/e71c1449273361ec413fffc7b0bf5507208689.png\" alt=\"图5 单个生产者生产过程示意图\"></p>\n<p>图5 单个生产者生产过程示意图</p>\n<h2 id=\"多个生产者\"><a href=\"#多个生产者\" class=\"headerlink\" title=\"多个生产者\"></a>多个生产者</h2><p>多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor的解决方法是，每个线程获取不同的一段数组空间进行操作。这个通过CAS很容易达到。只需要在分配元素的时候，通过CAS判断一下这段空间是否已经分配出去即可。</p>\n<p>但是会遇到一个新问题：如何防止读取的时候，读到还未写的元素。Disruptor在多个生产者的情况下，引入了一个与Ring Buffer大小相同的buffer：available Buffer。当某个位置写入成功的时候，便把availble Buffer相应的位置置位，标记为写入成功。读取的时候，会遍历available Buffer，来判断元素是否已经就绪。</p>\n<p>下面分读数据和写数据两种情况介绍。</p>\n<h3 id=\"读数据\"><a href=\"#读数据\" class=\"headerlink\" title=\"读数据\"></a>读数据</h3><p>生产者多线程写入的情况会复杂很多：</p>\n<ol>\n<li>申请读取到序号n；</li>\n<li>若writer cursor &gt;= n，这时仍然无法确定连续可读的最大下标。从reader cursor开始读取available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；</li>\n<li>消费者读取元素。</li>\n</ol>\n<p>如下图所示，读线程读到下标为2的元素，三个线程Writer1/Writer2/Writer3正在向RingBuffer相应位置写数据，写线程被分配到的最大元素下标是11。</p>\n<p>读线程申请读取到下标从3到11的元素，判断writer cursor&gt;=11。然后开始读取availableBuffer，从3开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。</p>\n<p>然后，消费者读取下标从3到6共计4个元素。</p>\n<p><img src=\"https://p0.meituan.net/travelcube/99c603494ea90c9535e165579daf340a161527.png\" alt=\"图6 多个生产者情况下，消费者消费过程示意图\"></p>\n<p>图6 多个生产者情况下，消费者消费过程示意图</p>\n<h3 id=\"写数据\"><a href=\"#写数据\" class=\"headerlink\" title=\"写数据\"></a>写数据</h3><p>多个生产者写入的时候：</p>\n<ol>\n<li>申请写入m个元素；</li>\n<li>若是有m个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；</li>\n<li>生产者写入元素，写入元素的同时设置available Buffer里面相应的位置，以标记自己哪些位置是已经写入成功的。</li>\n</ol>\n<p>如下图所示，Writer1和Writer2两个线程写入数组，都申请可写的数组空间。Writer1被分配了下标3到下表5的空间，Writer2被分配了下标6到下标9的空间。</p>\n<p>Writer1写入下标3位置的元素，同时把available Buffer相应位置置位，标记已经写入成功，往后移一位，开始写下标4位置的元素。Writer2同样的方式。最终都写入完成。</p>\n<p><img src=\"https://p1.meituan.net/travelcube/5e06841b1bba4dcf1d3fac169734ba36133983.png\" alt=\"图7 多个生产者情况下，生产者生产过程示意图\"></p>\n<p>图7 多个生产者情况下，生产者生产过程示意图</p>\n<p>防止不同生产者对同一段空间写入的代码，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public long tryNext(int n) throws InsufficientCapacityException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (n &lt; 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;n must be &gt; 0&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    long current;</span><br><span class=\"line\">    long next;</span><br><span class=\"line\"> </span><br><span class=\"line\">    do</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        current &#x3D; cursor.get();</span><br><span class=\"line\">        next &#x3D; current + n;</span><br><span class=\"line\"> </span><br><span class=\"line\">        if (!hasAvailableCapacity(gatingSequences, n, current))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            throw InsufficientCapacityException.INSTANCE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while (!cursor.compareAndSet(current, next));</span><br><span class=\"line\"> </span><br><span class=\"line\">    return next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过do/while循环的条件cursor.compareAndSet(current, next)，来判断每次申请的空间是否已经被其他生产者占据。假如已经被占据，该函数会返回失败，While循环重新执行，申请写入空间。</p>\n<p>消费者的流程与生产者非常类似，这儿就不多描述了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Disruptor通过精巧的无锁设计实现了在高并发情形下的高性能。</p>\n<p>在美团内部，很多高并发场景借鉴了Disruptor的设计，减少竞争的强度。其设计思想可以扩展到分布式场景，通过无锁设计，来提升服务性能。</p>\n<p>使用Disruptor比使用ArrayBlockingQueue略微复杂，为方便读者上手，增加代码样例。</p>\n<p>代码实现的功能：每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端。详细逻辑请细读代码。</p>\n<p>以下代码基于3.3.4版本的Disruptor包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.meituan.Disruptor;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @description disruptor代码样例。每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import com.lmax.disruptor.*;</span><br><span class=\"line\">import com.lmax.disruptor.dsl.Disruptor;</span><br><span class=\"line\">import com.lmax.disruptor.dsl.ProducerType;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.concurrent.ThreadFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class DisruptorMain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public static void main(String[] args) throws Exception</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 队列中的元素</span><br><span class=\"line\">        class Element &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            private int value;</span><br><span class=\"line\"></span><br><span class=\"line\">            public int get()&#123;</span><br><span class=\"line\">                return value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            public void set(int value)&#123;</span><br><span class=\"line\">                this.value&#x3D; value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 生产者的线程工厂</span><br><span class=\"line\">        ThreadFactory threadFactory &#x3D; new ThreadFactory()&#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Thread newThread(Runnable r) &#123;</span><br><span class=\"line\">                return new Thread(r, &quot;simpleThread&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; RingBuffer生产工厂,初始化RingBuffer的时候使用</span><br><span class=\"line\">        EventFactory&lt;Element&gt; factory &#x3D; new EventFactory&lt;Element&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Element newInstance() &#123;</span><br><span class=\"line\">                return new Element();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 处理Event的handler</span><br><span class=\"line\">        EventHandler&lt;Element&gt; handler &#x3D; new EventHandler&lt;Element&gt;()&#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onEvent(Element element, long sequence, boolean endOfBatch)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                System.out.println(&quot;Element: &quot; + element.get());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 阻塞策略</span><br><span class=\"line\">        BlockingWaitStrategy strategy &#x3D; new BlockingWaitStrategy();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 指定RingBuffer的大小</span><br><span class=\"line\">        int bufferSize &#x3D; 16;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 创建disruptor，采用单生产者模式</span><br><span class=\"line\">        Disruptor&lt;Element&gt; disruptor &#x3D; new Disruptor(factory, bufferSize, threadFactory, ProducerType.SINGLE, strategy);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 设置EventHandler</span><br><span class=\"line\">        disruptor.handleEventsWith(handler);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 启动disruptor的线程</span><br><span class=\"line\">        disruptor.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        RingBuffer&lt;Element&gt; ringBuffer &#x3D; disruptor.getRingBuffer();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int l &#x3D; 0; true; l++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 获取下一个可用位置的下标</span><br><span class=\"line\">            long sequence &#x3D; ringBuffer.next();  </span><br><span class=\"line\">            try</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 返回可用位置的元素</span><br><span class=\"line\">                Element event &#x3D; ringBuffer.get(sequence); </span><br><span class=\"line\">                &#x2F;&#x2F; 设置该位置元素的值</span><br><span class=\"line\">                event.set(l); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            finally</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ringBuffer.publish(sequence);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Thread.sleep(10);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><p>以下面这些模式测试性能:</p>\n<p><img src=\"https://p1.meituan.net/travelcube/ada37da4ad62709ab67d7a32147cb19a306409.png\" alt=\"img\"></p>\n<p>吞吐量测试数据（每秒的数量）如下。</p>\n<p>环境： - CPU:Intel Core i7 860 @ 2.8 GHz without HT - JVM:Java 1.6.0_25 64-bit - OS:Windows 7</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>ABQ</th>\n<th>Disruptor</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unicast: 1P – 1C</td>\n<td>5,339,256</td>\n<td>25,998,336</td>\n</tr>\n<tr>\n<td>Pipeline: 1P – 3C</td>\n<td>2,128,918</td>\n<td>16,806,157</td>\n</tr>\n<tr>\n<td>Sequencer: 3P – 1C</td>\n<td>5,539,531</td>\n<td>13,403,268</td>\n</tr>\n<tr>\n<td>Multicast: 1P – 3C</td>\n<td>1,077,384</td>\n<td>9,377,871</td>\n</tr>\n<tr>\n<td>Diamond: 1P – 3C</td>\n<td>2,113,941</td>\n<td>16,143,613</td>\n</tr>\n</tbody></table>\n<p>环境：</p>\n<ul>\n<li>CPU:Intel Core i7-2720QM</li>\n<li>JVM:Java 1.6.0_25 64-bit</li>\n<li>OS:Ubuntu 11.04</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>ABQ</th>\n<th>Disruptor</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unicast: 1P – 1C</td>\n<td>4,057,453</td>\n<td>22,381,378</td>\n</tr>\n<tr>\n<td>Pipeline: 1P – 3C</td>\n<td>2,006,903</td>\n<td>15,857,913</td>\n</tr>\n<tr>\n<td>Sequencer: 3P – 1C</td>\n<td>2,056,118</td>\n<td>14,540,519</td>\n</tr>\n<tr>\n<td>Multicast: 1P – 3C</td>\n<td>260,733</td>\n<td>10,860,121</td>\n</tr>\n<tr>\n<td>Diamond: 1P – 3C</td>\n<td>2,082,725</td>\n<td>15,295,197</td>\n</tr>\n</tbody></table>\n<p>依据并发竞争的激烈程度的不同，Disruptor比ArrayBlockingQueue吞吐量快4~7倍。</p>\n<p>按照Pipeline: 1P – 3C的连接模式测试延迟，生产者两次写入之间的延迟为1ms。</p>\n<p>运行环境：</p>\n<ul>\n<li>CPU:2.2GHz Core i7-2720QM</li>\n<li>Java: 1.6.0_25 64-bit</li>\n<li>OS:Ubuntu 11.04.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>Array Blocking Queue (ns)</th>\n<th>Disruptor (ns)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>99% observations less than</td>\n<td>2,097,152</td>\n<td>128</td>\n</tr>\n<tr>\n<td>99.99% observations less than</td>\n<td>4,194,304</td>\n<td>8,192</td>\n</tr>\n<tr>\n<td>Max Latency</td>\n<td>5,069,086</td>\n<td>175,567</td>\n</tr>\n<tr>\n<td>Mean Latency</td>\n<td>32,757</td>\n<td>52</td>\n</tr>\n<tr>\n<td>Min Latency</td>\n<td>145</td>\n<td>29</td>\n</tr>\n</tbody></table>\n<p>可见，平均延迟差了3个数量级。</p>\n<h2 id=\"等待策略\"><a href=\"#等待策略\" class=\"headerlink\" title=\"等待策略\"></a>等待策略</h2><h3 id=\"生产者的等待策略\"><a href=\"#生产者的等待策略\" class=\"headerlink\" title=\"生产者的等待策略\"></a>生产者的等待策略</h3><p>暂时只有休眠1ns。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LockSupport.parkNanos(1);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者的等待策略\"><a href=\"#消费者的等待策略\" class=\"headerlink\" title=\"消费者的等待策略\"></a>消费者的等待策略</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>措施</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>BlockingWaitStrategy</td>\n<td>加锁</td>\n<td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td>\n</tr>\n<tr>\n<td>BusySpinWaitStrategy</td>\n<td>自旋</td>\n<td>通过不断重试，减少切换线程导致的系统调用，而降低延迟。推荐在线程绑定到固定的CPU的场景下使用</td>\n</tr>\n<tr>\n<td>PhasedBackoffWaitStrategy</td>\n<td>自旋 + yield + 自定义策略</td>\n<td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td>\n</tr>\n<tr>\n<td>SleepingWaitStrategy</td>\n<td>自旋 + yield + sleep</td>\n<td>性能和CPU资源之间有很好的折中。延迟不均匀</td>\n</tr>\n<tr>\n<td>TimeoutBlockingWaitStrategy</td>\n<td>加锁，有超时限制</td>\n<td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td>\n</tr>\n<tr>\n<td>YieldingWaitStrategy</td>\n<td>自旋 + yield + 自旋</td>\n<td>性能和CPU资源之间有很好的折中。延迟比较均匀</td>\n</tr>\n</tbody></table>\n<h2 id=\"Log4j-2应用场景\"><a href=\"#Log4j-2应用场景\" class=\"headerlink\" title=\"Log4j 2应用场景\"></a>Log4j 2应用场景</h2><p>Log4j 2相对于Log4j 1最大的优势在于多线程并发场景下性能更优。该特性源自于Log4j 2的异步模式采用了Disruptor来处理。 在Log4j 2的配置文件中可以配置WaitStrategy，默认是Timeout策略。下面是Log4j 2中对WaitStrategy的配置官方文档：</p>\n<table>\n<thead>\n<tr>\n<th>System Property</th>\n<th>Default Value</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AsyncLogger.WaitStrategy</td>\n<td>Timeout</td>\n<td>Valid values: Block, Timeout, Sleep, Yield. Block is a strategy that uses a lock and condition variable for the I/O thread waiting for log events. Block can be used when throughput and low-latency are not as important as CPU resource. Recommended for resource constrained/virtualised environments. Timeout is a variation of the Block strategy that will periodically wake up from the lock condition await() call. This ensures that if a notification is missed somehow the consumer thread is not stuck but will recover with a small latency delay (default 10ms). Sleep is a strategy that initially spins, then uses a Thread.yield(), and eventually parks for the minimum number of nanos the OS and JVM will allow while the I/O thread is waiting for log events. Sleep is a good compromise between performance and CPU resource. This strategy has very low impact on the application thread, in exchange for some additional latency for actually getting the message logged. Yield is a strategy that uses a Thread.yield() for waiting for log events after an initially spinning. Yield is a good compromise between performance and CPU resource, but may use more CPU than Sleep in order to get the message logged to disk sooner.</td>\n</tr>\n</tbody></table>\n<h3 id=\"性能差异\"><a href=\"#性能差异\" class=\"headerlink\" title=\"性能差异\"></a>性能差异</h3><p>loggers all async采用的是Disruptor，而Async Appender采用的是ArrayBlockingQueue队列。</p>\n<p>由图可见，单线程情况下，loggers all async与Async Appender吞吐量相差不大，但是在64个线程的时候，loggers all async的吞吐量比Async Appender增加了12倍，是Sync模式的68倍。</p>\n<p><img src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/ad04b8bd.png\" alt=\"图8 Log4j 2各个模式性能比较\"></p>\n<p>图8 Log4j 2各个模式性能比较</p>\n<p>美团在公司内部统一推行日志接入规范，要求必须使用Log4j 2，使普通单机QPS的上限不再只停留在几千，极高地提升了服务性能。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ol>\n<li><a href=\"http://brokendreams.iteye.com/blog/2255720\" target=\"_blank\" rel=\"noopener\">http://brokendreams.iteye.com/blog/2255720</a></li>\n<li><a href=\"http://ifeve.com/dissecting-disruptor-whats-so-special/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/dissecting-disruptor-whats-so-special/</a></li>\n<li><a href=\"https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results\" target=\"_blank\" rel=\"noopener\">https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results</a></li>\n<li><a href=\"https://lmax-exchange.github.io/disruptor/\" target=\"_blank\" rel=\"noopener\">https://lmax-exchange.github.io/disruptor/</a></li>\n<li><a href=\"https://logging.apache.org/log4j/2.x/manual/async.html\" target=\"_blank\" rel=\"noopener\">https://logging.apache.org/log4j/2.x/manual/async.html</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级）。基于Disruptor开发的系统单线程能支撑每秒600万订单，2010年在QCon演讲后，获得了业界关注。2011年，企业应用软件专家Martin Fowler专门撰写长文介绍。同年它还获得了Oracle官方的Duke大奖。</p>\n<p>目前，包括Apache Storm、Camel、Log4j 2在内的很多知名项目都应用了Disruptor以获取高性能。在美团技术团队它也有不少应用，有的项目架构借鉴了它的设计机制。本文从实战角度剖析了Disruptor的实现原理。</p>\n<p>需要特别指出的是，这里所说的队列是系统内部的内存队列，而不是Kafka这样的分布式队列。另外，本文所描述的Disruptor特性限于3.3.4。</p>\n<h2 id=\"Java内置队列\"><a href=\"#Java内置队列\" class=\"headerlink\" title=\"Java内置队列\"></a>Java内置队列</h2><p>介绍Disruptor之前，我们先来看一看常用的线程安全的内置队列有什么问题。Java的内置队列如下表所示。</p>\n<table>\n<thead>\n<tr>\n<th>队列</th>\n<th>有界性</th>\n<th>锁</th>\n<th>数据结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayBlockingQueue</td>\n<td>bounded</td>\n<td>加锁</td>\n<td>arraylist</td>\n</tr>\n<tr>\n<td>LinkedBlockingQueue</td>\n<td>optionally-bounded</td>\n<td>加锁</td>\n<td>linkedlist</td>\n</tr>\n<tr>\n<td>ConcurrentLinkedQueue</td>\n<td>unbounded</td>\n<td>无锁</td>\n<td>linkedlist</td>\n</tr>\n<tr>\n<td>LinkedTransferQueue</td>\n<td>unbounded</td>\n<td>无锁</td>\n<td>linkedlist</td>\n</tr>\n<tr>\n<td>PriorityBlockingQueue</td>\n<td>unbounded</td>\n<td>加锁</td>\n<td>heap</td>\n</tr>\n<tr>\n<td>DelayQueue</td>\n<td>unbounded</td>\n<td>加锁</td>\n<td>heap</td>\n</tr>\n</tbody></table>\n<p>队列的底层一般分成三种：数组、链表和堆。其中，堆一般情况下是为了实现带有优先级特性的队列，暂且不考虑。</p>\n<p>我们就从数组和链表两种数据结构来看，基于数组线程安全的队列，比较典型的是ArrayBlockingQueue，它主要通过加锁的方式来保证线程安全；基于链表的线程安全队列分成LinkedBlockingQueue和ConcurrentLinkedQueue两大类，前者也通过锁的方式来实现线程安全，而后者以及上面表格中的LinkedTransferQueue都是通过原子变量compare and swap（以下简称“CAS”）这种不加锁的方式来实现的。</p>\n<p>通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在确定的范围内）；而加锁的方式，可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列；同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array/heap格式的数据结构。这样筛选下来，符合条件的队列就只有ArrayBlockingQueue。</p>\n<h2 id=\"ArrayBlockingQueue的问题\"><a href=\"#ArrayBlockingQueue的问题\" class=\"headerlink\" title=\"ArrayBlockingQueue的问题\"></a>ArrayBlockingQueue的问题</h2><p>ArrayBlockingQueue在实际使用过程中，会因为加锁和伪共享等出现严重的性能问题，我们下面来分析一下。</p>\n<h3 id=\"加锁\"><a href=\"#加锁\" class=\"headerlink\" title=\"加锁\"></a>加锁</h3><p>现实编程过程中，加锁通常会严重地影响性能。线程会因为竞争不到锁而被挂起，等锁被释放的时候，线程又会被恢复，这个过程中存在着很大的开销，并且通常会有较长时间的中断，因为当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，例如发生了缺页错误、调度延迟或者其它类似情况，那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，就会发生优先级反转。</p>\n<p>Disruptor论文中讲述了一个实验：</p>\n<ul>\n<li>这个测试程序调用了一个函数，该函数会对一个64位的计数器循环自增5亿次。</li>\n<li>机器环境：2.4G 6核</li>\n<li>运算： 64位的计数器累加5亿次</li>\n</ul>\n<p>|Method | Time (ms) | |— | —| |Single thread | 300| |Single thread with CAS | 5,700| |Single thread with lock | 10,000| |Single thread with volatile write | 4,700| |Two threads with CAS | 30,000| |Two threads with lock | 224,000|</p>\n<p>CAS操作比单线程无锁慢了1个数量级；有锁且多线程并发的情况下，速度比单线程无锁慢3个数量级。可见无锁速度最快。</p>\n<p>单线程情况下，不加锁的性能 &gt; CAS操作的性能 &gt; 加锁的性能。</p>\n<p>在多线程情况下，为了保证线程安全，必须使用CAS或锁，这种情况下，CAS的性能超过锁的性能，前者大约是后者的8倍。</p>\n<p>综上可知，加锁的性能是最差的。</p>\n<p><strong>关于锁和CAS</strong></p>\n<p>保证线程安全一般分成两种方式：锁和原子变量。</p>\n<p><strong>锁</strong></p>\n<p><img src=\"https://p1.meituan.net/travelcube/9b6a41f7d8527df9730b7832b38ec4d5180025.png\" alt=\"图1 通过加锁的方式实现线程安全\"></p>\n<p>图1 通过加锁的方式实现线程安全</p>\n<p>采取加锁的方式，默认线程会冲突，访问数据时，先加上锁再访问，访问之后再解锁。通过锁界定一个临界区，同时只有一个线程进入。如上图所示，Thread2访问Entry的时候，加了锁，Thread1就不能再执行访问Entry的代码，从而保证线程安全。</p>\n<p>下面是ArrayBlockingQueue通过加锁的方式实现的offer方法，保证线程安全。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public boolean offer(E e) &#123;</span><br><span class=\"line\">    checkNotNull(e);</span><br><span class=\"line\">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        if (count &#x3D;&#x3D; items.length)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            insert(e);</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>原子变量</strong></p>\n<p>原子变量能够保证原子性的操作，意思是某个任务在执行过程中，要么全部成功，要么全部失败回滚，恢复到执行之前的初态，不存在初态和成功之间的中间状态。例如CAS操作，要么比较并交换成功，要么比较并交换失败。由CPU保证原子性。</p>\n<p>通过原子变量可以实现线程安全。执行某个任务的时候，先假定不会有冲突，若不发生冲突，则直接执行成功；当发生冲突的时候，则执行失败，回滚再重新操作，直到不发生冲突。</p>\n<p><img src=\"https://p0.meituan.net/travelcube/de0ced42337014947e7466db4d8f2d4d158395.png\" alt=\"图2 通过原子变量CAS实现线程安全\"></p>\n<p>图2 通过原子变量CAS实现线程安全</p>\n<p>如图所示，Thread1和Thread2都要把Entry加1。若不加锁，也不使用CAS，有可能Thread1取到了myValue=1，Thread2也取到了myValue=1，然后相加，Entry中的value值为2。这与预期不相符，我们预期的是Entry的值经过两次相加后等于3。</p>\n<p>CAS会先把Entry现在的value跟线程当初读出的值相比较，若相同，则赋值；若不相同，则赋值执行失败。一般会通过while/for循环来重新执行，直到赋值成功。</p>\n<p>代码示例是AtomicInteger的getAndAdd方法。CAS是CPU的一个指令，由CPU保证原子性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Atomically adds the given value to the current value.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param delta the value to add</span><br><span class=\"line\"> * @return the previous value</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public final int getAndAdd(int delta) &#123;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        int current &#x3D; get();</span><br><span class=\"line\">        int next &#x3D; current + delta;</span><br><span class=\"line\">        if (compareAndSet(current, next))</span><br><span class=\"line\">            return current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Atomically sets the value to the given updated value</span><br><span class=\"line\"> * if the current value &#123;@code &#x3D;&#x3D;&#125; the expected value.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param expect the expected value</span><br><span class=\"line\"> * @param update the new value</span><br><span class=\"line\"> * @return true if successful. False return indicates that</span><br><span class=\"line\"> * the actual value was not equal to the expected value.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class=\"line\">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在高度竞争的情况下，锁的性能将超过原子变量的性能，但是更真实的竞争情况下，原子变量的性能将超过锁的性能。同时原子变量不会有死锁等活跃性问题。</p>\n<h3 id=\"伪共享\"><a href=\"#伪共享\" class=\"headerlink\" title=\"伪共享\"></a>伪共享</h3><p><strong>什么是共享</strong></p>\n<p>下图是计算的基本结构。L1、L2、L3分别表示一级缓存、二级缓存、三级缓存，越靠近CPU的缓存，速度越快，容量也越小。所以L1缓存很小但很快，并且紧靠着在使用它的CPU内核；L2大一些，也慢一些，并且仍然只能被一个单独的CPU核使用；L3更大、更慢，并且被单个插槽上的所有CPU核共享；最后是主存，由全部插槽上的所有CPU核共享。</p>\n<p><img src=\"https://p1.meituan.net/travelcube/69ce8ffbe7a4ebee01c377dac174842d433755.png\" alt=\"图3 计算机CPU与缓存示意图\"></p>\n<p>图3 计算机CPU与缓存示意图</p>\n<p>当CPU执行运算的时候，它先去L1查找所需的数据、再去L2、然后是L3，如果最后这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要尽量确保数据在L1缓存中。</p>\n<p>另外，线程之间共享一份数据的时候，需要一个线程把数据写回主存，而另一个线程访问主存中相应的数据。</p>\n<p>下面是从CPU访问不同层级数据的时间概念:</p>\n<table>\n<thead>\n<tr>\n<th>从CPU到</th>\n<th>大约需要的CPU周期</th>\n<th>大约需要的时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>主存</td>\n<td>-</td>\n<td>约60-80ns</td>\n</tr>\n<tr>\n<td>QPI 总线传输(between sockets, not drawn)</td>\n<td>-</td>\n<td>约20ns</td>\n</tr>\n<tr>\n<td>L3 cache</td>\n<td>约40-45 cycles</td>\n<td>约15ns</td>\n</tr>\n<tr>\n<td>L2 cache</td>\n<td>约10 cycles</td>\n<td>约3ns</td>\n</tr>\n<tr>\n<td>L1 cache</td>\n<td>约3-4 cycles</td>\n<td>约1ns</td>\n</tr>\n<tr>\n<td>寄存器</td>\n<td>1 cycle</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<p>可见CPU读取主存中的数据会比从L1中读取慢了近2个数量级。</p>\n<p><strong>缓存行</strong></p>\n<p>Cache是由很多个cache line组成的。每个cache line通常是64字节，并且它有效地引用主内存中的一块儿地址。一个Java的long类型变量是8字节，因此在一个缓存行中可以存8个long类型的变量。</p>\n<p>CPU每次从主存中拉取数据时，会把相邻的数据也存入同一个cache line。</p>\n<p>在访问一个long数组的时候，如果数组中的一个值被加载到缓存中，它会自动加载另外7个。因此你能非常快的遍历这个数组。事实上，你可以非常快速的遍历在连续内存块中分配的任意数据结构。</p>\n<p>下面的例子是测试利用cache line的特性和不利用cache line的特性的效果对比。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.meituan.FalseSharing;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @author gongming</span><br><span class=\"line\"> * @description</span><br><span class=\"line\"> * @date 16&#x2F;6&#x2F;4</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">public class CacheLineEffect &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;考虑一般缓存行大小是64字节，一个 long 类型占8字节</span><br><span class=\"line\">    static  long[][] arr;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        arr &#x3D; new long[1024 * 1024][];</span><br><span class=\"line\">        for (int i &#x3D; 0; i &lt; 1024 * 1024; i++) &#123;</span><br><span class=\"line\">            arr[i] &#x3D; new long[8];</span><br><span class=\"line\">            for (int j &#x3D; 0; j &lt; 8; j++) &#123;</span><br><span class=\"line\">                arr[i][j] &#x3D; 0L;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        long sum &#x3D; 0L;</span><br><span class=\"line\">        long marked &#x3D; System.currentTimeMillis();</span><br><span class=\"line\">        for (int i &#x3D; 0; i &lt; 1024 * 1024; i+&#x3D;1) &#123;</span><br><span class=\"line\">            for(int j &#x3D;0; j&lt; 8;j++)&#123;</span><br><span class=\"line\">                sum &#x3D; arr[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;Loop times:&quot; + (System.currentTimeMillis() - marked) + &quot;ms&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">        marked &#x3D; System.currentTimeMillis();</span><br><span class=\"line\">        for (int i &#x3D; 0; i &lt; 8; i+&#x3D;1) &#123;</span><br><span class=\"line\">            for(int j &#x3D;0; j&lt; 1024 * 1024;j++)&#123;</span><br><span class=\"line\">                sum &#x3D; arr[j][i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;Loop times:&quot; + (System.currentTimeMillis() - marked) + &quot;ms&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在2G Hz、2核、8G内存的运行环境中测试，速度差一倍。</p>\n<p>结果：</p>\n<p>Loop times:30ms Loop times:65ms</p>\n<p><strong>什么是伪共享</strong></p>\n<p>ArrayBlockingQueue有三个成员变量： - takeIndex：需要被取走的元素下标 - putIndex：可被元素插入的位置的下标 - count：队列中元素的数量</p>\n<p>这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。</p>\n<p><img src=\"https://p0.meituan.net/travelcube/192e9b87b7a5b68cac352fdeb81dc93b161543.png\" alt=\"图4 ArrayBlockingQueue伪共享示意图\"></p>\n<p>图4 ArrayBlockingQueue伪共享示意图</p>\n<p>如上图所示，当生产者线程put一个元素到ArrayBlockingQueue时，putIndex会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。</p>\n<p>这种无法充分使用缓存行特性的现象，称为伪共享。</p>\n<p>对于伪共享，一般的解决方案是，增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上，以空间换时间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.meituan.FalseSharing;</span><br><span class=\"line\"> </span><br><span class=\"line\">public class FalseSharing implements Runnable&#123;</span><br><span class=\"line\">        public final static long ITERATIONS &#x3D; 500L * 1000L * 100L;</span><br><span class=\"line\">        private int arrayIndex &#x3D; 0;</span><br><span class=\"line\"> </span><br><span class=\"line\">        private static ValuePadding[] longs;</span><br><span class=\"line\">        public FalseSharing(final int arrayIndex) &#123;</span><br><span class=\"line\">            this.arrayIndex &#x3D; arrayIndex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        public static void main(final String[] args) throws Exception &#123;</span><br><span class=\"line\">            for(int i&#x3D;1;i&lt;10;i++)&#123;</span><br><span class=\"line\">                System.gc();</span><br><span class=\"line\">                final long start &#x3D; System.currentTimeMillis();</span><br><span class=\"line\">                runTest(i);</span><br><span class=\"line\">                System.out.println(&quot;Thread num &quot;+i+&quot; duration &#x3D; &quot; + (System.currentTimeMillis() - start));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        private static void runTest(int NUM_THREADS) throws InterruptedException &#123;</span><br><span class=\"line\">            Thread[] threads &#x3D; new Thread[NUM_THREADS];</span><br><span class=\"line\">            longs &#x3D; new ValuePadding[NUM_THREADS];</span><br><span class=\"line\">            for (int i &#x3D; 0; i &lt; longs.length; i++) &#123;</span><br><span class=\"line\">                longs[i] &#x3D; new ValuePadding();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            for (int i &#x3D; 0; i &lt; threads.length; i++) &#123;</span><br><span class=\"line\">                threads[i] &#x3D; new Thread(new FalseSharing(i));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            for (Thread t : threads) &#123;</span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">            for (Thread t : threads) &#123;</span><br><span class=\"line\">                t.join();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            long i &#x3D; ITERATIONS + 1;</span><br><span class=\"line\">            while (0 !&#x3D; --i) &#123;</span><br><span class=\"line\">                longs[arrayIndex].value &#x3D; 0L;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        public final static class ValuePadding &#123;</span><br><span class=\"line\">            protected long p1, p2, p3, p4, p5, p6, p7;</span><br><span class=\"line\">            protected volatile long value &#x3D; 0L;</span><br><span class=\"line\">            protected long p9, p10, p11, p12, p13, p14;</span><br><span class=\"line\">            protected long p15;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        public final static class ValueNoPadding &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; protected long p1, p2, p3, p4, p5, p6, p7;</span><br><span class=\"line\">            protected volatile long value &#x3D; 0L;</span><br><span class=\"line\">            &#x2F;&#x2F; protected long p9, p10, p11, p12, p13, p14, p15;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在2G Hz，2核，8G内存, jdk 1.7.0_45 的运行环境下，使用了共享机制比没有使用共享机制，速度快了4倍左右。</p>\n<p>结果：</p>\n<ul>\n<li>Thread num 1 duration = 447</li>\n<li>Thread num 2 duration = 463</li>\n<li>Thread num 3 duration = 454</li>\n<li>Thread num 4 duration = 464</li>\n<li>Thread num 5 duration = 561</li>\n<li>Thread num 6 duration = 606</li>\n<li>Thread num 7 duration = 684</li>\n<li>Thread num 8 duration = 870</li>\n<li>Thread num 9 duration = 823</li>\n</ul>\n<p>把代码中ValuePadding都替换为ValueNoPadding后的结果：</p>\n<ul>\n<li>Thread num 1 duration = 446</li>\n<li>Thread num 2 duration = 2549</li>\n<li>Thread num 3 duration = 2898</li>\n<li>Thread num 4 duration = 3931</li>\n<li>Thread num 5 duration = 4716</li>\n<li>Thread num 6 duration = 5424</li>\n<li>Thread num 7 duration = 4868</li>\n<li>Thread num 8 duration = 4595</li>\n<li>Thread num 9 duration = 4540</li>\n</ul>\n<p>备注：在jdk1.8中，有专门的注解@Contended来避免伪共享，更优雅地解决问题。</p>\n<h2 id=\"Disruptor的设计方案\"><a href=\"#Disruptor的设计方案\" class=\"headerlink\" title=\"Disruptor的设计方案\"></a>Disruptor的设计方案</h2><p>Disruptor通过以下设计来解决队列速度慢的问题：</p>\n<ul>\n<li>环形数组结构</li>\n</ul>\n<p>为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。</p>\n<ul>\n<li>元素位置定位</li>\n</ul>\n<p>数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</p>\n<ul>\n<li>无锁设计</li>\n</ul>\n<p>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</p>\n<p>下面忽略数组的环形结构，介绍一下如何实现无锁设计。整个过程通过原子变量CAS，保证操作的线程安全。</p>\n<h3 id=\"一个生产者\"><a href=\"#一个生产者\" class=\"headerlink\" title=\"一个生产者\"></a>一个生产者</h3><p><strong>写数据</strong></p>\n<p>生产者单线程写数据的流程比较简单：</p>\n<ol>\n<li>申请写入m个元素；</li>\n<li>若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素；</li>\n<li>若是返回的正确，则生产者开始写入元素。</li>\n</ol>\n<p><img src=\"https://p1.meituan.net/travelcube/e71c1449273361ec413fffc7b0bf5507208689.png\" alt=\"图5 单个生产者生产过程示意图\"></p>\n<p>图5 单个生产者生产过程示意图</p>\n<h2 id=\"多个生产者\"><a href=\"#多个生产者\" class=\"headerlink\" title=\"多个生产者\"></a>多个生产者</h2><p>多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor的解决方法是，每个线程获取不同的一段数组空间进行操作。这个通过CAS很容易达到。只需要在分配元素的时候，通过CAS判断一下这段空间是否已经分配出去即可。</p>\n<p>但是会遇到一个新问题：如何防止读取的时候，读到还未写的元素。Disruptor在多个生产者的情况下，引入了一个与Ring Buffer大小相同的buffer：available Buffer。当某个位置写入成功的时候，便把availble Buffer相应的位置置位，标记为写入成功。读取的时候，会遍历available Buffer，来判断元素是否已经就绪。</p>\n<p>下面分读数据和写数据两种情况介绍。</p>\n<h3 id=\"读数据\"><a href=\"#读数据\" class=\"headerlink\" title=\"读数据\"></a>读数据</h3><p>生产者多线程写入的情况会复杂很多：</p>\n<ol>\n<li>申请读取到序号n；</li>\n<li>若writer cursor &gt;= n，这时仍然无法确定连续可读的最大下标。从reader cursor开始读取available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；</li>\n<li>消费者读取元素。</li>\n</ol>\n<p>如下图所示，读线程读到下标为2的元素，三个线程Writer1/Writer2/Writer3正在向RingBuffer相应位置写数据，写线程被分配到的最大元素下标是11。</p>\n<p>读线程申请读取到下标从3到11的元素，判断writer cursor&gt;=11。然后开始读取availableBuffer，从3开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。</p>\n<p>然后，消费者读取下标从3到6共计4个元素。</p>\n<p><img src=\"https://p0.meituan.net/travelcube/99c603494ea90c9535e165579daf340a161527.png\" alt=\"图6 多个生产者情况下，消费者消费过程示意图\"></p>\n<p>图6 多个生产者情况下，消费者消费过程示意图</p>\n<h3 id=\"写数据\"><a href=\"#写数据\" class=\"headerlink\" title=\"写数据\"></a>写数据</h3><p>多个生产者写入的时候：</p>\n<ol>\n<li>申请写入m个元素；</li>\n<li>若是有m个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；</li>\n<li>生产者写入元素，写入元素的同时设置available Buffer里面相应的位置，以标记自己哪些位置是已经写入成功的。</li>\n</ol>\n<p>如下图所示，Writer1和Writer2两个线程写入数组，都申请可写的数组空间。Writer1被分配了下标3到下表5的空间，Writer2被分配了下标6到下标9的空间。</p>\n<p>Writer1写入下标3位置的元素，同时把available Buffer相应位置置位，标记已经写入成功，往后移一位，开始写下标4位置的元素。Writer2同样的方式。最终都写入完成。</p>\n<p><img src=\"https://p1.meituan.net/travelcube/5e06841b1bba4dcf1d3fac169734ba36133983.png\" alt=\"图7 多个生产者情况下，生产者生产过程示意图\"></p>\n<p>图7 多个生产者情况下，生产者生产过程示意图</p>\n<p>防止不同生产者对同一段空间写入的代码，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public long tryNext(int n) throws InsufficientCapacityException</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (n &lt; 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        throw new IllegalArgumentException(&quot;n must be &gt; 0&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    long current;</span><br><span class=\"line\">    long next;</span><br><span class=\"line\"> </span><br><span class=\"line\">    do</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        current &#x3D; cursor.get();</span><br><span class=\"line\">        next &#x3D; current + n;</span><br><span class=\"line\"> </span><br><span class=\"line\">        if (!hasAvailableCapacity(gatingSequences, n, current))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            throw InsufficientCapacityException.INSTANCE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while (!cursor.compareAndSet(current, next));</span><br><span class=\"line\"> </span><br><span class=\"line\">    return next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过do/while循环的条件cursor.compareAndSet(current, next)，来判断每次申请的空间是否已经被其他生产者占据。假如已经被占据，该函数会返回失败，While循环重新执行，申请写入空间。</p>\n<p>消费者的流程与生产者非常类似，这儿就不多描述了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Disruptor通过精巧的无锁设计实现了在高并发情形下的高性能。</p>\n<p>在美团内部，很多高并发场景借鉴了Disruptor的设计，减少竞争的强度。其设计思想可以扩展到分布式场景，通过无锁设计，来提升服务性能。</p>\n<p>使用Disruptor比使用ArrayBlockingQueue略微复杂，为方便读者上手，增加代码样例。</p>\n<p>代码实现的功能：每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端。详细逻辑请细读代码。</p>\n<p>以下代码基于3.3.4版本的Disruptor包。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.meituan.Disruptor;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @description disruptor代码样例。每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">import com.lmax.disruptor.*;</span><br><span class=\"line\">import com.lmax.disruptor.dsl.Disruptor;</span><br><span class=\"line\">import com.lmax.disruptor.dsl.ProducerType;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.util.concurrent.ThreadFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">public class DisruptorMain</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public static void main(String[] args) throws Exception</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 队列中的元素</span><br><span class=\"line\">        class Element &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            private int value;</span><br><span class=\"line\"></span><br><span class=\"line\">            public int get()&#123;</span><br><span class=\"line\">                return value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            public void set(int value)&#123;</span><br><span class=\"line\">                this.value&#x3D; value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 生产者的线程工厂</span><br><span class=\"line\">        ThreadFactory threadFactory &#x3D; new ThreadFactory()&#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Thread newThread(Runnable r) &#123;</span><br><span class=\"line\">                return new Thread(r, &quot;simpleThread&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; RingBuffer生产工厂,初始化RingBuffer的时候使用</span><br><span class=\"line\">        EventFactory&lt;Element&gt; factory &#x3D; new EventFactory&lt;Element&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public Element newInstance() &#123;</span><br><span class=\"line\">                return new Element();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 处理Event的handler</span><br><span class=\"line\">        EventHandler&lt;Element&gt; handler &#x3D; new EventHandler&lt;Element&gt;()&#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onEvent(Element element, long sequence, boolean endOfBatch)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                System.out.println(&quot;Element: &quot; + element.get());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 阻塞策略</span><br><span class=\"line\">        BlockingWaitStrategy strategy &#x3D; new BlockingWaitStrategy();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 指定RingBuffer的大小</span><br><span class=\"line\">        int bufferSize &#x3D; 16;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 创建disruptor，采用单生产者模式</span><br><span class=\"line\">        Disruptor&lt;Element&gt; disruptor &#x3D; new Disruptor(factory, bufferSize, threadFactory, ProducerType.SINGLE, strategy);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 设置EventHandler</span><br><span class=\"line\">        disruptor.handleEventsWith(handler);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; 启动disruptor的线程</span><br><span class=\"line\">        disruptor.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        RingBuffer&lt;Element&gt; ringBuffer &#x3D; disruptor.getRingBuffer();</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int l &#x3D; 0; true; l++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 获取下一个可用位置的下标</span><br><span class=\"line\">            long sequence &#x3D; ringBuffer.next();  </span><br><span class=\"line\">            try</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; 返回可用位置的元素</span><br><span class=\"line\">                Element event &#x3D; ringBuffer.get(sequence); </span><br><span class=\"line\">                &#x2F;&#x2F; 设置该位置元素的值</span><br><span class=\"line\">                event.set(l); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            finally</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ringBuffer.publish(sequence);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Thread.sleep(10);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><p>以下面这些模式测试性能:</p>\n<p><img src=\"https://p1.meituan.net/travelcube/ada37da4ad62709ab67d7a32147cb19a306409.png\" alt=\"img\"></p>\n<p>吞吐量测试数据（每秒的数量）如下。</p>\n<p>环境： - CPU:Intel Core i7 860 @ 2.8 GHz without HT - JVM:Java 1.6.0_25 64-bit - OS:Windows 7</p>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>ABQ</th>\n<th>Disruptor</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unicast: 1P – 1C</td>\n<td>5,339,256</td>\n<td>25,998,336</td>\n</tr>\n<tr>\n<td>Pipeline: 1P – 3C</td>\n<td>2,128,918</td>\n<td>16,806,157</td>\n</tr>\n<tr>\n<td>Sequencer: 3P – 1C</td>\n<td>5,539,531</td>\n<td>13,403,268</td>\n</tr>\n<tr>\n<td>Multicast: 1P – 3C</td>\n<td>1,077,384</td>\n<td>9,377,871</td>\n</tr>\n<tr>\n<td>Diamond: 1P – 3C</td>\n<td>2,113,941</td>\n<td>16,143,613</td>\n</tr>\n</tbody></table>\n<p>环境：</p>\n<ul>\n<li>CPU:Intel Core i7-2720QM</li>\n<li>JVM:Java 1.6.0_25 64-bit</li>\n<li>OS:Ubuntu 11.04</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>ABQ</th>\n<th>Disruptor</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Unicast: 1P – 1C</td>\n<td>4,057,453</td>\n<td>22,381,378</td>\n</tr>\n<tr>\n<td>Pipeline: 1P – 3C</td>\n<td>2,006,903</td>\n<td>15,857,913</td>\n</tr>\n<tr>\n<td>Sequencer: 3P – 1C</td>\n<td>2,056,118</td>\n<td>14,540,519</td>\n</tr>\n<tr>\n<td>Multicast: 1P – 3C</td>\n<td>260,733</td>\n<td>10,860,121</td>\n</tr>\n<tr>\n<td>Diamond: 1P – 3C</td>\n<td>2,082,725</td>\n<td>15,295,197</td>\n</tr>\n</tbody></table>\n<p>依据并发竞争的激烈程度的不同，Disruptor比ArrayBlockingQueue吞吐量快4~7倍。</p>\n<p>按照Pipeline: 1P – 3C的连接模式测试延迟，生产者两次写入之间的延迟为1ms。</p>\n<p>运行环境：</p>\n<ul>\n<li>CPU:2.2GHz Core i7-2720QM</li>\n<li>Java: 1.6.0_25 64-bit</li>\n<li>OS:Ubuntu 11.04.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>-</th>\n<th>Array Blocking Queue (ns)</th>\n<th>Disruptor (ns)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>99% observations less than</td>\n<td>2,097,152</td>\n<td>128</td>\n</tr>\n<tr>\n<td>99.99% observations less than</td>\n<td>4,194,304</td>\n<td>8,192</td>\n</tr>\n<tr>\n<td>Max Latency</td>\n<td>5,069,086</td>\n<td>175,567</td>\n</tr>\n<tr>\n<td>Mean Latency</td>\n<td>32,757</td>\n<td>52</td>\n</tr>\n<tr>\n<td>Min Latency</td>\n<td>145</td>\n<td>29</td>\n</tr>\n</tbody></table>\n<p>可见，平均延迟差了3个数量级。</p>\n<h2 id=\"等待策略\"><a href=\"#等待策略\" class=\"headerlink\" title=\"等待策略\"></a>等待策略</h2><h3 id=\"生产者的等待策略\"><a href=\"#生产者的等待策略\" class=\"headerlink\" title=\"生产者的等待策略\"></a>生产者的等待策略</h3><p>暂时只有休眠1ns。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LockSupport.parkNanos(1);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"消费者的等待策略\"><a href=\"#消费者的等待策略\" class=\"headerlink\" title=\"消费者的等待策略\"></a>消费者的等待策略</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>措施</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>BlockingWaitStrategy</td>\n<td>加锁</td>\n<td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td>\n</tr>\n<tr>\n<td>BusySpinWaitStrategy</td>\n<td>自旋</td>\n<td>通过不断重试，减少切换线程导致的系统调用，而降低延迟。推荐在线程绑定到固定的CPU的场景下使用</td>\n</tr>\n<tr>\n<td>PhasedBackoffWaitStrategy</td>\n<td>自旋 + yield + 自定义策略</td>\n<td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td>\n</tr>\n<tr>\n<td>SleepingWaitStrategy</td>\n<td>自旋 + yield + sleep</td>\n<td>性能和CPU资源之间有很好的折中。延迟不均匀</td>\n</tr>\n<tr>\n<td>TimeoutBlockingWaitStrategy</td>\n<td>加锁，有超时限制</td>\n<td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td>\n</tr>\n<tr>\n<td>YieldingWaitStrategy</td>\n<td>自旋 + yield + 自旋</td>\n<td>性能和CPU资源之间有很好的折中。延迟比较均匀</td>\n</tr>\n</tbody></table>\n<h2 id=\"Log4j-2应用场景\"><a href=\"#Log4j-2应用场景\" class=\"headerlink\" title=\"Log4j 2应用场景\"></a>Log4j 2应用场景</h2><p>Log4j 2相对于Log4j 1最大的优势在于多线程并发场景下性能更优。该特性源自于Log4j 2的异步模式采用了Disruptor来处理。 在Log4j 2的配置文件中可以配置WaitStrategy，默认是Timeout策略。下面是Log4j 2中对WaitStrategy的配置官方文档：</p>\n<table>\n<thead>\n<tr>\n<th>System Property</th>\n<th>Default Value</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AsyncLogger.WaitStrategy</td>\n<td>Timeout</td>\n<td>Valid values: Block, Timeout, Sleep, Yield. Block is a strategy that uses a lock and condition variable for the I/O thread waiting for log events. Block can be used when throughput and low-latency are not as important as CPU resource. Recommended for resource constrained/virtualised environments. Timeout is a variation of the Block strategy that will periodically wake up from the lock condition await() call. This ensures that if a notification is missed somehow the consumer thread is not stuck but will recover with a small latency delay (default 10ms). Sleep is a strategy that initially spins, then uses a Thread.yield(), and eventually parks for the minimum number of nanos the OS and JVM will allow while the I/O thread is waiting for log events. Sleep is a good compromise between performance and CPU resource. This strategy has very low impact on the application thread, in exchange for some additional latency for actually getting the message logged. Yield is a strategy that uses a Thread.yield() for waiting for log events after an initially spinning. Yield is a good compromise between performance and CPU resource, but may use more CPU than Sleep in order to get the message logged to disk sooner.</td>\n</tr>\n</tbody></table>\n<h3 id=\"性能差异\"><a href=\"#性能差异\" class=\"headerlink\" title=\"性能差异\"></a>性能差异</h3><p>loggers all async采用的是Disruptor，而Async Appender采用的是ArrayBlockingQueue队列。</p>\n<p>由图可见，单线程情况下，loggers all async与Async Appender吞吐量相差不大，但是在64个线程的时候，loggers all async的吞吐量比Async Appender增加了12倍，是Sync模式的68倍。</p>\n<p><img src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/ad04b8bd.png\" alt=\"图8 Log4j 2各个模式性能比较\"></p>\n<p>图8 Log4j 2各个模式性能比较</p>\n<p>美团在公司内部统一推行日志接入规范，要求必须使用Log4j 2，使普通单机QPS的上限不再只停留在几千，极高地提升了服务性能。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ol>\n<li><a href=\"http://brokendreams.iteye.com/blog/2255720\" target=\"_blank\" rel=\"noopener\">http://brokendreams.iteye.com/blog/2255720</a></li>\n<li><a href=\"http://ifeve.com/dissecting-disruptor-whats-so-special/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/dissecting-disruptor-whats-so-special/</a></li>\n<li><a href=\"https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results\" target=\"_blank\" rel=\"noopener\">https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results</a></li>\n<li><a href=\"https://lmax-exchange.github.io/disruptor/\" target=\"_blank\" rel=\"noopener\">https://lmax-exchange.github.io/disruptor/</a></li>\n<li><a href=\"https://logging.apache.org/log4j/2.x/manual/async.html\" target=\"_blank\" rel=\"noopener\">https://logging.apache.org/log4j/2.x/manual/async.html</a></li>\n</ol>\n"},{"title":"Java 内存区域","date":"2020-05-26T05:22:27.000Z","_content":"如果没有特殊说明，都是针对的是 HotSpot 虚拟机。\n\n### 基本问题\n\n- **介绍下 Java 内存区域（运行时数据区）**\n- **Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）**\n- **对象的访问定位的两种方式（句柄和直接指针两种方式）**\n\n### 拓展问题\n\n- **String 类和常量池**\n- **8 种基本类型的包装类和常量池**\n\n## 一 概述\n\n对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。\n\n## 二 运行时数据区域\n\nJava 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同，下面会介绍到。\n\n**JDK 1.8 之前：**\n\n![ava-memor](/images/java-memory.png)\n\n**JDK 1.8 ：**\n\n![ava-memoryjdk](/images/java-memoryjdk8.png)\n\n**线程私有的：**\n\n- 程序计数器\n- 虚拟机栈\n- 本地方法栈\n\n**线程共享的：**\n\n- 堆\n- 方法区\n- 直接内存 (非运行时数据区的一部分)\n\n### 2.1 程序计数器\n\n程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**\n\n另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**\n\n**从上面的介绍中我们知道程序计数器主要有两个作用：**\n\n1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n\n**注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**\n\n### 2.2 Java 虚拟机栈\n\n**与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。**\n\n**Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）\n\n**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n\n**Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。**\n\n- **StackOverFlowError：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。\n- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。\n\nJava 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。\n\n**扩展：那么方法/函数如何调用？**\n\nJava 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。\n\nJava 方法有两种返回方式：\n\n1. return 语句。\n2. 抛出异常。\n\n不管哪种返回方式都会导致栈帧被弹出。\n\n### 2.3 本地方法栈\n\n和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n\n本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n\n方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。\n\n### 2.4 堆\n\nJava 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**\n\n**Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。**\n\nJava 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**\n\n在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：\n\n1. 新生代内存(Young Generation)\n2. 老生代(Old Generation)\n3. 永生代(Permanent Generation)\n\n![ava-memory-](/images/java-memory-g.jpg)\n\nJDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。\n\n![ava-memory-g](/images/java-memory-g8.jpg)\n\n**上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。**\n\n大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。\n\n> 修正（[issue552](https://github.com/Snailclimb/JavaGuide/issues/552)）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。\n>\n> **动态年龄计算的代码如下**\n>\n> ```java\n> uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {\n> \t//survivor_capacity是survivor空间的大小\n>   size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);\n>   size_t total = 0;\n>   uint age = 1;\n>   while (age < table_size) {\n>     total += sizes[age];//sizes数组是每个年龄段对象大小\n>     if (total > desired_survivor_size) break;\n>     age++;\n>   }525453625\n>   uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;\n> \t...\n> }\n> ```\n\n堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：\n\n1. **OutOfMemoryError: GC Overhead Limit Exceeded** ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。\n2. **java.lang.OutOfMemoryError: Java heap space** :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发`java.lang.OutOfMemoryError: Java heap space` 错误。(和本机物理内存无关，和你配置的内存大小有关！)\n3. ......\n\n### 2.5 方法区\n\n方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 **Java 虚拟机规范把方法区描述为堆的一个逻辑部分**，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。\n\n方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。\n\n#### 2.5.1 方法区和永久代的关系\n\n> 《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。\n\n#### 2.5.2 常用参数\n\nJDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小\n\n```java\n-XX:PermSize=N //方法区 (永久代) 初始大小\n-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen\n```\n\n相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。\n\nJDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。\n\n下面是一些常用参数：\n\n```java\n-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）\n-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小\n```\n\n与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。\n\n#### 2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?\n\n1. 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。\n\n> 当你元空间溢出时会得到如下错误： `java.lang.OutOfMemoryError: MetaSpace`\n\n你可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。\n\n1. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。\n2. 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。\n\n### 2.6 运行时常量池\n\n运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）\n\n既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。\n\n~~**JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**~~\n\n> 修正([issue747](https://github.com/Snailclimb/JavaGuide/issues/747)，[reference](https://blog.csdn.net/q5706503/article/details/84640762))：\n>\n> 1. **JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代**\n> 2. **JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代** 。\n> 3. **JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)**\n\n相关问题：JVM 常量池中存储的是对象还是引用呢？： <https://www.zhihu.com/question/57109429/answer/151717241> by RednaxelaFX\n\n### 2.7 直接内存\n\n**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。**\n\nJDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。\n\n本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。\n\n## 三 HotSpot 虚拟机对象探秘\n\n通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。\n\n### 3.1 对象的创建\n\n下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。\n\n![ava-memory-obj-creat](/images/java-memory-obj-create.png)\n\n#### Step1:类加载检查\n\n虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\n\n#### Step2:分配内存\n\n在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。\n\n**内存分配的两种方式：（补充内容，需要掌握）**\n\n选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是\"标记-清除\"，还是\"标记-整理\"（也称作\"标记-压缩\"），值得注意的是，复制算法内存也是规整的\n\n![ava-memory-malloc](/images/java-memory-mallock.png)\n\n**内存分配并发问题（补充内容，需要掌握）**\n\n在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：\n\n- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**\n- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配\n\n#### Step3:初始化零值\n\n内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n\n#### Step4:设置对象头\n\n初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n\n#### Step5:执行 init 方法\n\n在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\n\n### 3.2 对象的内存布局\n\n在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。\n\n**Hotspot 虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。\n\n**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。\n\n**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。\n\n### 3.3 对象的访问定位\n\n建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：\n\n1. **句柄：** 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；\n\n![ava-memory-obj-referenc](/images/java-memory-obj-reference.png)\n\n1. **直接指针：** 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。\n\n![ava-memory-obj-direc](/images/java-memory-obj-direct.png)\n\n**这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**\n\n## 四 重点补充内容\n\n### 4.1 String 类和常量池\n\n**String 对象的两种创建方式：**\n\n```java\nString str1 = \"abcd\";//先检查字符串常量池中有没有\"abcd\"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向\"abcd\"\"；\nString str2 = new String(\"abcd\");//堆中创建一个新的对象\nString str3 = new String(\"abcd\");//堆中创建一个新的对象\nSystem.out.println(str1==str2);//false\nSystem.out.println(str2==str3);//false\n```\n\n这两种不同的创建方法是有差别的。\n\n- 第一种方式是在常量池中拿对象；\n- 第二种方式是直接在堆内存空间创建一个新的对象。\n\n记住一点：**只要使用 new 方法，便需要创建新的对象。**\n\n再给大家一个图应该更容易理解，图片来源：<https://www.journaldev.com/797/what-is-java-string-pool>：\n\n![ava-memory-str-ne](/images/java-memory-str-new.png)\n\n**String 类型的常量池比较特殊。它的主要使用方法有两种：**\n\n- 直接使用双引号声明出来的 String 对象会直接存储在常量池中。\n- 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。\n\n```java\n\t      String s1 = new String(\"计算机\");\n\t      String s2 = s1.intern();\n\t      String s3 = \"计算机\";\n\t      System.out.println(s2);//计算机\n\t      System.out.println(s1 == s2);//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，\n\t      System.out.println(s3 == s2);//true，因为两个都是常量池中的 String 对象\n```\n\n**字符串拼接:**\n\n```java\n\t\t  String str1 = \"str\";\n\t\t  String str2 = \"ing\";\n\t\t \n\t\t  String str3 = \"str\" + \"ing\";//常量池中的对象\n\t\t  String str4 = str1 + str2; //在堆上创建的新的对象\t  \n\t\t  String str5 = \"string\";//常量池中的对象\n\t\t  System.out.println(str3 == str4);//false\n\t\t  System.out.println(str3 == str5);//true\n\t\t  System.out.println(str4 == str5);//false\n```\n\n![ava-memory-str-constan](/images/java-memory-str-constant.png)\n\n尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。\n\n### 4.2 String s1 = new String(\"abc\");这句话创建了几个字符串对象？\n\n**将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。**\n\n**验证：**\n\n```java\n\t\tString s1 = new String(\"abc\");// 堆内存的地址值\n\t\tString s2 = \"abc\";\n\t\tSystem.out.println(s1 == s2);// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。\n\t\tSystem.out.println(s1.equals(s2));// 输出 true\n```\n\n**结果：**\n\n```java\nfalse\ntrue\n```\n\n### 4.3 8 种基本类型的包装类和常量池\n\n**Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。** 为啥把缓存设置为[-128，127]区间？（[参见issue/461](https://github.com/Snailclimb/JavaGuide/issues/461)）性能和资源之间的权衡。\n\n```java\npublic static Boolean valueOf(boolean b) {\n    return (b ? TRUE : FALSE);\n}\n```\n\n```java\nprivate static class CharacterCache {         \n    private CharacterCache(){}\n          \n    static final Character cache[] = new Character[127 + 1];          \n    static {             \n        for (int i = 0; i < cache.length; i++)                 \n            cache[i] = new Character((char)i);         \n    }   \n}\n```\n\n两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。**\n\n```java\n\t\tInteger i1 = 33;\n\t\tInteger i2 = 33;\n\t\tSystem.out.println(i1 == i2);// 输出 true\n\t\tInteger i11 = 333;\n\t\tInteger i22 = 333;\n\t\tSystem.out.println(i11 == i22);// 输出 false\n\t\tDouble i3 = 1.2;\n\t\tDouble i4 = 1.2;\n\t\tSystem.out.println(i3 == i4);// 输出 false\n```\n\n**Integer 缓存源代码：**\n\n```java\n/**\n*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。\n*/\n    public static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n```\n\n**应用场景：**\n\n1. Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。\n2. Integer i1 = new Integer(40);这种情况下会创建新的对象。\n\n```java\n  Integer i1 = 40;\n  Integer i2 = new Integer(40);\n  System.out.println(i1==i2);//输出 false\n```\n\n**Integer 比较更丰富的一个例子:**\n\n```java\n  Integer i1 = 40;\n  Integer i2 = 40;\n  Integer i3 = 0;\n  Integer i4 = new Integer(40);\n  Integer i5 = new Integer(40);\n  Integer i6 = new Integer(0);\n  \n  System.out.println(\"i1=i2   \" + (i1 == i2));\n  System.out.println(\"i1=i2+i3   \" + (i1 == i2 + i3));\n  System.out.println(\"i1=i4   \" + (i1 == i4));\n  System.out.println(\"i4=i5   \" + (i4 == i5));\n  System.out.println(\"i4=i5+i6   \" + (i4 == i5 + i6));   \n  System.out.println(\"40=i5+i6   \" + (40 == i5 + i6));     \n```\n\n结果：\n\n```java\ni1=i2   true\ni1=i2+i3   true\ni1=i4   false\ni4=i5   false\ni4=i5+i6   true\n40=i5+i6   true\n```\n\n解释：\n\n语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。\n\n## 参考\n\n- 《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》\n- 《实战 java 虚拟机》\n- <https://docs.oracle.com/javase/specs/index.html>\n- <http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/>\n- <https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou>\n- <https://stackoverflow.com/questions/9095748/method-area-and-permgen>\n- 深入解析String#intern<https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html>","source":"_posts/java/java-memory.md","raw":"---\ntitle: Java 内存区域\ndate: 2020-05-26 13:22:27\ntags:\n    - java\n    - memory\ncategories:\n    - java\n    - memory\n---\n如果没有特殊说明，都是针对的是 HotSpot 虚拟机。\n\n### 基本问题\n\n- **介绍下 Java 内存区域（运行时数据区）**\n- **Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）**\n- **对象的访问定位的两种方式（句柄和直接指针两种方式）**\n\n### 拓展问题\n\n- **String 类和常量池**\n- **8 种基本类型的包装类和常量池**\n\n## 一 概述\n\n对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。\n\n## 二 运行时数据区域\n\nJava 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同，下面会介绍到。\n\n**JDK 1.8 之前：**\n\n![ava-memor](/images/java-memory.png)\n\n**JDK 1.8 ：**\n\n![ava-memoryjdk](/images/java-memoryjdk8.png)\n\n**线程私有的：**\n\n- 程序计数器\n- 虚拟机栈\n- 本地方法栈\n\n**线程共享的：**\n\n- 堆\n- 方法区\n- 直接内存 (非运行时数据区的一部分)\n\n### 2.1 程序计数器\n\n程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**\n\n另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**\n\n**从上面的介绍中我们知道程序计数器主要有两个作用：**\n\n1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n\n**注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**\n\n### 2.2 Java 虚拟机栈\n\n**与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。**\n\n**Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）\n\n**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n\n**Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。**\n\n- **StackOverFlowError：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。\n- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。\n\nJava 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。\n\n**扩展：那么方法/函数如何调用？**\n\nJava 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。\n\nJava 方法有两种返回方式：\n\n1. return 语句。\n2. 抛出异常。\n\n不管哪种返回方式都会导致栈帧被弹出。\n\n### 2.3 本地方法栈\n\n和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n\n本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n\n方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。\n\n### 2.4 堆\n\nJava 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**\n\n**Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。**\n\nJava 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**\n\n在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：\n\n1. 新生代内存(Young Generation)\n2. 老生代(Old Generation)\n3. 永生代(Permanent Generation)\n\n![ava-memory-](/images/java-memory-g.jpg)\n\nJDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。\n\n![ava-memory-g](/images/java-memory-g8.jpg)\n\n**上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。**\n\n大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。\n\n> 修正（[issue552](https://github.com/Snailclimb/JavaGuide/issues/552)）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。\n>\n> **动态年龄计算的代码如下**\n>\n> ```java\n> uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {\n> \t//survivor_capacity是survivor空间的大小\n>   size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);\n>   size_t total = 0;\n>   uint age = 1;\n>   while (age < table_size) {\n>     total += sizes[age];//sizes数组是每个年龄段对象大小\n>     if (total > desired_survivor_size) break;\n>     age++;\n>   }525453625\n>   uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;\n> \t...\n> }\n> ```\n\n堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：\n\n1. **OutOfMemoryError: GC Overhead Limit Exceeded** ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。\n2. **java.lang.OutOfMemoryError: Java heap space** :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发`java.lang.OutOfMemoryError: Java heap space` 错误。(和本机物理内存无关，和你配置的内存大小有关！)\n3. ......\n\n### 2.5 方法区\n\n方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 **Java 虚拟机规范把方法区描述为堆的一个逻辑部分**，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。\n\n方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。\n\n#### 2.5.1 方法区和永久代的关系\n\n> 《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 **方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。\n\n#### 2.5.2 常用参数\n\nJDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小\n\n```java\n-XX:PermSize=N //方法区 (永久代) 初始大小\n-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen\n```\n\n相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。\n\nJDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。\n\n下面是一些常用参数：\n\n```java\n-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）\n-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小\n```\n\n与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。\n\n#### 2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?\n\n1. 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。\n\n> 当你元空间溢出时会得到如下错误： `java.lang.OutOfMemoryError: MetaSpace`\n\n你可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。\n\n1. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。\n2. 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。\n\n### 2.6 运行时常量池\n\n运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）\n\n既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。\n\n~~**JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**~~\n\n> 修正([issue747](https://github.com/Snailclimb/JavaGuide/issues/747)，[reference](https://blog.csdn.net/q5706503/article/details/84640762))：\n>\n> 1. **JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代**\n> 2. **JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代** 。\n> 3. **JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)**\n\n相关问题：JVM 常量池中存储的是对象还是引用呢？： <https://www.zhihu.com/question/57109429/answer/151717241> by RednaxelaFX\n\n### 2.7 直接内存\n\n**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。**\n\nJDK1.4 中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。\n\n本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。\n\n## 三 HotSpot 虚拟机对象探秘\n\n通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。\n\n### 3.1 对象的创建\n\n下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。\n\n![ava-memory-obj-creat](/images/java-memory-obj-create.png)\n\n#### Step1:类加载检查\n\n虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。\n\n#### Step2:分配内存\n\n在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。\n\n**内存分配的两种方式：（补充内容，需要掌握）**\n\n选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是\"标记-清除\"，还是\"标记-整理\"（也称作\"标记-压缩\"），值得注意的是，复制算法内存也是规整的\n\n![ava-memory-malloc](/images/java-memory-mallock.png)\n\n**内存分配并发问题（补充内容，需要掌握）**\n\n在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：\n\n- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**\n- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配\n\n#### Step3:初始化零值\n\n内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。\n\n#### Step4:设置对象头\n\n初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n\n#### Step5:执行 init 方法\n\n在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。\n\n### 3.2 对象的内存布局\n\n在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。\n\n**Hotspot 虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。\n\n**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。\n\n**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。\n\n### 3.3 对象的访问定位\n\n建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：\n\n1. **句柄：** 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；\n\n![ava-memory-obj-referenc](/images/java-memory-obj-reference.png)\n\n1. **直接指针：** 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。\n\n![ava-memory-obj-direc](/images/java-memory-obj-direct.png)\n\n**这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**\n\n## 四 重点补充内容\n\n### 4.1 String 类和常量池\n\n**String 对象的两种创建方式：**\n\n```java\nString str1 = \"abcd\";//先检查字符串常量池中有没有\"abcd\"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向\"abcd\"\"；\nString str2 = new String(\"abcd\");//堆中创建一个新的对象\nString str3 = new String(\"abcd\");//堆中创建一个新的对象\nSystem.out.println(str1==str2);//false\nSystem.out.println(str2==str3);//false\n```\n\n这两种不同的创建方法是有差别的。\n\n- 第一种方式是在常量池中拿对象；\n- 第二种方式是直接在堆内存空间创建一个新的对象。\n\n记住一点：**只要使用 new 方法，便需要创建新的对象。**\n\n再给大家一个图应该更容易理解，图片来源：<https://www.journaldev.com/797/what-is-java-string-pool>：\n\n![ava-memory-str-ne](/images/java-memory-str-new.png)\n\n**String 类型的常量池比较特殊。它的主要使用方法有两种：**\n\n- 直接使用双引号声明出来的 String 对象会直接存储在常量池中。\n- 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。\n\n```java\n\t      String s1 = new String(\"计算机\");\n\t      String s2 = s1.intern();\n\t      String s3 = \"计算机\";\n\t      System.out.println(s2);//计算机\n\t      System.out.println(s1 == s2);//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，\n\t      System.out.println(s3 == s2);//true，因为两个都是常量池中的 String 对象\n```\n\n**字符串拼接:**\n\n```java\n\t\t  String str1 = \"str\";\n\t\t  String str2 = \"ing\";\n\t\t \n\t\t  String str3 = \"str\" + \"ing\";//常量池中的对象\n\t\t  String str4 = str1 + str2; //在堆上创建的新的对象\t  \n\t\t  String str5 = \"string\";//常量池中的对象\n\t\t  System.out.println(str3 == str4);//false\n\t\t  System.out.println(str3 == str5);//true\n\t\t  System.out.println(str4 == str5);//false\n```\n\n![ava-memory-str-constan](/images/java-memory-str-constant.png)\n\n尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。\n\n### 4.2 String s1 = new String(\"abc\");这句话创建了几个字符串对象？\n\n**将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。**\n\n**验证：**\n\n```java\n\t\tString s1 = new String(\"abc\");// 堆内存的地址值\n\t\tString s2 = \"abc\";\n\t\tSystem.out.println(s1 == s2);// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。\n\t\tSystem.out.println(s1.equals(s2));// 输出 true\n```\n\n**结果：**\n\n```java\nfalse\ntrue\n```\n\n### 4.3 8 种基本类型的包装类和常量池\n\n**Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。** 为啥把缓存设置为[-128，127]区间？（[参见issue/461](https://github.com/Snailclimb/JavaGuide/issues/461)）性能和资源之间的权衡。\n\n```java\npublic static Boolean valueOf(boolean b) {\n    return (b ? TRUE : FALSE);\n}\n```\n\n```java\nprivate static class CharacterCache {         \n    private CharacterCache(){}\n          \n    static final Character cache[] = new Character[127 + 1];          \n    static {             \n        for (int i = 0; i < cache.length; i++)                 \n            cache[i] = new Character((char)i);         \n    }   \n}\n```\n\n两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。**\n\n```java\n\t\tInteger i1 = 33;\n\t\tInteger i2 = 33;\n\t\tSystem.out.println(i1 == i2);// 输出 true\n\t\tInteger i11 = 333;\n\t\tInteger i22 = 333;\n\t\tSystem.out.println(i11 == i22);// 输出 false\n\t\tDouble i3 = 1.2;\n\t\tDouble i4 = 1.2;\n\t\tSystem.out.println(i3 == i4);// 输出 false\n```\n\n**Integer 缓存源代码：**\n\n```java\n/**\n*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。\n*/\n    public static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n```\n\n**应用场景：**\n\n1. Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。\n2. Integer i1 = new Integer(40);这种情况下会创建新的对象。\n\n```java\n  Integer i1 = 40;\n  Integer i2 = new Integer(40);\n  System.out.println(i1==i2);//输出 false\n```\n\n**Integer 比较更丰富的一个例子:**\n\n```java\n  Integer i1 = 40;\n  Integer i2 = 40;\n  Integer i3 = 0;\n  Integer i4 = new Integer(40);\n  Integer i5 = new Integer(40);\n  Integer i6 = new Integer(0);\n  \n  System.out.println(\"i1=i2   \" + (i1 == i2));\n  System.out.println(\"i1=i2+i3   \" + (i1 == i2 + i3));\n  System.out.println(\"i1=i4   \" + (i1 == i4));\n  System.out.println(\"i4=i5   \" + (i4 == i5));\n  System.out.println(\"i4=i5+i6   \" + (i4 == i5 + i6));   \n  System.out.println(\"40=i5+i6   \" + (40 == i5 + i6));     \n```\n\n结果：\n\n```java\ni1=i2   true\ni1=i2+i3   true\ni1=i4   false\ni4=i5   false\ni4=i5+i6   true\n40=i5+i6   true\n```\n\n解释：\n\n语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。\n\n## 参考\n\n- 《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》\n- 《实战 java 虚拟机》\n- <https://docs.oracle.com/javase/specs/index.html>\n- <http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/>\n- <https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou>\n- <https://stackoverflow.com/questions/9095748/method-area-and-permgen>\n- 深入解析String#intern<https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html>","slug":"java/java-memory","published":1,"updated":"2020-05-26T02:52:38.015Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7m10067vgjacsmkbew1","content":"<p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p>\n<h3 id=\"基本问题\"><a href=\"#基本问题\" class=\"headerlink\" title=\"基本问题\"></a>基本问题</h3><ul>\n<li><strong>介绍下 Java 内存区域（运行时数据区）</strong></li>\n<li><strong>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</strong></li>\n<li><strong>对象的访问定位的两种方式（句柄和直接指针两种方式）</strong></li>\n</ul>\n<h3 id=\"拓展问题\"><a href=\"#拓展问题\" class=\"headerlink\" title=\"拓展问题\"></a>拓展问题</h3><ul>\n<li><strong>String 类和常量池</strong></li>\n<li><strong>8 种基本类型的包装类和常量池</strong></li>\n</ul>\n<h2 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h2><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>\n<h2 id=\"二-运行时数据区域\"><a href=\"#二-运行时数据区域\" class=\"headerlink\" title=\"二 运行时数据区域\"></a>二 运行时数据区域</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同，下面会介绍到。</p>\n<p><strong>JDK 1.8 之前：</strong></p>\n<p><img src=\"/images/java-memory.png\" alt=\"ava-memor\"></p>\n<p><strong>JDK 1.8 ：</strong></p>\n<p><img src=\"/images/java-memoryjdk8.png\" alt=\"ava-memoryjdk\"></p>\n<p><strong>线程私有的：</strong></p>\n<ul>\n<li>程序计数器</li>\n<li>虚拟机栈</li>\n<li>本地方法栈</li>\n</ul>\n<p><strong>线程共享的：</strong></p>\n<ul>\n<li>堆</li>\n<li>方法区</li>\n<li>直接内存 (非运行时数据区的一部分)</li>\n</ul>\n<h3 id=\"2-1-程序计数器\"><a href=\"#2-1-程序计数器\" class=\"headerlink\" title=\"2.1 程序计数器\"></a>2.1 程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p>\n<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>\n<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>\n<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n</ol>\n<p><strong>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>\n<h3 id=\"2-2-Java-虚拟机栈\"><a href=\"#2-2-Java-虚拟机栈\" class=\"headerlink\" title=\"2.2 Java 虚拟机栈\"></a>2.2 Java 虚拟机栈</h3><p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p>\n<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>\n<p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>\n<p><strong>Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。</strong></p>\n<ul>\n<li><strong>StackOverFlowError：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li>\n<li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。</li>\n</ul>\n<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>\n<p><strong>扩展：那么方法/函数如何调用？</strong></p>\n<p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>\n<p>Java 方法有两种返回方式：</p>\n<ol>\n<li>return 语句。</li>\n<li>抛出异常。</li>\n</ol>\n<p>不管哪种返回方式都会导致栈帧被弹出。</p>\n<h3 id=\"2-3-本地方法栈\"><a href=\"#2-3-本地方法栈\" class=\"headerlink\" title=\"2.3 本地方法栈\"></a>2.3 本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>\n<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>\n<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p>\n<h3 id=\"2-4-堆\"><a href=\"#2-4-堆\" class=\"headerlink\" title=\"2.4 堆\"></a>2.4 堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>\n<p><strong>Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p>\n<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>\n<p>在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：</p>\n<ol>\n<li>新生代内存(Young Generation)</li>\n<li>老生代(Old Generation)</li>\n<li>永生代(Permanent Generation)</li>\n</ol>\n<p><img src=\"/images/java-memory-g.jpg\" alt=\"ava-memory-\"></p>\n<p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>\n<p><img src=\"/images/java-memory-g8.jpg\" alt=\"ava-memory-g\"></p>\n<p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p>\n<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>\n<blockquote>\n<p>修正（<a href=\"https://github.com/Snailclimb/JavaGuide/issues/552\" target=\"_blank\" rel=\"noopener\">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p>\n<p><strong>动态年龄计算的代码如下</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//survivor_capacity是survivor空间的大小</span></span><br><span class=\"line\">  size_t desired_survivor_size = (size_t)((((<span class=\"keyword\">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class=\"number\">100</span>);</span><br><span class=\"line\">  size_t total = <span class=\"number\">0</span>;</span><br><span class=\"line\">  uint age = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (age &lt; table_size) &#123;</span><br><span class=\"line\">    total += sizes[age];<span class=\"comment\">//sizes数组是每个年龄段对象大小</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (total &gt; desired_survivor_size) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    age++;</span><br><span class=\"line\">  &#125;<span class=\"number\">525453625</span></span><br><span class=\"line\">  uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p>\n<ol>\n<li><strong>OutOfMemoryError: GC Overhead Limit Exceeded</strong> ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>\n<li><strong>java.lang.OutOfMemoryError: Java heap space</strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发<code>java.lang.OutOfMemoryError: Java heap space</code> 错误。(和本机物理内存无关，和你配置的内存大小有关！)</li>\n<li>……</li>\n</ol>\n<h3 id=\"2-5-方法区\"><a href=\"#2-5-方法区\" class=\"headerlink\" title=\"2.5 方法区\"></a>2.5 方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>\n<p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p>\n<h4 id=\"2-5-1-方法区和永久代的关系\"><a href=\"#2-5-1-方法区和永久代的关系\" class=\"headerlink\" title=\"2.5.1 方法区和永久代的关系\"></a>2.5.1 方法区和永久代的关系</h4><blockquote>\n<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>\n</blockquote>\n<h4 id=\"2-5-2-常用参数\"><a href=\"#2-5-2-常用参数\" class=\"headerlink\" title=\"2.5.2 常用参数\"></a>2.5.2 常用参数</h4><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:PermSize=N <span class=\"comment\">//方法区 (永久代) 初始大小</span></span><br><span class=\"line\">-XX:MaxPermSize=N <span class=\"comment\">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure>\n\n<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>\n<p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>\n<p>下面是一些常用参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:MetaspaceSize=N <span class=\"comment\">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class=\"line\">-XX:MaxMetaspaceSize=N <span class=\"comment\">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure>\n\n<p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>\n<h4 id=\"2-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢\"><a href=\"#2-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢\" class=\"headerlink\" title=\"2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?\"></a>2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h4><ol>\n<li>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li>\n</ol>\n<blockquote>\n<p>当你元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>\n</blockquote>\n<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>\n<ol>\n<li>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</li>\n<li>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</li>\n</ol>\n<h3 id=\"2-6-运行时常量池\"><a href=\"#2-6-运行时常量池\" class=\"headerlink\" title=\"2.6 运行时常量池\"></a>2.6 运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p>\n<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>\n<p><del><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></del></p>\n<blockquote>\n<p>修正(<a href=\"https://github.com/Snailclimb/JavaGuide/issues/747\" target=\"_blank\" rel=\"noopener\">issue747</a>，<a href=\"https://blog.csdn.net/q5706503/article/details/84640762\" target=\"_blank\" rel=\"noopener\">reference</a>)：</p>\n<ol>\n<li><strong>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</strong></li>\n<li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</strong> 。</li>\n<li><strong>JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li>\n</ol>\n</blockquote>\n<p>相关问题：JVM 常量池中存储的是对象还是引用呢？： <a href=\"https://www.zhihu.com/question/57109429/answer/151717241\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/57109429/answer/151717241</a> by RednaxelaFX</p>\n<h3 id=\"2-7-直接内存\"><a href=\"#2-7-直接内存\" class=\"headerlink\" title=\"2.7 直接内存\"></a>2.7 直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>\n<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>\n<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>\n<h2 id=\"三-HotSpot-虚拟机对象探秘\"><a href=\"#三-HotSpot-虚拟机对象探秘\" class=\"headerlink\" title=\"三 HotSpot 虚拟机对象探秘\"></a>三 HotSpot 虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>\n<h3 id=\"3-1-对象的创建\"><a href=\"#3-1-对象的创建\" class=\"headerlink\" title=\"3.1 对象的创建\"></a>3.1 对象的创建</h3><p>下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。</p>\n<p><img src=\"/images/java-memory-obj-create.png\" alt=\"ava-memory-obj-creat\"></p>\n<h4 id=\"Step1-类加载检查\"><a href=\"#Step1-类加载检查\" class=\"headerlink\" title=\"Step1:类加载检查\"></a>Step1:类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>\n<h4 id=\"Step2-分配内存\"><a href=\"#Step2-分配内存\" class=\"headerlink\" title=\"Step2:分配内存\"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>\n<p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p>\n<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p>\n<p><img src=\"/images/java-memory-mallock.png\" alt=\"ava-memory-malloc\"></p>\n<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>\n<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>\n<ul>\n<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>\n<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>\n</ul>\n<h4 id=\"Step3-初始化零值\"><a href=\"#Step3-初始化零值\" class=\"headerlink\" title=\"Step3:初始化零值\"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>\n<h4 id=\"Step4-设置对象头\"><a href=\"#Step4-设置对象头\" class=\"headerlink\" title=\"Step4:设置对象头\"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>\n<h4 id=\"Step5-执行-init-方法\"><a href=\"#Step5-执行-init-方法\" class=\"headerlink\" title=\"Step5:执行 init 方法\"></a>Step5:执行 init 方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>\n<h3 id=\"3-2-对象的内存布局\"><a href=\"#3-2-对象的内存布局\" class=\"headerlink\" title=\"3.2 对象的内存布局\"></a>3.2 对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>\n<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>\n<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>\n<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>\n<h3 id=\"3-3-对象的访问定位\"><a href=\"#3-3-对象的访问定位\" class=\"headerlink\" title=\"3.3 对象的访问定位\"></a>3.3 对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p>\n<ol>\n<li><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>\n</ol>\n<p><img src=\"/images/java-memory-obj-reference.png\" alt=\"ava-memory-obj-referenc\"></p>\n<ol>\n<li><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</li>\n</ol>\n<p><img src=\"/images/java-memory-obj-direct.png\" alt=\"ava-memory-obj-direc\"></p>\n<p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>\n<h2 id=\"四-重点补充内容\"><a href=\"#四-重点补充内容\" class=\"headerlink\" title=\"四 重点补充内容\"></a>四 重点补充内容</h2><h3 id=\"4-1-String-类和常量池\"><a href=\"#4-1-String-类和常量池\" class=\"headerlink\" title=\"4.1 String 类和常量池\"></a>4.1 String 类和常量池</h3><p><strong>String 对象的两种创建方式：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">\"abcd\"</span>;<span class=\"comment\">//先检查字符串常量池中有没有\"abcd\"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向\"abcd\"\"；</span></span><br><span class=\"line\">String str2 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abcd\"</span>);<span class=\"comment\">//堆中创建一个新的对象</span></span><br><span class=\"line\">String str3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abcd\"</span>);<span class=\"comment\">//堆中创建一个新的对象</span></span><br><span class=\"line\">System.out.println(str1==str2);<span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(str2==str3);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p>这两种不同的创建方法是有差别的。</p>\n<ul>\n<li>第一种方式是在常量池中拿对象；</li>\n<li>第二种方式是直接在堆内存空间创建一个新的对象。</li>\n</ul>\n<p>记住一点：<strong>只要使用 new 方法，便需要创建新的对象。</strong></p>\n<p>再给大家一个图应该更容易理解，图片来源：<a href=\"https://www.journaldev.com/797/what-is-java-string-pool\" target=\"_blank\" rel=\"noopener\">https://www.journaldev.com/797/what-is-java-string-pool</a>：</p>\n<p><img src=\"/images/java-memory-str-new.png\" alt=\"ava-memory-str-ne\"></p>\n<p><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p>\n<ul>\n<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li>\n<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"计算机\"</span>);</span><br><span class=\"line\">String s2 = s1.intern();</span><br><span class=\"line\">String s3 = <span class=\"string\">\"计算机\"</span>;</span><br><span class=\"line\">System.out.println(s2);<span class=\"comment\">//计算机</span></span><br><span class=\"line\">System.out.println(s1 == s2);<span class=\"comment\">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class=\"line\">System.out.println(s3 == s2);<span class=\"comment\">//true，因为两个都是常量池中的 String 对象</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>字符串拼接:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">\"str\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"string\">\"ing\"</span>;</span><br><span class=\"line\">\t\t </span><br><span class=\"line\">String str3 = <span class=\"string\">\"str\"</span> + <span class=\"string\">\"ing\"</span>;<span class=\"comment\">//常量池中的对象</span></span><br><span class=\"line\">String str4 = str1 + str2; <span class=\"comment\">//在堆上创建的新的对象\t  </span></span><br><span class=\"line\">String str5 = <span class=\"string\">\"string\"</span>;<span class=\"comment\">//常量池中的对象</span></span><br><span class=\"line\">System.out.println(str3 == str4);<span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(str3 == str5);<span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(str4 == str5);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/java-memory-str-constant.png\" alt=\"ava-memory-str-constan\"></p>\n<p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。</p>\n<h3 id=\"4-2-String-s1-new-String-“abc”-这句话创建了几个字符串对象？\"><a href=\"#4-2-String-s1-new-String-“abc”-这句话创建了几个字符串对象？\" class=\"headerlink\" title=\"4.2 String s1 = new String(“abc”);这句话创建了几个字符串对象？\"></a>4.2 String s1 = new String(“abc”);这句话创建了几个字符串对象？</h3><p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</strong></p>\n<p><strong>验证：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);<span class=\"comment\">// 堆内存的地址值</span></span><br><span class=\"line\">String s2 = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">System.out.println(s1 == s2);<span class=\"comment\">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span></span><br><span class=\"line\">System.out.println(s1.equals(s2));<span class=\"comment\">// 输出 true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">false</span></span><br><span class=\"line\"><span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-8-种基本类型的包装类和常量池\"><a href=\"#4-3-8-种基本类型的包装类和常量池\" class=\"headerlink\" title=\"4.3 8 种基本类型的包装类和常量池\"></a>4.3 8 种基本类型的包装类和常量池</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。</strong> 为啥把缓存设置为[-128，127]区间？（<a href=\"https://github.com/Snailclimb/JavaGuide/issues/461\" target=\"_blank\" rel=\"noopener\">参见issue/461</a>）性能和资源之间的权衡。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Boolean <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (b ? TRUE : FALSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CharacterCache</span> </span>&#123;         </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">CharacterCache</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">          </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Character cache[] = <span class=\"keyword\">new</span> Character[<span class=\"number\">127</span> + <span class=\"number\">1</span>];          </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;             </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cache.length; i++)                 </span><br><span class=\"line\">            cache[i] = <span class=\"keyword\">new</span> Character((<span class=\"keyword\">char</span>)i);         </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。**</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">33</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">33</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);<span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">Integer i11 = <span class=\"number\">333</span>;</span><br><span class=\"line\">Integer i22 = <span class=\"number\">333</span>;</span><br><span class=\"line\">System.out.println(i11 == i22);<span class=\"comment\">// 输出 false</span></span><br><span class=\"line\">Double i3 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">Double i4 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">System.out.println(i3 == i4);<span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Integer 缓存源代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Integer(i);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>应用场景：</strong></p>\n<ol>\n<li>Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</li>\n<li>Integer i1 = new Integer(40);这种情况下会创建新的对象。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">40</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">40</span>);</span><br><span class=\"line\">System.out.println(i1==i2);<span class=\"comment\">//输出 false</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Integer 比较更丰富的一个例子:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">40</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">40</span>;</span><br><span class=\"line\">Integer i3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">Integer i4 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">40</span>);</span><br><span class=\"line\">Integer i5 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">40</span>);</span><br><span class=\"line\">Integer i6 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"i1=i2   \"</span> + (i1 == i2));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"i1=i2+i3   \"</span> + (i1 == i2 + i3));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"i1=i4   \"</span> + (i1 == i4));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"i4=i5   \"</span> + (i4 == i5));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"i4=i5+i6   \"</span> + (i4 == i5 + i6));   </span><br><span class=\"line\">System.out.println(<span class=\"string\">\"40=i5+i6   \"</span> + (<span class=\"number\">40</span> == i5 + i6));</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i1=i2   <span class=\"keyword\">true</span></span><br><span class=\"line\">i1=i2+i3   <span class=\"keyword\">true</span></span><br><span class=\"line\">i1=i4   <span class=\"keyword\">false</span></span><br><span class=\"line\">i4=i5   <span class=\"keyword\">false</span></span><br><span class=\"line\">i4=i5+i6   <span class=\"keyword\">true</span></span><br><span class=\"line\"><span class=\"number\">40</span>=i5+i6   <span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：</p>\n<p>语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li>\n<li>《实战 java 虚拟机》</li>\n<li><a href=\"https://docs.oracle.com/javase/specs/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/specs/index.html</a></li>\n<li><a href=\"http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/\" target=\"_blank\" rel=\"noopener\">http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/</a></li>\n<li><a href=\"https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou\" target=\"_blank\" rel=\"noopener\">https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou</a></li>\n<li><a href=\"https://stackoverflow.com/questions/9095748/method-area-and-permgen\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/9095748/method-area-and-permgen</a></li>\n<li>深入解析String#intern<a href=\"https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html\" target=\"_blank\" rel=\"noopener\">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p>\n<h3 id=\"基本问题\"><a href=\"#基本问题\" class=\"headerlink\" title=\"基本问题\"></a>基本问题</h3><ul>\n<li><strong>介绍下 Java 内存区域（运行时数据区）</strong></li>\n<li><strong>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</strong></li>\n<li><strong>对象的访问定位的两种方式（句柄和直接指针两种方式）</strong></li>\n</ul>\n<h3 id=\"拓展问题\"><a href=\"#拓展问题\" class=\"headerlink\" title=\"拓展问题\"></a>拓展问题</h3><ul>\n<li><strong>String 类和常量池</strong></li>\n<li><strong>8 种基本类型的包装类和常量池</strong></li>\n</ul>\n<h2 id=\"一-概述\"><a href=\"#一-概述\" class=\"headerlink\" title=\"一 概述\"></a>一 概述</h2><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>\n<h2 id=\"二-运行时数据区域\"><a href=\"#二-运行时数据区域\" class=\"headerlink\" title=\"二 运行时数据区域\"></a>二 运行时数据区域</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同，下面会介绍到。</p>\n<p><strong>JDK 1.8 之前：</strong></p>\n<p><img src=\"/images/java-memory.png\" alt=\"ava-memor\"></p>\n<p><strong>JDK 1.8 ：</strong></p>\n<p><img src=\"/images/java-memoryjdk8.png\" alt=\"ava-memoryjdk\"></p>\n<p><strong>线程私有的：</strong></p>\n<ul>\n<li>程序计数器</li>\n<li>虚拟机栈</li>\n<li>本地方法栈</li>\n</ul>\n<p><strong>线程共享的：</strong></p>\n<ul>\n<li>堆</li>\n<li>方法区</li>\n<li>直接内存 (非运行时数据区的一部分)</li>\n</ul>\n<h3 id=\"2-1-程序计数器\"><a href=\"#2-1-程序计数器\" class=\"headerlink\" title=\"2.1 程序计数器\"></a>2.1 程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p>\n<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>\n<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>\n<ol>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>\n<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>\n</ol>\n<p><strong>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>\n<h3 id=\"2-2-Java-虚拟机栈\"><a href=\"#2-2-Java-虚拟机栈\" class=\"headerlink\" title=\"2.2 Java 虚拟机栈\"></a>2.2 Java 虚拟机栈</h3><p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p>\n<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>\n<p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>\n<p><strong>Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。</strong></p>\n<ul>\n<li><strong>StackOverFlowError：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li>\n<li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。</li>\n</ul>\n<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>\n<p><strong>扩展：那么方法/函数如何调用？</strong></p>\n<p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>\n<p>Java 方法有两种返回方式：</p>\n<ol>\n<li>return 语句。</li>\n<li>抛出异常。</li>\n</ol>\n<p>不管哪种返回方式都会导致栈帧被弹出。</p>\n<h3 id=\"2-3-本地方法栈\"><a href=\"#2-3-本地方法栈\" class=\"headerlink\" title=\"2.3 本地方法栈\"></a>2.3 本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>\n<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>\n<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p>\n<h3 id=\"2-4-堆\"><a href=\"#2-4-堆\" class=\"headerlink\" title=\"2.4 堆\"></a>2.4 堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>\n<p><strong>Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p>\n<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>\n<p>在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：</p>\n<ol>\n<li>新生代内存(Young Generation)</li>\n<li>老生代(Old Generation)</li>\n<li>永生代(Permanent Generation)</li>\n</ol>\n<p><img src=\"/images/java-memory-g.jpg\" alt=\"ava-memory-\"></p>\n<p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>\n<p><img src=\"/images/java-memory-g8.jpg\" alt=\"ava-memory-g\"></p>\n<p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p>\n<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>\n<blockquote>\n<p>修正（<a href=\"https://github.com/Snailclimb/JavaGuide/issues/552\" target=\"_blank\" rel=\"noopener\">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p>\n<p><strong>动态年龄计算的代码如下</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//survivor_capacity是survivor空间的大小</span></span><br><span class=\"line\">  size_t desired_survivor_size = (size_t)((((<span class=\"keyword\">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class=\"number\">100</span>);</span><br><span class=\"line\">  size_t total = <span class=\"number\">0</span>;</span><br><span class=\"line\">  uint age = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (age &lt; table_size) &#123;</span><br><span class=\"line\">    total += sizes[age];<span class=\"comment\">//sizes数组是每个年龄段对象大小</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (total &gt; desired_survivor_size) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    age++;</span><br><span class=\"line\">  &#125;<span class=\"number\">525453625</span></span><br><span class=\"line\">  uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p>\n<ol>\n<li><strong>OutOfMemoryError: GC Overhead Limit Exceeded</strong> ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>\n<li><strong>java.lang.OutOfMemoryError: Java heap space</strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发<code>java.lang.OutOfMemoryError: Java heap space</code> 错误。(和本机物理内存无关，和你配置的内存大小有关！)</li>\n<li>……</li>\n</ol>\n<h3 id=\"2-5-方法区\"><a href=\"#2-5-方法区\" class=\"headerlink\" title=\"2.5 方法区\"></a>2.5 方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>\n<p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p>\n<h4 id=\"2-5-1-方法区和永久代的关系\"><a href=\"#2-5-1-方法区和永久代的关系\" class=\"headerlink\" title=\"2.5.1 方法区和永久代的关系\"></a>2.5.1 方法区和永久代的关系</h4><blockquote>\n<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>\n</blockquote>\n<h4 id=\"2-5-2-常用参数\"><a href=\"#2-5-2-常用参数\" class=\"headerlink\" title=\"2.5.2 常用参数\"></a>2.5.2 常用参数</h4><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:PermSize=N <span class=\"comment\">//方法区 (永久代) 初始大小</span></span><br><span class=\"line\">-XX:MaxPermSize=N <span class=\"comment\">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure>\n\n<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>\n<p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>\n<p>下面是一些常用参数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:MetaspaceSize=N <span class=\"comment\">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class=\"line\">-XX:MaxMetaspaceSize=N <span class=\"comment\">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure>\n\n<p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>\n<h4 id=\"2-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢\"><a href=\"#2-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢\" class=\"headerlink\" title=\"2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?\"></a>2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h4><ol>\n<li>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</li>\n</ol>\n<blockquote>\n<p>当你元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>\n</blockquote>\n<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>\n<ol>\n<li>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</li>\n<li>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</li>\n</ol>\n<h3 id=\"2-6-运行时常量池\"><a href=\"#2-6-运行时常量池\" class=\"headerlink\" title=\"2.6 运行时常量池\"></a>2.6 运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p>\n<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>\n<p><del><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></del></p>\n<blockquote>\n<p>修正(<a href=\"https://github.com/Snailclimb/JavaGuide/issues/747\" target=\"_blank\" rel=\"noopener\">issue747</a>，<a href=\"https://blog.csdn.net/q5706503/article/details/84640762\" target=\"_blank\" rel=\"noopener\">reference</a>)：</p>\n<ol>\n<li><strong>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</strong></li>\n<li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</strong> 。</li>\n<li><strong>JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li>\n</ol>\n</blockquote>\n<p>相关问题：JVM 常量池中存储的是对象还是引用呢？： <a href=\"https://www.zhihu.com/question/57109429/answer/151717241\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/57109429/answer/151717241</a> by RednaxelaFX</p>\n<h3 id=\"2-7-直接内存\"><a href=\"#2-7-直接内存\" class=\"headerlink\" title=\"2.7 直接内存\"></a>2.7 直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>\n<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p>\n<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>\n<h2 id=\"三-HotSpot-虚拟机对象探秘\"><a href=\"#三-HotSpot-虚拟机对象探秘\" class=\"headerlink\" title=\"三 HotSpot 虚拟机对象探秘\"></a>三 HotSpot 虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>\n<h3 id=\"3-1-对象的创建\"><a href=\"#3-1-对象的创建\" class=\"headerlink\" title=\"3.1 对象的创建\"></a>3.1 对象的创建</h3><p>下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。</p>\n<p><img src=\"/images/java-memory-obj-create.png\" alt=\"ava-memory-obj-creat\"></p>\n<h4 id=\"Step1-类加载检查\"><a href=\"#Step1-类加载检查\" class=\"headerlink\" title=\"Step1:类加载检查\"></a>Step1:类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>\n<h4 id=\"Step2-分配内存\"><a href=\"#Step2-分配内存\" class=\"headerlink\" title=\"Step2:分配内存\"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>\n<p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p>\n<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p>\n<p><img src=\"/images/java-memory-mallock.png\" alt=\"ava-memory-malloc\"></p>\n<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>\n<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>\n<ul>\n<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>\n<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>\n</ul>\n<h4 id=\"Step3-初始化零值\"><a href=\"#Step3-初始化零值\" class=\"headerlink\" title=\"Step3:初始化零值\"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>\n<h4 id=\"Step4-设置对象头\"><a href=\"#Step4-设置对象头\" class=\"headerlink\" title=\"Step4:设置对象头\"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>\n<h4 id=\"Step5-执行-init-方法\"><a href=\"#Step5-执行-init-方法\" class=\"headerlink\" title=\"Step5:执行 init 方法\"></a>Step5:执行 init 方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>\n<h3 id=\"3-2-对象的内存布局\"><a href=\"#3-2-对象的内存布局\" class=\"headerlink\" title=\"3.2 对象的内存布局\"></a>3.2 对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>\n<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>\n<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>\n<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>\n<h3 id=\"3-3-对象的访问定位\"><a href=\"#3-3-对象的访问定位\" class=\"headerlink\" title=\"3.3 对象的访问定位\"></a>3.3 对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p>\n<ol>\n<li><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>\n</ol>\n<p><img src=\"/images/java-memory-obj-reference.png\" alt=\"ava-memory-obj-referenc\"></p>\n<ol>\n<li><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</li>\n</ol>\n<p><img src=\"/images/java-memory-obj-direct.png\" alt=\"ava-memory-obj-direc\"></p>\n<p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>\n<h2 id=\"四-重点补充内容\"><a href=\"#四-重点补充内容\" class=\"headerlink\" title=\"四 重点补充内容\"></a>四 重点补充内容</h2><h3 id=\"4-1-String-类和常量池\"><a href=\"#4-1-String-类和常量池\" class=\"headerlink\" title=\"4.1 String 类和常量池\"></a>4.1 String 类和常量池</h3><p><strong>String 对象的两种创建方式：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">\"abcd\"</span>;<span class=\"comment\">//先检查字符串常量池中有没有\"abcd\"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向\"abcd\"\"；</span></span><br><span class=\"line\">String str2 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abcd\"</span>);<span class=\"comment\">//堆中创建一个新的对象</span></span><br><span class=\"line\">String str3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abcd\"</span>);<span class=\"comment\">//堆中创建一个新的对象</span></span><br><span class=\"line\">System.out.println(str1==str2);<span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(str2==str3);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p>这两种不同的创建方法是有差别的。</p>\n<ul>\n<li>第一种方式是在常量池中拿对象；</li>\n<li>第二种方式是直接在堆内存空间创建一个新的对象。</li>\n</ul>\n<p>记住一点：<strong>只要使用 new 方法，便需要创建新的对象。</strong></p>\n<p>再给大家一个图应该更容易理解，图片来源：<a href=\"https://www.journaldev.com/797/what-is-java-string-pool\" target=\"_blank\" rel=\"noopener\">https://www.journaldev.com/797/what-is-java-string-pool</a>：</p>\n<p><img src=\"/images/java-memory-str-new.png\" alt=\"ava-memory-str-ne\"></p>\n<p><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p>\n<ul>\n<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li>\n<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"计算机\"</span>);</span><br><span class=\"line\">String s2 = s1.intern();</span><br><span class=\"line\">String s3 = <span class=\"string\">\"计算机\"</span>;</span><br><span class=\"line\">System.out.println(s2);<span class=\"comment\">//计算机</span></span><br><span class=\"line\">System.out.println(s1 == s2);<span class=\"comment\">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class=\"line\">System.out.println(s3 == s2);<span class=\"comment\">//true，因为两个都是常量池中的 String 对象</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>字符串拼接:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">\"str\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"string\">\"ing\"</span>;</span><br><span class=\"line\">\t\t </span><br><span class=\"line\">String str3 = <span class=\"string\">\"str\"</span> + <span class=\"string\">\"ing\"</span>;<span class=\"comment\">//常量池中的对象</span></span><br><span class=\"line\">String str4 = str1 + str2; <span class=\"comment\">//在堆上创建的新的对象\t  </span></span><br><span class=\"line\">String str5 = <span class=\"string\">\"string\"</span>;<span class=\"comment\">//常量池中的对象</span></span><br><span class=\"line\">System.out.println(str3 == str4);<span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(str3 == str5);<span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(str4 == str5);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/java-memory-str-constant.png\" alt=\"ava-memory-str-constan\"></p>\n<p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。</p>\n<h3 id=\"4-2-String-s1-new-String-“abc”-这句话创建了几个字符串对象？\"><a href=\"#4-2-String-s1-new-String-“abc”-这句话创建了几个字符串对象？\" class=\"headerlink\" title=\"4.2 String s1 = new String(“abc”);这句话创建了几个字符串对象？\"></a>4.2 String s1 = new String(“abc”);这句话创建了几个字符串对象？</h3><p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</strong></p>\n<p><strong>验证：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);<span class=\"comment\">// 堆内存的地址值</span></span><br><span class=\"line\">String s2 = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">System.out.println(s1 == s2);<span class=\"comment\">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span></span><br><span class=\"line\">System.out.println(s1.equals(s2));<span class=\"comment\">// 输出 true</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">false</span></span><br><span class=\"line\"><span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-8-种基本类型的包装类和常量池\"><a href=\"#4-3-8-种基本类型的包装类和常量池\" class=\"headerlink\" title=\"4.3 8 种基本类型的包装类和常量池\"></a>4.3 8 种基本类型的包装类和常量池</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。</strong> 为啥把缓存设置为[-128，127]区间？（<a href=\"https://github.com/Snailclimb/JavaGuide/issues/461\" target=\"_blank\" rel=\"noopener\">参见issue/461</a>）性能和资源之间的权衡。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Boolean <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">boolean</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (b ? TRUE : FALSE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CharacterCache</span> </span>&#123;         </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">CharacterCache</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">          </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Character cache[] = <span class=\"keyword\">new</span> Character[<span class=\"number\">127</span> + <span class=\"number\">1</span>];          </span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;             </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; cache.length; i++)                 </span><br><span class=\"line\">            cache[i] = <span class=\"keyword\">new</span> Character((<span class=\"keyword\">char</span>)i);         </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。**</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">33</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">33</span>;</span><br><span class=\"line\">System.out.println(i1 == i2);<span class=\"comment\">// 输出 true</span></span><br><span class=\"line\">Integer i11 = <span class=\"number\">333</span>;</span><br><span class=\"line\">Integer i22 = <span class=\"number\">333</span>;</span><br><span class=\"line\">System.out.println(i11 == i22);<span class=\"comment\">// 输出 false</span></span><br><span class=\"line\">Double i3 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">Double i4 = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">System.out.println(i3 == i4);<span class=\"comment\">// 输出 false</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Integer 缓存源代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Integer(i);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>应用场景：</strong></p>\n<ol>\n<li>Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</li>\n<li>Integer i1 = new Integer(40);这种情况下会创建新的对象。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">40</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">40</span>);</span><br><span class=\"line\">System.out.println(i1==i2);<span class=\"comment\">//输出 false</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Integer 比较更丰富的一个例子:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer i1 = <span class=\"number\">40</span>;</span><br><span class=\"line\">Integer i2 = <span class=\"number\">40</span>;</span><br><span class=\"line\">Integer i3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">Integer i4 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">40</span>);</span><br><span class=\"line\">Integer i5 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">40</span>);</span><br><span class=\"line\">Integer i6 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"i1=i2   \"</span> + (i1 == i2));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"i1=i2+i3   \"</span> + (i1 == i2 + i3));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"i1=i4   \"</span> + (i1 == i4));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"i4=i5   \"</span> + (i4 == i5));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"i4=i5+i6   \"</span> + (i4 == i5 + i6));   </span><br><span class=\"line\">System.out.println(<span class=\"string\">\"40=i5+i6   \"</span> + (<span class=\"number\">40</span> == i5 + i6));</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i1=i2   <span class=\"keyword\">true</span></span><br><span class=\"line\">i1=i2+i3   <span class=\"keyword\">true</span></span><br><span class=\"line\">i1=i4   <span class=\"keyword\">false</span></span><br><span class=\"line\">i4=i5   <span class=\"keyword\">false</span></span><br><span class=\"line\">i4=i5+i6   <span class=\"keyword\">true</span></span><br><span class=\"line\"><span class=\"number\">40</span>=i5+i6   <span class=\"keyword\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>解释：</p>\n<p>语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li>\n<li>《实战 java 虚拟机》</li>\n<li><a href=\"https://docs.oracle.com/javase/specs/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/specs/index.html</a></li>\n<li><a href=\"http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/\" target=\"_blank\" rel=\"noopener\">http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/</a></li>\n<li><a href=\"https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou\" target=\"_blank\" rel=\"noopener\">https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou</a></li>\n<li><a href=\"https://stackoverflow.com/questions/9095748/method-area-and-permgen\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/9095748/method-area-and-permgen</a></li>\n<li>深入解析String#intern<a href=\"https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html\" target=\"_blank\" rel=\"noopener\">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></li>\n</ul>\n"},{"title":"\\[转\\]Mysql分库分表方案","date":"2020-06-04T08:05:46.000Z","_content":"**一、分库分表背景**\n\n1. 为什么分库\n\n1.1数据库最容易产生性能瓶颈的服务组件。数据库连接数资源捉襟见肘和数据库因为表多、数据多造成的性能问题。这里以淘宝为例，在淘宝平台向共享服务体系改造的过程中，通过各个服务中心拥有各自独立数据库的方式，即采用数据库垂直分区的方式对业务数据进行分区。\n\n1.2单一服务中心的数据访问压力也必然会达到单机数据库的承载上限，所以在进行服务化改造的同一时间段内，需要对数据库能力做扩展的工作。\n\n1.3.单台数据库 这里以mysql为例，mysql数据库，当访问连接数过多时，就会出现‘too many connections’的错误，一般来说是访问量太大或者数据库设置的最大连接数太小的原因。Mysql默认的最大连接数为100.这个连接连接数可以修改，而mysql服务允许的最大连接数为16384.虽然可以通过连接池可以一定程序上优化连接，但是当数据量过大时，单台数据库显示已经不能支撑应用服务器的访问。所以就需要做分库，具体分库方法下面会有详细介绍。\n\n1.4 在实际的应用中，绝大部分情况都是读远大于写。Mysql提供了读写分离的机制，所有的写操作都必须对应到Master，读操作可以在 Master和Slave机器上进行，Slave与Master的结构完全一样，一个Master可以有多个Slave,甚至Slave下还可以挂 Slave,通过此方式可以有效的提高DB集群的 QPS.\n\n所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。\n\n此外，可以看出Master是集群的瓶颈，当写操作过多，会严重影响到Master的稳定性，如果Master挂掉，整个集群都将不能正常工作。\n\n所以\n\n\\1. 当读压力很大的时候，可以考虑添加Slave机器的分式解决，但是当Slave机器达到一定的数量就得考虑分库了。\n\n\\2. 当写压力很大的时候，就必须得进行分库操作。\n\n2.为什么分表\n\n有一组数据可以参考：\n\n基本指标:\n\n库物理文件大小<100G\n\n表<100\n\n字段<200\n\n单表记录数<500W\n\n经测试在单表1000万条记录一下,写入读取性能是比较好的. 这样在留点buffer,那么单表全是数字类型的保持在800万条记录以下, 有字符型的单表保持在500万以下.如果按 100库100表来规划,如用户业务:\n\n500万*100*100 = 50000000万 = 5000亿记录.供参考,具体按按业务做规划.\n\n3.什么是分区\n\n分表是将一张表分成N多个小表，分区是把一张表的数据分成N多个区块，这些区块可以在同一个磁盘上，也可以在不同的磁盘上。mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件，一个.MYD数据文件，.MYI索引文件，.frm表结构文件。\n\n**二、现状**\n\n2.1淘宝的解决方案\n\n首先是实施的是数据库的读写分离。读写分离的基本原理是让主数据库处理事务性增、改、删（Insert、update、delete）操作，而从数据库专门负责处理查询（select）操作，在数据库的后台会把事务性操作导致的主数据库中的数据变更同步到集群中的从数据库。\n\n![img](/images/v2-cdca1f51c4a3bef0b30221a947144bdd_720w.jpg)\n\n采用读写分离的方式，拓展了数据库对数据读的处理能力，整体上也大大提升了数据库的读写能力。但是这样的架构在主数据库的数据写入能力依然没法扩展，一旦数据库写压力比较大时，则对整个平台带来非常大的影响。而且数据库单表的数据量是有限制的，当单表数据量达到一定数量后数据库性能会出现显著下降的情况，所以简单的读写分离不能满足淘宝的发展的要求。\n\n为了更好的在数据库层面支持好淘宝的业务，在2008年，阿里巴巴内部开始了分布式数据库的研发工作，相关的平台和工具陆续登上了淘宝技术发展史的历史舞台。\n\n2006年阿里巴巴以开源的形式研发了Cobar这一关系型数据库的分布式处理系统。当时Cobar平均每天处理近50亿次的SQL操作，但是随着阿里巴巴业务场景越来越复杂，有以下缺点：\n\n1. 不支持跨库情况下的连接、分页、排序、子查询\n2. SET语句执行会被忽略，处理事务和字符集设置除外。\n3. 分库情况下，insert语句必须包含拆分字段列名\n4. 分库情况下，update语句不能更新拆分字段的值\n5. 不支持SAVEPOINT操作\n6. 使用JBDC时，不支持rewriteBatchStatements = true参数设置\n\n等\n\n2008年内部 在Cobar的基础上重新研发了分布式数据层框架TDDL（外号头都大了）\n\n![img](/images/v2-9f56d1d058e3a87a8c6be5b58696f14b_720w.jpg)\n\n![img](/images/v2-c526027f5f2dae54753239d5d9bd277b_720w.jpg)\n\nTDDL提供了以下优点：\n\n1. 数据库主备和动态切换\n2. 带权重的读写分离\n3. 单线程读重试\n4. 集中式数据源信息管理和动态变更\n5. 支持MySQL和Oracle数据库\n6. 基于JDBC规范，很容易扩展支持实现JDBC规范的数据源\n7. 无Server、client-jar形式存在，应用直连数据库\n8. 读写次数，并发度流程控制，动态变更\n9. 可分析的日志打印，日志流控，动态变更。\n\n阿里巴巴分库分表的几个原则：\n\n1. 数据尽可能的平均拆分\n2. 尽可能的减少事务边界 所谓的事务边界 指单个SQL语句在后端数据库上同时执行的数量。因为事务边界越大，系统的锁冲突概率就越高，系统越难以扩展，整体性能越低。\n3. 异构索引表尽量降低全表扫描频率 这个是针对假如数据是按订单id进行分拆，当用户想查看自己的订单时，针对这种场景，常采用异构索引表来解决，即采用异步机制将原表内的每一次创建或更新，都换另一个维度保存一份完整的数据表或索引表。本质上这是互联网公司很多时候采用的一个解决思路：拿空间换时间 。\n\n![img](/images/v2-60336a35f872a24562326304943292b9_720w.jpg)\n\n实现异构索引的方式，也就是阿里巴巴内部目前采用的方式 ，通过一填名为精卫填海的产品实现了数据的异构复制。\n\n1. 将多条件频繁查询引入搜索引擎平台 比如Iucene、Solr、ElasticSearch等搜索引擎。\n\n总结\n\n从系统的风险的角度考虑，以82法则，在实际中，我们仅针对那些在80%情况下访问的那20%的场景进行如数据异构索引这样的处理，达到这类场景的性能最优化，而以其他80%偶尔出现跨库join、全表扫描的场景，采用最为简单直接的方式往往是最有效的方式。\n\n2.2美团的解决方案\n\n通常有两种方案。第一种方案是直接对现有的商品库进行垂直拆分，可以缓解目前写峰值QPS过大、DB主从延迟的问题。第二种方案是对现有的商品库大表进行分库分表，从根本上解决现有问题。方案一实施起来周期较短，但只能解决一时之痛，由此可见，分库分表是必然的。\n\n在确定分库分表的方案之后，调研了外卖订单、结算以及主站等业务的分库分表实现方案，也调研了业界很多分库分表中间件。在综合考虑性能、稳定性及实现成本的前提下，最终决定自主研发客户端分库分表中间件MTDDL来支撑外卖商品分库分表项目，这也就是MTDDL的由来。\n\n在MTDDL的设计研发过程中，我们充分考虑了MTDDL的通用性、可扩展性、功能的全面性和接入的便利性。到目前为止一共开发了四期，实现了MySQL动态数据源、读写分离、分布式唯一主键生成器、分库分表、连接池及SQL监控、动态化配置等一系列功能，支持分库分表算法、分布式唯一主键生成算法的高可扩展性，而且支持全注解的方式接入，业务方不需要引入任何配置文件。\n\n![img](/images/v2-ddda0732607e2bcb365960c675e0dc71_720w.jpg)\n\n分布式唯一主键生成器\n\n众所周知，分库分表首先要解决的就是分布式唯一主键的问题，业界也有很多相关方案（大众点评用的是时间戳+用户标识码+随机数）：\n\n![img](/images/v2-c52ddb056dbd39595e7c6f5b2c4fb3b5_720w.jpg)\n\n综上，方案3的缺点可以通过一些手段避免，但其他方案的缺点不好处理，所以选择第3种方案。目前该方案已由美团点评技术工程部实现——分布式ID生成系统Leaf，MTDDL集成了此功能。\n\n美团分库分表流程\n\n![img](/images/v2-94c4670cb6b6099055a5146f1a034b9b_720w.jpg)\n\n分库分表取模算法：\n\n分库分表目前默认使用的是取模算法，分表算法为 (#shard_key % (group_shard_num * table_shard_num))，分库算法为 (#shard_key % (group_shard_num * table_shard_num)) / table_shard_num，其中group_shard_num为分库个数，table_shard_num为每个库的分表个数。\n\n例如把一张大表分成100张小表然后散到2个库，则0-49落在第一个库、50-99落在第二个库。核心实现如下：\n\n![img](/images/v2-73c1d9300839c0ee560c9bfcc685d653_720w.jpg)\n\n大众点评订单表早已超过200G，由于查询维度较多，即使加了两个从库，优化索引，仍然存在很多查询不理想的情况。\n\n先对订单库进行垂直切分，将原有的订单库分为基础订单库、订单流程库等。\n\n![img](/images/v2-432781b10f8582f5bf192e1a050e99a1_720w.jpg)\n\n垂直切分缓解了原来单集群的压力，但是在抢购时仍然捉襟见肘。原有的订单模型已经无法满足业务需求，于是我们设计了一套新的统一订单模型，为同时满足C端用户、B端商户、客服、运营等的需求，我们分别通过用户ID和商户ID进行切分，并通过PUMA（我们内部开发的MySQL binlog实时解析服务）同步到一个运营库。\n\n![img](/images/v2-373b769b0466f324fd0553f5074d1b37_720w.jpg)\n\n切分策略\n\n1. 查询切分\n\n将ID和库的Mapping关系记录在一个单独的库中。\n\n![img](/images/v2-eb03c274f799a5147abc23bb99a56b4c_720w.jpg)\n\n优点：ID和库的Mapping算法可以随意更改\n\n缺点：引入额外的单点\n\n1. 范围切分\n\n比如按照时间区间或ID区间来切分\n\n![img](/images/v2-b8854e3034ce49c2f8d652394c2328ac_720w.jpg)\n\n优点：单表大小可控，天然水平扩展\n\n缺点：无法解决集中写入瓶颈的问题\n\n1. hash切分\n\n一般采用Mod来切分，下面着重讲一下Mod的策略\n\n![img](/images/v2-104267f964da011318238d357f05bb6c_720w.jpg)\n\n数据水平切分后我们希望是一劳永逸或者易于水平扩展的，所以推荐mod2^n这种一致性Hash\n\n以统一订单库为例，我们分库分表的方案是32*32的，即通过UserId后四位mod32到32个库中，同时再将UserId后四位Div 32 Mod 32将每个库分为32个表，共计分为1024个表。线上部署情况为8个集群（主从），每个集群4个库。为什么说这种方式易于水平扩展呢？\n\n分析两种场景。\n\n场景一：数据库性能达到瓶颈\n\n方法一\n\n按照现有规则不变，可以直接扩展到32个数据库集群。\n\n![img](/images/v2-65d90f64aa52be10b9bdc1b8042e9e31_720w.jpg)\n\n方法二\n\n如果32个集群也无法满足需求，那么将分库分表规则调整为（32*2^n）*(32/2^n)可以达到最多1024个集群。\n\n场景二：单表容量达瓶颈（或者1024已经无法满足）\n\n方法：\n\n![img](/images/v2-c431ecdd67246b4e7745d58155d4e64d_720w.jpg)\n\n假如单表都已突破200G,200*1024=200T（按照现有的订单模型算了算，大概1000万亿订单），32*（32*2^n），这时分库规则不变，单库里的表再进行裂变，当然目前的订单规则下（userId后四位mod）还是有极限的。因为只有四位，所以最多拆8192个表。\n\n唯一ID方案\n\n这个方案也有很多种，主流的有那么几种：\n\n1. 利用数据库自增ID\n\n优点：最简单。缺点：单点风险，单机性能瓶颈。\n\n\\2. 利用数据库集群并设置相应的步长（Flickr方案）\n\n优点：高可用、ID较简洁。 缺点：需要单独的数据库集群。\n\n\\3. Twitter Snowflake\n\n优点：高性能高可用、易拓展。 缺点：需要独立的集群以及ZK。\n\n\\4. 一大波GUID、Random算法\n\n优点：简单。 缺点：生成ID较长，有重复几率。\n\n美团的方案：为了减少运营成本并减少额外的风险，排除了所有需要独立集群的方案，采用带有业务属性的议案： 时间戳+用户标识码+随机数\n\n有以下几个好处：\n\n1.方便、成本低。\n\n2.基本无重复的可能。\n\n3.自带分库规则，这里的用户标识码即为用户ID的后四位，在查询的场景下，只需要订单号就可以匹配到相应的库表而无需用户ID，只取四位是希望订单号尽可能的短一些，并且评估下来四位已经足够。\n\n4.可排序，因为时间戳在最前面。\n\n其他问题\n\n事务支持：我们是将整个订单领域聚合体切分，维度一致，所以对聚合体的事务是支持的。\n\n复杂查询：垂直切分后，就跟join说拜拜了；水平切分后，查询的条件一定要在切分的维度内，比如查询具体某个用户下的各位订单等；禁止不带切分的维度的查询，即使中间件可以支持这种查询，可以在内存中组装，但是这种需求往往不应该在在线库查询，或者可以通过其他方法转换到切分的维度来实现。\n\n数据迁移\n\n数据库拆分一般是业务发展到一定规模之后的优化和重构，为了支持业务快速上线，很难一开始就分库分表，垂直拆分还好办，改改数据源就搞定了，一旦开始水平拆分，数据清洗是一个大问题。为此，经历了以下几个阶段。\n\n第一阶段：\n\n![img](/images/v2-73771a9cec11fc86e5aa0145885b05c8_720w.jpg)\n\n数据库双写（事务成功以老模型为准），查询走老模型\n\n每日job数据对账（通过DW），并将差异补平\n\n通过job导历史数据\n\n第二阶段\n\n![img](/images/v2-86d44b4b844c130414c4653f215ec149_720w.jpg)\n\n历史数据导入完毕并且数据对账无误\n\n依然是数据库双写，但是事务成功与否以新模型为准，在线查询切换新模型\n\n每日job数据对账，将差异补平\n\n第三阶段\n\n![img](/images/v2-fe9119746d34b5396e48eac6ecd16746_720w.jpg)\n\n老模型不同同步写入，仅当订单有终态时才会异步补上。\n\n此阶段只有离线数据依然依赖老的模型，并且下游的依赖非常多，待DW改造完就可以完全废除老模型了。\n\n总结\n\n1.并非所有表都需要水平拆分，要看增长的类型和速度，水平拆分是大招，拆分后会增加开发的复杂度，不到万不得已不使用。\n\n2.在大规模并发的业务上，尽量做到在线查询和离线查询隔离，交易查询和运营/客服查询隔离。\n\n3.拆分维度的选择很重要，要尽可能在解决拆分前问题的基础上，便于开发。\n\n4.数据库没你想象的那么坚强，需要保护，尽量使用简单的、良好索引的查询，这样数据库整体可控，也易于长期容量规划以及水平扩展。\n\n**三、分库方案**\n\n3.1垂直切分\n\n按业务切分，将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如用户相关、教务相关、cc业务相关、报表相关等。\n\n3.2水平切分\n\n当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如userID散列，进行划分，然后存储到多个结构相同的表，和不同的库上。例如，我们的userDB中的用户数据表中，每一个表的数据量都很大，就可以把userDB切分为结构相同的多个userDB：part0DB、part1DB等，再将userDB上的用户数据表userTable，切分为很多userTable：userTable0、userTable1等，然后将这些表按照一定的规则存储到多个userDB上。\n\n3.3切分的选择\n\n应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。\n\n如果数据库是因为表太多而造成海量数据，并且项目的各项业务逻辑划分清晰、低耦合，那么规则简单明了、容易实施的垂直切分必是首选。而如果数据库中的表并不多，但单表的数据量很大、或数据热度很高，这种情况之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估，考虑数据平均和负载平均，后期也将对项目人员及应用程序产生额外的数据管理负担。\n\n在现实项目中，往往是这两种情况兼而有之，这就需要做出权衡，甚至既需要垂直切分，又需要水平切分。\n\n**四、分表方案**\n\n4.1利用数据库的merge存储引擎来实现分表\n\n优势：不用改代码。\n\n缺点：有一些限制，必须是MyISAM存储引擎，分表的id不能是自增的，每个分表的表结构必须相同，Mysql必须具有存储分一数据文件和索引文件的目录的读写权限，必须启用mysql的符号链接支持功能。\n\n4.2垂直切分\n\n垂直拆分是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放入到用户库，把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联。\n\n比如原始用户表是：\n\n![img](/images/v2-f9315b646c72eb17564ebc0507458b14_720w.jpg)\n\n垂直拆分后的表是：\n\n![img](/images/v2-31eb992f13d3222fcfc4cd222158a702_720w.jpg)\n\n垂直拆分的优点是：\n\n\\1. 可以使得数据变小，一个数据块（block）就能存放更多的数据，在查询时就会减少I/O次数（每次查询时读取的Block就少）\n\n\\2. 可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起\n\n\\3. 数据维护简单\n\n缺点是：\n\n1.主键出现冗余，需要管理冗余例\n\n2.会引起表连接JOIN操作(增加CPU开销)可以通过在业务服务器上进行join来减少数据库压力\n\n3.依然存在单表数据量过大的问题(需要水平拆分)\n\n4.事务处理复杂\n\n4.3 水平切分\n\n4.3.1按照订单号做Hash分散订单数据\n\n把订单号看作是一个字符串，做hash，分散到多个服务器。具体分到哪个库、哪个表存储数据，订单号的数字来记录。以微信红包为例：订单分库分表，是对订单号进行hash计算。然后订单的末尾3个数包含了库名称、表名称。如：可参考美团的方法。\n\n那么如何查询某用户的所有订单呢？由于根据订单号来分散数据的，他们的订单分散在了多个库、多个表中。\n\n建异构索引表\n\n同样如何应付多维度的检索，例如所有订单的分页、订单状态检索、根据促销维度检索等\n\n做数据冗余、存储多份。或者用ES来处理\n\n4.3.2按照用户id来切分\n\n按照用户来切分数据有两种思路：\n\n一种方案是某个范围的uid订单到哪些库。例如0到2000w uid对应订单数据到a库，2000w到4000w对应订单到b库。\n\n缺点：某个范围内的用户，下单量比较多，那么造成这个库的压力特别大，数据分布极为不均衡。\n\n优点：查询指定用户的所有订单，避免了跨库跨表查询。因为用户的id是规定不变的，那么计算出的值永远是固定的某库某表。那么a用户的所有订单都是在某库某表里面。\n\n第二种方案是使用uid取模运算，第二种方案业界用的比较多。\n\n具体实现如下：\n\n按照用户id作为key来切分订单数据，具体如下：\n\n1、 库名称定位：用户id末尾4位 Mod 32。\n\nMod表示除以一个数后，取余下的数。比如除以32后，余下8，余数就是8。\n\n代码符号是用%表示：15%4=3。\n\n2、表名称定位：（用户id末尾4位 Dev 32） Mod 32。\n\nDev表示除以一个数，取结果的整数。比如得到结果是25.6，取整就是25。\n\n代码用/来表示：$get_int = floor(15/4)。15除以4，是一个小数3.75，向下取整就是3。一定是向下取整，向上取整就变成了4了。\n\n按照上面的规则：总共可以表示多少张表呢？32个库*每个库32个表=1024张表。如果想表的数量小，就把32改小一些。\n\n上面是用计算机术语来表示， 下面用通俗的话描述。\n\n1、库名称计算\n\n用户id的后4位数，取32的模(取模就是除以这个数后，余多少)。余下的数，是0-31之间。\n\n这样可以表示从0-31之间，总共32个数字。用这个32个数字代表着32个库名称：order_db_0、order_db_2.........................order_db_31\n\n2、表名称计算\n\n最后要存储定到哪个表名里面去呢？\n\n用户id的最后4位数，除以32，取整数。将整数除以32，得到余数，能够表示从0-31之间32个数字，表示表名称。\n\n表名称类似这样：order_tb_1、order_tb_2..........................order_tb_31。一个库里面，总共32个表名称。\n\n比如用户id：19408064，用最后4位数字8064除以32，得到是251.9，取它的整数是251。\n\n接着将251除以32，取余数，余数为27。\n\n为了保持性能，每张表的数据量要控制。单表可以维持在一千万-5千万行的数据。1024*一千万。这个已经是很大的数据量了。\n\n4.3.4按订单的时间来分表\n\n一个月一张，一年一张表，用户的所有订单，会分散在不同的库、不同的表中。这个可以根据实际的应用场景来使用。适合于经常只查询某一时间段的数据。因为这个种分表方法会有几个缺点，如果查询某个用户所有订单数据，就会出现跨库、跨表，效率会低。\n\n4.4 阿里云的RDS分库分表方案。DRDS（Distributed Relational Database Service，分布式关系型数据库服务 ）是阿里巴巴自主研发，致力于解决单机数据库瓶颈而推出的分布式数据库中间件产品。DRDS高度兼容Mysql协议和语法，支持水平拆分、平滑扩容、弹性扩展、透明读写分离和分布式事务等特性，具备分布式数据库全生命周期的运维管控能力。\n\n![img](/images/v2-26e9c6b2d131c19e25d7283f37940ae1_720w.jpg)\n\nDRDS 支持库级拆分、表级拆分和分库分表拆分。拆分键暂时只支持单个字段。\n分库键：DRDS 根据分库键的值将数据水平拆分到后端的每一个 RDS 分库里。键值相同的数据，一定会位于同一个 RDS 数据库里。\n分表键：每一张逻辑表都可以定义自己的分表键，键值相同的数据，一定会位于同一个 RDS 数据表里。\n\n![img](/images/v2-ae88013d0531eac5ebc96fad2e4f8594_720w.jpg)\n\n网上数据：贝聊大概有几万所幼儿园，上亿数据量，效果比较 ：\n\n1、 性能大幅度提升\n响应速度提升5至10倍，以当时获取班级动态列表接口为例：\n分库分表实施前：响应时间大致为200ms至1500ms级之间。\n分库分表实施后：响应时间提升至大致为30ms至300ms之间。\n2、 可方便快速进行横向扩容\n如果需要扩容，直接按照阿里云DRDS指引，增加新的分库即可。\n3、 架构的优化\n独立动态业务，通过Dubbo提供服务，对系统进行解耦，让业务具备快速横向扩容能力。\n4、后遗症\n独立后，暂时没有做分布式事务，在业务中需要避免跨库事务。\n\n1. 分库分表存在的问题及解决方案\n2. 事务问题\n\n在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。\n\n1. 跨库跨表join问题\n\n在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。\n\n解决方法：建立异构索引表。以此为例，建立用户id与订单号的索引关系表。\n\n例如：假设是以订单号分散订单数据。需求是查询某个用户的所有订单。如果知道某个用户的所有订单。那么就可以根据订单号定位到表名称。假设是以用户id分散订单数据的，那么我们只要知道这个订单号是谁的（得到了用户id）,就知道去哪个库、哪个表查询数据了。\n\n索引表里包括两项：订单号、用户编号。当数据量越来越大时，索引表也不能用单个表存储了，也需要分库分表了，因为关系一一对应，不会变化，所以也可以存在redis里。这样速度就比较快了。\n\n五、总结\n\n根据公司的adu来看，包括与美团淘宝的比较而言，可以通过业务来分库，并不是一定要做以id取模来分库，否则要更改的东西比较 大。另外分表的话可以水平和垂直混用，包括适当的场景用ES.而具体实施的时候参美团的三个步骤执行，先老库旧库时间使用，然后监控情况，待新库稳定之后再切到新库。另外以于一些开源的工具可以参考使用。如果按业务进行拆分的话，像报表统计相关的可以分离，教研相关业务独立拆分，用户相关、权限管理可独立拆分成一个模块，小程序相关独立拆分，cc业务独立拆分，订单业务独立拆分、app相关独立拆分、市场推广独立拆分。原则是高聚合，低耦合。具体根据公司的实际应用场景再有所调整。\n\n文献\n\n企业IT架构转型之道 阿里巴巴中台战略思想与架构实践 钟华","source":"_posts/sql/Mysql分库分表方案.md","raw":"---\ntitle: \\[转\\]Mysql分库分表方案 \ntags:\n  - 数据库\n  - 分库分表方案\ncategories:\n  - 数据库\n  - 分库分表方案\ndate: 2020-06-04 16:05:46\n---\n**一、分库分表背景**\n\n1. 为什么分库\n\n1.1数据库最容易产生性能瓶颈的服务组件。数据库连接数资源捉襟见肘和数据库因为表多、数据多造成的性能问题。这里以淘宝为例，在淘宝平台向共享服务体系改造的过程中，通过各个服务中心拥有各自独立数据库的方式，即采用数据库垂直分区的方式对业务数据进行分区。\n\n1.2单一服务中心的数据访问压力也必然会达到单机数据库的承载上限，所以在进行服务化改造的同一时间段内，需要对数据库能力做扩展的工作。\n\n1.3.单台数据库 这里以mysql为例，mysql数据库，当访问连接数过多时，就会出现‘too many connections’的错误，一般来说是访问量太大或者数据库设置的最大连接数太小的原因。Mysql默认的最大连接数为100.这个连接连接数可以修改，而mysql服务允许的最大连接数为16384.虽然可以通过连接池可以一定程序上优化连接，但是当数据量过大时，单台数据库显示已经不能支撑应用服务器的访问。所以就需要做分库，具体分库方法下面会有详细介绍。\n\n1.4 在实际的应用中，绝大部分情况都是读远大于写。Mysql提供了读写分离的机制，所有的写操作都必须对应到Master，读操作可以在 Master和Slave机器上进行，Slave与Master的结构完全一样，一个Master可以有多个Slave,甚至Slave下还可以挂 Slave,通过此方式可以有效的提高DB集群的 QPS.\n\n所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。\n\n此外，可以看出Master是集群的瓶颈，当写操作过多，会严重影响到Master的稳定性，如果Master挂掉，整个集群都将不能正常工作。\n\n所以\n\n\\1. 当读压力很大的时候，可以考虑添加Slave机器的分式解决，但是当Slave机器达到一定的数量就得考虑分库了。\n\n\\2. 当写压力很大的时候，就必须得进行分库操作。\n\n2.为什么分表\n\n有一组数据可以参考：\n\n基本指标:\n\n库物理文件大小<100G\n\n表<100\n\n字段<200\n\n单表记录数<500W\n\n经测试在单表1000万条记录一下,写入读取性能是比较好的. 这样在留点buffer,那么单表全是数字类型的保持在800万条记录以下, 有字符型的单表保持在500万以下.如果按 100库100表来规划,如用户业务:\n\n500万*100*100 = 50000000万 = 5000亿记录.供参考,具体按按业务做规划.\n\n3.什么是分区\n\n分表是将一张表分成N多个小表，分区是把一张表的数据分成N多个区块，这些区块可以在同一个磁盘上，也可以在不同的磁盘上。mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件，一个.MYD数据文件，.MYI索引文件，.frm表结构文件。\n\n**二、现状**\n\n2.1淘宝的解决方案\n\n首先是实施的是数据库的读写分离。读写分离的基本原理是让主数据库处理事务性增、改、删（Insert、update、delete）操作，而从数据库专门负责处理查询（select）操作，在数据库的后台会把事务性操作导致的主数据库中的数据变更同步到集群中的从数据库。\n\n![img](/images/v2-cdca1f51c4a3bef0b30221a947144bdd_720w.jpg)\n\n采用读写分离的方式，拓展了数据库对数据读的处理能力，整体上也大大提升了数据库的读写能力。但是这样的架构在主数据库的数据写入能力依然没法扩展，一旦数据库写压力比较大时，则对整个平台带来非常大的影响。而且数据库单表的数据量是有限制的，当单表数据量达到一定数量后数据库性能会出现显著下降的情况，所以简单的读写分离不能满足淘宝的发展的要求。\n\n为了更好的在数据库层面支持好淘宝的业务，在2008年，阿里巴巴内部开始了分布式数据库的研发工作，相关的平台和工具陆续登上了淘宝技术发展史的历史舞台。\n\n2006年阿里巴巴以开源的形式研发了Cobar这一关系型数据库的分布式处理系统。当时Cobar平均每天处理近50亿次的SQL操作，但是随着阿里巴巴业务场景越来越复杂，有以下缺点：\n\n1. 不支持跨库情况下的连接、分页、排序、子查询\n2. SET语句执行会被忽略，处理事务和字符集设置除外。\n3. 分库情况下，insert语句必须包含拆分字段列名\n4. 分库情况下，update语句不能更新拆分字段的值\n5. 不支持SAVEPOINT操作\n6. 使用JBDC时，不支持rewriteBatchStatements = true参数设置\n\n等\n\n2008年内部 在Cobar的基础上重新研发了分布式数据层框架TDDL（外号头都大了）\n\n![img](/images/v2-9f56d1d058e3a87a8c6be5b58696f14b_720w.jpg)\n\n![img](/images/v2-c526027f5f2dae54753239d5d9bd277b_720w.jpg)\n\nTDDL提供了以下优点：\n\n1. 数据库主备和动态切换\n2. 带权重的读写分离\n3. 单线程读重试\n4. 集中式数据源信息管理和动态变更\n5. 支持MySQL和Oracle数据库\n6. 基于JDBC规范，很容易扩展支持实现JDBC规范的数据源\n7. 无Server、client-jar形式存在，应用直连数据库\n8. 读写次数，并发度流程控制，动态变更\n9. 可分析的日志打印，日志流控，动态变更。\n\n阿里巴巴分库分表的几个原则：\n\n1. 数据尽可能的平均拆分\n2. 尽可能的减少事务边界 所谓的事务边界 指单个SQL语句在后端数据库上同时执行的数量。因为事务边界越大，系统的锁冲突概率就越高，系统越难以扩展，整体性能越低。\n3. 异构索引表尽量降低全表扫描频率 这个是针对假如数据是按订单id进行分拆，当用户想查看自己的订单时，针对这种场景，常采用异构索引表来解决，即采用异步机制将原表内的每一次创建或更新，都换另一个维度保存一份完整的数据表或索引表。本质上这是互联网公司很多时候采用的一个解决思路：拿空间换时间 。\n\n![img](/images/v2-60336a35f872a24562326304943292b9_720w.jpg)\n\n实现异构索引的方式，也就是阿里巴巴内部目前采用的方式 ，通过一填名为精卫填海的产品实现了数据的异构复制。\n\n1. 将多条件频繁查询引入搜索引擎平台 比如Iucene、Solr、ElasticSearch等搜索引擎。\n\n总结\n\n从系统的风险的角度考虑，以82法则，在实际中，我们仅针对那些在80%情况下访问的那20%的场景进行如数据异构索引这样的处理，达到这类场景的性能最优化，而以其他80%偶尔出现跨库join、全表扫描的场景，采用最为简单直接的方式往往是最有效的方式。\n\n2.2美团的解决方案\n\n通常有两种方案。第一种方案是直接对现有的商品库进行垂直拆分，可以缓解目前写峰值QPS过大、DB主从延迟的问题。第二种方案是对现有的商品库大表进行分库分表，从根本上解决现有问题。方案一实施起来周期较短，但只能解决一时之痛，由此可见，分库分表是必然的。\n\n在确定分库分表的方案之后，调研了外卖订单、结算以及主站等业务的分库分表实现方案，也调研了业界很多分库分表中间件。在综合考虑性能、稳定性及实现成本的前提下，最终决定自主研发客户端分库分表中间件MTDDL来支撑外卖商品分库分表项目，这也就是MTDDL的由来。\n\n在MTDDL的设计研发过程中，我们充分考虑了MTDDL的通用性、可扩展性、功能的全面性和接入的便利性。到目前为止一共开发了四期，实现了MySQL动态数据源、读写分离、分布式唯一主键生成器、分库分表、连接池及SQL监控、动态化配置等一系列功能，支持分库分表算法、分布式唯一主键生成算法的高可扩展性，而且支持全注解的方式接入，业务方不需要引入任何配置文件。\n\n![img](/images/v2-ddda0732607e2bcb365960c675e0dc71_720w.jpg)\n\n分布式唯一主键生成器\n\n众所周知，分库分表首先要解决的就是分布式唯一主键的问题，业界也有很多相关方案（大众点评用的是时间戳+用户标识码+随机数）：\n\n![img](/images/v2-c52ddb056dbd39595e7c6f5b2c4fb3b5_720w.jpg)\n\n综上，方案3的缺点可以通过一些手段避免，但其他方案的缺点不好处理，所以选择第3种方案。目前该方案已由美团点评技术工程部实现——分布式ID生成系统Leaf，MTDDL集成了此功能。\n\n美团分库分表流程\n\n![img](/images/v2-94c4670cb6b6099055a5146f1a034b9b_720w.jpg)\n\n分库分表取模算法：\n\n分库分表目前默认使用的是取模算法，分表算法为 (#shard_key % (group_shard_num * table_shard_num))，分库算法为 (#shard_key % (group_shard_num * table_shard_num)) / table_shard_num，其中group_shard_num为分库个数，table_shard_num为每个库的分表个数。\n\n例如把一张大表分成100张小表然后散到2个库，则0-49落在第一个库、50-99落在第二个库。核心实现如下：\n\n![img](/images/v2-73c1d9300839c0ee560c9bfcc685d653_720w.jpg)\n\n大众点评订单表早已超过200G，由于查询维度较多，即使加了两个从库，优化索引，仍然存在很多查询不理想的情况。\n\n先对订单库进行垂直切分，将原有的订单库分为基础订单库、订单流程库等。\n\n![img](/images/v2-432781b10f8582f5bf192e1a050e99a1_720w.jpg)\n\n垂直切分缓解了原来单集群的压力，但是在抢购时仍然捉襟见肘。原有的订单模型已经无法满足业务需求，于是我们设计了一套新的统一订单模型，为同时满足C端用户、B端商户、客服、运营等的需求，我们分别通过用户ID和商户ID进行切分，并通过PUMA（我们内部开发的MySQL binlog实时解析服务）同步到一个运营库。\n\n![img](/images/v2-373b769b0466f324fd0553f5074d1b37_720w.jpg)\n\n切分策略\n\n1. 查询切分\n\n将ID和库的Mapping关系记录在一个单独的库中。\n\n![img](/images/v2-eb03c274f799a5147abc23bb99a56b4c_720w.jpg)\n\n优点：ID和库的Mapping算法可以随意更改\n\n缺点：引入额外的单点\n\n1. 范围切分\n\n比如按照时间区间或ID区间来切分\n\n![img](/images/v2-b8854e3034ce49c2f8d652394c2328ac_720w.jpg)\n\n优点：单表大小可控，天然水平扩展\n\n缺点：无法解决集中写入瓶颈的问题\n\n1. hash切分\n\n一般采用Mod来切分，下面着重讲一下Mod的策略\n\n![img](/images/v2-104267f964da011318238d357f05bb6c_720w.jpg)\n\n数据水平切分后我们希望是一劳永逸或者易于水平扩展的，所以推荐mod2^n这种一致性Hash\n\n以统一订单库为例，我们分库分表的方案是32*32的，即通过UserId后四位mod32到32个库中，同时再将UserId后四位Div 32 Mod 32将每个库分为32个表，共计分为1024个表。线上部署情况为8个集群（主从），每个集群4个库。为什么说这种方式易于水平扩展呢？\n\n分析两种场景。\n\n场景一：数据库性能达到瓶颈\n\n方法一\n\n按照现有规则不变，可以直接扩展到32个数据库集群。\n\n![img](/images/v2-65d90f64aa52be10b9bdc1b8042e9e31_720w.jpg)\n\n方法二\n\n如果32个集群也无法满足需求，那么将分库分表规则调整为（32*2^n）*(32/2^n)可以达到最多1024个集群。\n\n场景二：单表容量达瓶颈（或者1024已经无法满足）\n\n方法：\n\n![img](/images/v2-c431ecdd67246b4e7745d58155d4e64d_720w.jpg)\n\n假如单表都已突破200G,200*1024=200T（按照现有的订单模型算了算，大概1000万亿订单），32*（32*2^n），这时分库规则不变，单库里的表再进行裂变，当然目前的订单规则下（userId后四位mod）还是有极限的。因为只有四位，所以最多拆8192个表。\n\n唯一ID方案\n\n这个方案也有很多种，主流的有那么几种：\n\n1. 利用数据库自增ID\n\n优点：最简单。缺点：单点风险，单机性能瓶颈。\n\n\\2. 利用数据库集群并设置相应的步长（Flickr方案）\n\n优点：高可用、ID较简洁。 缺点：需要单独的数据库集群。\n\n\\3. Twitter Snowflake\n\n优点：高性能高可用、易拓展。 缺点：需要独立的集群以及ZK。\n\n\\4. 一大波GUID、Random算法\n\n优点：简单。 缺点：生成ID较长，有重复几率。\n\n美团的方案：为了减少运营成本并减少额外的风险，排除了所有需要独立集群的方案，采用带有业务属性的议案： 时间戳+用户标识码+随机数\n\n有以下几个好处：\n\n1.方便、成本低。\n\n2.基本无重复的可能。\n\n3.自带分库规则，这里的用户标识码即为用户ID的后四位，在查询的场景下，只需要订单号就可以匹配到相应的库表而无需用户ID，只取四位是希望订单号尽可能的短一些，并且评估下来四位已经足够。\n\n4.可排序，因为时间戳在最前面。\n\n其他问题\n\n事务支持：我们是将整个订单领域聚合体切分，维度一致，所以对聚合体的事务是支持的。\n\n复杂查询：垂直切分后，就跟join说拜拜了；水平切分后，查询的条件一定要在切分的维度内，比如查询具体某个用户下的各位订单等；禁止不带切分的维度的查询，即使中间件可以支持这种查询，可以在内存中组装，但是这种需求往往不应该在在线库查询，或者可以通过其他方法转换到切分的维度来实现。\n\n数据迁移\n\n数据库拆分一般是业务发展到一定规模之后的优化和重构，为了支持业务快速上线，很难一开始就分库分表，垂直拆分还好办，改改数据源就搞定了，一旦开始水平拆分，数据清洗是一个大问题。为此，经历了以下几个阶段。\n\n第一阶段：\n\n![img](/images/v2-73771a9cec11fc86e5aa0145885b05c8_720w.jpg)\n\n数据库双写（事务成功以老模型为准），查询走老模型\n\n每日job数据对账（通过DW），并将差异补平\n\n通过job导历史数据\n\n第二阶段\n\n![img](/images/v2-86d44b4b844c130414c4653f215ec149_720w.jpg)\n\n历史数据导入完毕并且数据对账无误\n\n依然是数据库双写，但是事务成功与否以新模型为准，在线查询切换新模型\n\n每日job数据对账，将差异补平\n\n第三阶段\n\n![img](/images/v2-fe9119746d34b5396e48eac6ecd16746_720w.jpg)\n\n老模型不同同步写入，仅当订单有终态时才会异步补上。\n\n此阶段只有离线数据依然依赖老的模型，并且下游的依赖非常多，待DW改造完就可以完全废除老模型了。\n\n总结\n\n1.并非所有表都需要水平拆分，要看增长的类型和速度，水平拆分是大招，拆分后会增加开发的复杂度，不到万不得已不使用。\n\n2.在大规模并发的业务上，尽量做到在线查询和离线查询隔离，交易查询和运营/客服查询隔离。\n\n3.拆分维度的选择很重要，要尽可能在解决拆分前问题的基础上，便于开发。\n\n4.数据库没你想象的那么坚强，需要保护，尽量使用简单的、良好索引的查询，这样数据库整体可控，也易于长期容量规划以及水平扩展。\n\n**三、分库方案**\n\n3.1垂直切分\n\n按业务切分，将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如用户相关、教务相关、cc业务相关、报表相关等。\n\n3.2水平切分\n\n当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如userID散列，进行划分，然后存储到多个结构相同的表，和不同的库上。例如，我们的userDB中的用户数据表中，每一个表的数据量都很大，就可以把userDB切分为结构相同的多个userDB：part0DB、part1DB等，再将userDB上的用户数据表userTable，切分为很多userTable：userTable0、userTable1等，然后将这些表按照一定的规则存储到多个userDB上。\n\n3.3切分的选择\n\n应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。\n\n如果数据库是因为表太多而造成海量数据，并且项目的各项业务逻辑划分清晰、低耦合，那么规则简单明了、容易实施的垂直切分必是首选。而如果数据库中的表并不多，但单表的数据量很大、或数据热度很高，这种情况之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估，考虑数据平均和负载平均，后期也将对项目人员及应用程序产生额外的数据管理负担。\n\n在现实项目中，往往是这两种情况兼而有之，这就需要做出权衡，甚至既需要垂直切分，又需要水平切分。\n\n**四、分表方案**\n\n4.1利用数据库的merge存储引擎来实现分表\n\n优势：不用改代码。\n\n缺点：有一些限制，必须是MyISAM存储引擎，分表的id不能是自增的，每个分表的表结构必须相同，Mysql必须具有存储分一数据文件和索引文件的目录的读写权限，必须启用mysql的符号链接支持功能。\n\n4.2垂直切分\n\n垂直拆分是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放入到用户库，把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联。\n\n比如原始用户表是：\n\n![img](/images/v2-f9315b646c72eb17564ebc0507458b14_720w.jpg)\n\n垂直拆分后的表是：\n\n![img](/images/v2-31eb992f13d3222fcfc4cd222158a702_720w.jpg)\n\n垂直拆分的优点是：\n\n\\1. 可以使得数据变小，一个数据块（block）就能存放更多的数据，在查询时就会减少I/O次数（每次查询时读取的Block就少）\n\n\\2. 可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起\n\n\\3. 数据维护简单\n\n缺点是：\n\n1.主键出现冗余，需要管理冗余例\n\n2.会引起表连接JOIN操作(增加CPU开销)可以通过在业务服务器上进行join来减少数据库压力\n\n3.依然存在单表数据量过大的问题(需要水平拆分)\n\n4.事务处理复杂\n\n4.3 水平切分\n\n4.3.1按照订单号做Hash分散订单数据\n\n把订单号看作是一个字符串，做hash，分散到多个服务器。具体分到哪个库、哪个表存储数据，订单号的数字来记录。以微信红包为例：订单分库分表，是对订单号进行hash计算。然后订单的末尾3个数包含了库名称、表名称。如：可参考美团的方法。\n\n那么如何查询某用户的所有订单呢？由于根据订单号来分散数据的，他们的订单分散在了多个库、多个表中。\n\n建异构索引表\n\n同样如何应付多维度的检索，例如所有订单的分页、订单状态检索、根据促销维度检索等\n\n做数据冗余、存储多份。或者用ES来处理\n\n4.3.2按照用户id来切分\n\n按照用户来切分数据有两种思路：\n\n一种方案是某个范围的uid订单到哪些库。例如0到2000w uid对应订单数据到a库，2000w到4000w对应订单到b库。\n\n缺点：某个范围内的用户，下单量比较多，那么造成这个库的压力特别大，数据分布极为不均衡。\n\n优点：查询指定用户的所有订单，避免了跨库跨表查询。因为用户的id是规定不变的，那么计算出的值永远是固定的某库某表。那么a用户的所有订单都是在某库某表里面。\n\n第二种方案是使用uid取模运算，第二种方案业界用的比较多。\n\n具体实现如下：\n\n按照用户id作为key来切分订单数据，具体如下：\n\n1、 库名称定位：用户id末尾4位 Mod 32。\n\nMod表示除以一个数后，取余下的数。比如除以32后，余下8，余数就是8。\n\n代码符号是用%表示：15%4=3。\n\n2、表名称定位：（用户id末尾4位 Dev 32） Mod 32。\n\nDev表示除以一个数，取结果的整数。比如得到结果是25.6，取整就是25。\n\n代码用/来表示：$get_int = floor(15/4)。15除以4，是一个小数3.75，向下取整就是3。一定是向下取整，向上取整就变成了4了。\n\n按照上面的规则：总共可以表示多少张表呢？32个库*每个库32个表=1024张表。如果想表的数量小，就把32改小一些。\n\n上面是用计算机术语来表示， 下面用通俗的话描述。\n\n1、库名称计算\n\n用户id的后4位数，取32的模(取模就是除以这个数后，余多少)。余下的数，是0-31之间。\n\n这样可以表示从0-31之间，总共32个数字。用这个32个数字代表着32个库名称：order_db_0、order_db_2.........................order_db_31\n\n2、表名称计算\n\n最后要存储定到哪个表名里面去呢？\n\n用户id的最后4位数，除以32，取整数。将整数除以32，得到余数，能够表示从0-31之间32个数字，表示表名称。\n\n表名称类似这样：order_tb_1、order_tb_2..........................order_tb_31。一个库里面，总共32个表名称。\n\n比如用户id：19408064，用最后4位数字8064除以32，得到是251.9，取它的整数是251。\n\n接着将251除以32，取余数，余数为27。\n\n为了保持性能，每张表的数据量要控制。单表可以维持在一千万-5千万行的数据。1024*一千万。这个已经是很大的数据量了。\n\n4.3.4按订单的时间来分表\n\n一个月一张，一年一张表，用户的所有订单，会分散在不同的库、不同的表中。这个可以根据实际的应用场景来使用。适合于经常只查询某一时间段的数据。因为这个种分表方法会有几个缺点，如果查询某个用户所有订单数据，就会出现跨库、跨表，效率会低。\n\n4.4 阿里云的RDS分库分表方案。DRDS（Distributed Relational Database Service，分布式关系型数据库服务 ）是阿里巴巴自主研发，致力于解决单机数据库瓶颈而推出的分布式数据库中间件产品。DRDS高度兼容Mysql协议和语法，支持水平拆分、平滑扩容、弹性扩展、透明读写分离和分布式事务等特性，具备分布式数据库全生命周期的运维管控能力。\n\n![img](/images/v2-26e9c6b2d131c19e25d7283f37940ae1_720w.jpg)\n\nDRDS 支持库级拆分、表级拆分和分库分表拆分。拆分键暂时只支持单个字段。\n分库键：DRDS 根据分库键的值将数据水平拆分到后端的每一个 RDS 分库里。键值相同的数据，一定会位于同一个 RDS 数据库里。\n分表键：每一张逻辑表都可以定义自己的分表键，键值相同的数据，一定会位于同一个 RDS 数据表里。\n\n![img](/images/v2-ae88013d0531eac5ebc96fad2e4f8594_720w.jpg)\n\n网上数据：贝聊大概有几万所幼儿园，上亿数据量，效果比较 ：\n\n1、 性能大幅度提升\n响应速度提升5至10倍，以当时获取班级动态列表接口为例：\n分库分表实施前：响应时间大致为200ms至1500ms级之间。\n分库分表实施后：响应时间提升至大致为30ms至300ms之间。\n2、 可方便快速进行横向扩容\n如果需要扩容，直接按照阿里云DRDS指引，增加新的分库即可。\n3、 架构的优化\n独立动态业务，通过Dubbo提供服务，对系统进行解耦，让业务具备快速横向扩容能力。\n4、后遗症\n独立后，暂时没有做分布式事务，在业务中需要避免跨库事务。\n\n1. 分库分表存在的问题及解决方案\n2. 事务问题\n\n在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。\n\n1. 跨库跨表join问题\n\n在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。\n\n解决方法：建立异构索引表。以此为例，建立用户id与订单号的索引关系表。\n\n例如：假设是以订单号分散订单数据。需求是查询某个用户的所有订单。如果知道某个用户的所有订单。那么就可以根据订单号定位到表名称。假设是以用户id分散订单数据的，那么我们只要知道这个订单号是谁的（得到了用户id）,就知道去哪个库、哪个表查询数据了。\n\n索引表里包括两项：订单号、用户编号。当数据量越来越大时，索引表也不能用单个表存储了，也需要分库分表了，因为关系一一对应，不会变化，所以也可以存在redis里。这样速度就比较快了。\n\n五、总结\n\n根据公司的adu来看，包括与美团淘宝的比较而言，可以通过业务来分库，并不是一定要做以id取模来分库，否则要更改的东西比较 大。另外分表的话可以水平和垂直混用，包括适当的场景用ES.而具体实施的时候参美团的三个步骤执行，先老库旧库时间使用，然后监控情况，待新库稳定之后再切到新库。另外以于一些开源的工具可以参考使用。如果按业务进行拆分的话，像报表统计相关的可以分离，教研相关业务独立拆分，用户相关、权限管理可独立拆分成一个模块，小程序相关独立拆分，cc业务独立拆分，订单业务独立拆分、app相关独立拆分、市场推广独立拆分。原则是高聚合，低耦合。具体根据公司的实际应用场景再有所调整。\n\n文献\n\n企业IT架构转型之道 阿里巴巴中台战略思想与架构实践 钟华","slug":"sql/Mysql分库分表方案","published":1,"updated":"2020-06-04T07:48:16.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7m40069vgjahzxp928p","content":"<p><strong>一、分库分表背景</strong></p>\n<ol>\n<li>为什么分库</li>\n</ol>\n<p>1.1数据库最容易产生性能瓶颈的服务组件。数据库连接数资源捉襟见肘和数据库因为表多、数据多造成的性能问题。这里以淘宝为例，在淘宝平台向共享服务体系改造的过程中，通过各个服务中心拥有各自独立数据库的方式，即采用数据库垂直分区的方式对业务数据进行分区。</p>\n<p>1.2单一服务中心的数据访问压力也必然会达到单机数据库的承载上限，所以在进行服务化改造的同一时间段内，需要对数据库能力做扩展的工作。</p>\n<p>1.3.单台数据库 这里以mysql为例，mysql数据库，当访问连接数过多时，就会出现‘too many connections’的错误，一般来说是访问量太大或者数据库设置的最大连接数太小的原因。Mysql默认的最大连接数为100.这个连接连接数可以修改，而mysql服务允许的最大连接数为16384.虽然可以通过连接池可以一定程序上优化连接，但是当数据量过大时，单台数据库显示已经不能支撑应用服务器的访问。所以就需要做分库，具体分库方法下面会有详细介绍。</p>\n<p>1.4 在实际的应用中，绝大部分情况都是读远大于写。Mysql提供了读写分离的机制，所有的写操作都必须对应到Master，读操作可以在 Master和Slave机器上进行，Slave与Master的结构完全一样，一个Master可以有多个Slave,甚至Slave下还可以挂 Slave,通过此方式可以有效的提高DB集群的 QPS.</p>\n<p>所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>\n<p>此外，可以看出Master是集群的瓶颈，当写操作过多，会严重影响到Master的稳定性，如果Master挂掉，整个集群都将不能正常工作。</p>\n<p>所以</p>\n<p>\\1. 当读压力很大的时候，可以考虑添加Slave机器的分式解决，但是当Slave机器达到一定的数量就得考虑分库了。</p>\n<p>\\2. 当写压力很大的时候，就必须得进行分库操作。</p>\n<p>2.为什么分表</p>\n<p>有一组数据可以参考：</p>\n<p>基本指标:</p>\n<p>库物理文件大小&lt;100G</p>\n<p>表&lt;100</p>\n<p>字段&lt;200</p>\n<p>单表记录数&lt;500W</p>\n<p>经测试在单表1000万条记录一下,写入读取性能是比较好的. 这样在留点buffer,那么单表全是数字类型的保持在800万条记录以下, 有字符型的单表保持在500万以下.如果按 100库100表来规划,如用户业务:</p>\n<p>500万<em>100</em>100 = 50000000万 = 5000亿记录.供参考,具体按按业务做规划.</p>\n<p>3.什么是分区</p>\n<p>分表是将一张表分成N多个小表，分区是把一张表的数据分成N多个区块，这些区块可以在同一个磁盘上，也可以在不同的磁盘上。mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件，一个.MYD数据文件，.MYI索引文件，.frm表结构文件。</p>\n<p><strong>二、现状</strong></p>\n<p>2.1淘宝的解决方案</p>\n<p>首先是实施的是数据库的读写分离。读写分离的基本原理是让主数据库处理事务性增、改、删（Insert、update、delete）操作，而从数据库专门负责处理查询（select）操作，在数据库的后台会把事务性操作导致的主数据库中的数据变更同步到集群中的从数据库。</p>\n<p><img src=\"/images/v2-cdca1f51c4a3bef0b30221a947144bdd_720w.jpg\" alt=\"img\"></p>\n<p>采用读写分离的方式，拓展了数据库对数据读的处理能力，整体上也大大提升了数据库的读写能力。但是这样的架构在主数据库的数据写入能力依然没法扩展，一旦数据库写压力比较大时，则对整个平台带来非常大的影响。而且数据库单表的数据量是有限制的，当单表数据量达到一定数量后数据库性能会出现显著下降的情况，所以简单的读写分离不能满足淘宝的发展的要求。</p>\n<p>为了更好的在数据库层面支持好淘宝的业务，在2008年，阿里巴巴内部开始了分布式数据库的研发工作，相关的平台和工具陆续登上了淘宝技术发展史的历史舞台。</p>\n<p>2006年阿里巴巴以开源的形式研发了Cobar这一关系型数据库的分布式处理系统。当时Cobar平均每天处理近50亿次的SQL操作，但是随着阿里巴巴业务场景越来越复杂，有以下缺点：</p>\n<ol>\n<li>不支持跨库情况下的连接、分页、排序、子查询</li>\n<li>SET语句执行会被忽略，处理事务和字符集设置除外。</li>\n<li>分库情况下，insert语句必须包含拆分字段列名</li>\n<li>分库情况下，update语句不能更新拆分字段的值</li>\n<li>不支持SAVEPOINT操作</li>\n<li>使用JBDC时，不支持rewriteBatchStatements = true参数设置</li>\n</ol>\n<p>等</p>\n<p>2008年内部 在Cobar的基础上重新研发了分布式数据层框架TDDL（外号头都大了）</p>\n<p><img src=\"/images/v2-9f56d1d058e3a87a8c6be5b58696f14b_720w.jpg\" alt=\"img\"></p>\n<p><img src=\"/images/v2-c526027f5f2dae54753239d5d9bd277b_720w.jpg\" alt=\"img\"></p>\n<p>TDDL提供了以下优点：</p>\n<ol>\n<li>数据库主备和动态切换</li>\n<li>带权重的读写分离</li>\n<li>单线程读重试</li>\n<li>集中式数据源信息管理和动态变更</li>\n<li>支持MySQL和Oracle数据库</li>\n<li>基于JDBC规范，很容易扩展支持实现JDBC规范的数据源</li>\n<li>无Server、client-jar形式存在，应用直连数据库</li>\n<li>读写次数，并发度流程控制，动态变更</li>\n<li>可分析的日志打印，日志流控，动态变更。</li>\n</ol>\n<p>阿里巴巴分库分表的几个原则：</p>\n<ol>\n<li>数据尽可能的平均拆分</li>\n<li>尽可能的减少事务边界 所谓的事务边界 指单个SQL语句在后端数据库上同时执行的数量。因为事务边界越大，系统的锁冲突概率就越高，系统越难以扩展，整体性能越低。</li>\n<li>异构索引表尽量降低全表扫描频率 这个是针对假如数据是按订单id进行分拆，当用户想查看自己的订单时，针对这种场景，常采用异构索引表来解决，即采用异步机制将原表内的每一次创建或更新，都换另一个维度保存一份完整的数据表或索引表。本质上这是互联网公司很多时候采用的一个解决思路：拿空间换时间 。</li>\n</ol>\n<p><img src=\"/images/v2-60336a35f872a24562326304943292b9_720w.jpg\" alt=\"img\"></p>\n<p>实现异构索引的方式，也就是阿里巴巴内部目前采用的方式 ，通过一填名为精卫填海的产品实现了数据的异构复制。</p>\n<ol>\n<li>将多条件频繁查询引入搜索引擎平台 比如Iucene、Solr、ElasticSearch等搜索引擎。</li>\n</ol>\n<p>总结</p>\n<p>从系统的风险的角度考虑，以82法则，在实际中，我们仅针对那些在80%情况下访问的那20%的场景进行如数据异构索引这样的处理，达到这类场景的性能最优化，而以其他80%偶尔出现跨库join、全表扫描的场景，采用最为简单直接的方式往往是最有效的方式。</p>\n<p>2.2美团的解决方案</p>\n<p>通常有两种方案。第一种方案是直接对现有的商品库进行垂直拆分，可以缓解目前写峰值QPS过大、DB主从延迟的问题。第二种方案是对现有的商品库大表进行分库分表，从根本上解决现有问题。方案一实施起来周期较短，但只能解决一时之痛，由此可见，分库分表是必然的。</p>\n<p>在确定分库分表的方案之后，调研了外卖订单、结算以及主站等业务的分库分表实现方案，也调研了业界很多分库分表中间件。在综合考虑性能、稳定性及实现成本的前提下，最终决定自主研发客户端分库分表中间件MTDDL来支撑外卖商品分库分表项目，这也就是MTDDL的由来。</p>\n<p>在MTDDL的设计研发过程中，我们充分考虑了MTDDL的通用性、可扩展性、功能的全面性和接入的便利性。到目前为止一共开发了四期，实现了MySQL动态数据源、读写分离、分布式唯一主键生成器、分库分表、连接池及SQL监控、动态化配置等一系列功能，支持分库分表算法、分布式唯一主键生成算法的高可扩展性，而且支持全注解的方式接入，业务方不需要引入任何配置文件。</p>\n<p><img src=\"/images/v2-ddda0732607e2bcb365960c675e0dc71_720w.jpg\" alt=\"img\"></p>\n<p>分布式唯一主键生成器</p>\n<p>众所周知，分库分表首先要解决的就是分布式唯一主键的问题，业界也有很多相关方案（大众点评用的是时间戳+用户标识码+随机数）：</p>\n<p><img src=\"/images/v2-c52ddb056dbd39595e7c6f5b2c4fb3b5_720w.jpg\" alt=\"img\"></p>\n<p>综上，方案3的缺点可以通过一些手段避免，但其他方案的缺点不好处理，所以选择第3种方案。目前该方案已由美团点评技术工程部实现——分布式ID生成系统Leaf，MTDDL集成了此功能。</p>\n<p>美团分库分表流程</p>\n<p><img src=\"/images/v2-94c4670cb6b6099055a5146f1a034b9b_720w.jpg\" alt=\"img\"></p>\n<p>分库分表取模算法：</p>\n<p>分库分表目前默认使用的是取模算法，分表算法为 (#shard_key % (group_shard_num * table_shard_num))，分库算法为 (#shard_key % (group_shard_num * table_shard_num)) / table_shard_num，其中group_shard_num为分库个数，table_shard_num为每个库的分表个数。</p>\n<p>例如把一张大表分成100张小表然后散到2个库，则0-49落在第一个库、50-99落在第二个库。核心实现如下：</p>\n<p><img src=\"/images/v2-73c1d9300839c0ee560c9bfcc685d653_720w.jpg\" alt=\"img\"></p>\n<p>大众点评订单表早已超过200G，由于查询维度较多，即使加了两个从库，优化索引，仍然存在很多查询不理想的情况。</p>\n<p>先对订单库进行垂直切分，将原有的订单库分为基础订单库、订单流程库等。</p>\n<p><img src=\"/images/v2-432781b10f8582f5bf192e1a050e99a1_720w.jpg\" alt=\"img\"></p>\n<p>垂直切分缓解了原来单集群的压力，但是在抢购时仍然捉襟见肘。原有的订单模型已经无法满足业务需求，于是我们设计了一套新的统一订单模型，为同时满足C端用户、B端商户、客服、运营等的需求，我们分别通过用户ID和商户ID进行切分，并通过PUMA（我们内部开发的MySQL binlog实时解析服务）同步到一个运营库。</p>\n<p><img src=\"/images/v2-373b769b0466f324fd0553f5074d1b37_720w.jpg\" alt=\"img\"></p>\n<p>切分策略</p>\n<ol>\n<li>查询切分</li>\n</ol>\n<p>将ID和库的Mapping关系记录在一个单独的库中。</p>\n<p><img src=\"/images/v2-eb03c274f799a5147abc23bb99a56b4c_720w.jpg\" alt=\"img\"></p>\n<p>优点：ID和库的Mapping算法可以随意更改</p>\n<p>缺点：引入额外的单点</p>\n<ol>\n<li>范围切分</li>\n</ol>\n<p>比如按照时间区间或ID区间来切分</p>\n<p><img src=\"/images/v2-b8854e3034ce49c2f8d652394c2328ac_720w.jpg\" alt=\"img\"></p>\n<p>优点：单表大小可控，天然水平扩展</p>\n<p>缺点：无法解决集中写入瓶颈的问题</p>\n<ol>\n<li>hash切分</li>\n</ol>\n<p>一般采用Mod来切分，下面着重讲一下Mod的策略</p>\n<p><img src=\"/images/v2-104267f964da011318238d357f05bb6c_720w.jpg\" alt=\"img\"></p>\n<p>数据水平切分后我们希望是一劳永逸或者易于水平扩展的，所以推荐mod2^n这种一致性Hash</p>\n<p>以统一订单库为例，我们分库分表的方案是32*32的，即通过UserId后四位mod32到32个库中，同时再将UserId后四位Div 32 Mod 32将每个库分为32个表，共计分为1024个表。线上部署情况为8个集群（主从），每个集群4个库。为什么说这种方式易于水平扩展呢？</p>\n<p>分析两种场景。</p>\n<p>场景一：数据库性能达到瓶颈</p>\n<p>方法一</p>\n<p>按照现有规则不变，可以直接扩展到32个数据库集群。</p>\n<p><img src=\"/images/v2-65d90f64aa52be10b9bdc1b8042e9e31_720w.jpg\" alt=\"img\"></p>\n<p>方法二</p>\n<p>如果32个集群也无法满足需求，那么将分库分表规则调整为（32<em>2^n）</em>(32/2^n)可以达到最多1024个集群。</p>\n<p>场景二：单表容量达瓶颈（或者1024已经无法满足）</p>\n<p>方法：</p>\n<p><img src=\"/images/v2-c431ecdd67246b4e7745d58155d4e64d_720w.jpg\" alt=\"img\"></p>\n<p>假如单表都已突破200G,200<em>1024=200T（按照现有的订单模型算了算，大概1000万亿订单），32</em>（32*2^n），这时分库规则不变，单库里的表再进行裂变，当然目前的订单规则下（userId后四位mod）还是有极限的。因为只有四位，所以最多拆8192个表。</p>\n<p>唯一ID方案</p>\n<p>这个方案也有很多种，主流的有那么几种：</p>\n<ol>\n<li>利用数据库自增ID</li>\n</ol>\n<p>优点：最简单。缺点：单点风险，单机性能瓶颈。</p>\n<p>\\2. 利用数据库集群并设置相应的步长（Flickr方案）</p>\n<p>优点：高可用、ID较简洁。 缺点：需要单独的数据库集群。</p>\n<p>\\3. Twitter Snowflake</p>\n<p>优点：高性能高可用、易拓展。 缺点：需要独立的集群以及ZK。</p>\n<p>\\4. 一大波GUID、Random算法</p>\n<p>优点：简单。 缺点：生成ID较长，有重复几率。</p>\n<p>美团的方案：为了减少运营成本并减少额外的风险，排除了所有需要独立集群的方案，采用带有业务属性的议案： 时间戳+用户标识码+随机数</p>\n<p>有以下几个好处：</p>\n<p>1.方便、成本低。</p>\n<p>2.基本无重复的可能。</p>\n<p>3.自带分库规则，这里的用户标识码即为用户ID的后四位，在查询的场景下，只需要订单号就可以匹配到相应的库表而无需用户ID，只取四位是希望订单号尽可能的短一些，并且评估下来四位已经足够。</p>\n<p>4.可排序，因为时间戳在最前面。</p>\n<p>其他问题</p>\n<p>事务支持：我们是将整个订单领域聚合体切分，维度一致，所以对聚合体的事务是支持的。</p>\n<p>复杂查询：垂直切分后，就跟join说拜拜了；水平切分后，查询的条件一定要在切分的维度内，比如查询具体某个用户下的各位订单等；禁止不带切分的维度的查询，即使中间件可以支持这种查询，可以在内存中组装，但是这种需求往往不应该在在线库查询，或者可以通过其他方法转换到切分的维度来实现。</p>\n<p>数据迁移</p>\n<p>数据库拆分一般是业务发展到一定规模之后的优化和重构，为了支持业务快速上线，很难一开始就分库分表，垂直拆分还好办，改改数据源就搞定了，一旦开始水平拆分，数据清洗是一个大问题。为此，经历了以下几个阶段。</p>\n<p>第一阶段：</p>\n<p><img src=\"/images/v2-73771a9cec11fc86e5aa0145885b05c8_720w.jpg\" alt=\"img\"></p>\n<p>数据库双写（事务成功以老模型为准），查询走老模型</p>\n<p>每日job数据对账（通过DW），并将差异补平</p>\n<p>通过job导历史数据</p>\n<p>第二阶段</p>\n<p><img src=\"/images/v2-86d44b4b844c130414c4653f215ec149_720w.jpg\" alt=\"img\"></p>\n<p>历史数据导入完毕并且数据对账无误</p>\n<p>依然是数据库双写，但是事务成功与否以新模型为准，在线查询切换新模型</p>\n<p>每日job数据对账，将差异补平</p>\n<p>第三阶段</p>\n<p><img src=\"/images/v2-fe9119746d34b5396e48eac6ecd16746_720w.jpg\" alt=\"img\"></p>\n<p>老模型不同同步写入，仅当订单有终态时才会异步补上。</p>\n<p>此阶段只有离线数据依然依赖老的模型，并且下游的依赖非常多，待DW改造完就可以完全废除老模型了。</p>\n<p>总结</p>\n<p>1.并非所有表都需要水平拆分，要看增长的类型和速度，水平拆分是大招，拆分后会增加开发的复杂度，不到万不得已不使用。</p>\n<p>2.在大规模并发的业务上，尽量做到在线查询和离线查询隔离，交易查询和运营/客服查询隔离。</p>\n<p>3.拆分维度的选择很重要，要尽可能在解决拆分前问题的基础上，便于开发。</p>\n<p>4.数据库没你想象的那么坚强，需要保护，尽量使用简单的、良好索引的查询，这样数据库整体可控，也易于长期容量规划以及水平扩展。</p>\n<p><strong>三、分库方案</strong></p>\n<p>3.1垂直切分</p>\n<p>按业务切分，将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如用户相关、教务相关、cc业务相关、报表相关等。</p>\n<p>3.2水平切分</p>\n<p>当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如userID散列，进行划分，然后存储到多个结构相同的表，和不同的库上。例如，我们的userDB中的用户数据表中，每一个表的数据量都很大，就可以把userDB切分为结构相同的多个userDB：part0DB、part1DB等，再将userDB上的用户数据表userTable，切分为很多userTable：userTable0、userTable1等，然后将这些表按照一定的规则存储到多个userDB上。</p>\n<p>3.3切分的选择</p>\n<p>应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。</p>\n<p>如果数据库是因为表太多而造成海量数据，并且项目的各项业务逻辑划分清晰、低耦合，那么规则简单明了、容易实施的垂直切分必是首选。而如果数据库中的表并不多，但单表的数据量很大、或数据热度很高，这种情况之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估，考虑数据平均和负载平均，后期也将对项目人员及应用程序产生额外的数据管理负担。</p>\n<p>在现实项目中，往往是这两种情况兼而有之，这就需要做出权衡，甚至既需要垂直切分，又需要水平切分。</p>\n<p><strong>四、分表方案</strong></p>\n<p>4.1利用数据库的merge存储引擎来实现分表</p>\n<p>优势：不用改代码。</p>\n<p>缺点：有一些限制，必须是MyISAM存储引擎，分表的id不能是自增的，每个分表的表结构必须相同，Mysql必须具有存储分一数据文件和索引文件的目录的读写权限，必须启用mysql的符号链接支持功能。</p>\n<p>4.2垂直切分</p>\n<p>垂直拆分是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放入到用户库，把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联。</p>\n<p>比如原始用户表是：</p>\n<p><img src=\"/images/v2-f9315b646c72eb17564ebc0507458b14_720w.jpg\" alt=\"img\"></p>\n<p>垂直拆分后的表是：</p>\n<p><img src=\"/images/v2-31eb992f13d3222fcfc4cd222158a702_720w.jpg\" alt=\"img\"></p>\n<p>垂直拆分的优点是：</p>\n<p>\\1. 可以使得数据变小，一个数据块（block）就能存放更多的数据，在查询时就会减少I/O次数（每次查询时读取的Block就少）</p>\n<p>\\2. 可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起</p>\n<p>\\3. 数据维护简单</p>\n<p>缺点是：</p>\n<p>1.主键出现冗余，需要管理冗余例</p>\n<p>2.会引起表连接JOIN操作(增加CPU开销)可以通过在业务服务器上进行join来减少数据库压力</p>\n<p>3.依然存在单表数据量过大的问题(需要水平拆分)</p>\n<p>4.事务处理复杂</p>\n<p>4.3 水平切分</p>\n<p>4.3.1按照订单号做Hash分散订单数据</p>\n<p>把订单号看作是一个字符串，做hash，分散到多个服务器。具体分到哪个库、哪个表存储数据，订单号的数字来记录。以微信红包为例：订单分库分表，是对订单号进行hash计算。然后订单的末尾3个数包含了库名称、表名称。如：可参考美团的方法。</p>\n<p>那么如何查询某用户的所有订单呢？由于根据订单号来分散数据的，他们的订单分散在了多个库、多个表中。</p>\n<p>建异构索引表</p>\n<p>同样如何应付多维度的检索，例如所有订单的分页、订单状态检索、根据促销维度检索等</p>\n<p>做数据冗余、存储多份。或者用ES来处理</p>\n<p>4.3.2按照用户id来切分</p>\n<p>按照用户来切分数据有两种思路：</p>\n<p>一种方案是某个范围的uid订单到哪些库。例如0到2000w uid对应订单数据到a库，2000w到4000w对应订单到b库。</p>\n<p>缺点：某个范围内的用户，下单量比较多，那么造成这个库的压力特别大，数据分布极为不均衡。</p>\n<p>优点：查询指定用户的所有订单，避免了跨库跨表查询。因为用户的id是规定不变的，那么计算出的值永远是固定的某库某表。那么a用户的所有订单都是在某库某表里面。</p>\n<p>第二种方案是使用uid取模运算，第二种方案业界用的比较多。</p>\n<p>具体实现如下：</p>\n<p>按照用户id作为key来切分订单数据，具体如下：</p>\n<p>1、 库名称定位：用户id末尾4位 Mod 32。</p>\n<p>Mod表示除以一个数后，取余下的数。比如除以32后，余下8，余数就是8。</p>\n<p>代码符号是用%表示：15%4=3。</p>\n<p>2、表名称定位：（用户id末尾4位 Dev 32） Mod 32。</p>\n<p>Dev表示除以一个数，取结果的整数。比如得到结果是25.6，取整就是25。</p>\n<p>代码用/来表示：$get_int = floor(15/4)。15除以4，是一个小数3.75，向下取整就是3。一定是向下取整，向上取整就变成了4了。</p>\n<p>按照上面的规则：总共可以表示多少张表呢？32个库*每个库32个表=1024张表。如果想表的数量小，就把32改小一些。</p>\n<p>上面是用计算机术语来表示， 下面用通俗的话描述。</p>\n<p>1、库名称计算</p>\n<p>用户id的后4位数，取32的模(取模就是除以这个数后，余多少)。余下的数，是0-31之间。</p>\n<p>这样可以表示从0-31之间，总共32个数字。用这个32个数字代表着32个库名称：order_db_0、order_db_2…………………….order_db_31</p>\n<p>2、表名称计算</p>\n<p>最后要存储定到哪个表名里面去呢？</p>\n<p>用户id的最后4位数，除以32，取整数。将整数除以32，得到余数，能够表示从0-31之间32个数字，表示表名称。</p>\n<p>表名称类似这样：order_tb_1、order_tb_2……………………..order_tb_31。一个库里面，总共32个表名称。</p>\n<p>比如用户id：19408064，用最后4位数字8064除以32，得到是251.9，取它的整数是251。</p>\n<p>接着将251除以32，取余数，余数为27。</p>\n<p>为了保持性能，每张表的数据量要控制。单表可以维持在一千万-5千万行的数据。1024*一千万。这个已经是很大的数据量了。</p>\n<p>4.3.4按订单的时间来分表</p>\n<p>一个月一张，一年一张表，用户的所有订单，会分散在不同的库、不同的表中。这个可以根据实际的应用场景来使用。适合于经常只查询某一时间段的数据。因为这个种分表方法会有几个缺点，如果查询某个用户所有订单数据，就会出现跨库、跨表，效率会低。</p>\n<p>4.4 阿里云的RDS分库分表方案。DRDS（Distributed Relational Database Service，分布式关系型数据库服务 ）是阿里巴巴自主研发，致力于解决单机数据库瓶颈而推出的分布式数据库中间件产品。DRDS高度兼容Mysql协议和语法，支持水平拆分、平滑扩容、弹性扩展、透明读写分离和分布式事务等特性，具备分布式数据库全生命周期的运维管控能力。</p>\n<p><img src=\"/images/v2-26e9c6b2d131c19e25d7283f37940ae1_720w.jpg\" alt=\"img\"></p>\n<p>DRDS 支持库级拆分、表级拆分和分库分表拆分。拆分键暂时只支持单个字段。<br>分库键：DRDS 根据分库键的值将数据水平拆分到后端的每一个 RDS 分库里。键值相同的数据，一定会位于同一个 RDS 数据库里。<br>分表键：每一张逻辑表都可以定义自己的分表键，键值相同的数据，一定会位于同一个 RDS 数据表里。</p>\n<p><img src=\"/images/v2-ae88013d0531eac5ebc96fad2e4f8594_720w.jpg\" alt=\"img\"></p>\n<p>网上数据：贝聊大概有几万所幼儿园，上亿数据量，效果比较 ：</p>\n<p>1、 性能大幅度提升<br>响应速度提升5至10倍，以当时获取班级动态列表接口为例：<br>分库分表实施前：响应时间大致为200ms至1500ms级之间。<br>分库分表实施后：响应时间提升至大致为30ms至300ms之间。<br>2、 可方便快速进行横向扩容<br>如果需要扩容，直接按照阿里云DRDS指引，增加新的分库即可。<br>3、 架构的优化<br>独立动态业务，通过Dubbo提供服务，对系统进行解耦，让业务具备快速横向扩容能力。<br>4、后遗症<br>独立后，暂时没有做分布式事务，在业务中需要避免跨库事务。</p>\n<ol>\n<li>分库分表存在的问题及解决方案</li>\n<li>事务问题</li>\n</ol>\n<p>在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p>\n<ol>\n<li>跨库跨表join问题</li>\n</ol>\n<p>在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。</p>\n<p>解决方法：建立异构索引表。以此为例，建立用户id与订单号的索引关系表。</p>\n<p>例如：假设是以订单号分散订单数据。需求是查询某个用户的所有订单。如果知道某个用户的所有订单。那么就可以根据订单号定位到表名称。假设是以用户id分散订单数据的，那么我们只要知道这个订单号是谁的（得到了用户id）,就知道去哪个库、哪个表查询数据了。</p>\n<p>索引表里包括两项：订单号、用户编号。当数据量越来越大时，索引表也不能用单个表存储了，也需要分库分表了，因为关系一一对应，不会变化，所以也可以存在redis里。这样速度就比较快了。</p>\n<p>五、总结</p>\n<p>根据公司的adu来看，包括与美团淘宝的比较而言，可以通过业务来分库，并不是一定要做以id取模来分库，否则要更改的东西比较 大。另外分表的话可以水平和垂直混用，包括适当的场景用ES.而具体实施的时候参美团的三个步骤执行，先老库旧库时间使用，然后监控情况，待新库稳定之后再切到新库。另外以于一些开源的工具可以参考使用。如果按业务进行拆分的话，像报表统计相关的可以分离，教研相关业务独立拆分，用户相关、权限管理可独立拆分成一个模块，小程序相关独立拆分，cc业务独立拆分，订单业务独立拆分、app相关独立拆分、市场推广独立拆分。原则是高聚合，低耦合。具体根据公司的实际应用场景再有所调整。</p>\n<p>文献</p>\n<p>企业IT架构转型之道 阿里巴巴中台战略思想与架构实践 钟华</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>一、分库分表背景</strong></p>\n<ol>\n<li>为什么分库</li>\n</ol>\n<p>1.1数据库最容易产生性能瓶颈的服务组件。数据库连接数资源捉襟见肘和数据库因为表多、数据多造成的性能问题。这里以淘宝为例，在淘宝平台向共享服务体系改造的过程中，通过各个服务中心拥有各自独立数据库的方式，即采用数据库垂直分区的方式对业务数据进行分区。</p>\n<p>1.2单一服务中心的数据访问压力也必然会达到单机数据库的承载上限，所以在进行服务化改造的同一时间段内，需要对数据库能力做扩展的工作。</p>\n<p>1.3.单台数据库 这里以mysql为例，mysql数据库，当访问连接数过多时，就会出现‘too many connections’的错误，一般来说是访问量太大或者数据库设置的最大连接数太小的原因。Mysql默认的最大连接数为100.这个连接连接数可以修改，而mysql服务允许的最大连接数为16384.虽然可以通过连接池可以一定程序上优化连接，但是当数据量过大时，单台数据库显示已经不能支撑应用服务器的访问。所以就需要做分库，具体分库方法下面会有详细介绍。</p>\n<p>1.4 在实际的应用中，绝大部分情况都是读远大于写。Mysql提供了读写分离的机制，所有的写操作都必须对应到Master，读操作可以在 Master和Slave机器上进行，Slave与Master的结构完全一样，一个Master可以有多个Slave,甚至Slave下还可以挂 Slave,通过此方式可以有效的提高DB集群的 QPS.</p>\n<p>所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>\n<p>此外，可以看出Master是集群的瓶颈，当写操作过多，会严重影响到Master的稳定性，如果Master挂掉，整个集群都将不能正常工作。</p>\n<p>所以</p>\n<p>\\1. 当读压力很大的时候，可以考虑添加Slave机器的分式解决，但是当Slave机器达到一定的数量就得考虑分库了。</p>\n<p>\\2. 当写压力很大的时候，就必须得进行分库操作。</p>\n<p>2.为什么分表</p>\n<p>有一组数据可以参考：</p>\n<p>基本指标:</p>\n<p>库物理文件大小&lt;100G</p>\n<p>表&lt;100</p>\n<p>字段&lt;200</p>\n<p>单表记录数&lt;500W</p>\n<p>经测试在单表1000万条记录一下,写入读取性能是比较好的. 这样在留点buffer,那么单表全是数字类型的保持在800万条记录以下, 有字符型的单表保持在500万以下.如果按 100库100表来规划,如用户业务:</p>\n<p>500万<em>100</em>100 = 50000000万 = 5000亿记录.供参考,具体按按业务做规划.</p>\n<p>3.什么是分区</p>\n<p>分表是将一张表分成N多个小表，分区是把一张表的数据分成N多个区块，这些区块可以在同一个磁盘上，也可以在不同的磁盘上。mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件，一个.MYD数据文件，.MYI索引文件，.frm表结构文件。</p>\n<p><strong>二、现状</strong></p>\n<p>2.1淘宝的解决方案</p>\n<p>首先是实施的是数据库的读写分离。读写分离的基本原理是让主数据库处理事务性增、改、删（Insert、update、delete）操作，而从数据库专门负责处理查询（select）操作，在数据库的后台会把事务性操作导致的主数据库中的数据变更同步到集群中的从数据库。</p>\n<p><img src=\"/images/v2-cdca1f51c4a3bef0b30221a947144bdd_720w.jpg\" alt=\"img\"></p>\n<p>采用读写分离的方式，拓展了数据库对数据读的处理能力，整体上也大大提升了数据库的读写能力。但是这样的架构在主数据库的数据写入能力依然没法扩展，一旦数据库写压力比较大时，则对整个平台带来非常大的影响。而且数据库单表的数据量是有限制的，当单表数据量达到一定数量后数据库性能会出现显著下降的情况，所以简单的读写分离不能满足淘宝的发展的要求。</p>\n<p>为了更好的在数据库层面支持好淘宝的业务，在2008年，阿里巴巴内部开始了分布式数据库的研发工作，相关的平台和工具陆续登上了淘宝技术发展史的历史舞台。</p>\n<p>2006年阿里巴巴以开源的形式研发了Cobar这一关系型数据库的分布式处理系统。当时Cobar平均每天处理近50亿次的SQL操作，但是随着阿里巴巴业务场景越来越复杂，有以下缺点：</p>\n<ol>\n<li>不支持跨库情况下的连接、分页、排序、子查询</li>\n<li>SET语句执行会被忽略，处理事务和字符集设置除外。</li>\n<li>分库情况下，insert语句必须包含拆分字段列名</li>\n<li>分库情况下，update语句不能更新拆分字段的值</li>\n<li>不支持SAVEPOINT操作</li>\n<li>使用JBDC时，不支持rewriteBatchStatements = true参数设置</li>\n</ol>\n<p>等</p>\n<p>2008年内部 在Cobar的基础上重新研发了分布式数据层框架TDDL（外号头都大了）</p>\n<p><img src=\"/images/v2-9f56d1d058e3a87a8c6be5b58696f14b_720w.jpg\" alt=\"img\"></p>\n<p><img src=\"/images/v2-c526027f5f2dae54753239d5d9bd277b_720w.jpg\" alt=\"img\"></p>\n<p>TDDL提供了以下优点：</p>\n<ol>\n<li>数据库主备和动态切换</li>\n<li>带权重的读写分离</li>\n<li>单线程读重试</li>\n<li>集中式数据源信息管理和动态变更</li>\n<li>支持MySQL和Oracle数据库</li>\n<li>基于JDBC规范，很容易扩展支持实现JDBC规范的数据源</li>\n<li>无Server、client-jar形式存在，应用直连数据库</li>\n<li>读写次数，并发度流程控制，动态变更</li>\n<li>可分析的日志打印，日志流控，动态变更。</li>\n</ol>\n<p>阿里巴巴分库分表的几个原则：</p>\n<ol>\n<li>数据尽可能的平均拆分</li>\n<li>尽可能的减少事务边界 所谓的事务边界 指单个SQL语句在后端数据库上同时执行的数量。因为事务边界越大，系统的锁冲突概率就越高，系统越难以扩展，整体性能越低。</li>\n<li>异构索引表尽量降低全表扫描频率 这个是针对假如数据是按订单id进行分拆，当用户想查看自己的订单时，针对这种场景，常采用异构索引表来解决，即采用异步机制将原表内的每一次创建或更新，都换另一个维度保存一份完整的数据表或索引表。本质上这是互联网公司很多时候采用的一个解决思路：拿空间换时间 。</li>\n</ol>\n<p><img src=\"/images/v2-60336a35f872a24562326304943292b9_720w.jpg\" alt=\"img\"></p>\n<p>实现异构索引的方式，也就是阿里巴巴内部目前采用的方式 ，通过一填名为精卫填海的产品实现了数据的异构复制。</p>\n<ol>\n<li>将多条件频繁查询引入搜索引擎平台 比如Iucene、Solr、ElasticSearch等搜索引擎。</li>\n</ol>\n<p>总结</p>\n<p>从系统的风险的角度考虑，以82法则，在实际中，我们仅针对那些在80%情况下访问的那20%的场景进行如数据异构索引这样的处理，达到这类场景的性能最优化，而以其他80%偶尔出现跨库join、全表扫描的场景，采用最为简单直接的方式往往是最有效的方式。</p>\n<p>2.2美团的解决方案</p>\n<p>通常有两种方案。第一种方案是直接对现有的商品库进行垂直拆分，可以缓解目前写峰值QPS过大、DB主从延迟的问题。第二种方案是对现有的商品库大表进行分库分表，从根本上解决现有问题。方案一实施起来周期较短，但只能解决一时之痛，由此可见，分库分表是必然的。</p>\n<p>在确定分库分表的方案之后，调研了外卖订单、结算以及主站等业务的分库分表实现方案，也调研了业界很多分库分表中间件。在综合考虑性能、稳定性及实现成本的前提下，最终决定自主研发客户端分库分表中间件MTDDL来支撑外卖商品分库分表项目，这也就是MTDDL的由来。</p>\n<p>在MTDDL的设计研发过程中，我们充分考虑了MTDDL的通用性、可扩展性、功能的全面性和接入的便利性。到目前为止一共开发了四期，实现了MySQL动态数据源、读写分离、分布式唯一主键生成器、分库分表、连接池及SQL监控、动态化配置等一系列功能，支持分库分表算法、分布式唯一主键生成算法的高可扩展性，而且支持全注解的方式接入，业务方不需要引入任何配置文件。</p>\n<p><img src=\"/images/v2-ddda0732607e2bcb365960c675e0dc71_720w.jpg\" alt=\"img\"></p>\n<p>分布式唯一主键生成器</p>\n<p>众所周知，分库分表首先要解决的就是分布式唯一主键的问题，业界也有很多相关方案（大众点评用的是时间戳+用户标识码+随机数）：</p>\n<p><img src=\"/images/v2-c52ddb056dbd39595e7c6f5b2c4fb3b5_720w.jpg\" alt=\"img\"></p>\n<p>综上，方案3的缺点可以通过一些手段避免，但其他方案的缺点不好处理，所以选择第3种方案。目前该方案已由美团点评技术工程部实现——分布式ID生成系统Leaf，MTDDL集成了此功能。</p>\n<p>美团分库分表流程</p>\n<p><img src=\"/images/v2-94c4670cb6b6099055a5146f1a034b9b_720w.jpg\" alt=\"img\"></p>\n<p>分库分表取模算法：</p>\n<p>分库分表目前默认使用的是取模算法，分表算法为 (#shard_key % (group_shard_num * table_shard_num))，分库算法为 (#shard_key % (group_shard_num * table_shard_num)) / table_shard_num，其中group_shard_num为分库个数，table_shard_num为每个库的分表个数。</p>\n<p>例如把一张大表分成100张小表然后散到2个库，则0-49落在第一个库、50-99落在第二个库。核心实现如下：</p>\n<p><img src=\"/images/v2-73c1d9300839c0ee560c9bfcc685d653_720w.jpg\" alt=\"img\"></p>\n<p>大众点评订单表早已超过200G，由于查询维度较多，即使加了两个从库，优化索引，仍然存在很多查询不理想的情况。</p>\n<p>先对订单库进行垂直切分，将原有的订单库分为基础订单库、订单流程库等。</p>\n<p><img src=\"/images/v2-432781b10f8582f5bf192e1a050e99a1_720w.jpg\" alt=\"img\"></p>\n<p>垂直切分缓解了原来单集群的压力，但是在抢购时仍然捉襟见肘。原有的订单模型已经无法满足业务需求，于是我们设计了一套新的统一订单模型，为同时满足C端用户、B端商户、客服、运营等的需求，我们分别通过用户ID和商户ID进行切分，并通过PUMA（我们内部开发的MySQL binlog实时解析服务）同步到一个运营库。</p>\n<p><img src=\"/images/v2-373b769b0466f324fd0553f5074d1b37_720w.jpg\" alt=\"img\"></p>\n<p>切分策略</p>\n<ol>\n<li>查询切分</li>\n</ol>\n<p>将ID和库的Mapping关系记录在一个单独的库中。</p>\n<p><img src=\"/images/v2-eb03c274f799a5147abc23bb99a56b4c_720w.jpg\" alt=\"img\"></p>\n<p>优点：ID和库的Mapping算法可以随意更改</p>\n<p>缺点：引入额外的单点</p>\n<ol>\n<li>范围切分</li>\n</ol>\n<p>比如按照时间区间或ID区间来切分</p>\n<p><img src=\"/images/v2-b8854e3034ce49c2f8d652394c2328ac_720w.jpg\" alt=\"img\"></p>\n<p>优点：单表大小可控，天然水平扩展</p>\n<p>缺点：无法解决集中写入瓶颈的问题</p>\n<ol>\n<li>hash切分</li>\n</ol>\n<p>一般采用Mod来切分，下面着重讲一下Mod的策略</p>\n<p><img src=\"/images/v2-104267f964da011318238d357f05bb6c_720w.jpg\" alt=\"img\"></p>\n<p>数据水平切分后我们希望是一劳永逸或者易于水平扩展的，所以推荐mod2^n这种一致性Hash</p>\n<p>以统一订单库为例，我们分库分表的方案是32*32的，即通过UserId后四位mod32到32个库中，同时再将UserId后四位Div 32 Mod 32将每个库分为32个表，共计分为1024个表。线上部署情况为8个集群（主从），每个集群4个库。为什么说这种方式易于水平扩展呢？</p>\n<p>分析两种场景。</p>\n<p>场景一：数据库性能达到瓶颈</p>\n<p>方法一</p>\n<p>按照现有规则不变，可以直接扩展到32个数据库集群。</p>\n<p><img src=\"/images/v2-65d90f64aa52be10b9bdc1b8042e9e31_720w.jpg\" alt=\"img\"></p>\n<p>方法二</p>\n<p>如果32个集群也无法满足需求，那么将分库分表规则调整为（32<em>2^n）</em>(32/2^n)可以达到最多1024个集群。</p>\n<p>场景二：单表容量达瓶颈（或者1024已经无法满足）</p>\n<p>方法：</p>\n<p><img src=\"/images/v2-c431ecdd67246b4e7745d58155d4e64d_720w.jpg\" alt=\"img\"></p>\n<p>假如单表都已突破200G,200<em>1024=200T（按照现有的订单模型算了算，大概1000万亿订单），32</em>（32*2^n），这时分库规则不变，单库里的表再进行裂变，当然目前的订单规则下（userId后四位mod）还是有极限的。因为只有四位，所以最多拆8192个表。</p>\n<p>唯一ID方案</p>\n<p>这个方案也有很多种，主流的有那么几种：</p>\n<ol>\n<li>利用数据库自增ID</li>\n</ol>\n<p>优点：最简单。缺点：单点风险，单机性能瓶颈。</p>\n<p>\\2. 利用数据库集群并设置相应的步长（Flickr方案）</p>\n<p>优点：高可用、ID较简洁。 缺点：需要单独的数据库集群。</p>\n<p>\\3. Twitter Snowflake</p>\n<p>优点：高性能高可用、易拓展。 缺点：需要独立的集群以及ZK。</p>\n<p>\\4. 一大波GUID、Random算法</p>\n<p>优点：简单。 缺点：生成ID较长，有重复几率。</p>\n<p>美团的方案：为了减少运营成本并减少额外的风险，排除了所有需要独立集群的方案，采用带有业务属性的议案： 时间戳+用户标识码+随机数</p>\n<p>有以下几个好处：</p>\n<p>1.方便、成本低。</p>\n<p>2.基本无重复的可能。</p>\n<p>3.自带分库规则，这里的用户标识码即为用户ID的后四位，在查询的场景下，只需要订单号就可以匹配到相应的库表而无需用户ID，只取四位是希望订单号尽可能的短一些，并且评估下来四位已经足够。</p>\n<p>4.可排序，因为时间戳在最前面。</p>\n<p>其他问题</p>\n<p>事务支持：我们是将整个订单领域聚合体切分，维度一致，所以对聚合体的事务是支持的。</p>\n<p>复杂查询：垂直切分后，就跟join说拜拜了；水平切分后，查询的条件一定要在切分的维度内，比如查询具体某个用户下的各位订单等；禁止不带切分的维度的查询，即使中间件可以支持这种查询，可以在内存中组装，但是这种需求往往不应该在在线库查询，或者可以通过其他方法转换到切分的维度来实现。</p>\n<p>数据迁移</p>\n<p>数据库拆分一般是业务发展到一定规模之后的优化和重构，为了支持业务快速上线，很难一开始就分库分表，垂直拆分还好办，改改数据源就搞定了，一旦开始水平拆分，数据清洗是一个大问题。为此，经历了以下几个阶段。</p>\n<p>第一阶段：</p>\n<p><img src=\"/images/v2-73771a9cec11fc86e5aa0145885b05c8_720w.jpg\" alt=\"img\"></p>\n<p>数据库双写（事务成功以老模型为准），查询走老模型</p>\n<p>每日job数据对账（通过DW），并将差异补平</p>\n<p>通过job导历史数据</p>\n<p>第二阶段</p>\n<p><img src=\"/images/v2-86d44b4b844c130414c4653f215ec149_720w.jpg\" alt=\"img\"></p>\n<p>历史数据导入完毕并且数据对账无误</p>\n<p>依然是数据库双写，但是事务成功与否以新模型为准，在线查询切换新模型</p>\n<p>每日job数据对账，将差异补平</p>\n<p>第三阶段</p>\n<p><img src=\"/images/v2-fe9119746d34b5396e48eac6ecd16746_720w.jpg\" alt=\"img\"></p>\n<p>老模型不同同步写入，仅当订单有终态时才会异步补上。</p>\n<p>此阶段只有离线数据依然依赖老的模型，并且下游的依赖非常多，待DW改造完就可以完全废除老模型了。</p>\n<p>总结</p>\n<p>1.并非所有表都需要水平拆分，要看增长的类型和速度，水平拆分是大招，拆分后会增加开发的复杂度，不到万不得已不使用。</p>\n<p>2.在大规模并发的业务上，尽量做到在线查询和离线查询隔离，交易查询和运营/客服查询隔离。</p>\n<p>3.拆分维度的选择很重要，要尽可能在解决拆分前问题的基础上，便于开发。</p>\n<p>4.数据库没你想象的那么坚强，需要保护，尽量使用简单的、良好索引的查询，这样数据库整体可控，也易于长期容量规划以及水平扩展。</p>\n<p><strong>三、分库方案</strong></p>\n<p>3.1垂直切分</p>\n<p>按业务切分，将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如用户相关、教务相关、cc业务相关、报表相关等。</p>\n<p>3.2水平切分</p>\n<p>当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如userID散列，进行划分，然后存储到多个结构相同的表，和不同的库上。例如，我们的userDB中的用户数据表中，每一个表的数据量都很大，就可以把userDB切分为结构相同的多个userDB：part0DB、part1DB等，再将userDB上的用户数据表userTable，切分为很多userTable：userTable0、userTable1等，然后将这些表按照一定的规则存储到多个userDB上。</p>\n<p>3.3切分的选择</p>\n<p>应该使用哪一种方式来实施数据库分库分表，这要看数据库中数据量的瓶颈所在，并综合项目的业务类型进行考虑。</p>\n<p>如果数据库是因为表太多而造成海量数据，并且项目的各项业务逻辑划分清晰、低耦合，那么规则简单明了、容易实施的垂直切分必是首选。而如果数据库中的表并不多，但单表的数据量很大、或数据热度很高，这种情况之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估，考虑数据平均和负载平均，后期也将对项目人员及应用程序产生额外的数据管理负担。</p>\n<p>在现实项目中，往往是这两种情况兼而有之，这就需要做出权衡，甚至既需要垂直切分，又需要水平切分。</p>\n<p><strong>四、分表方案</strong></p>\n<p>4.1利用数据库的merge存储引擎来实现分表</p>\n<p>优势：不用改代码。</p>\n<p>缺点：有一些限制，必须是MyISAM存储引擎，分表的id不能是自增的，每个分表的表结构必须相同，Mysql必须具有存储分一数据文件和索引文件的目录的读写权限，必须启用mysql的符号链接支持功能。</p>\n<p>4.2垂直切分</p>\n<p>垂直拆分是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放入到用户库，把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联。</p>\n<p>比如原始用户表是：</p>\n<p><img src=\"/images/v2-f9315b646c72eb17564ebc0507458b14_720w.jpg\" alt=\"img\"></p>\n<p>垂直拆分后的表是：</p>\n<p><img src=\"/images/v2-31eb992f13d3222fcfc4cd222158a702_720w.jpg\" alt=\"img\"></p>\n<p>垂直拆分的优点是：</p>\n<p>\\1. 可以使得数据变小，一个数据块（block）就能存放更多的数据，在查询时就会减少I/O次数（每次查询时读取的Block就少）</p>\n<p>\\2. 可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起</p>\n<p>\\3. 数据维护简单</p>\n<p>缺点是：</p>\n<p>1.主键出现冗余，需要管理冗余例</p>\n<p>2.会引起表连接JOIN操作(增加CPU开销)可以通过在业务服务器上进行join来减少数据库压力</p>\n<p>3.依然存在单表数据量过大的问题(需要水平拆分)</p>\n<p>4.事务处理复杂</p>\n<p>4.3 水平切分</p>\n<p>4.3.1按照订单号做Hash分散订单数据</p>\n<p>把订单号看作是一个字符串，做hash，分散到多个服务器。具体分到哪个库、哪个表存储数据，订单号的数字来记录。以微信红包为例：订单分库分表，是对订单号进行hash计算。然后订单的末尾3个数包含了库名称、表名称。如：可参考美团的方法。</p>\n<p>那么如何查询某用户的所有订单呢？由于根据订单号来分散数据的，他们的订单分散在了多个库、多个表中。</p>\n<p>建异构索引表</p>\n<p>同样如何应付多维度的检索，例如所有订单的分页、订单状态检索、根据促销维度检索等</p>\n<p>做数据冗余、存储多份。或者用ES来处理</p>\n<p>4.3.2按照用户id来切分</p>\n<p>按照用户来切分数据有两种思路：</p>\n<p>一种方案是某个范围的uid订单到哪些库。例如0到2000w uid对应订单数据到a库，2000w到4000w对应订单到b库。</p>\n<p>缺点：某个范围内的用户，下单量比较多，那么造成这个库的压力特别大，数据分布极为不均衡。</p>\n<p>优点：查询指定用户的所有订单，避免了跨库跨表查询。因为用户的id是规定不变的，那么计算出的值永远是固定的某库某表。那么a用户的所有订单都是在某库某表里面。</p>\n<p>第二种方案是使用uid取模运算，第二种方案业界用的比较多。</p>\n<p>具体实现如下：</p>\n<p>按照用户id作为key来切分订单数据，具体如下：</p>\n<p>1、 库名称定位：用户id末尾4位 Mod 32。</p>\n<p>Mod表示除以一个数后，取余下的数。比如除以32后，余下8，余数就是8。</p>\n<p>代码符号是用%表示：15%4=3。</p>\n<p>2、表名称定位：（用户id末尾4位 Dev 32） Mod 32。</p>\n<p>Dev表示除以一个数，取结果的整数。比如得到结果是25.6，取整就是25。</p>\n<p>代码用/来表示：$get_int = floor(15/4)。15除以4，是一个小数3.75，向下取整就是3。一定是向下取整，向上取整就变成了4了。</p>\n<p>按照上面的规则：总共可以表示多少张表呢？32个库*每个库32个表=1024张表。如果想表的数量小，就把32改小一些。</p>\n<p>上面是用计算机术语来表示， 下面用通俗的话描述。</p>\n<p>1、库名称计算</p>\n<p>用户id的后4位数，取32的模(取模就是除以这个数后，余多少)。余下的数，是0-31之间。</p>\n<p>这样可以表示从0-31之间，总共32个数字。用这个32个数字代表着32个库名称：order_db_0、order_db_2…………………….order_db_31</p>\n<p>2、表名称计算</p>\n<p>最后要存储定到哪个表名里面去呢？</p>\n<p>用户id的最后4位数，除以32，取整数。将整数除以32，得到余数，能够表示从0-31之间32个数字，表示表名称。</p>\n<p>表名称类似这样：order_tb_1、order_tb_2……………………..order_tb_31。一个库里面，总共32个表名称。</p>\n<p>比如用户id：19408064，用最后4位数字8064除以32，得到是251.9，取它的整数是251。</p>\n<p>接着将251除以32，取余数，余数为27。</p>\n<p>为了保持性能，每张表的数据量要控制。单表可以维持在一千万-5千万行的数据。1024*一千万。这个已经是很大的数据量了。</p>\n<p>4.3.4按订单的时间来分表</p>\n<p>一个月一张，一年一张表，用户的所有订单，会分散在不同的库、不同的表中。这个可以根据实际的应用场景来使用。适合于经常只查询某一时间段的数据。因为这个种分表方法会有几个缺点，如果查询某个用户所有订单数据，就会出现跨库、跨表，效率会低。</p>\n<p>4.4 阿里云的RDS分库分表方案。DRDS（Distributed Relational Database Service，分布式关系型数据库服务 ）是阿里巴巴自主研发，致力于解决单机数据库瓶颈而推出的分布式数据库中间件产品。DRDS高度兼容Mysql协议和语法，支持水平拆分、平滑扩容、弹性扩展、透明读写分离和分布式事务等特性，具备分布式数据库全生命周期的运维管控能力。</p>\n<p><img src=\"/images/v2-26e9c6b2d131c19e25d7283f37940ae1_720w.jpg\" alt=\"img\"></p>\n<p>DRDS 支持库级拆分、表级拆分和分库分表拆分。拆分键暂时只支持单个字段。<br>分库键：DRDS 根据分库键的值将数据水平拆分到后端的每一个 RDS 分库里。键值相同的数据，一定会位于同一个 RDS 数据库里。<br>分表键：每一张逻辑表都可以定义自己的分表键，键值相同的数据，一定会位于同一个 RDS 数据表里。</p>\n<p><img src=\"/images/v2-ae88013d0531eac5ebc96fad2e4f8594_720w.jpg\" alt=\"img\"></p>\n<p>网上数据：贝聊大概有几万所幼儿园，上亿数据量，效果比较 ：</p>\n<p>1、 性能大幅度提升<br>响应速度提升5至10倍，以当时获取班级动态列表接口为例：<br>分库分表实施前：响应时间大致为200ms至1500ms级之间。<br>分库分表实施后：响应时间提升至大致为30ms至300ms之间。<br>2、 可方便快速进行横向扩容<br>如果需要扩容，直接按照阿里云DRDS指引，增加新的分库即可。<br>3、 架构的优化<br>独立动态业务，通过Dubbo提供服务，对系统进行解耦，让业务具备快速横向扩容能力。<br>4、后遗症<br>独立后，暂时没有做分布式事务，在业务中需要避免跨库事务。</p>\n<ol>\n<li>分库分表存在的问题及解决方案</li>\n<li>事务问题</li>\n</ol>\n<p>在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p>\n<ol>\n<li>跨库跨表join问题</li>\n</ol>\n<p>在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。</p>\n<p>解决方法：建立异构索引表。以此为例，建立用户id与订单号的索引关系表。</p>\n<p>例如：假设是以订单号分散订单数据。需求是查询某个用户的所有订单。如果知道某个用户的所有订单。那么就可以根据订单号定位到表名称。假设是以用户id分散订单数据的，那么我们只要知道这个订单号是谁的（得到了用户id）,就知道去哪个库、哪个表查询数据了。</p>\n<p>索引表里包括两项：订单号、用户编号。当数据量越来越大时，索引表也不能用单个表存储了，也需要分库分表了，因为关系一一对应，不会变化，所以也可以存在redis里。这样速度就比较快了。</p>\n<p>五、总结</p>\n<p>根据公司的adu来看，包括与美团淘宝的比较而言，可以通过业务来分库，并不是一定要做以id取模来分库，否则要更改的东西比较 大。另外分表的话可以水平和垂直混用，包括适当的场景用ES.而具体实施的时候参美团的三个步骤执行，先老库旧库时间使用，然后监控情况，待新库稳定之后再切到新库。另外以于一些开源的工具可以参考使用。如果按业务进行拆分的话，像报表统计相关的可以分离，教研相关业务独立拆分，用户相关、权限管理可独立拆分成一个模块，小程序相关独立拆分，cc业务独立拆分，订单业务独立拆分、app相关独立拆分、市场推广独立拆分。原则是高聚合，低耦合。具体根据公司的实际应用场景再有所调整。</p>\n<p>文献</p>\n<p>企业IT架构转型之道 阿里巴巴中台战略思想与架构实践 钟华</p>\n"},{"title":"JVM 垃圾回收","date":"2020-05-26T06:44:29.000Z","_content":"\n问题答案在文中都有提到\n\n- 如何判断对象是否死亡（两种方法）。\n- 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。\n- 如何判断一个常量是废弃常量\n- 如何判断一个类是无用的类\n- 垃圾收集有哪些算法，各自的特点？\n- HotSpot 为什么要分为新生代和老年代？\n- 常见的垃圾回收器有哪些？\n- 介绍一下 CMS,G1 收集器。\n- Minor Gc 和 Full GC 有什么不同呢？\n\n### 本文导火索\n\n![img](/images/1a1742222.png)\n\n当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。\n\n## 1 揭开 JVM 内存分配与回收的神秘面纱\n\nJava 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 **堆** 内存中对象的分配与回收。\n\nJava 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**\n\n**堆空间的基本结构：**\n\n![img](/images/5a086e7bb93e69e842e706e67.png)\n\n上图所示的 eden 区、s0(\"From\") 区、s1(\"To\") 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(\"To\")，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。经过这次GC后，Eden区和\"From\"区已经被清空。这个时候，\"From\"和\"To\"会交换他们的角色，也就是新的\"To\"就是上次GC前的“From”，新的\"From\"就是上次GC前的\"To\"。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，\"To\"区被填满之后，会将所有对象移动到老年代中。\n\n![545352](/images/25453525.jpg)\n\n### 1.1 对象优先在 eden 区分配\n\n目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。\n\n在测试之前我们先来看看 **Minor GC 和 Full GC 有什么不同呢？**\n\n- **新生代 GC（Minor GC）**:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。\n- **老年代 GC（Major GC/Full GC）**:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。\n\n> [issue#664 ](https://github.com/Snailclimb/JavaGuide/issues/664):**guang19** 补充：个人在网上查阅相关资料的时候发现如题所说的观点。有的文章说 Major GC 与 Full GC 一样是属于对老年代的GC，也有的文章说 Major GC 是对整个堆区的GC，所以这点需要各位同学自行分辨 Major GC 语义。见: [知乎讨论](https://www.zhihu.com/question/41922036)\n\n**测试：**\n\n```java\npublic class GCTest {\n\n\tpublic static void main(String[] args) {\n\t\tbyte[] allocation1, allocation2;\n\t\tallocation1 = new byte[30900*1024];\n\t\t//allocation2 = new byte[900*1024];\n\t}\n}\n```\n\n通过以下方式运行： ![img](/images/335302e6a7067.png)\n\n添加的参数：`-XX:+PrintGCDetails` ![img](/images/687474703a.png)\n\n运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：\n\n![img](/images/68747470.png)\n\n从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？\n\n```java\nallocation2 = new byte[900*1024];\n```\n\n![img](/images/383738352e6a7067.png)\n\n**简单解释一下为什么会出现这种情况：** 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 **分配担保机制** 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：\n\n```java\npublic class GCTest {\n\n\tpublic static void main(String[] args) {\n\t\tbyte[] allocation1, allocation2,allocation3,allocation4,allocation5;\n\t\tallocation1 = new byte[32000*1024];\n\t\tallocation2 = new byte[1000*1024];\n\t\tallocation3 = new byte[1000*1024];\n\t\tallocation4 = new byte[1000*1024];\n\t\tallocation5 = new byte[1000*1024];\n\t}\n}\n```\n\n### 1.2 大对象直接进入老年代\n\n大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。\n\n**为什么要这样呢？**\n\n为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。\n\n### 1.3 长期存活的对象将进入老年代\n\n既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。\n\n如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。\n\n### 1.4 动态对象年龄判定\n\n大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。\n\n> 修正（[issue552](https://github.com/Snailclimb/JavaGuide/issues/552)）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。\n>\n> **动态年龄计算的代码如下**\n>\n> ```java\n> uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {\n> \t//survivor_capacity是survivor空间的大小\n> size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);\n> size_t total = 0;\n> uint age = 1;\n> while (age < table_size) {\n>  total += sizes[age];//sizes数组是每个年龄段对象大小\n>  if (total > desired_survivor_size) break;\n>  age++;\n> }\n> uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;\n> \t...\n> }\n> ```\n>\n> 额外补充说明([issue672](https://github.com/Snailclimb/JavaGuide/issues/672))：**关于默认的晋升年龄是15，这个说法的来源大部分都是《深入理解Java虚拟机》这本书。** 如果你去Oracle的官网阅读[相关的虚拟机参数](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)，你会发现`-XX:MaxTenuringThreshold=threshold`这里有个说明\n>\n> **Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6.**\n\n## 2 对象已经死亡？\n\n堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。\n\n![img](/images/33343235392e6a7067.png)\n\n给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。\n\n**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。** 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。\n\n```java\npublic class ReferenceCountingGc {\n    Object instance = null;\n\tpublic static void main(String[] args) {\n\t\tReferenceCountingGc objA = new ReferenceCountingGc();\n\t\tReferenceCountingGc objB = new ReferenceCountingGc();\n\t\tobjA.instance = objB;\n\t\tobjB.instance = objA;\n\t\tobjA = null;\n\t\tobjB = null;\n\n\t}\n}\n```\n\n### 2.2 可达性分析算法\n\n这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。\n\n![可达性分析算法 ](/images/34392e6a7067.png)\n\n### 2.3 再谈引用\n\n无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。\n\nJDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。\n\nJDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）\n\n**1．强引用（StrongReference）**\n\n以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于**必不可少的生活用品**，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n**2．软引用（SoftReference）**\n\n如果一个对象只具有软引用，那就类似于**可有可无的生活用品**。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n**3．弱引用（WeakReference）**\n\n如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n**4．虚引用（PhantomReference）**\n\n\"虚引用\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n\n**虚引用主要用来跟踪对象被垃圾回收的活动**。\n\n**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n\n特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。\n\n### 2.4 不可达的对象并非“非死不可”\n\n即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。\n\n被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\n\n### 2.5 如何判断一个常量是废弃常量\n\n运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？\n\n假如在常量池中存在字符串 \"abc\"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 \"abc\" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，\"abc\" 就会被系统清理出常量池。\n\n注意：我们在 [可能是把 Java 内存区域讲的最清楚的一篇文章 ](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484303&idx=1&sn=af0fd436cef755463f59ee4dd0720cbd&chksm=fd9855eecaefdcf8d94ac581cfda4e16c8a730bda60c3b50bc55c124b92f23b6217f7f8e58d5&token=506869459&lang=zh_CN#rd)也讲了 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。\n\n### 2.6 如何判断一个类是无用的类\n\n方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？\n\n判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：\n\n- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n- 加载该类的 ClassLoader 已经被回收。\n- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。\n\n## 3 垃圾收集算法\n\n![2545362](/images/525453625.jpg)\n\n### 3.1 标记-清除算法\n\n该算法分为“标记”和“清除”阶段：首先比较出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：\n\n1. **效率问题**\n2. **空间问题（标记清除后会产生大量不连续的碎片）**\n\n![公众号](/images/238312e6a7067.png)\n\n### 3.2 复制算法\n\n为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\n\n![公众号](/images/e6a7067.png)\n\n### 3.3 标记-整理算法\n\n根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n\n![标记-整理算法 ](/images/34392e6a702267.png)\n\n### 3.4 分代收集算法\n\n当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n**比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**\n\n**延伸面试问题：** HotSpot 为什么要分为新生代和老年代？\n\n根据上面的对分代收集算法的介绍回答。\n\n## 4 垃圾收集器\n\n![2](/images/625.jpg)\n\n**如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**\n\n虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，**我们能做的就是根据具体应用场景选择适合自己的垃圾收集器**。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。\n\n### 4.1 Serial 收集器\n\nSerial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **\"Stop The World\"** ），直到它收集结束。\n\n**新生代采用复制算法，老年代采用标记-整理算法。** ![ Serial 收集器 ](/images/032362e6a7067.png)\n\n虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。\n\n但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它**简单而高效（与其他收集器的单线程相比）**。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。\n\n### 4.2 ParNew 收集器\n\n**ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。**\n\n**新生代采用复制算法，老年代采用标记-整理算法。** ![ParNew 收集器 ](/images/1383336382e6a7067.png)\n\n它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。\n\n**并行和并发概念补充：**\n\n- **并行（Parallel）** ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。\n- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。\n\n### 4.3 Parallel Scavenge 收集器\n\nParallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew都一样。 **那么它有什么特别之处呢？**\n\n```java\n-XX:+UseParallelGC \n\n    使用 Parallel 收集器+ 老年代串行\n\n-XX:+UseParallelOldGC\n\n    使用 Parallel 收集器+ 老年代并行\n```\n\n**Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。** Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。\n\n**新生代采用复制算法，老年代采用标记-整理算法。** ![Parallel Scavenge 收集器 ](/images/031383336382e6a7067.png)\n\n### 4.4.Serial Old 收集器\n\n**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。\n\n### 4.5 Parallel Old 收集器\n\n**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。\n\n### 4.6 CMS 收集器\n\n**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**\n\n**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**\n\n从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\n\n- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；\n- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\n- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。\n\n![CMS 垃圾收集器 ](/images/3832353037392e6a7067.png)\n\n从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：\n\n- **对 CPU 资源敏感；**\n- **无法处理浮动垃圾；**\n- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**\n\n### 4.7 G1 收集器\n\n**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**\n\n被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：\n\n- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。\n- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。\n- **空间整合**：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。\n- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。\n\nG1 收集器的运作大致分为以下几个步骤：\n\n- **初始标记**\n- **并发标记**\n- **最终标记**\n- **筛选回收**\n\n**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)**。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\n\n## 参考\n\n- 《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》\n- <https://my.oschina.net/hosee/blog/644618>\n- <https://docs.oracle.com/javase/specs/jvms/se8/html/index.html>","source":"_posts/java/JVM 垃圾回收.md","raw":"---\ntitle: JVM 垃圾回收\ndate: 2020-05-26 14:44:29\ntags:\n    - java\n    - memory\n    - garbage\ncategories:\n    - java\n    - memory\n    - garbage\n---\n\n问题答案在文中都有提到\n\n- 如何判断对象是否死亡（两种方法）。\n- 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。\n- 如何判断一个常量是废弃常量\n- 如何判断一个类是无用的类\n- 垃圾收集有哪些算法，各自的特点？\n- HotSpot 为什么要分为新生代和老年代？\n- 常见的垃圾回收器有哪些？\n- 介绍一下 CMS,G1 收集器。\n- Minor Gc 和 Full GC 有什么不同呢？\n\n### 本文导火索\n\n![img](/images/1a1742222.png)\n\n当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。\n\n## 1 揭开 JVM 内存分配与回收的神秘面纱\n\nJava 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 **堆** 内存中对象的分配与回收。\n\nJava 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**\n\n**堆空间的基本结构：**\n\n![img](/images/5a086e7bb93e69e842e706e67.png)\n\n上图所示的 eden 区、s0(\"From\") 区、s1(\"To\") 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(\"To\")，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。经过这次GC后，Eden区和\"From\"区已经被清空。这个时候，\"From\"和\"To\"会交换他们的角色，也就是新的\"To\"就是上次GC前的“From”，新的\"From\"就是上次GC前的\"To\"。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，\"To\"区被填满之后，会将所有对象移动到老年代中。\n\n![545352](/images/25453525.jpg)\n\n### 1.1 对象优先在 eden 区分配\n\n目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。\n\n在测试之前我们先来看看 **Minor GC 和 Full GC 有什么不同呢？**\n\n- **新生代 GC（Minor GC）**:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。\n- **老年代 GC（Major GC/Full GC）**:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。\n\n> [issue#664 ](https://github.com/Snailclimb/JavaGuide/issues/664):**guang19** 补充：个人在网上查阅相关资料的时候发现如题所说的观点。有的文章说 Major GC 与 Full GC 一样是属于对老年代的GC，也有的文章说 Major GC 是对整个堆区的GC，所以这点需要各位同学自行分辨 Major GC 语义。见: [知乎讨论](https://www.zhihu.com/question/41922036)\n\n**测试：**\n\n```java\npublic class GCTest {\n\n\tpublic static void main(String[] args) {\n\t\tbyte[] allocation1, allocation2;\n\t\tallocation1 = new byte[30900*1024];\n\t\t//allocation2 = new byte[900*1024];\n\t}\n}\n```\n\n通过以下方式运行： ![img](/images/335302e6a7067.png)\n\n添加的参数：`-XX:+PrintGCDetails` ![img](/images/687474703a.png)\n\n运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：\n\n![img](/images/68747470.png)\n\n从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？\n\n```java\nallocation2 = new byte[900*1024];\n```\n\n![img](/images/383738352e6a7067.png)\n\n**简单解释一下为什么会出现这种情况：** 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 **分配担保机制** 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：\n\n```java\npublic class GCTest {\n\n\tpublic static void main(String[] args) {\n\t\tbyte[] allocation1, allocation2,allocation3,allocation4,allocation5;\n\t\tallocation1 = new byte[32000*1024];\n\t\tallocation2 = new byte[1000*1024];\n\t\tallocation3 = new byte[1000*1024];\n\t\tallocation4 = new byte[1000*1024];\n\t\tallocation5 = new byte[1000*1024];\n\t}\n}\n```\n\n### 1.2 大对象直接进入老年代\n\n大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。\n\n**为什么要这样呢？**\n\n为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。\n\n### 1.3 长期存活的对象将进入老年代\n\n既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。\n\n如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。\n\n### 1.4 动态对象年龄判定\n\n大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。\n\n> 修正（[issue552](https://github.com/Snailclimb/JavaGuide/issues/552)）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。\n>\n> **动态年龄计算的代码如下**\n>\n> ```java\n> uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {\n> \t//survivor_capacity是survivor空间的大小\n> size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);\n> size_t total = 0;\n> uint age = 1;\n> while (age < table_size) {\n>  total += sizes[age];//sizes数组是每个年龄段对象大小\n>  if (total > desired_survivor_size) break;\n>  age++;\n> }\n> uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;\n> \t...\n> }\n> ```\n>\n> 额外补充说明([issue672](https://github.com/Snailclimb/JavaGuide/issues/672))：**关于默认的晋升年龄是15，这个说法的来源大部分都是《深入理解Java虚拟机》这本书。** 如果你去Oracle的官网阅读[相关的虚拟机参数](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)，你会发现`-XX:MaxTenuringThreshold=threshold`这里有个说明\n>\n> **Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6.**\n\n## 2 对象已经死亡？\n\n堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。\n\n![img](/images/33343235392e6a7067.png)\n\n给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。\n\n**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。** 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。\n\n```java\npublic class ReferenceCountingGc {\n    Object instance = null;\n\tpublic static void main(String[] args) {\n\t\tReferenceCountingGc objA = new ReferenceCountingGc();\n\t\tReferenceCountingGc objB = new ReferenceCountingGc();\n\t\tobjA.instance = objB;\n\t\tobjB.instance = objA;\n\t\tobjA = null;\n\t\tobjB = null;\n\n\t}\n}\n```\n\n### 2.2 可达性分析算法\n\n这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。\n\n![可达性分析算法 ](/images/34392e6a7067.png)\n\n### 2.3 再谈引用\n\n无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。\n\nJDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。\n\nJDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）\n\n**1．强引用（StrongReference）**\n\n以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于**必不可少的生活用品**，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n**2．软引用（SoftReference）**\n\n如果一个对象只具有软引用，那就类似于**可有可无的生活用品**。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n**3．弱引用（WeakReference）**\n\n如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n**4．虚引用（PhantomReference）**\n\n\"虚引用\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。\n\n**虚引用主要用来跟踪对象被垃圾回收的活动**。\n\n**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n\n特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。\n\n### 2.4 不可达的对象并非“非死不可”\n\n即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。\n\n被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。\n\n### 2.5 如何判断一个常量是废弃常量\n\n运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？\n\n假如在常量池中存在字符串 \"abc\"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 \"abc\" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，\"abc\" 就会被系统清理出常量池。\n\n注意：我们在 [可能是把 Java 内存区域讲的最清楚的一篇文章 ](https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484303&idx=1&sn=af0fd436cef755463f59ee4dd0720cbd&chksm=fd9855eecaefdcf8d94ac581cfda4e16c8a730bda60c3b50bc55c124b92f23b6217f7f8e58d5&token=506869459&lang=zh_CN#rd)也讲了 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。\n\n### 2.6 如何判断一个类是无用的类\n\n方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？\n\n判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：\n\n- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。\n- 加载该类的 ClassLoader 已经被回收。\n- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。\n\n## 3 垃圾收集算法\n\n![2545362](/images/525453625.jpg)\n\n### 3.1 标记-清除算法\n\n该算法分为“标记”和“清除”阶段：首先比较出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：\n\n1. **效率问题**\n2. **空间问题（标记清除后会产生大量不连续的碎片）**\n\n![公众号](/images/238312e6a7067.png)\n\n### 3.2 复制算法\n\n为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\n\n![公众号](/images/e6a7067.png)\n\n### 3.3 标记-整理算法\n\n根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n\n![标记-整理算法 ](/images/34392e6a702267.png)\n\n### 3.4 分代收集算法\n\n当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n**比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**\n\n**延伸面试问题：** HotSpot 为什么要分为新生代和老年代？\n\n根据上面的对分代收集算法的介绍回答。\n\n## 4 垃圾收集器\n\n![2](/images/625.jpg)\n\n**如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**\n\n虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，**我们能做的就是根据具体应用场景选择适合自己的垃圾收集器**。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。\n\n### 4.1 Serial 收集器\n\nSerial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **\"Stop The World\"** ），直到它收集结束。\n\n**新生代采用复制算法，老年代采用标记-整理算法。** ![ Serial 收集器 ](/images/032362e6a7067.png)\n\n虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。\n\n但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它**简单而高效（与其他收集器的单线程相比）**。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。\n\n### 4.2 ParNew 收集器\n\n**ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。**\n\n**新生代采用复制算法，老年代采用标记-整理算法。** ![ParNew 收集器 ](/images/1383336382e6a7067.png)\n\n它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。\n\n**并行和并发概念补充：**\n\n- **并行（Parallel）** ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。\n- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。\n\n### 4.3 Parallel Scavenge 收集器\n\nParallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew都一样。 **那么它有什么特别之处呢？**\n\n```java\n-XX:+UseParallelGC \n\n    使用 Parallel 收集器+ 老年代串行\n\n-XX:+UseParallelOldGC\n\n    使用 Parallel 收集器+ 老年代并行\n```\n\n**Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。** Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。\n\n**新生代采用复制算法，老年代采用标记-整理算法。** ![Parallel Scavenge 收集器 ](/images/031383336382e6a7067.png)\n\n### 4.4.Serial Old 收集器\n\n**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。\n\n### 4.5 Parallel Old 收集器\n\n**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。\n\n### 4.6 CMS 收集器\n\n**CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**\n\n**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**\n\n从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\n\n- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；\n- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\n- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。\n\n![CMS 垃圾收集器 ](/images/3832353037392e6a7067.png)\n\n从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：\n\n- **对 CPU 资源敏感；**\n- **无法处理浮动垃圾；**\n- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**\n\n### 4.7 G1 收集器\n\n**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**\n\n被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：\n\n- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。\n- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。\n- **空间整合**：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。\n- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。\n\nG1 收集器的运作大致分为以下几个步骤：\n\n- **初始标记**\n- **并发标记**\n- **最终标记**\n- **筛选回收**\n\n**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)**。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\n\n## 参考\n\n- 《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》\n- <https://my.oschina.net/hosee/blog/644618>\n- <https://docs.oracle.com/javase/specs/jvms/se8/html/index.html>","slug":"java/JVM 垃圾回收","published":1,"updated":"2020-05-26T02:30:34.060Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7m6006bvgja0d29d4b0","content":"<p>问题答案在文中都有提到</p>\n<ul>\n<li>如何判断对象是否死亡（两种方法）。</li>\n<li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li>\n<li>如何判断一个常量是废弃常量</li>\n<li>如何判断一个类是无用的类</li>\n<li>垃圾收集有哪些算法，各自的特点？</li>\n<li>HotSpot 为什么要分为新生代和老年代？</li>\n<li>常见的垃圾回收器有哪些？</li>\n<li>介绍一下 CMS,G1 收集器。</li>\n<li>Minor Gc 和 Full GC 有什么不同呢？</li>\n</ul>\n<h3 id=\"本文导火索\"><a href=\"#本文导火索\" class=\"headerlink\" title=\"本文导火索\"></a>本文导火索</h3><p><img src=\"/images/1a1742222.png\" alt=\"img\"></p>\n<p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p>\n<h2 id=\"1-揭开-JVM-内存分配与回收的神秘面纱\"><a href=\"#1-揭开-JVM-内存分配与回收的神秘面纱\" class=\"headerlink\" title=\"1 揭开 JVM 内存分配与回收的神秘面纱\"></a>1 揭开 JVM 内存分配与回收的神秘面纱</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>\n<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>\n<p><strong>堆空间的基本结构：</strong></p>\n<p><img src=\"/images/5a086e7bb93e69e842e706e67.png\" alt=\"img\"></p>\n<p>上图所示的 eden 区、s0(“From”) 区、s1(“To”) 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。经过这次GC后，Eden区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次GC前的“From”，新的”From”就是上次GC前的”To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到老年代中。</p>\n<p><img src=\"/images/25453525.jpg\" alt=\"545352\"></p>\n<h3 id=\"1-1-对象优先在-eden-区分配\"><a href=\"#1-1-对象优先在-eden-区分配\" class=\"headerlink\" title=\"1.1 对象优先在 eden 区分配\"></a>1.1 对象优先在 eden 区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>\n<p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。</p>\n<p>在测试之前我们先来看看 <strong>Minor GC 和 Full GC 有什么不同呢？</strong></p>\n<ul>\n<li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li>\n<li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://github.com/Snailclimb/JavaGuide/issues/664\" target=\"_blank\" rel=\"noopener\">issue#664 </a>:<strong>guang19</strong> 补充：个人在网上查阅相关资料的时候发现如题所说的观点。有的文章说 Major GC 与 Full GC 一样是属于对老年代的GC，也有的文章说 Major GC 是对整个堆区的GC，所以这点需要各位同学自行分辨 Major GC 语义。见: <a href=\"https://www.zhihu.com/question/41922036\" target=\"_blank\" rel=\"noopener\">知乎讨论</a></p>\n</blockquote>\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GCTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] allocation1, allocation2;</span><br><span class=\"line\">\t\tallocation1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">30900</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\t<span class=\"comment\">//allocation2 = new byte[900*1024];</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过以下方式运行： <img src=\"/images/335302e6a7067.png\" alt=\"img\"></p>\n<p>添加的参数：<code>-XX:+PrintGCDetails</code> <img src=\"/images/687474703a.png\" alt=\"img\"></p>\n<p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p>\n<p><img src=\"/images/68747470.png\" alt=\"img\"></p>\n<p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allocation2 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">900</span>*<span class=\"number\">1024</span>];</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/383738352e6a7067.png\" alt=\"img\"></p>\n<p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GCTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class=\"line\">\t\tallocation1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">32000</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\tallocation2 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1000</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\tallocation3 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1000</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\tallocation4 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1000</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\tallocation5 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1000</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-大对象直接进入老年代\"><a href=\"#1-2-大对象直接进入老年代\" class=\"headerlink\" title=\"1.2 大对象直接进入老年代\"></a>1.2 大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>\n<p><strong>为什么要这样呢？</strong></p>\n<p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>\n<h3 id=\"1-3-长期存活的对象将进入老年代\"><a href=\"#1-3-长期存活的对象将进入老年代\" class=\"headerlink\" title=\"1.3 长期存活的对象将进入老年代\"></a>1.3 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p>\n<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>\n<h3 id=\"1-4-动态对象年龄判定\"><a href=\"#1-4-动态对象年龄判定\" class=\"headerlink\" title=\"1.4 动态对象年龄判定\"></a>1.4 动态对象年龄判定</h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>\n<blockquote>\n<p>修正（<a href=\"https://github.com/Snailclimb/JavaGuide/issues/552\" target=\"_blank\" rel=\"noopener\">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p>\n<p><strong>动态年龄计算的代码如下</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//survivor_capacity是survivor空间的大小</span></span><br><span class=\"line\">size_t desired_survivor_size = (size_t)((((<span class=\"keyword\">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class=\"number\">100</span>);</span><br><span class=\"line\">size_t total = <span class=\"number\">0</span>;</span><br><span class=\"line\">uint age = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (age &lt; table_size) &#123;</span><br><span class=\"line\"> total += sizes[age];<span class=\"comment\">//sizes数组是每个年龄段对象大小</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (total &gt; desired_survivor_size) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"> age++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>额外补充说明(<a href=\"https://github.com/Snailclimb/JavaGuide/issues/672\" target=\"_blank\" rel=\"noopener\">issue672</a>)：<strong>关于默认的晋升年龄是15，这个说法的来源大部分都是《深入理解Java虚拟机》这本书。</strong> 如果你去Oracle的官网阅读<a href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\" target=\"_blank\" rel=\"noopener\">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p>\n<p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6.</strong></p>\n</blockquote>\n<h2 id=\"2-对象已经死亡？\"><a href=\"#2-对象已经死亡？\" class=\"headerlink\" title=\"2 对象已经死亡？\"></a>2 对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p>\n<p><img src=\"/images/33343235392e6a7067.png\" alt=\"img\"></p>\n<p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p>\n<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceCountingGc</span> </span>&#123;</span><br><span class=\"line\">    Object instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tReferenceCountingGc objA = <span class=\"keyword\">new</span> ReferenceCountingGc();</span><br><span class=\"line\">\t\tReferenceCountingGc objB = <span class=\"keyword\">new</span> ReferenceCountingGc();</span><br><span class=\"line\">\t\tobjA.instance = objB;</span><br><span class=\"line\">\t\tobjB.instance = objA;</span><br><span class=\"line\">\t\tobjA = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tobjB = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-可达性分析算法\"><a href=\"#2-2-可达性分析算法\" class=\"headerlink\" title=\"2.2 可达性分析算法\"></a>2.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p>\n<p><img src=\"/images/34392e6a7067.png\" alt=\"可达性分析算法 \"></p>\n<h3 id=\"2-3-再谈引用\"><a href=\"#2-3-再谈引用\" class=\"headerlink\" title=\"2.3 再谈引用\"></a>2.3 再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p>\n<p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p>\n<p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p>\n<p><strong>1．强引用（StrongReference）</strong></p>\n<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>\n<p><strong>2．软引用（SoftReference）</strong></p>\n<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>\n<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<p><strong>3．弱引用（WeakReference）</strong></p>\n<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<p><strong>4．虚引用（PhantomReference）</strong></p>\n<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>\n<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>\n<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>\n<h3 id=\"2-4-不可达的对象并非“非死不可”\"><a href=\"#2-4-不可达的对象并非“非死不可”\" class=\"headerlink\" title=\"2.4 不可达的对象并非“非死不可”\"></a>2.4 不可达的对象并非“非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>\n<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>\n<h3 id=\"2-5-如何判断一个常量是废弃常量\"><a href=\"#2-5-如何判断一个常量是废弃常量\" class=\"headerlink\" title=\"2.5 如何判断一个常量是废弃常量\"></a>2.5 如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p>\n<p>假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p>\n<p>注意：我们在 <a href=\"https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484303&idx=1&sn=af0fd436cef755463f59ee4dd0720cbd&chksm=fd9855eecaefdcf8d94ac581cfda4e16c8a730bda60c3b50bc55c124b92f23b6217f7f8e58d5&token=506869459&lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener\">可能是把 Java 内存区域讲的最清楚的一篇文章 </a>也讲了 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</p>\n<h3 id=\"2-6-如何判断一个类是无用的类\"><a href=\"#2-6-如何判断一个类是无用的类\" class=\"headerlink\" title=\"2.6 如何判断一个类是无用的类\"></a>2.6 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p>\n<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>\n<li>加载该类的 ClassLoader 已经被回收。</li>\n<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>\n<h2 id=\"3-垃圾收集算法\"><a href=\"#3-垃圾收集算法\" class=\"headerlink\" title=\"3 垃圾收集算法\"></a>3 垃圾收集算法</h2><p><img src=\"/images/525453625.jpg\" alt=\"2545362\"></p>\n<h3 id=\"3-1-标记-清除算法\"><a href=\"#3-1-标记-清除算法\" class=\"headerlink\" title=\"3.1 标记-清除算法\"></a>3.1 标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先比较出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>\n<ol>\n<li><strong>效率问题</strong></li>\n<li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li>\n</ol>\n<p><img src=\"/images/238312e6a7067.png\" alt=\"公众号\"></p>\n<h3 id=\"3-2-复制算法\"><a href=\"#3-2-复制算法\" class=\"headerlink\" title=\"3.2 复制算法\"></a>3.2 复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>\n<p><img src=\"/images/e6a7067.png\" alt=\"公众号\"></p>\n<h3 id=\"3-3-标记-整理算法\"><a href=\"#3-3-标记-整理算法\" class=\"headerlink\" title=\"3.3 标记-整理算法\"></a>3.3 标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>\n<p><img src=\"/images/34392e6a702267.png\" alt=\"标记-整理算法 \"></p>\n<h3 id=\"3-4-分代收集算法\"><a href=\"#3-4-分代收集算法\" class=\"headerlink\" title=\"3.4 分代收集算法\"></a>3.4 分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>\n<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>\n<p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p>\n<p>根据上面的对分代收集算法的介绍回答。</p>\n<h2 id=\"4-垃圾收集器\"><a href=\"#4-垃圾收集器\" class=\"headerlink\" title=\"4 垃圾收集器\"></a>4 垃圾收集器</h2><p><img src=\"/images/625.jpg\" alt=\"2\"></p>\n<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>\n<p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p>\n<h3 id=\"4-1-Serial-收集器\"><a href=\"#4-1-Serial-收集器\" class=\"headerlink\" title=\"4.1 Serial 收集器\"></a>4.1 Serial 收集器</h3><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>\n<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong> <img src=\"/images/032362e6a7067.png\" alt=\" Serial 收集器 \"></p>\n<p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>\n<p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p>\n<h3 id=\"4-2-ParNew-收集器\"><a href=\"#4-2-ParNew-收集器\" class=\"headerlink\" title=\"4.2 ParNew 收集器\"></a>4.2 ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p>\n<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong> <img src=\"/images/1383336382e6a7067.png\" alt=\"ParNew 收集器 \"></p>\n<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>\n<p><strong>并行和并发概念补充：</strong></p>\n<ul>\n<li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>\n<li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li>\n</ul>\n<h3 id=\"4-3-Parallel-Scavenge-收集器\"><a href=\"#4-3-Parallel-Scavenge-收集器\" class=\"headerlink\" title=\"4.3 Parallel Scavenge 收集器\"></a>4.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew都一样。 <strong>那么它有什么特别之处呢？</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:+UseParallelGC </span><br><span class=\"line\"></span><br><span class=\"line\">    使用 Parallel 收集器+ 老年代串行</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseParallelOldGC</span><br><span class=\"line\"></span><br><span class=\"line\">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></table></figure>\n\n<p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>\n<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong> <img src=\"/images/031383336382e6a7067.png\" alt=\"Parallel Scavenge 收集器 \"></p>\n<h3 id=\"4-4-Serial-Old-收集器\"><a href=\"#4-4-Serial-Old-收集器\" class=\"headerlink\" title=\"4.4.Serial Old 收集器\"></a>4.4.Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>\n<h3 id=\"4-5-Parallel-Old-收集器\"><a href=\"#4-5-Parallel-Old-收集器\" class=\"headerlink\" title=\"4.5 Parallel Old 收集器\"></a>4.5 Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>\n<h3 id=\"4-6-CMS-收集器\"><a href=\"#4-6-CMS-收集器\" class=\"headerlink\" title=\"4.6 CMS 收集器\"></a>4.6 CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p>\n<p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>\n<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>\n<ul>\n<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>\n<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>\n<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>\n<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>\n</ul>\n<p><img src=\"/images/3832353037392e6a7067.png\" alt=\"CMS 垃圾收集器 \"></p>\n<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>\n<ul>\n<li><strong>对 CPU 资源敏感；</strong></li>\n<li><strong>无法处理浮动垃圾；</strong></li>\n<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>\n</ul>\n<h3 id=\"4-7-G1-收集器\"><a href=\"#4-7-G1-收集器\" class=\"headerlink\" title=\"4.7 G1 收集器\"></a>4.7 G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>\n<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p>\n<ul>\n<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>\n<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>\n<li><strong>空间整合</strong>：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>\n<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>\n</ul>\n<p>G1 收集器的运作大致分为以下几个步骤：</p>\n<ul>\n<li><strong>初始标记</strong></li>\n<li><strong>并发标记</strong></li>\n<li><strong>最终标记</strong></li>\n<li><strong>筛选回收</strong></li>\n</ul>\n<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong>。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li>\n<li><a href=\"https://my.oschina.net/hosee/blog/644618\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/hosee/blog/644618</a></li>\n<li><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>问题答案在文中都有提到</p>\n<ul>\n<li>如何判断对象是否死亡（两种方法）。</li>\n<li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li>\n<li>如何判断一个常量是废弃常量</li>\n<li>如何判断一个类是无用的类</li>\n<li>垃圾收集有哪些算法，各自的特点？</li>\n<li>HotSpot 为什么要分为新生代和老年代？</li>\n<li>常见的垃圾回收器有哪些？</li>\n<li>介绍一下 CMS,G1 收集器。</li>\n<li>Minor Gc 和 Full GC 有什么不同呢？</li>\n</ul>\n<h3 id=\"本文导火索\"><a href=\"#本文导火索\" class=\"headerlink\" title=\"本文导火索\"></a>本文导火索</h3><p><img src=\"/images/1a1742222.png\" alt=\"img\"></p>\n<p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p>\n<h2 id=\"1-揭开-JVM-内存分配与回收的神秘面纱\"><a href=\"#1-揭开-JVM-内存分配与回收的神秘面纱\" class=\"headerlink\" title=\"1 揭开 JVM 内存分配与回收的神秘面纱\"></a>1 揭开 JVM 内存分配与回收的神秘面纱</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>\n<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>\n<p><strong>堆空间的基本结构：</strong></p>\n<p><img src=\"/images/5a086e7bb93e69e842e706e67.png\" alt=\"img\"></p>\n<p>上图所示的 eden 区、s0(“From”) 区、s1(“To”) 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。经过这次GC后，Eden区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次GC前的“From”，新的”From”就是上次GC前的”To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，”To”区被填满之后，会将所有对象移动到老年代中。</p>\n<p><img src=\"/images/25453525.jpg\" alt=\"545352\"></p>\n<h3 id=\"1-1-对象优先在-eden-区分配\"><a href=\"#1-1-对象优先在-eden-区分配\" class=\"headerlink\" title=\"1.1 对象优先在 eden 区分配\"></a>1.1 对象优先在 eden 区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>\n<p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。</p>\n<p>在测试之前我们先来看看 <strong>Minor GC 和 Full GC 有什么不同呢？</strong></p>\n<ul>\n<li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li>\n<li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li>\n</ul>\n<blockquote>\n<p><a href=\"https://github.com/Snailclimb/JavaGuide/issues/664\" target=\"_blank\" rel=\"noopener\">issue#664 </a>:<strong>guang19</strong> 补充：个人在网上查阅相关资料的时候发现如题所说的观点。有的文章说 Major GC 与 Full GC 一样是属于对老年代的GC，也有的文章说 Major GC 是对整个堆区的GC，所以这点需要各位同学自行分辨 Major GC 语义。见: <a href=\"https://www.zhihu.com/question/41922036\" target=\"_blank\" rel=\"noopener\">知乎讨论</a></p>\n</blockquote>\n<p><strong>测试：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GCTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] allocation1, allocation2;</span><br><span class=\"line\">\t\tallocation1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">30900</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\t<span class=\"comment\">//allocation2 = new byte[900*1024];</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过以下方式运行： <img src=\"/images/335302e6a7067.png\" alt=\"img\"></p>\n<p>添加的参数：<code>-XX:+PrintGCDetails</code> <img src=\"/images/687474703a.png\" alt=\"img\"></p>\n<p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p>\n<p><img src=\"/images/68747470.png\" alt=\"img\"></p>\n<p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">allocation2 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">900</span>*<span class=\"number\">1024</span>];</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/383738352e6a7067.png\" alt=\"img\"></p>\n<p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GCTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class=\"line\">\t\tallocation1 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">32000</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\tallocation2 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1000</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\tallocation3 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1000</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\tallocation4 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1000</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t\tallocation5 = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1000</span>*<span class=\"number\">1024</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-大对象直接进入老年代\"><a href=\"#1-2-大对象直接进入老年代\" class=\"headerlink\" title=\"1.2 大对象直接进入老年代\"></a>1.2 大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>\n<p><strong>为什么要这样呢？</strong></p>\n<p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>\n<h3 id=\"1-3-长期存活的对象将进入老年代\"><a href=\"#1-3-长期存活的对象将进入老年代\" class=\"headerlink\" title=\"1.3 长期存活的对象将进入老年代\"></a>1.3 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p>\n<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>\n<h3 id=\"1-4-动态对象年龄判定\"><a href=\"#1-4-动态对象年龄判定\" class=\"headerlink\" title=\"1.4 动态对象年龄判定\"></a>1.4 动态对象年龄判定</h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>\n<blockquote>\n<p>修正（<a href=\"https://github.com/Snailclimb/JavaGuide/issues/552\" target=\"_blank\" rel=\"noopener\">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p>\n<p><strong>动态年龄计算的代码如下</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//survivor_capacity是survivor空间的大小</span></span><br><span class=\"line\">size_t desired_survivor_size = (size_t)((((<span class=\"keyword\">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class=\"number\">100</span>);</span><br><span class=\"line\">size_t total = <span class=\"number\">0</span>;</span><br><span class=\"line\">uint age = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (age &lt; table_size) &#123;</span><br><span class=\"line\"> total += sizes[age];<span class=\"comment\">//sizes数组是每个年龄段对象大小</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (total &gt; desired_survivor_size) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"> age++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>额外补充说明(<a href=\"https://github.com/Snailclimb/JavaGuide/issues/672\" target=\"_blank\" rel=\"noopener\">issue672</a>)：<strong>关于默认的晋升年龄是15，这个说法的来源大部分都是《深入理解Java虚拟机》这本书。</strong> 如果你去Oracle的官网阅读<a href=\"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\" target=\"_blank\" rel=\"noopener\">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p>\n<p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS就是6.</strong></p>\n</blockquote>\n<h2 id=\"2-对象已经死亡？\"><a href=\"#2-对象已经死亡？\" class=\"headerlink\" title=\"2 对象已经死亡？\"></a>2 对象已经死亡？</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p>\n<p><img src=\"/images/33343235392e6a7067.png\" alt=\"img\"></p>\n<p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p>\n<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReferenceCountingGc</span> </span>&#123;</span><br><span class=\"line\">    Object instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tReferenceCountingGc objA = <span class=\"keyword\">new</span> ReferenceCountingGc();</span><br><span class=\"line\">\t\tReferenceCountingGc objB = <span class=\"keyword\">new</span> ReferenceCountingGc();</span><br><span class=\"line\">\t\tobjA.instance = objB;</span><br><span class=\"line\">\t\tobjB.instance = objA;</span><br><span class=\"line\">\t\tobjA = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tobjB = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-可达性分析算法\"><a href=\"#2-2-可达性分析算法\" class=\"headerlink\" title=\"2.2 可达性分析算法\"></a>2.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p>\n<p><img src=\"/images/34392e6a7067.png\" alt=\"可达性分析算法 \"></p>\n<h3 id=\"2-3-再谈引用\"><a href=\"#2-3-再谈引用\" class=\"headerlink\" title=\"2.3 再谈引用\"></a>2.3 再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p>\n<p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p>\n<p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p>\n<p><strong>1．强引用（StrongReference）</strong></p>\n<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>\n<p><strong>2．软引用（SoftReference）</strong></p>\n<p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>\n<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<p><strong>3．弱引用（WeakReference）</strong></p>\n<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>\n<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<p><strong>4．虚引用（PhantomReference）</strong></p>\n<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>\n<p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p>\n<p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n<p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p>\n<h3 id=\"2-4-不可达的对象并非“非死不可”\"><a href=\"#2-4-不可达的对象并非“非死不可”\" class=\"headerlink\" title=\"2.4 不可达的对象并非“非死不可”\"></a>2.4 不可达的对象并非“非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>\n<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>\n<h3 id=\"2-5-如何判断一个常量是废弃常量\"><a href=\"#2-5-如何判断一个常量是废弃常量\" class=\"headerlink\" title=\"2.5 如何判断一个常量是废弃常量\"></a>2.5 如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p>\n<p>假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p>\n<p>注意：我们在 <a href=\"https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484303&idx=1&sn=af0fd436cef755463f59ee4dd0720cbd&chksm=fd9855eecaefdcf8d94ac581cfda4e16c8a730bda60c3b50bc55c124b92f23b6217f7f8e58d5&token=506869459&lang=zh_CN#rd\" target=\"_blank\" rel=\"noopener\">可能是把 Java 内存区域讲的最清楚的一篇文章 </a>也讲了 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</p>\n<h3 id=\"2-6-如何判断一个类是无用的类\"><a href=\"#2-6-如何判断一个类是无用的类\" class=\"headerlink\" title=\"2.6 如何判断一个类是无用的类\"></a>2.6 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p>\n<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>\n<li>加载该类的 ClassLoader 已经被回收。</li>\n<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>\n</ul>\n<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>\n<h2 id=\"3-垃圾收集算法\"><a href=\"#3-垃圾收集算法\" class=\"headerlink\" title=\"3 垃圾收集算法\"></a>3 垃圾收集算法</h2><p><img src=\"/images/525453625.jpg\" alt=\"2545362\"></p>\n<h3 id=\"3-1-标记-清除算法\"><a href=\"#3-1-标记-清除算法\" class=\"headerlink\" title=\"3.1 标记-清除算法\"></a>3.1 标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先比较出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>\n<ol>\n<li><strong>效率问题</strong></li>\n<li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li>\n</ol>\n<p><img src=\"/images/238312e6a7067.png\" alt=\"公众号\"></p>\n<h3 id=\"3-2-复制算法\"><a href=\"#3-2-复制算法\" class=\"headerlink\" title=\"3.2 复制算法\"></a>3.2 复制算法</h3><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>\n<p><img src=\"/images/e6a7067.png\" alt=\"公众号\"></p>\n<h3 id=\"3-3-标记-整理算法\"><a href=\"#3-3-标记-整理算法\" class=\"headerlink\" title=\"3.3 标记-整理算法\"></a>3.3 标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>\n<p><img src=\"/images/34392e6a702267.png\" alt=\"标记-整理算法 \"></p>\n<h3 id=\"3-4-分代收集算法\"><a href=\"#3-4-分代收集算法\" class=\"headerlink\" title=\"3.4 分代收集算法\"></a>3.4 分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>\n<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>\n<p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p>\n<p>根据上面的对分代收集算法的介绍回答。</p>\n<h2 id=\"4-垃圾收集器\"><a href=\"#4-垃圾收集器\" class=\"headerlink\" title=\"4 垃圾收集器\"></a>4 垃圾收集器</h2><p><img src=\"/images/625.jpg\" alt=\"2\"></p>\n<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>\n<p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p>\n<h3 id=\"4-1-Serial-收集器\"><a href=\"#4-1-Serial-收集器\" class=\"headerlink\" title=\"4.1 Serial 收集器\"></a>4.1 Serial 收集器</h3><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p>\n<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong> <img src=\"/images/032362e6a7067.png\" alt=\" Serial 收集器 \"></p>\n<p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>\n<p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p>\n<h3 id=\"4-2-ParNew-收集器\"><a href=\"#4-2-ParNew-收集器\" class=\"headerlink\" title=\"4.2 ParNew 收集器\"></a>4.2 ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p>\n<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong> <img src=\"/images/1383336382e6a7067.png\" alt=\"ParNew 收集器 \"></p>\n<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>\n<p><strong>并行和并发概念补充：</strong></p>\n<ul>\n<li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>\n<li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li>\n</ul>\n<h3 id=\"4-3-Parallel-Scavenge-收集器\"><a href=\"#4-3-Parallel-Scavenge-收集器\" class=\"headerlink\" title=\"4.3 Parallel Scavenge 收集器\"></a>4.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew都一样。 <strong>那么它有什么特别之处呢？</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:+UseParallelGC </span><br><span class=\"line\"></span><br><span class=\"line\">    使用 Parallel 收集器+ 老年代串行</span><br><span class=\"line\"></span><br><span class=\"line\">-XX:+UseParallelOldGC</span><br><span class=\"line\"></span><br><span class=\"line\">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></table></figure>\n\n<p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>\n<p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong> <img src=\"/images/031383336382e6a7067.png\" alt=\"Parallel Scavenge 收集器 \"></p>\n<h3 id=\"4-4-Serial-Old-收集器\"><a href=\"#4-4-Serial-Old-收集器\" class=\"headerlink\" title=\"4.4.Serial Old 收集器\"></a>4.4.Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>\n<h3 id=\"4-5-Parallel-Old-收集器\"><a href=\"#4-5-Parallel-Old-收集器\" class=\"headerlink\" title=\"4.5 Parallel Old 收集器\"></a>4.5 Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>\n<h3 id=\"4-6-CMS-收集器\"><a href=\"#4-6-CMS-收集器\" class=\"headerlink\" title=\"4.6 CMS 收集器\"></a>4.6 CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p>\n<p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>\n<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>\n<ul>\n<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>\n<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>\n<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>\n<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>\n</ul>\n<p><img src=\"/images/3832353037392e6a7067.png\" alt=\"CMS 垃圾收集器 \"></p>\n<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>\n<ul>\n<li><strong>对 CPU 资源敏感；</strong></li>\n<li><strong>无法处理浮动垃圾；</strong></li>\n<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>\n</ul>\n<h3 id=\"4-7-G1-收集器\"><a href=\"#4-7-G1-收集器\" class=\"headerlink\" title=\"4.7 G1 收集器\"></a>4.7 G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p>\n<p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p>\n<ul>\n<li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li>\n<li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li>\n<li><strong>空间整合</strong>：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>\n<li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li>\n</ul>\n<p>G1 收集器的运作大致分为以下几个步骤：</p>\n<ul>\n<li><strong>初始标记</strong></li>\n<li><strong>并发标记</strong></li>\n<li><strong>最终标记</strong></li>\n<li><strong>筛选回收</strong></li>\n</ul>\n<p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong>。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li>\n<li><a href=\"https://my.oschina.net/hosee/blog/644618\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/hosee/blog/644618</a></li>\n<li><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li>\n</ul>\n"},{"title":"Java线程池实现原理及实践","date":"2020-05-22T08:55:27.000Z","_content":"#  AQS 介绍\n\n### 1 AQS 简单介绍\n\nAQS 的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks 包下面。\n\n![类图](/images/54546254.png)\n\nAQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask(jdk1.7) 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。\n\n### 2 AQS 原理\n\n> 在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。\n\n下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。\n\n#### 2.1 AQS 原理概览\n\n**AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**\n\n> CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。\n\n看个 AQS(AbstractQueuedSynchronizer)原理图：\n\n![453525](/images/453525.png)\n\nAQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。\n\n```java\nprivate volatile int state;//共享变量，使用volatile修饰保证线程可见性\n```\n\n状态信息通过 protected 类型的`getState`，`setState`，`compareAndSetState`进行操作\n\n```java\n//返回同步状态的当前值\nprotected final int getState() {\n        return state;\n}\n // 设置同步状态的值\nprotected final void setState(int newState) {\n        state = newState;\n}\n//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）\nprotected final boolean compareAndSetState(int expect, int update) {\n        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n```\n\n#### 2.2 AQS 对资源的共享方式\n\n**AQS 定义两种资源共享方式**\n\n**1)Exclusive**（独占）\n\n只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：\n\n- 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\n- 非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。\n\n> 说明：下面这部分关于 `ReentrantLock` 源代码内容节选自：<https://www.javadoop.com/post/AbstractQueuedSynchronizer-2> ，这是一篇很不错文章，推荐阅读。\n\n**下面来看 ReentrantLock 中相关的源代码：**\n\nReentrantLock 默认采用非公平锁，因为考虑获得更好的性能，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）。\n\n```java\n/** Synchronizer providing all implementation mechanics */\nprivate final Sync sync;\npublic ReentrantLock() {\n    // 默认非公平锁\n    sync = new NonfairSync();\n}\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n```\n\nReentrantLock 中公平锁的 `lock` 方法\n\n```java\nstatic final class FairSync extends Sync {\n    final void lock() {\n        acquire(1);\n    }\n    // AbstractQueuedSynchronizer.acquire(int arg)\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n    protected final boolean tryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            // 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待\n            if (!hasQueuedPredecessors() &&\n                compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n非公平锁的 lock 方法：\n\n```java\nstatic final class NonfairSync extends Sync {\n    final void lock() {\n        // 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了\n        if (compareAndSetState(0, 1))\n            setExclusiveOwnerThread(Thread.currentThread());\n        else\n            acquire(1);\n    }\n    // AbstractQueuedSynchronizer.acquire(int arg)\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n    protected final boolean tryAcquire(int acquires) {\n        return nonfairTryAcquire(acquires);\n    }\n}\n/**\n * Performs non-fair tryLock.  tryAcquire is implemented in\n * subclasses, but both need nonfair try for trylock method.\n */\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        // 这里没有对阻塞队列进行判断\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n总结：公平锁和非公平锁只有两处不同：\n\n1. 非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。\n2. 非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。\n\n公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。\n\n相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。\n\n**2)Share**（共享）\n\n多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。\n\nReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。\n\n不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。\n\n#### 2.3 AQS 底层使用了模板方法模式\n\n同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：\n\n1. 使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）\n2. 将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。\n\n这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。\n\n> 模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票`buyTicket()`->安检`securityCheck()`->乘坐某某工具回家`ride()`->到达目的地`arrive()`。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了`ride()`方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 `ride()`方法。\n\n**AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：**\n\n```java\nisHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。\ntryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。\ntryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。\ntryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\ntryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。\n```\n\n默认情况下，每个方法都抛出 `UnsupportedOperationException`。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。\n\n以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。\n\n再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。\n\n一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现`tryAcquire-tryRelease`、`tryAcquireShared-tryReleaseShared`中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如`ReentrantReadWriteLock`。\n\n推荐两篇 AQS 原理和相关源码分析的文章：\n\n- <http://www.cnblogs.com/waterystone/p/4920797.html>\n- <https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html>\n\n### 3 Semaphore(信号量)-允许多个线程同时访问\n\n**synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。**\n\n示例代码如下：\n\n```java\n/**\n *\n * @author Snailclimb\n * @date 2018年9月30日\n * @Description: 需要一次性拿一个许可的情况\n */\npublic class SemaphoreExample1 {\n  // 请求的数量\n  private static final int threadCount = 550;\n\n  public static void main(String[] args) throws InterruptedException {\n    // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）\n    ExecutorService threadPool = Executors.newFixedThreadPool(300);\n    // 一次只能允许执行的线程数量。\n    final Semaphore semaphore = new Semaphore(20);\n\n    for (int i = 0; i < threadCount; i++) {\n      final int threadnum = i;\n      threadPool.execute(() -> {// Lambda 表达式的运用\n        try {\n          semaphore.acquire();// 获取一个许可，所以可运行线程数量为20/1=20\n          test(threadnum);\n          semaphore.release();// 释放一个许可\n        } catch (InterruptedException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n        }\n\n      });\n    }\n    threadPool.shutdown();\n    System.out.println(\"finish\");\n  }\n\n  public static void test(int threadnum) throws InterruptedException {\n    Thread.sleep(1000);// 模拟请求的耗时操作\n    System.out.println(\"threadnum:\" + threadnum);\n    Thread.sleep(1000);// 模拟请求的耗时操作\n  }\n}\n```\n\n执行 `acquire` 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 `release` 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。\n\n当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：\n\n```java\nsemaphore.acquire(5);// 获取5个许可，所以可运行线程数量为20/5=4\ntest(threadnum);\nsemaphore.release(5);// 获取5个许可，所以可运行线程数量为20/5=4\n```\n\n除了 `acquire`方法之外，另一个比较常用的与之对应的方法是`tryAcquire`方法，该方法如果获取不到许可就立即返回 false。\n\nSemaphore 有两种模式，公平模式和非公平模式。\n\n- **公平模式：** 调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；\n- **非公平模式：** 抢占式的。\n\n**Semaphore 对应的两个构造方法如下：**\n\n```java\n   public Semaphore(int permits) {\n        sync = new NonfairSync(permits);\n    }\n\n    public Semaphore(int permits, boolean fair) {\n        sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n    }\n```\n\n**这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。**\n\n[issue645补充内容](https://github.com/Snailclimb/JavaGuide/issues/645) ：Semaphore与CountDownLatch一样，也是共享锁的一种实现。它默认构造AQS的state为permits。当执行任务的线程数量超出permits,那么多余的线程将会被放入阻塞队列Park,并自旋判断state是否大于0。只有当state大于0的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行release方法，release方法使得state的变量会加1，那么自旋的线程便会判断成功。 如此，每次只有最多不超过permits数量的线程能自旋成功，便限制了执行任务线程的数量。\n\n由于篇幅问题，如果对 Semaphore 源码感兴趣的朋友可以看下这篇文章：<https://juejin.im/post/5ae755366fb9a07ab508adc6>\n\n### 4 CountDownLatch （倒计时器）\n\nCountDownLatch允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。在 Java 并发中，countdownlatch 的概念是一个常见的面试题，所以一定要确保你很好的理解了它。\n\nCountDownLatch是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用countDown方法时,其实使用了`tryReleaseShared`方法以CAS的操作来减少state,直至state为0就代表所有的线程都调用了countDown方法。当调用await方法的时候，如果state不为0，就代表仍然有线程没有调用countDown方法，那么就把已经调用过countDown的线程都放入阻塞队列Park,并自旋CAS判断state == 0，直至最后一个线程调用了countDown，使得state == 0，于是阻塞的线程便判断成功，全部往下执行。\n\n#### 4.1 CountDownLatch 的两种典型用法\n\n1. 某一线程在开始运行前等待 n 个线程执行完毕。将 CountDownLatch 的计数器初始化为 n ：`new CountDownLatch(n)`，每当一个任务线程执行完毕，就将计数器减 1 `countdownlatch.countDown()`，当计数器的值变为 0 时，在`CountDownLatch上 await()` 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。\n2. 实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 `CountDownLatch` 对象，将其计数器初始化为 1 ：`new CountDownLatch(1)`，多个线程在开始执行任务前首先 `coundownlatch.await()`，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。\n\n#### 4.2 CountDownLatch 的使用示例\n\n```java\n/**\n *\n * @author SnailClimb\n * @date 2018年10月1日\n * @Description: CountDownLatch 使用方法示例\n */\npublic class CountDownLatchExample1 {\n  // 请求的数量\n  private static final int threadCount = 550;\n\n  public static void main(String[] args) throws InterruptedException {\n    // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）\n    ExecutorService threadPool = Executors.newFixedThreadPool(300);\n    final CountDownLatch countDownLatch = new CountDownLatch(threadCount);\n    for (int i = 0; i < threadCount; i++) {\n      final int threadnum = i;\n      threadPool.execute(() -> {// Lambda 表达式的运用\n        try {\n          test(threadnum);\n        } catch (InterruptedException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n        } finally {\n          countDownLatch.countDown();// 表示一个请求已经被完成\n        }\n\n      });\n    }\n    countDownLatch.await();\n    threadPool.shutdown();\n    System.out.println(\"finish\");\n  }\n\n  public static void test(int threadnum) throws InterruptedException {\n    Thread.sleep(1000);// 模拟请求的耗时操作\n    System.out.println(\"threadnum:\" + threadnum);\n    Thread.sleep(1000);// 模拟请求的耗时操作\n  }\n}\n```\n\n上面的代码中，我们定义了请求的数量为 550，当这 550 个请求被处理完成之后，才会执行`System.out.println(\"finish\");`。\n\n与 CountDownLatch 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 `CountDownLatch.await()` 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。\n\n其他 N 个线程必须引用闭锁对象，因为他们需要通知 `CountDownLatch` 对象，他们已经完成了各自的任务。这种通知机制是通过 `CountDownLatch.countDown()`方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 `await()`方法，恢复执行自己的任务。\n\n再插一嘴：`CountDownLatch` 的 `await()` 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：\n\n```java\nfor (int i = 0; i < threadCount-1; i++) {\n.......\n}\n```\n\n这样就导致 `count` 的值没办法等于 0，然后就会导致一直等待。\n\n如果对CountDownLatch源码感兴趣的朋友，可以查看： [【JUC】JDK1.8源码分析之CountDownLatch（五）](https://www.cnblogs.com/leesf456/p/5406191.html)\n\n#### 4.3 CountDownLatch 的不足\n\nCountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。\n\n#### 4.4 CountDownLatch 相常见面试题\n\n解释一下 CountDownLatch 概念？\n\nCountDownLatch 和 CyclicBarrier 的不同之处？\n\n给出一些 CountDownLatch 使用的例子？\n\nCountDownLatch 类中主要的方法？\n\n### 5 CyclicBarrier(循环栅栏)\n\nCyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。\n\n> CountDownLatch的实现是基于AQS的，而CycliBarrier是基于 ReentrantLock(ReentrantLock也属于AQS同步器)和 Condition 的.\n\nCyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 `CyclicBarrier(int parties)`，其参数表示屏障拦截的线程数量，每个线程调用`await`方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。\n\n再来看一下它的构造函数：\n\n```java\npublic CyclicBarrier(int parties) {\n    this(parties, null);\n}\n\npublic CyclicBarrier(int parties, Runnable barrierAction) {\n    if (parties <= 0) throw new IllegalArgumentException();\n    this.parties = parties;\n    this.count = parties;\n    this.barrierCommand = barrierAction;\n}\n```\n\n其中，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。\n\n#### 5.1 CyclicBarrier 的应用场景\n\nCyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。\n\n#### 5.2 CyclicBarrier 的使用示例\n\n示例 1：\n\n```java\n/**\n *\n * @author Snailclimb\n * @date 2018年10月1日\n * @Description: 测试 CyclicBarrier 类中带参数的 await() 方法\n */\npublic class CyclicBarrierExample2 {\n  // 请求的数量\n  private static final int threadCount = 550;\n  // 需要同步的线程数量\n  private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5);\n\n  public static void main(String[] args) throws InterruptedException {\n    // 创建线程池\n    ExecutorService threadPool = Executors.newFixedThreadPool(10);\n\n    for (int i = 0; i < threadCount; i++) {\n      final int threadNum = i;\n      Thread.sleep(1000);\n      threadPool.execute(() -> {\n        try {\n          test(threadNum);\n        } catch (InterruptedException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n        }\n      });\n    }\n    threadPool.shutdown();\n  }\n\n  public static void test(int threadnum) throws InterruptedException, BrokenBarrierException {\n    System.out.println(\"threadnum:\" + threadnum + \"is ready\");\n    try {\n      /**等待60秒，保证子线程完全执行结束*/\n      cyclicBarrier.await(60, TimeUnit.SECONDS);\n    } catch (Exception e) {\n      System.out.println(\"-----CyclicBarrierException------\");\n    }\n    System.out.println(\"threadnum:\" + threadnum + \"is finish\");\n  }\n\n}\n```\n\n运行结果，如下：\n\n```java\nthreadnum:0is ready\nthreadnum:1is ready\nthreadnum:2is ready\nthreadnum:3is ready\nthreadnum:4is ready\nthreadnum:4is finish\nthreadnum:0is finish\nthreadnum:1is finish\nthreadnum:2is finish\nthreadnum:3is finish\nthreadnum:5is ready\nthreadnum:6is ready\nthreadnum:7is ready\nthreadnum:8is ready\nthreadnum:9is ready\nthreadnum:9is finish\nthreadnum:5is finish\nthreadnum:8is finish\nthreadnum:7is finish\nthreadnum:6is finish\n......\n```\n\n可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， `await`方法之后的方法才被执行。\n\n另外，CyclicBarrier 还提供一个更高级的构造函数`CyclicBarrier(int parties, Runnable barrierAction)`，用于在线程到达屏障时，优先执行`barrierAction`，方便处理更复杂的业务场景。示例代码如下：\n\n```java\n/**\n *\n * @author SnailClimb\n * @date 2018年10月1日\n * @Description: 新建 CyclicBarrier 的时候指定一个 Runnable\n */\npublic class CyclicBarrierExample3 {\n  // 请求的数量\n  private static final int threadCount = 550;\n  // 需要同步的线程数量\n  private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5, () -> {\n    System.out.println(\"------当线程数达到之后，优先执行------\");\n  });\n\n  public static void main(String[] args) throws InterruptedException {\n    // 创建线程池\n    ExecutorService threadPool = Executors.newFixedThreadPool(10);\n\n    for (int i = 0; i < threadCount; i++) {\n      final int threadNum = i;\n      Thread.sleep(1000);\n      threadPool.execute(() -> {\n        try {\n          test(threadNum);\n        } catch (InterruptedException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n        }\n      });\n    }\n    threadPool.shutdown();\n  }\n\n  public static void test(int threadnum) throws InterruptedException, BrokenBarrierException {\n    System.out.println(\"threadnum:\" + threadnum + \"is ready\");\n    cyclicBarrier.await();\n    System.out.println(\"threadnum:\" + threadnum + \"is finish\");\n  }\n\n}\n```\n\n运行结果，如下：\n\n```java\nthreadnum:0is ready\nthreadnum:1is ready\nthreadnum:2is ready\nthreadnum:3is ready\nthreadnum:4is ready\n------当线程数达到之后，优先执行------\nthreadnum:4is finish\nthreadnum:0is finish\nthreadnum:2is finish\nthreadnum:1is finish\nthreadnum:3is finish\nthreadnum:5is ready\nthreadnum:6is ready\nthreadnum:7is ready\nthreadnum:8is ready\nthreadnum:9is ready\n------当线程数达到之后，优先执行------\nthreadnum:9is finish\nthreadnum:5is finish\nthreadnum:6is finish\nthreadnum:8is finish\nthreadnum:7is finish\n......\n```\n\n#### 5.3 `CyclicBarrier`源码分析\n\n当调用 `CyclicBarrier` 对象调用 `await()` 方法时，实际上调用的是`dowait(false, 0L)`方法。 `await()` 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 parties 的值时，栅栏才会打开，线程才得以通过执行。\n\n```java\n    public int await() throws InterruptedException, BrokenBarrierException {\n        try {\n            return dowait(false, 0L);\n        } catch (TimeoutException toe) {\n            throw new Error(toe); // cannot happen\n        }\n    }\n```\n\n`dowait(false, 0L)`：\n\n```java\n    // 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。\n    private int count;\n    /**\n     * Main barrier code, covering the various policies.\n     */\n    private int dowait(boolean timed, long nanos)\n        throws InterruptedException, BrokenBarrierException,\n               TimeoutException {\n        final ReentrantLock lock = this.lock;\n        // 锁住\n        lock.lock();\n        try {\n            final Generation g = generation;\n\n            if (g.broken)\n                throw new BrokenBarrierException();\n\n            // 如果线程中断了，抛出异常\n            if (Thread.interrupted()) {\n                breakBarrier();\n                throw new InterruptedException();\n            }\n            // cout减1\n            int index = --count;\n            // 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件\n            if (index == 0) {  // tripped\n                boolean ranAction = false;\n                try {\n                    final Runnable command = barrierCommand;\n                    if (command != null)\n                        command.run();\n                    ranAction = true;\n                    // 将 count 重置为 parties 属性的初始化值\n                    // 唤醒之前等待的线程\n                    // 下一波执行开始\n                    nextGeneration();\n                    return 0;\n                } finally {\n                    if (!ranAction)\n                        breakBarrier();\n                }\n            }\n\n            // loop until tripped, broken, interrupted, or timed out\n            for (;;) {\n                try {\n                    if (!timed)\n                        trip.await();\n                    else if (nanos > 0L)\n                        nanos = trip.awaitNanos(nanos);\n                } catch (InterruptedException ie) {\n                    if (g == generation && ! g.broken) {\n                        breakBarrier();\n                        throw ie;\n                    } else {\n                        // We're about to finish waiting even if we had not\n                        // been interrupted, so this interrupt is deemed to\n                        // \"belong\" to subsequent execution.\n                        Thread.currentThread().interrupt();\n                    }\n                }\n\n                if (g.broken)\n                    throw new BrokenBarrierException();\n\n                if (g != generation)\n                    return index;\n\n                if (timed && nanos <= 0L) {\n                    breakBarrier();\n                    throw new TimeoutException();\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n总结：`CyclicBarrier` 内部通过一个 count 变量作为计数器，cout 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。\n\n#### 5.4 CyclicBarrier 和 CountDownLatch 的区别\n\n**下面这个是国外一个大佬的回答：**\n\nCountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从 jdk 作者设计的目的来看，javadoc 是这么描述它们的：\n\n> CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)\n\n对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。\n\nCountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。\n\n### 6 ReentrantLock 和 ReentrantReadWriteLock\n\nReentrantLock 和 synchronized 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。\n\n### 参考\n\n- <https://juejin.im/post/5ae755256fb9a07ac3634067>\n- <https://blog.csdn.net/u010185262/article/details/54692886>\n- <https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0>","source":"_posts/java/java-syc-AQS.md","raw":"---\ntitle: Java线程池实现原理及实践\ndate: 2020-05-22 16:55:27\ntags:\n    - java\n    - concurrent\n    - AQS\ncategories:\n    - java\n    - concurrent\n    - AQS\n---\n#  AQS 介绍\n\n### 1 AQS 简单介绍\n\nAQS 的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks 包下面。\n\n![类图](/images/54546254.png)\n\nAQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask(jdk1.7) 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。\n\n### 2 AQS 原理\n\n> 在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。\n\n下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。\n\n#### 2.1 AQS 原理概览\n\n**AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**\n\n> CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。\n\n看个 AQS(AbstractQueuedSynchronizer)原理图：\n\n![453525](/images/453525.png)\n\nAQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。\n\n```java\nprivate volatile int state;//共享变量，使用volatile修饰保证线程可见性\n```\n\n状态信息通过 protected 类型的`getState`，`setState`，`compareAndSetState`进行操作\n\n```java\n//返回同步状态的当前值\nprotected final int getState() {\n        return state;\n}\n // 设置同步状态的值\nprotected final void setState(int newState) {\n        state = newState;\n}\n//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）\nprotected final boolean compareAndSetState(int expect, int update) {\n        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n```\n\n#### 2.2 AQS 对资源的共享方式\n\n**AQS 定义两种资源共享方式**\n\n**1)Exclusive**（独占）\n\n只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：\n\n- 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁\n- 非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。\n\n> 说明：下面这部分关于 `ReentrantLock` 源代码内容节选自：<https://www.javadoop.com/post/AbstractQueuedSynchronizer-2> ，这是一篇很不错文章，推荐阅读。\n\n**下面来看 ReentrantLock 中相关的源代码：**\n\nReentrantLock 默认采用非公平锁，因为考虑获得更好的性能，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）。\n\n```java\n/** Synchronizer providing all implementation mechanics */\nprivate final Sync sync;\npublic ReentrantLock() {\n    // 默认非公平锁\n    sync = new NonfairSync();\n}\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n```\n\nReentrantLock 中公平锁的 `lock` 方法\n\n```java\nstatic final class FairSync extends Sync {\n    final void lock() {\n        acquire(1);\n    }\n    // AbstractQueuedSynchronizer.acquire(int arg)\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n    protected final boolean tryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            // 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待\n            if (!hasQueuedPredecessors() &&\n                compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n非公平锁的 lock 方法：\n\n```java\nstatic final class NonfairSync extends Sync {\n    final void lock() {\n        // 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了\n        if (compareAndSetState(0, 1))\n            setExclusiveOwnerThread(Thread.currentThread());\n        else\n            acquire(1);\n    }\n    // AbstractQueuedSynchronizer.acquire(int arg)\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n    protected final boolean tryAcquire(int acquires) {\n        return nonfairTryAcquire(acquires);\n    }\n}\n/**\n * Performs non-fair tryLock.  tryAcquire is implemented in\n * subclasses, but both need nonfair try for trylock method.\n */\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        // 这里没有对阻塞队列进行判断\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n总结：公平锁和非公平锁只有两处不同：\n\n1. 非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。\n2. 非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。\n\n公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。\n\n相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。\n\n**2)Share**（共享）\n\n多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。\n\nReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。\n\n不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。\n\n#### 2.3 AQS 底层使用了模板方法模式\n\n同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：\n\n1. 使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）\n2. 将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。\n\n这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。\n\n> 模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票`buyTicket()`->安检`securityCheck()`->乘坐某某工具回家`ride()`->到达目的地`arrive()`。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了`ride()`方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 `ride()`方法。\n\n**AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：**\n\n```java\nisHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。\ntryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。\ntryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。\ntryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\ntryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。\n```\n\n默认情况下，每个方法都抛出 `UnsupportedOperationException`。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。\n\n以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。\n\n再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。\n\n一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现`tryAcquire-tryRelease`、`tryAcquireShared-tryReleaseShared`中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如`ReentrantReadWriteLock`。\n\n推荐两篇 AQS 原理和相关源码分析的文章：\n\n- <http://www.cnblogs.com/waterystone/p/4920797.html>\n- <https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html>\n\n### 3 Semaphore(信号量)-允许多个线程同时访问\n\n**synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。**\n\n示例代码如下：\n\n```java\n/**\n *\n * @author Snailclimb\n * @date 2018年9月30日\n * @Description: 需要一次性拿一个许可的情况\n */\npublic class SemaphoreExample1 {\n  // 请求的数量\n  private static final int threadCount = 550;\n\n  public static void main(String[] args) throws InterruptedException {\n    // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）\n    ExecutorService threadPool = Executors.newFixedThreadPool(300);\n    // 一次只能允许执行的线程数量。\n    final Semaphore semaphore = new Semaphore(20);\n\n    for (int i = 0; i < threadCount; i++) {\n      final int threadnum = i;\n      threadPool.execute(() -> {// Lambda 表达式的运用\n        try {\n          semaphore.acquire();// 获取一个许可，所以可运行线程数量为20/1=20\n          test(threadnum);\n          semaphore.release();// 释放一个许可\n        } catch (InterruptedException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n        }\n\n      });\n    }\n    threadPool.shutdown();\n    System.out.println(\"finish\");\n  }\n\n  public static void test(int threadnum) throws InterruptedException {\n    Thread.sleep(1000);// 模拟请求的耗时操作\n    System.out.println(\"threadnum:\" + threadnum);\n    Thread.sleep(1000);// 模拟请求的耗时操作\n  }\n}\n```\n\n执行 `acquire` 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 `release` 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。\n\n当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：\n\n```java\nsemaphore.acquire(5);// 获取5个许可，所以可运行线程数量为20/5=4\ntest(threadnum);\nsemaphore.release(5);// 获取5个许可，所以可运行线程数量为20/5=4\n```\n\n除了 `acquire`方法之外，另一个比较常用的与之对应的方法是`tryAcquire`方法，该方法如果获取不到许可就立即返回 false。\n\nSemaphore 有两种模式，公平模式和非公平模式。\n\n- **公平模式：** 调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；\n- **非公平模式：** 抢占式的。\n\n**Semaphore 对应的两个构造方法如下：**\n\n```java\n   public Semaphore(int permits) {\n        sync = new NonfairSync(permits);\n    }\n\n    public Semaphore(int permits, boolean fair) {\n        sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n    }\n```\n\n**这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。**\n\n[issue645补充内容](https://github.com/Snailclimb/JavaGuide/issues/645) ：Semaphore与CountDownLatch一样，也是共享锁的一种实现。它默认构造AQS的state为permits。当执行任务的线程数量超出permits,那么多余的线程将会被放入阻塞队列Park,并自旋判断state是否大于0。只有当state大于0的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行release方法，release方法使得state的变量会加1，那么自旋的线程便会判断成功。 如此，每次只有最多不超过permits数量的线程能自旋成功，便限制了执行任务线程的数量。\n\n由于篇幅问题，如果对 Semaphore 源码感兴趣的朋友可以看下这篇文章：<https://juejin.im/post/5ae755366fb9a07ab508adc6>\n\n### 4 CountDownLatch （倒计时器）\n\nCountDownLatch允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。在 Java 并发中，countdownlatch 的概念是一个常见的面试题，所以一定要确保你很好的理解了它。\n\nCountDownLatch是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用countDown方法时,其实使用了`tryReleaseShared`方法以CAS的操作来减少state,直至state为0就代表所有的线程都调用了countDown方法。当调用await方法的时候，如果state不为0，就代表仍然有线程没有调用countDown方法，那么就把已经调用过countDown的线程都放入阻塞队列Park,并自旋CAS判断state == 0，直至最后一个线程调用了countDown，使得state == 0，于是阻塞的线程便判断成功，全部往下执行。\n\n#### 4.1 CountDownLatch 的两种典型用法\n\n1. 某一线程在开始运行前等待 n 个线程执行完毕。将 CountDownLatch 的计数器初始化为 n ：`new CountDownLatch(n)`，每当一个任务线程执行完毕，就将计数器减 1 `countdownlatch.countDown()`，当计数器的值变为 0 时，在`CountDownLatch上 await()` 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。\n2. 实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 `CountDownLatch` 对象，将其计数器初始化为 1 ：`new CountDownLatch(1)`，多个线程在开始执行任务前首先 `coundownlatch.await()`，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。\n\n#### 4.2 CountDownLatch 的使用示例\n\n```java\n/**\n *\n * @author SnailClimb\n * @date 2018年10月1日\n * @Description: CountDownLatch 使用方法示例\n */\npublic class CountDownLatchExample1 {\n  // 请求的数量\n  private static final int threadCount = 550;\n\n  public static void main(String[] args) throws InterruptedException {\n    // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）\n    ExecutorService threadPool = Executors.newFixedThreadPool(300);\n    final CountDownLatch countDownLatch = new CountDownLatch(threadCount);\n    for (int i = 0; i < threadCount; i++) {\n      final int threadnum = i;\n      threadPool.execute(() -> {// Lambda 表达式的运用\n        try {\n          test(threadnum);\n        } catch (InterruptedException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n        } finally {\n          countDownLatch.countDown();// 表示一个请求已经被完成\n        }\n\n      });\n    }\n    countDownLatch.await();\n    threadPool.shutdown();\n    System.out.println(\"finish\");\n  }\n\n  public static void test(int threadnum) throws InterruptedException {\n    Thread.sleep(1000);// 模拟请求的耗时操作\n    System.out.println(\"threadnum:\" + threadnum);\n    Thread.sleep(1000);// 模拟请求的耗时操作\n  }\n}\n```\n\n上面的代码中，我们定义了请求的数量为 550，当这 550 个请求被处理完成之后，才会执行`System.out.println(\"finish\");`。\n\n与 CountDownLatch 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 `CountDownLatch.await()` 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。\n\n其他 N 个线程必须引用闭锁对象，因为他们需要通知 `CountDownLatch` 对象，他们已经完成了各自的任务。这种通知机制是通过 `CountDownLatch.countDown()`方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 `await()`方法，恢复执行自己的任务。\n\n再插一嘴：`CountDownLatch` 的 `await()` 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：\n\n```java\nfor (int i = 0; i < threadCount-1; i++) {\n.......\n}\n```\n\n这样就导致 `count` 的值没办法等于 0，然后就会导致一直等待。\n\n如果对CountDownLatch源码感兴趣的朋友，可以查看： [【JUC】JDK1.8源码分析之CountDownLatch（五）](https://www.cnblogs.com/leesf456/p/5406191.html)\n\n#### 4.3 CountDownLatch 的不足\n\nCountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。\n\n#### 4.4 CountDownLatch 相常见面试题\n\n解释一下 CountDownLatch 概念？\n\nCountDownLatch 和 CyclicBarrier 的不同之处？\n\n给出一些 CountDownLatch 使用的例子？\n\nCountDownLatch 类中主要的方法？\n\n### 5 CyclicBarrier(循环栅栏)\n\nCyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。\n\n> CountDownLatch的实现是基于AQS的，而CycliBarrier是基于 ReentrantLock(ReentrantLock也属于AQS同步器)和 Condition 的.\n\nCyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 `CyclicBarrier(int parties)`，其参数表示屏障拦截的线程数量，每个线程调用`await`方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。\n\n再来看一下它的构造函数：\n\n```java\npublic CyclicBarrier(int parties) {\n    this(parties, null);\n}\n\npublic CyclicBarrier(int parties, Runnable barrierAction) {\n    if (parties <= 0) throw new IllegalArgumentException();\n    this.parties = parties;\n    this.count = parties;\n    this.barrierCommand = barrierAction;\n}\n```\n\n其中，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。\n\n#### 5.1 CyclicBarrier 的应用场景\n\nCyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。\n\n#### 5.2 CyclicBarrier 的使用示例\n\n示例 1：\n\n```java\n/**\n *\n * @author Snailclimb\n * @date 2018年10月1日\n * @Description: 测试 CyclicBarrier 类中带参数的 await() 方法\n */\npublic class CyclicBarrierExample2 {\n  // 请求的数量\n  private static final int threadCount = 550;\n  // 需要同步的线程数量\n  private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5);\n\n  public static void main(String[] args) throws InterruptedException {\n    // 创建线程池\n    ExecutorService threadPool = Executors.newFixedThreadPool(10);\n\n    for (int i = 0; i < threadCount; i++) {\n      final int threadNum = i;\n      Thread.sleep(1000);\n      threadPool.execute(() -> {\n        try {\n          test(threadNum);\n        } catch (InterruptedException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n        }\n      });\n    }\n    threadPool.shutdown();\n  }\n\n  public static void test(int threadnum) throws InterruptedException, BrokenBarrierException {\n    System.out.println(\"threadnum:\" + threadnum + \"is ready\");\n    try {\n      /**等待60秒，保证子线程完全执行结束*/\n      cyclicBarrier.await(60, TimeUnit.SECONDS);\n    } catch (Exception e) {\n      System.out.println(\"-----CyclicBarrierException------\");\n    }\n    System.out.println(\"threadnum:\" + threadnum + \"is finish\");\n  }\n\n}\n```\n\n运行结果，如下：\n\n```java\nthreadnum:0is ready\nthreadnum:1is ready\nthreadnum:2is ready\nthreadnum:3is ready\nthreadnum:4is ready\nthreadnum:4is finish\nthreadnum:0is finish\nthreadnum:1is finish\nthreadnum:2is finish\nthreadnum:3is finish\nthreadnum:5is ready\nthreadnum:6is ready\nthreadnum:7is ready\nthreadnum:8is ready\nthreadnum:9is ready\nthreadnum:9is finish\nthreadnum:5is finish\nthreadnum:8is finish\nthreadnum:7is finish\nthreadnum:6is finish\n......\n```\n\n可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， `await`方法之后的方法才被执行。\n\n另外，CyclicBarrier 还提供一个更高级的构造函数`CyclicBarrier(int parties, Runnable barrierAction)`，用于在线程到达屏障时，优先执行`barrierAction`，方便处理更复杂的业务场景。示例代码如下：\n\n```java\n/**\n *\n * @author SnailClimb\n * @date 2018年10月1日\n * @Description: 新建 CyclicBarrier 的时候指定一个 Runnable\n */\npublic class CyclicBarrierExample3 {\n  // 请求的数量\n  private static final int threadCount = 550;\n  // 需要同步的线程数量\n  private static final CyclicBarrier cyclicBarrier = new CyclicBarrier(5, () -> {\n    System.out.println(\"------当线程数达到之后，优先执行------\");\n  });\n\n  public static void main(String[] args) throws InterruptedException {\n    // 创建线程池\n    ExecutorService threadPool = Executors.newFixedThreadPool(10);\n\n    for (int i = 0; i < threadCount; i++) {\n      final int threadNum = i;\n      Thread.sleep(1000);\n      threadPool.execute(() -> {\n        try {\n          test(threadNum);\n        } catch (InterruptedException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n          // TODO Auto-generated catch block\n          e.printStackTrace();\n        }\n      });\n    }\n    threadPool.shutdown();\n  }\n\n  public static void test(int threadnum) throws InterruptedException, BrokenBarrierException {\n    System.out.println(\"threadnum:\" + threadnum + \"is ready\");\n    cyclicBarrier.await();\n    System.out.println(\"threadnum:\" + threadnum + \"is finish\");\n  }\n\n}\n```\n\n运行结果，如下：\n\n```java\nthreadnum:0is ready\nthreadnum:1is ready\nthreadnum:2is ready\nthreadnum:3is ready\nthreadnum:4is ready\n------当线程数达到之后，优先执行------\nthreadnum:4is finish\nthreadnum:0is finish\nthreadnum:2is finish\nthreadnum:1is finish\nthreadnum:3is finish\nthreadnum:5is ready\nthreadnum:6is ready\nthreadnum:7is ready\nthreadnum:8is ready\nthreadnum:9is ready\n------当线程数达到之后，优先执行------\nthreadnum:9is finish\nthreadnum:5is finish\nthreadnum:6is finish\nthreadnum:8is finish\nthreadnum:7is finish\n......\n```\n\n#### 5.3 `CyclicBarrier`源码分析\n\n当调用 `CyclicBarrier` 对象调用 `await()` 方法时，实际上调用的是`dowait(false, 0L)`方法。 `await()` 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 parties 的值时，栅栏才会打开，线程才得以通过执行。\n\n```java\n    public int await() throws InterruptedException, BrokenBarrierException {\n        try {\n            return dowait(false, 0L);\n        } catch (TimeoutException toe) {\n            throw new Error(toe); // cannot happen\n        }\n    }\n```\n\n`dowait(false, 0L)`：\n\n```java\n    // 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。\n    private int count;\n    /**\n     * Main barrier code, covering the various policies.\n     */\n    private int dowait(boolean timed, long nanos)\n        throws InterruptedException, BrokenBarrierException,\n               TimeoutException {\n        final ReentrantLock lock = this.lock;\n        // 锁住\n        lock.lock();\n        try {\n            final Generation g = generation;\n\n            if (g.broken)\n                throw new BrokenBarrierException();\n\n            // 如果线程中断了，抛出异常\n            if (Thread.interrupted()) {\n                breakBarrier();\n                throw new InterruptedException();\n            }\n            // cout减1\n            int index = --count;\n            // 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件\n            if (index == 0) {  // tripped\n                boolean ranAction = false;\n                try {\n                    final Runnable command = barrierCommand;\n                    if (command != null)\n                        command.run();\n                    ranAction = true;\n                    // 将 count 重置为 parties 属性的初始化值\n                    // 唤醒之前等待的线程\n                    // 下一波执行开始\n                    nextGeneration();\n                    return 0;\n                } finally {\n                    if (!ranAction)\n                        breakBarrier();\n                }\n            }\n\n            // loop until tripped, broken, interrupted, or timed out\n            for (;;) {\n                try {\n                    if (!timed)\n                        trip.await();\n                    else if (nanos > 0L)\n                        nanos = trip.awaitNanos(nanos);\n                } catch (InterruptedException ie) {\n                    if (g == generation && ! g.broken) {\n                        breakBarrier();\n                        throw ie;\n                    } else {\n                        // We're about to finish waiting even if we had not\n                        // been interrupted, so this interrupt is deemed to\n                        // \"belong\" to subsequent execution.\n                        Thread.currentThread().interrupt();\n                    }\n                }\n\n                if (g.broken)\n                    throw new BrokenBarrierException();\n\n                if (g != generation)\n                    return index;\n\n                if (timed && nanos <= 0L) {\n                    breakBarrier();\n                    throw new TimeoutException();\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n\n总结：`CyclicBarrier` 内部通过一个 count 变量作为计数器，cout 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。\n\n#### 5.4 CyclicBarrier 和 CountDownLatch 的区别\n\n**下面这个是国外一个大佬的回答：**\n\nCountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从 jdk 作者设计的目的来看，javadoc 是这么描述它们的：\n\n> CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)\n\n对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。\n\nCountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。\n\n### 6 ReentrantLock 和 ReentrantReadWriteLock\n\nReentrantLock 和 synchronized 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。\n\n### 参考\n\n- <https://juejin.im/post/5ae755256fb9a07ac3634067>\n- <https://blog.csdn.net/u010185262/article/details/54692886>\n- <https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0>","slug":"java/java-syc-AQS","published":1,"updated":"2020-05-22T09:49:04.412Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7mg0079vgjabvkbabae","content":"<h1 id=\"AQS-介绍\"><a href=\"#AQS-介绍\" class=\"headerlink\" title=\"AQS 介绍\"></a>AQS 介绍</h1><h3 id=\"1-AQS-简单介绍\"><a href=\"#1-AQS-简单介绍\" class=\"headerlink\" title=\"1 AQS 简单介绍\"></a>1 AQS 简单介绍</h3><p>AQS 的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks 包下面。</p>\n<p><img src=\"/images/54546254.png\" alt=\"类图\"></p>\n<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask(jdk1.7) 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>\n<h3 id=\"2-AQS-原理\"><a href=\"#2-AQS-原理\" class=\"headerlink\" title=\"2 AQS 原理\"></a>2 AQS 原理</h3><blockquote>\n<p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p>\n</blockquote>\n<p>下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p>\n<h4 id=\"2-1-AQS-原理概览\"><a href=\"#2-1-AQS-原理概览\" class=\"headerlink\" title=\"2.1 AQS 原理概览\"></a>2.1 AQS 原理概览</h4><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>\n<blockquote>\n<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>\n</blockquote>\n<p>看个 AQS(AbstractQueuedSynchronizer)原理图：</p>\n<p><img src=\"/images/453525.png\" alt=\"453525\"></p>\n<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;<span class=\"comment\">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>\n\n<p>状态信息通过 protected 类型的<code>getState</code>，<code>setState</code>，<code>compareAndSetState</code>进行操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回同步状态的当前值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"comment\">// 设置同步状态的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(<span class=\"keyword\">int</span> newState)</span> </span>&#123;</span><br><span class=\"line\">        state = newState;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetState</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-AQS-对资源的共享方式\"><a href=\"#2-2-AQS-对资源的共享方式\" class=\"headerlink\" title=\"2.2 AQS 对资源的共享方式\"></a>2.2 AQS 对资源的共享方式</h4><p><strong>AQS 定义两种资源共享方式</strong></p>\n<p><strong>1)Exclusive</strong>（独占）</p>\n<p>只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：</p>\n<ul>\n<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>\n<li>非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li>\n</ul>\n<blockquote>\n<p>说明：下面这部分关于 <code>ReentrantLock</code> 源代码内容节选自：<a href=\"https://www.javadoop.com/post/AbstractQueuedSynchronizer-2\" target=\"_blank\" rel=\"noopener\">https://www.javadoop.com/post/AbstractQueuedSynchronizer-2</a> ，这是一篇很不错文章，推荐阅读。</p>\n</blockquote>\n<p><strong>下面来看 ReentrantLock 中相关的源代码：</strong></p>\n<p>ReentrantLock 默认采用非公平锁，因为考虑获得更好的性能，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Synchronizer providing all implementation mechanics */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 默认非公平锁</span></span><br><span class=\"line\">    sync = <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    sync = fair ? <span class=\"keyword\">new</span> FairSync() : <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ReentrantLock 中公平锁的 <code>lock</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">            selfInterrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">                compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(current);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">            setState(nextc);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>非公平锁的 lock 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">            selfInterrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class=\"line\"><span class=\"comment\"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里没有对阻塞队列进行判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：公平锁和非公平锁只有两处不同：</p>\n<ol>\n<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>\n<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>\n</ol>\n<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>\n<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>\n<p><strong>2)Share</strong>（共享）</p>\n<p>多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p>\n<p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p>\n<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p>\n<h4 id=\"2-3-AQS-底层使用了模板方法模式\"><a href=\"#2-3-AQS-底层使用了模板方法模式\" class=\"headerlink\" title=\"2.3 AQS 底层使用了模板方法模式\"></a>2.3 AQS 底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>\n<ol>\n<li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>\n<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>\n</ol>\n<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。</p>\n<blockquote>\n<p>模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票<code>buyTicket()</code>-&gt;安检<code>securityCheck()</code>-&gt;乘坐某某工具回家<code>ride()</code>-&gt;到达目的地<code>arrive()</code>。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了<code>ride()</code>方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 <code>ride()</code>方法。</p>\n</blockquote>\n<p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isHeldExclusively()<span class=\"comment\">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class=\"line\">tryAcquire(<span class=\"keyword\">int</span>)<span class=\"comment\">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class=\"line\">tryRelease(<span class=\"keyword\">int</span>)<span class=\"comment\">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class=\"line\">tryAcquireShared(<span class=\"keyword\">int</span>)<span class=\"comment\">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class=\"line\">tryReleaseShared(<span class=\"keyword\">int</span>)<span class=\"comment\">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>\n<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p>\n<p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</p>\n<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>\n<p>推荐两篇 AQS 原理和相关源码分析的文章：</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/waterystone/p/4920797.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/waterystone/p/4920797.html</a></li>\n<li><a href=\"https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li>\n</ul>\n<h3 id=\"3-Semaphore-信号量-允许多个线程同时访问\"><a href=\"#3-Semaphore-信号量-允许多个线程同时访问\" class=\"headerlink\" title=\"3 Semaphore(信号量)-允许多个线程同时访问\"></a>3 Semaphore(信号量)-允许多个线程同时访问</h3><p><strong>synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</strong></p>\n<p>示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Snailclimb</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018年9月30日</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 需要一次性拿一个许可的情况</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SemaphoreExample1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求的数量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">550</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class=\"line\">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">300</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 一次只能允许执行的线程数量。</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Semaphore semaphore = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadnum = i;</span><br><span class=\"line\">      threadPool.execute(() -&gt; &#123;<span class=\"comment\">// Lambda 表达式的运用</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          semaphore.acquire();<span class=\"comment\">// 获取一个许可，所以可运行线程数量为20/1=20</span></span><br><span class=\"line\">          test(threadnum);</span><br><span class=\"line\">          semaphore.release();<span class=\"comment\">// 释放一个许可</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threadPool.shutdown();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"finish\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> threadnum)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">// 模拟请求的耗时操作</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"threadnum:\"</span> + threadnum);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">// 模拟请求的耗时操作</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行 <code>acquire</code> 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 <code>release</code> 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。</p>\n<p>当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore.acquire(<span class=\"number\">5</span>);<span class=\"comment\">// 获取5个许可，所以可运行线程数量为20/5=4</span></span><br><span class=\"line\">test(threadnum);</span><br><span class=\"line\">semaphore.release(<span class=\"number\">5</span>);<span class=\"comment\">// 获取5个许可，所以可运行线程数量为20/5=4</span></span><br></pre></td></tr></table></figure>\n\n<p>除了 <code>acquire</code>方法之外，另一个比较常用的与之对应的方法是<code>tryAcquire</code>方法，该方法如果获取不到许可就立即返回 false。</p>\n<p>Semaphore 有两种模式，公平模式和非公平模式。</p>\n<ul>\n<li><strong>公平模式：</strong> 调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；</li>\n<li><strong>非公平模式：</strong> 抢占式的。</li>\n</ul>\n<p><strong>Semaphore 对应的两个构造方法如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> </span>&#123;</span><br><span class=\"line\">     sync = <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits, <span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">     sync = fair ? <span class=\"keyword\">new</span> FairSync(permits) : <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p>\n<p><a href=\"https://github.com/Snailclimb/JavaGuide/issues/645\" target=\"_blank\" rel=\"noopener\">issue645补充内容</a> ：Semaphore与CountDownLatch一样，也是共享锁的一种实现。它默认构造AQS的state为permits。当执行任务的线程数量超出permits,那么多余的线程将会被放入阻塞队列Park,并自旋判断state是否大于0。只有当state大于0的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行release方法，release方法使得state的变量会加1，那么自旋的线程便会判断成功。 如此，每次只有最多不超过permits数量的线程能自旋成功，便限制了执行任务线程的数量。</p>\n<p>由于篇幅问题，如果对 Semaphore 源码感兴趣的朋友可以看下这篇文章：<a href=\"https://juejin.im/post/5ae755366fb9a07ab508adc6\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ae755366fb9a07ab508adc6</a></p>\n<h3 id=\"4-CountDownLatch-（倒计时器）\"><a href=\"#4-CountDownLatch-（倒计时器）\" class=\"headerlink\" title=\"4 CountDownLatch （倒计时器）\"></a>4 CountDownLatch （倒计时器）</h3><p>CountDownLatch允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。在 Java 并发中，countdownlatch 的概念是一个常见的面试题，所以一定要确保你很好的理解了它。</p>\n<p>CountDownLatch是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用countDown方法时,其实使用了<code>tryReleaseShared</code>方法以CAS的操作来减少state,直至state为0就代表所有的线程都调用了countDown方法。当调用await方法的时候，如果state不为0，就代表仍然有线程没有调用countDown方法，那么就把已经调用过countDown的线程都放入阻塞队列Park,并自旋CAS判断state == 0，直至最后一个线程调用了countDown，使得state == 0，于是阻塞的线程便判断成功，全部往下执行。</p>\n<h4 id=\"4-1-CountDownLatch-的两种典型用法\"><a href=\"#4-1-CountDownLatch-的两种典型用法\" class=\"headerlink\" title=\"4.1 CountDownLatch 的两种典型用法\"></a>4.1 CountDownLatch 的两种典型用法</h4><ol>\n<li>某一线程在开始运行前等待 n 个线程执行完毕。将 CountDownLatch 的计数器初始化为 n ：<code>new CountDownLatch(n)</code>，每当一个任务线程执行完毕，就将计数器减 1 <code>countdownlatch.countDown()</code>，当计数器的值变为 0 时，在<code>CountDownLatch上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li>\n<li>实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 ：<code>new CountDownLatch(1)</code>，多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。</li>\n</ol>\n<h4 id=\"4-2-CountDownLatch-的使用示例\"><a href=\"#4-2-CountDownLatch-的使用示例\" class=\"headerlink\" title=\"4.2 CountDownLatch 的使用示例\"></a>4.2 CountDownLatch 的使用示例</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> SnailClimb</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018年10月1日</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: CountDownLatch 使用方法示例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountDownLatchExample1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求的数量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">550</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class=\"line\">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">300</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(threadCount);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadnum = i;</span><br><span class=\"line\">      threadPool.execute(() -&gt; &#123;<span class=\"comment\">// Lambda 表达式的运用</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          test(threadnum);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          countDownLatch.countDown();<span class=\"comment\">// 表示一个请求已经被完成</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    countDownLatch.await();</span><br><span class=\"line\">    threadPool.shutdown();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"finish\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> threadnum)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">// 模拟请求的耗时操作</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"threadnum:\"</span> + threadnum);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">// 模拟请求的耗时操作</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码中，我们定义了请求的数量为 550，当这 550 个请求被处理完成之后，才会执行<code>System.out.println(&quot;finish&quot;);</code>。</p>\n<p>与 CountDownLatch 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code>CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p>\n<p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 <code>await()</code>方法，恢复执行自己的任务。</p>\n<p>再插一嘴：<code>CountDownLatch</code> 的 <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount-<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">.......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就导致 <code>count</code> 的值没办法等于 0，然后就会导致一直等待。</p>\n<p>如果对CountDownLatch源码感兴趣的朋友，可以查看： <a href=\"https://www.cnblogs.com/leesf456/p/5406191.html\" target=\"_blank\" rel=\"noopener\">【JUC】JDK1.8源码分析之CountDownLatch（五）</a></p>\n<h4 id=\"4-3-CountDownLatch-的不足\"><a href=\"#4-3-CountDownLatch-的不足\" class=\"headerlink\" title=\"4.3 CountDownLatch 的不足\"></a>4.3 CountDownLatch 的不足</h4><p>CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。</p>\n<h4 id=\"4-4-CountDownLatch-相常见面试题\"><a href=\"#4-4-CountDownLatch-相常见面试题\" class=\"headerlink\" title=\"4.4 CountDownLatch 相常见面试题\"></a>4.4 CountDownLatch 相常见面试题</h4><p>解释一下 CountDownLatch 概念？</p>\n<p>CountDownLatch 和 CyclicBarrier 的不同之处？</p>\n<p>给出一些 CountDownLatch 使用的例子？</p>\n<p>CountDownLatch 类中主要的方法？</p>\n<h3 id=\"5-CyclicBarrier-循环栅栏\"><a href=\"#5-CyclicBarrier-循环栅栏\" class=\"headerlink\" title=\"5 CyclicBarrier(循环栅栏)\"></a>5 CyclicBarrier(循环栅栏)</h3><p>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。</p>\n<blockquote>\n<p>CountDownLatch的实现是基于AQS的，而CycliBarrier是基于 ReentrantLock(ReentrantLock也属于AQS同步器)和 Condition 的.</p>\n</blockquote>\n<p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p>\n<p>再来看一下它的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CyclicBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> parties)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(parties, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CyclicBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parties &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.parties = parties;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.count = parties;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.barrierCommand = barrierAction;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p>\n<h4 id=\"5-1-CyclicBarrier-的应用场景\"><a href=\"#5-1-CyclicBarrier-的应用场景\" class=\"headerlink\" title=\"5.1 CyclicBarrier 的应用场景\"></a>5.1 CyclicBarrier 的应用场景</h4><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p>\n<h4 id=\"5-2-CyclicBarrier-的使用示例\"><a href=\"#5-2-CyclicBarrier-的使用示例\" class=\"headerlink\" title=\"5.2 CyclicBarrier 的使用示例\"></a>5.2 CyclicBarrier 的使用示例</h4><p>示例 1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Snailclimb</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018年10月1日</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 测试 CyclicBarrier 类中带参数的 await() 方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierExample2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求的数量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">550</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 需要同步的线程数量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> CyclicBarrier cyclicBarrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建线程池</span></span><br><span class=\"line\">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadNum = i;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      threadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          test(threadNum);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threadPool.shutdown();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> threadnum)</span> <span class=\"keyword\">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"threadnum:\"</span> + threadnum + <span class=\"string\">\"is ready\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**等待60秒，保证子线程完全执行结束*/</span></span><br><span class=\"line\">      cyclicBarrier.await(<span class=\"number\">60</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"-----CyclicBarrierException------\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"threadnum:\"</span> + threadnum + <span class=\"string\">\"is finish\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadnum:<span class=\"number\">0</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">1</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">2</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">3</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">4</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">4</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">0</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">1</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">2</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">3</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">5</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">6</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">7</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">8</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">9</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">9</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">5</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">8</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">7</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">6</span>is finish</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， <code>await</code>方法之后的方法才被执行。</p>\n<p>另外，CyclicBarrier 还提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行<code>barrierAction</code>，方便处理更复杂的业务场景。示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> SnailClimb</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018年10月1日</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 新建 CyclicBarrier 的时候指定一个 Runnable</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierExample3</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求的数量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">550</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 需要同步的线程数量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> CyclicBarrier cyclicBarrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">5</span>, () -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"------当线程数达到之后，优先执行------\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建线程池</span></span><br><span class=\"line\">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadNum = i;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      threadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          test(threadNum);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threadPool.shutdown();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> threadnum)</span> <span class=\"keyword\">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"threadnum:\"</span> + threadnum + <span class=\"string\">\"is ready\"</span>);</span><br><span class=\"line\">    cyclicBarrier.await();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"threadnum:\"</span> + threadnum + <span class=\"string\">\"is finish\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadnum:<span class=\"number\">0</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">1</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">2</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">3</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">4</span>is ready</span><br><span class=\"line\">------当线程数达到之后，优先执行------</span><br><span class=\"line\">threadnum:<span class=\"number\">4</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">0</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">2</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">1</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">3</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">5</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">6</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">7</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">8</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">9</span>is ready</span><br><span class=\"line\">------当线程数达到之后，优先执行------</span><br><span class=\"line\">threadnum:<span class=\"number\">9</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">5</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">6</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">8</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">7</span>is finish</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-3-CyclicBarrier源码分析\"><a href=\"#5-3-CyclicBarrier源码分析\" class=\"headerlink\" title=\"5.3 CyclicBarrier源码分析\"></a>5.3 <code>CyclicBarrier</code>源码分析</h4><p>当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是<code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 parties 的值时，栅栏才会打开，线程才得以通过执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dowait(<span class=\"keyword\">false</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (TimeoutException toe) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(toe); <span class=\"comment\">// cannot happen</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dowait(false, 0L)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Main barrier code, covering the various policies.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dowait</span><span class=\"params\">(<span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class=\"line\"><span class=\"function\">           TimeoutException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    <span class=\"comment\">// 锁住</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Generation g = generation;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g.broken)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BrokenBarrierException();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果线程中断了，抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.interrupted()) &#123;</span><br><span class=\"line\">            breakBarrier();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// cout减1</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = --count;</span><br><span class=\"line\">        <span class=\"comment\">// 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// tripped</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> ranAction = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Runnable command = barrierCommand;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (command != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    command.run();</span><br><span class=\"line\">                ranAction = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 将 count 重置为 parties 属性的初始化值</span></span><br><span class=\"line\">                <span class=\"comment\">// 唤醒之前等待的线程</span></span><br><span class=\"line\">                <span class=\"comment\">// 下一波执行开始</span></span><br><span class=\"line\">                nextGeneration();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ranAction)</span><br><span class=\"line\">                    breakBarrier();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!timed)</span><br><span class=\"line\">                    trip.await();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nanos &gt; <span class=\"number\">0L</span>)</span><br><span class=\"line\">                    nanos = trip.awaitNanos(nanos);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException ie) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class=\"line\">                    breakBarrier();</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> ie;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// We're about to finish waiting even if we had not</span></span><br><span class=\"line\">                    <span class=\"comment\">// been interrupted, so this interrupt is deemed to</span></span><br><span class=\"line\">                    <span class=\"comment\">// \"belong\" to subsequent execution.</span></span><br><span class=\"line\">                    Thread.currentThread().interrupt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g.broken)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BrokenBarrierException();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g != generation)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timed &amp;&amp; nanos &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                breakBarrier();</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TimeoutException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：<code>CyclicBarrier</code> 内部通过一个 count 变量作为计数器，cout 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>\n<h4 id=\"5-4-CyclicBarrier-和-CountDownLatch-的区别\"><a href=\"#5-4-CyclicBarrier-和-CountDownLatch-的区别\" class=\"headerlink\" title=\"5.4 CyclicBarrier 和 CountDownLatch 的区别\"></a>5.4 CyclicBarrier 和 CountDownLatch 的区别</h4><p><strong>下面这个是国外一个大佬的回答：</strong></p>\n<p>CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从 jdk 作者设计的目的来看，javadoc 是这么描述它们的：</p>\n<blockquote>\n<p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p>\n</blockquote>\n<p>对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p>\n<p>CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p>\n<h3 id=\"6-ReentrantLock-和-ReentrantReadWriteLock\"><a href=\"#6-ReentrantLock-和-ReentrantReadWriteLock\" class=\"headerlink\" title=\"6 ReentrantLock 和 ReentrantReadWriteLock\"></a>6 ReentrantLock 和 ReentrantReadWriteLock</h3><p>ReentrantLock 和 synchronized 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://juejin.im/post/5ae755256fb9a07ac3634067\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ae755256fb9a07ac3634067</a></li>\n<li><a href=\"https://blog.csdn.net/u010185262/article/details/54692886\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010185262/article/details/54692886</a></li>\n<li><a href=\"https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"AQS-介绍\"><a href=\"#AQS-介绍\" class=\"headerlink\" title=\"AQS 介绍\"></a>AQS 介绍</h1><h3 id=\"1-AQS-简单介绍\"><a href=\"#1-AQS-简单介绍\" class=\"headerlink\" title=\"1 AQS 简单介绍\"></a>1 AQS 简单介绍</h3><p>AQS 的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks 包下面。</p>\n<p><img src=\"/images/54546254.png\" alt=\"类图\"></p>\n<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask(jdk1.7) 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>\n<h3 id=\"2-AQS-原理\"><a href=\"#2-AQS-原理\" class=\"headerlink\" title=\"2 AQS 原理\"></a>2 AQS 原理</h3><blockquote>\n<p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p>\n</blockquote>\n<p>下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p>\n<h4 id=\"2-1-AQS-原理概览\"><a href=\"#2-1-AQS-原理概览\" class=\"headerlink\" title=\"2.1 AQS 原理概览\"></a>2.1 AQS 原理概览</h4><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>\n<blockquote>\n<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>\n</blockquote>\n<p>看个 AQS(AbstractQueuedSynchronizer)原理图：</p>\n<p><img src=\"/images/453525.png\" alt=\"453525\"></p>\n<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;<span class=\"comment\">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>\n\n<p>状态信息通过 protected 类型的<code>getState</code>，<code>setState</code>，<code>compareAndSetState</code>进行操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回同步状态的当前值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"comment\">// 设置同步状态的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(<span class=\"keyword\">int</span> newState)</span> </span>&#123;</span><br><span class=\"line\">        state = newState;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetState</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-AQS-对资源的共享方式\"><a href=\"#2-2-AQS-对资源的共享方式\" class=\"headerlink\" title=\"2.2 AQS 对资源的共享方式\"></a>2.2 AQS 对资源的共享方式</h4><p><strong>AQS 定义两种资源共享方式</strong></p>\n<p><strong>1)Exclusive</strong>（独占）</p>\n<p>只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：</p>\n<ul>\n<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>\n<li>非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li>\n</ul>\n<blockquote>\n<p>说明：下面这部分关于 <code>ReentrantLock</code> 源代码内容节选自：<a href=\"https://www.javadoop.com/post/AbstractQueuedSynchronizer-2\" target=\"_blank\" rel=\"noopener\">https://www.javadoop.com/post/AbstractQueuedSynchronizer-2</a> ，这是一篇很不错文章，推荐阅读。</p>\n</blockquote>\n<p><strong>下面来看 ReentrantLock 中相关的源代码：</strong></p>\n<p>ReentrantLock 默认采用非公平锁，因为考虑获得更好的性能，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Synchronizer providing all implementation mechanics */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 默认非公平锁</span></span><br><span class=\"line\">    sync = <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    sync = fair ? <span class=\"keyword\">new</span> FairSync() : <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ReentrantLock 中公平锁的 <code>lock</code> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">            selfInterrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">                compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(current);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">            setState(nextc);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>非公平锁的 lock 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">            selfInterrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class=\"line\"><span class=\"comment\"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里没有对阻塞队列进行判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：公平锁和非公平锁只有两处不同：</p>\n<ol>\n<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>\n<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>\n</ol>\n<p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p>\n<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>\n<p><strong>2)Share</strong>（共享）</p>\n<p>多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p>\n<p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p>\n<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在上层已经帮我们实现好了。</p>\n<h4 id=\"2-3-AQS-底层使用了模板方法模式\"><a href=\"#2-3-AQS-底层使用了模板方法模式\" class=\"headerlink\" title=\"2.3 AQS 底层使用了模板方法模式\"></a>2.3 AQS 底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>\n<ol>\n<li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>\n<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>\n</ol>\n<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。</p>\n<blockquote>\n<p>模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票<code>buyTicket()</code>-&gt;安检<code>securityCheck()</code>-&gt;乘坐某某工具回家<code>ride()</code>-&gt;到达目的地<code>arrive()</code>。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了<code>ride()</code>方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 <code>ride()</code>方法。</p>\n</blockquote>\n<p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isHeldExclusively()<span class=\"comment\">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class=\"line\">tryAcquire(<span class=\"keyword\">int</span>)<span class=\"comment\">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class=\"line\">tryRelease(<span class=\"keyword\">int</span>)<span class=\"comment\">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class=\"line\">tryAcquireShared(<span class=\"keyword\">int</span>)<span class=\"comment\">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class=\"line\">tryReleaseShared(<span class=\"keyword\">int</span>)<span class=\"comment\">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>\n<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到 A 线程 unlock()到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p>\n<p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS(Compare and Swap)减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。</p>\n<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>\n<p>推荐两篇 AQS 原理和相关源码分析的文章：</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/waterystone/p/4920797.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/waterystone/p/4920797.html</a></li>\n<li><a href=\"https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li>\n</ul>\n<h3 id=\"3-Semaphore-信号量-允许多个线程同时访问\"><a href=\"#3-Semaphore-信号量-允许多个线程同时访问\" class=\"headerlink\" title=\"3 Semaphore(信号量)-允许多个线程同时访问\"></a>3 Semaphore(信号量)-允许多个线程同时访问</h3><p><strong>synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</strong></p>\n<p>示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Snailclimb</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018年9月30日</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 需要一次性拿一个许可的情况</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SemaphoreExample1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求的数量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">550</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class=\"line\">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">300</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 一次只能允许执行的线程数量。</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Semaphore semaphore = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadnum = i;</span><br><span class=\"line\">      threadPool.execute(() -&gt; &#123;<span class=\"comment\">// Lambda 表达式的运用</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          semaphore.acquire();<span class=\"comment\">// 获取一个许可，所以可运行线程数量为20/1=20</span></span><br><span class=\"line\">          test(threadnum);</span><br><span class=\"line\">          semaphore.release();<span class=\"comment\">// 释放一个许可</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threadPool.shutdown();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"finish\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> threadnum)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">// 模拟请求的耗时操作</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"threadnum:\"</span> + threadnum);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">// 模拟请求的耗时操作</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行 <code>acquire</code> 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 <code>release</code> 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。 Semaphore 经常用于限制获取某种资源的线程数量。</p>\n<p>当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore.acquire(<span class=\"number\">5</span>);<span class=\"comment\">// 获取5个许可，所以可运行线程数量为20/5=4</span></span><br><span class=\"line\">test(threadnum);</span><br><span class=\"line\">semaphore.release(<span class=\"number\">5</span>);<span class=\"comment\">// 获取5个许可，所以可运行线程数量为20/5=4</span></span><br></pre></td></tr></table></figure>\n\n<p>除了 <code>acquire</code>方法之外，另一个比较常用的与之对应的方法是<code>tryAcquire</code>方法，该方法如果获取不到许可就立即返回 false。</p>\n<p>Semaphore 有两种模式，公平模式和非公平模式。</p>\n<ul>\n<li><strong>公平模式：</strong> 调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；</li>\n<li><strong>非公平模式：</strong> 抢占式的。</li>\n</ul>\n<p><strong>Semaphore 对应的两个构造方法如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> </span>&#123;</span><br><span class=\"line\">     sync = <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits, <span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">     sync = fair ? <span class=\"keyword\">new</span> FairSync(permits) : <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</strong></p>\n<p><a href=\"https://github.com/Snailclimb/JavaGuide/issues/645\" target=\"_blank\" rel=\"noopener\">issue645补充内容</a> ：Semaphore与CountDownLatch一样，也是共享锁的一种实现。它默认构造AQS的state为permits。当执行任务的线程数量超出permits,那么多余的线程将会被放入阻塞队列Park,并自旋判断state是否大于0。只有当state大于0的时候，阻塞的线程才能继续执行,此时先前执行任务的线程继续执行release方法，release方法使得state的变量会加1，那么自旋的线程便会判断成功。 如此，每次只有最多不超过permits数量的线程能自旋成功，便限制了执行任务线程的数量。</p>\n<p>由于篇幅问题，如果对 Semaphore 源码感兴趣的朋友可以看下这篇文章：<a href=\"https://juejin.im/post/5ae755366fb9a07ab508adc6\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ae755366fb9a07ab508adc6</a></p>\n<h3 id=\"4-CountDownLatch-（倒计时器）\"><a href=\"#4-CountDownLatch-（倒计时器）\" class=\"headerlink\" title=\"4 CountDownLatch （倒计时器）\"></a>4 CountDownLatch （倒计时器）</h3><p>CountDownLatch允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。在 Java 并发中，countdownlatch 的概念是一个常见的面试题，所以一定要确保你很好的理解了它。</p>\n<p>CountDownLatch是共享锁的一种实现,它默认构造 AQS 的 state 值为 count。当线程使用countDown方法时,其实使用了<code>tryReleaseShared</code>方法以CAS的操作来减少state,直至state为0就代表所有的线程都调用了countDown方法。当调用await方法的时候，如果state不为0，就代表仍然有线程没有调用countDown方法，那么就把已经调用过countDown的线程都放入阻塞队列Park,并自旋CAS判断state == 0，直至最后一个线程调用了countDown，使得state == 0，于是阻塞的线程便判断成功，全部往下执行。</p>\n<h4 id=\"4-1-CountDownLatch-的两种典型用法\"><a href=\"#4-1-CountDownLatch-的两种典型用法\" class=\"headerlink\" title=\"4.1 CountDownLatch 的两种典型用法\"></a>4.1 CountDownLatch 的两种典型用法</h4><ol>\n<li>某一线程在开始运行前等待 n 个线程执行完毕。将 CountDownLatch 的计数器初始化为 n ：<code>new CountDownLatch(n)</code>，每当一个任务线程执行完毕，就将计数器减 1 <code>countdownlatch.countDown()</code>，当计数器的值变为 0 时，在<code>CountDownLatch上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li>\n<li>实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 ：<code>new CountDownLatch(1)</code>，多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 countDown() 时，计数器变为 0，多个线程同时被唤醒。</li>\n</ol>\n<h4 id=\"4-2-CountDownLatch-的使用示例\"><a href=\"#4-2-CountDownLatch-的使用示例\" class=\"headerlink\" title=\"4.2 CountDownLatch 的使用示例\"></a>4.2 CountDownLatch 的使用示例</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> SnailClimb</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018年10月1日</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: CountDownLatch 使用方法示例</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountDownLatchExample1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求的数量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">550</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class=\"line\">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">300</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> CountDownLatch countDownLatch = <span class=\"keyword\">new</span> CountDownLatch(threadCount);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadnum = i;</span><br><span class=\"line\">      threadPool.execute(() -&gt; &#123;<span class=\"comment\">// Lambda 表达式的运用</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          test(threadnum);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          countDownLatch.countDown();<span class=\"comment\">// 表示一个请求已经被完成</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    countDownLatch.await();</span><br><span class=\"line\">    threadPool.shutdown();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"finish\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> threadnum)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">// 模拟请求的耗时操作</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"threadnum:\"</span> + threadnum);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);<span class=\"comment\">// 模拟请求的耗时操作</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码中，我们定义了请求的数量为 550，当这 550 个请求被处理完成之后，才会执行<code>System.out.println(&quot;finish&quot;);</code>。</p>\n<p>与 CountDownLatch 的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用 <code>CountDownLatch.await()</code> 方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p>\n<p>其他 N 个线程必须引用闭锁对象，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；每调用一次这个方法，在构造函数中初始化的 count 值就减 1。所以当 N 个线程都调 用了这个方法，count 的值等于 0，然后主线程就能通过 <code>await()</code>方法，恢复执行自己的任务。</p>\n<p>再插一嘴：<code>CountDownLatch</code> 的 <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount-<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">.......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就导致 <code>count</code> 的值没办法等于 0，然后就会导致一直等待。</p>\n<p>如果对CountDownLatch源码感兴趣的朋友，可以查看： <a href=\"https://www.cnblogs.com/leesf456/p/5406191.html\" target=\"_blank\" rel=\"noopener\">【JUC】JDK1.8源码分析之CountDownLatch（五）</a></p>\n<h4 id=\"4-3-CountDownLatch-的不足\"><a href=\"#4-3-CountDownLatch-的不足\" class=\"headerlink\" title=\"4.3 CountDownLatch 的不足\"></a>4.3 CountDownLatch 的不足</h4><p>CountDownLatch 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 CountDownLatch 使用完毕后，它不能再次被使用。</p>\n<h4 id=\"4-4-CountDownLatch-相常见面试题\"><a href=\"#4-4-CountDownLatch-相常见面试题\" class=\"headerlink\" title=\"4.4 CountDownLatch 相常见面试题\"></a>4.4 CountDownLatch 相常见面试题</h4><p>解释一下 CountDownLatch 概念？</p>\n<p>CountDownLatch 和 CyclicBarrier 的不同之处？</p>\n<p>给出一些 CountDownLatch 使用的例子？</p>\n<p>CountDownLatch 类中主要的方法？</p>\n<h3 id=\"5-CyclicBarrier-循环栅栏\"><a href=\"#5-CyclicBarrier-循环栅栏\" class=\"headerlink\" title=\"5 CyclicBarrier(循环栅栏)\"></a>5 CyclicBarrier(循环栅栏)</h3><p>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。</p>\n<blockquote>\n<p>CountDownLatch的实现是基于AQS的，而CycliBarrier是基于 ReentrantLock(ReentrantLock也属于AQS同步器)和 Condition 的.</p>\n</blockquote>\n<p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p>\n<p>再来看一下它的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CyclicBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> parties)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(parties, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CyclicBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parties &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.parties = parties;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.count = parties;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.barrierCommand = barrierAction;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中，parties 就代表了有拦截的线程的数量，当拦截的线程数量达到这个值的时候就打开栅栏，让所有线程通过。</p>\n<h4 id=\"5-1-CyclicBarrier-的应用场景\"><a href=\"#5-1-CyclicBarrier-的应用场景\" class=\"headerlink\" title=\"5.1 CyclicBarrier 的应用场景\"></a>5.1 CyclicBarrier 的应用场景</h4><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</p>\n<h4 id=\"5-2-CyclicBarrier-的使用示例\"><a href=\"#5-2-CyclicBarrier-的使用示例\" class=\"headerlink\" title=\"5.2 CyclicBarrier 的使用示例\"></a>5.2 CyclicBarrier 的使用示例</h4><p>示例 1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Snailclimb</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018年10月1日</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 测试 CyclicBarrier 类中带参数的 await() 方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierExample2</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求的数量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">550</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 需要同步的线程数量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> CyclicBarrier cyclicBarrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建线程池</span></span><br><span class=\"line\">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadNum = i;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      threadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          test(threadNum);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threadPool.shutdown();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> threadnum)</span> <span class=\"keyword\">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"threadnum:\"</span> + threadnum + <span class=\"string\">\"is ready\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/**等待60秒，保证子线程完全执行结束*/</span></span><br><span class=\"line\">      cyclicBarrier.await(<span class=\"number\">60</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"-----CyclicBarrierException------\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"threadnum:\"</span> + threadnum + <span class=\"string\">\"is finish\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadnum:<span class=\"number\">0</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">1</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">2</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">3</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">4</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">4</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">0</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">1</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">2</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">3</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">5</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">6</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">7</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">8</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">9</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">9</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">5</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">8</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">7</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">6</span>is finish</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<p>可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， <code>await</code>方法之后的方法才被执行。</p>\n<p>另外，CyclicBarrier 还提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行<code>barrierAction</code>，方便处理更复杂的业务场景。示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> SnailClimb</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018年10月1日</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span>: 新建 CyclicBarrier 的时候指定一个 Runnable</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierExample3</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 请求的数量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">550</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 需要同步的线程数量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> CyclicBarrier cyclicBarrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">5</span>, () -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"------当线程数达到之后，优先执行------\"</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建线程池</span></span><br><span class=\"line\">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadNum = i;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">      threadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          test(threadNum);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">          e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threadPool.shutdown();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> threadnum)</span> <span class=\"keyword\">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"threadnum:\"</span> + threadnum + <span class=\"string\">\"is ready\"</span>);</span><br><span class=\"line\">    cyclicBarrier.await();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"threadnum:\"</span> + threadnum + <span class=\"string\">\"is finish\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadnum:<span class=\"number\">0</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">1</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">2</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">3</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">4</span>is ready</span><br><span class=\"line\">------当线程数达到之后，优先执行------</span><br><span class=\"line\">threadnum:<span class=\"number\">4</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">0</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">2</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">1</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">3</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">5</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">6</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">7</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">8</span>is ready</span><br><span class=\"line\">threadnum:<span class=\"number\">9</span>is ready</span><br><span class=\"line\">------当线程数达到之后，优先执行------</span><br><span class=\"line\">threadnum:<span class=\"number\">9</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">5</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">6</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">8</span>is finish</span><br><span class=\"line\">threadnum:<span class=\"number\">7</span>is finish</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-3-CyclicBarrier源码分析\"><a href=\"#5-3-CyclicBarrier源码分析\" class=\"headerlink\" title=\"5.3 CyclicBarrier源码分析\"></a>5.3 <code>CyclicBarrier</code>源码分析</h4><p>当调用 <code>CyclicBarrier</code> 对象调用 <code>await()</code> 方法时，实际上调用的是<code>dowait(false, 0L)</code>方法。 <code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 parties 的值时，栅栏才会打开，线程才得以通过执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dowait(<span class=\"keyword\">false</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (TimeoutException toe) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(toe); <span class=\"comment\">// cannot happen</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>dowait(false, 0L)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Main barrier code, covering the various policies.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dowait</span><span class=\"params\">(<span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class=\"line\"><span class=\"function\">           TimeoutException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    <span class=\"comment\">// 锁住</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Generation g = generation;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g.broken)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BrokenBarrierException();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果线程中断了，抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.interrupted()) &#123;</span><br><span class=\"line\">            breakBarrier();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// cout减1</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = --count;</span><br><span class=\"line\">        <span class=\"comment\">// 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == <span class=\"number\">0</span>) &#123;  <span class=\"comment\">// tripped</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> ranAction = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Runnable command = barrierCommand;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (command != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    command.run();</span><br><span class=\"line\">                ranAction = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 将 count 重置为 parties 属性的初始化值</span></span><br><span class=\"line\">                <span class=\"comment\">// 唤醒之前等待的线程</span></span><br><span class=\"line\">                <span class=\"comment\">// 下一波执行开始</span></span><br><span class=\"line\">                nextGeneration();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ranAction)</span><br><span class=\"line\">                    breakBarrier();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!timed)</span><br><span class=\"line\">                    trip.await();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nanos &gt; <span class=\"number\">0L</span>)</span><br><span class=\"line\">                    nanos = trip.awaitNanos(nanos);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException ie) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class=\"line\">                    breakBarrier();</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> ie;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// We're about to finish waiting even if we had not</span></span><br><span class=\"line\">                    <span class=\"comment\">// been interrupted, so this interrupt is deemed to</span></span><br><span class=\"line\">                    <span class=\"comment\">// \"belong\" to subsequent execution.</span></span><br><span class=\"line\">                    Thread.currentThread().interrupt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g.broken)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BrokenBarrierException();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g != generation)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timed &amp;&amp; nanos &lt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                breakBarrier();</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TimeoutException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：<code>CyclicBarrier</code> 内部通过一个 count 变量作为计数器，cout 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p>\n<h4 id=\"5-4-CyclicBarrier-和-CountDownLatch-的区别\"><a href=\"#5-4-CyclicBarrier-和-CountDownLatch-的区别\" class=\"headerlink\" title=\"5.4 CyclicBarrier 和 CountDownLatch 的区别\"></a>5.4 CyclicBarrier 和 CountDownLatch 的区别</h4><p><strong>下面这个是国外一个大佬的回答：</strong></p>\n<p>CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从 jdk 作者设计的目的来看，javadoc 是这么描述它们的：</p>\n<blockquote>\n<p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p>\n</blockquote>\n<p>对于 CountDownLatch 来说，重点是“一个线程（多个线程）等待”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p>\n<p>CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p>\n<h3 id=\"6-ReentrantLock-和-ReentrantReadWriteLock\"><a href=\"#6-ReentrantLock-和-ReentrantReadWriteLock\" class=\"headerlink\" title=\"6 ReentrantLock 和 ReentrantReadWriteLock\"></a>6 ReentrantLock 和 ReentrantReadWriteLock</h3><p>ReentrantLock 和 synchronized 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://juejin.im/post/5ae755256fb9a07ac3634067\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5ae755256fb9a07ac3634067</a></li>\n<li><a href=\"https://blog.csdn.net/u010185262/article/details/54692886\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u010185262/article/details/54692886</a></li>\n<li><a href=\"https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0</a></li>\n</ul>\n"},{"title":"Java线程池实现原理及实践","date":"2020-05-22T08:55:27.000Z","_content":"# Java线程池实现原理及实践\n\n随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。了解并合理使用线程池，是一个开发人员必修的基本功。\n\n本文开篇简述线程池概念和用途，接着结合线程池的源码，帮助读者领略线程池的设计思路，最后回归实践，通过案例讲述使用线程池遇到的问题，并给出了一种动态化线程池解决方案。\n\n## 一、写在前面\n\n### 1.1 线程池是什么\n\n线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。\n\n线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。\n\n而本文描述线程池是JDK中提供的ThreadPoolExecutor类。\n\n当然，使用线程池可以带来一系列好处：\n\n- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。\n- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。\n- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。\n- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。\n\n### 1.2 线程池解决的问题是什么\n\n线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：\n\n1. 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。\n2. 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。\n3. 系统无法合理管理内部的资源分布，会降低系统的稳定性。\n\n为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。\n\nPooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia\n\n“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。\n\n在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：\n\n1. 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。\n2. 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。\n3. 实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。\n\n在了解完“是什么”和“为什么”之后，下面我们来一起深入一下线程池的内部实现原理。\n\n## 二、线程池核心设计与实现\n\n在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。那么它的的详细设计与实现是什么样的呢？我们会在本章进行详细介绍。\n\n### 2.1 总体设计\n\nJava中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。\n\n![图1 ThreadPoolExecutor UML类图](/images/912883e51327e0c7a9d753d11896326511272.png)\n\n图1 ThreadPoolExecutor UML类图\n\nThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。\n\nThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：\n\n![图2 ThreadPoolExecutor运行流程](/images/thread-pool.png)\n\n图2 ThreadPoolExecutor运行流程\n\n线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。\n\n接下来，我们会按照以下三个部分去详细讲解线程池运行机制：\n\n1. 线程池如何维护自身状态。\n2. 线程池如何管理任务。\n3. 线程池如何管理线程。\n\n### 2.2 生命周期管理\n\n线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：\n\n```\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n```\n\n`ctl`这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。\n\n关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：\n\n```\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; } //计算当前运行状态\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }  //计算当前线程数量\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }   //通过状态和线程数生成ctl\n```\n\nThreadPoolExecutor的运行状态有5种，分别为：\n\n![img](https://p0.meituan.net/travelcube/62853fa44bfa47d63143babe3b5a4c6e82532.png)\n\n其生命周期转换如下入所示：\n\n![图3 线程池生命周期](/images/582d1606d57ff99aa0e5f8fc59c7819329028.png)\n\n图3 线程池生命周期\n\n### 2.3 任务执行机制\n\n**2.3.1 任务调度**\n\n任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。\n\n首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：\n\n1. 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。\n2. 如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。\n3. 如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。\n4. 如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。\n5. 如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。\n\n其执行流程如下图所示：\n\n![图4 任务调度流程](/images/31bad766983e212431077ca8da92762050214.png)\n\n图4 任务调度流程\n\n**2.3.2 任务缓冲**\n\n任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。\n\n阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。\n\n下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：\n\n![图5 阻塞队列](/images/f4d89c87acf102b45be8ccf3ed83352a9497.png)\n\n图5 阻塞队列\n\n使用不同的队列可以实现不一样的任务存取策略。在这里，我们可以再介绍下阻塞队列的成员：\n\n![img](/images/725a3db5114d95675f2098c12dc331c3316963.png)\n\n**2.3.3 任务申请**\n\n由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。\n\n线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：\n\n![图6 获取任务流程图](/images/49d8041f8480aba5ef59079fcc7143b996706.png)\n\n图6 获取任务流程图\n\ngetTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。\n\n**2.3.4 任务拒绝**\n\n任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。\n\n拒绝策略是一个接口，其设计如下：\n\n```\npublic interface RejectedExecutionHandler {\n    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);\n}\n```\n\n用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：\n\n![img](/images/9ffb64cc4c64c0cb8d38dac01c89c905178456.png)\n\n2.4 Worker线程管理\n\n2.4.1 Worker线程\n\n线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码：\n\n```\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable{\n    final Thread thread;//Worker持有的线程\n    Runnable firstTask;//初始化的任务，可以为null\n}\n```\n\nWorker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。\n\nWorker执行任务的模型如下图所示：\n\n![图7 Worker执行任务](/images/03268b9dc49bd30bb63064421bb036bf90315.png)\n\n图7 Worker执行任务\n\n线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。\n\nWorker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。\n\n1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。\n\n在线程回收过程中就使用到了这种特性，回收过程如下图所示：\n\n![图8 线程池回收过程](/images/9d8dc9cebe59122127460f81a98894bb34085.png)\n\n图8 线程池回收过程\n\n**2.4.2 Worker线程增加**\n\n增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，其执行流程如下图所示：\n\n![图9 申请线程执行流程图](/images/49527b1bb385f0f43529e57b614f59ae145454.png)\n\n图9 申请线程执行流程图\n\n**2.4.3 Worker线程回收**\n\n线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。\n\n```\ntry {\n  while (task != null || (task = getTask()) != null) {\n    //执行任务\n  }\n} finally {\n  processWorkerExit(w, completedAbruptly);//获取不到任务时，主动回收自己\n}\n```\n\n线程回收的工作是在processWorkerExit方法完成的。\n\n![图10 线程销毁流程](/images/90ea093549782945f2c968403fdc39d415386.png)\n\n图10 线程销毁流程\n\n事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。\n\n**2.4.4 Worker线程执行任务**\n\n在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：\n\n1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。\n\n执行流程如下图所示：\n\n![图11 执行任务流程](/images/879edb4f06043d76cea27a3ff358cb1d45243.png)\n\n图11 执行任务流程\n\n## 三、线程池在业务中的实践\n\n### 3.1 业务背景\n\n在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。\n\n**场景1：快速响应用户请求**\n\n**描述**：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。\n\n**分析**：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。\n\n![图12 并行执行任务提升任务响应速度](/images/e9a363c8577f211577e4962e9110cb0226733.png)\n\n图12 并行执行任务提升任务响应速度\n\n**场景2：快速处理批量任务**\n\n**描述**：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。\n\n**分析**：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。\n\n![图13 并行执行任务提升批量任务执行速度](/images/1a1746f33bfdcb03da074d8539ebb2f367563.png)\n\n图13 并行执行任务提升批量任务执行速度\n\n### 3.2 实际问题及方案思考\n\n线程池使用面临的核心的问题在于：**线程池的参数并不好配置**。一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大，IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。\n\n关于线程池配置不合理引发的故障，公司内部有较多记录，下面举一些例子：\n\n**Case1**：2018年XX页面展示接口大量调用降级：\n\n**事故描述**：XX页面展示接口产生大量调用降级，数量级在几十到上百。\n\n**事故原因**：该服务展示接口内部逻辑使用线程池做并行计算，由于没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件，示意图如下：\n\n![图14 线程数核心设置过小引发RejectExecutionException](/images/1df932840b31f41931bb69e16be2932844240.png)\n\n图14 线程数核心设置过小引发RejectExecutionException\n\n**Case2**：2018年XX业务服务不可用S2级故障\n\n**事故描述**：XX业务提供的服务执行时间过长，作为上游服务整体超时，大量下游服务调用失败。\n\n**事故原因**：该服务处理请求内部逻辑使用线程池做资源隔离，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。示意图如下：\n\n![图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低](/images/668e3c90f4b918bfcead2f4280091e9757284.png)\n\n图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低\n\n业务中要使用线程池，而使用不当又会导致故障，那么我们怎样才能更好地使用线程池呢？针对这个问题，我们下面延展几个方向：\n\n**1. 能否不用线程池?**\n\n回到最初的问题，业务使用线程池是为了获取并发性，对于获取并发性，是否可以有什么其他的方案呢替代？我们尝试进行了一些其他方案的调研：\n\n![img](/images/56ab763273b2c03b2f1c37db7b150338414771.png)\n\n综合考虑，这些新的方案都能在某种情况下提升并行任务的性能，然而本次重点解决的问题是如何更简易、更安全地获得的并发性。另外，Actor模型的应用实际上甚少，只在Scala中使用广泛，协程框架在Java中维护的也不成熟。这三者现阶段都不是足够的易用，也并不能解决业务上现阶段的问题。\n\n**2. 追求参数设置合理性？**\n\n有没有一种计算公式，能够让开发同学很简易地计算出某种场景中的线程池应该是什么参数呢？\n\n带着这样的疑问，我们调研了业界的一些线程池参数配置方案：\n\n![img](/images/23a44974ff68a08261fb675242b83648181953.png)\n\n调研了以上业界方案后，我们并没有得出通用的线程池计算方式。并发任务的执行情况和任务类型相关，IO密集型和CPU密集型的任务运行起来的情况差异非常大，但这种占比是较难合理预估的，这导致很难有一个简单有效的通用公式帮我们直接计算出结果。\n\n**3. 线程池参数动态化？**\n\n尽管经过谨慎的评估，仍然不能够保证一次计算出来合适的参数，那么我们是否可以将修改线程池参数的成本降下来，这样至少可以发生故障的时候可以快速调整从而缩短故障恢复的时间呢？基于这个思考，我们是否可以将线程池的参数从代码中迁移到分布式配置中心上，实现线程池参数可动态配置和即时生效，线程池参数动态化前后的参数修改流程对比如下：\n\n![图16 动态修改线程池参数新旧流程对比](/images/c6caa5be64f39758ada0593b995d65fd25982.png)\n\n图16 动态修改线程池参数新旧流程对比\n\n基于以上三个方向对比，我们可以看出参数动态化方向简单有效。\n\n### 3.3 动态化线程池\n\n**3.3.1 整体设计**\n\n动态化线程池的核心设计包括以下三个方面：\n\n1. 简化线程池配置：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。\n2. 参数可动态修改：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。\n3. 增加线程池监控：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。\n\n![图17 动态化线程池整体设计](/images/4d5c410ad23782350cc9f980787151fd54144.png)\n\n图17 动态化线程池整体设计\n\n**3.3.2 功能架构**\n\n动态化线程池提供如下功能：\n\n**动态调参**：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。 **任务监控**：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95/99线等。 **负载告警**：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。 **操作监控**：创建/修改和删除线程池都会通知到应用的开发负责人。 **操作日志**：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。 **权限校验**：只有应用开发负责人才能够修改应用的线程池参数。\n\n![图18 动态化线程池功能架构](/images/6c0091e92e90f50f89fd83f3b9eb5472135718.png)\n\n图18 动态化线程池功能架构\n\n**参数动态化**\n\nJDK原生线程池ThreadPoolExecutor提供了如下几个public的setter方法，如下图所示：\n\n![图19 JDK 线程池参数设置接口](/images/efd32f1211e9cf0a3ca9d35b0dc5de8588353.png)\n\n图19 JDK 线程池参数设置接口\n\nJDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务，setCorePoolSize具体流程如下：\n\n![图20 setCorePoolSize方法执行流程](/images/9379fe1666818237f842138812bf63bd85645.png)\n\n图20 setCorePoolSize方法执行流程\n\n线程池内部会处理好当前状态做到平滑修改，其他几个方法限于篇幅，这里不一一介绍。重点是基于这几个public方法，我们只需要维护ThreadPoolExecutor的实例，并且在需要修改的时候拿到实例修改其参数即可。基于以上的思路，我们实现了线程池参数的动态化、线程池参数在管理平台可配置可修改，其效果图如下图所示：\n\n![图21 可动态修改线程池参数](/images/414ba7f3abd11e5f805c58635ae10988166121.png)\n\n图21 可动态修改线程池参数\n\n用户可以在管理平台上通过线程池的名字找到指定的线程池，然后对其参数进行修改，保存后会实时生效。目前支持的动态参数包括核心数、最大值、队列长度等。除此之外，在界面中，我们还能看到用户可以配置是否开启告警、队列等待任务告警阈值、活跃度告警等等。关于监控和告警，我们下面一节会对齐进行介绍。\n\n**线程池监控**\n\n除了参数动态化之外，为了更好地使用线程池，我们需要对线程池的运行状况有感知，比如当前线程池的负载是怎么样的？分配的资源够不够用？任务的执行情况是怎么样的？是长任务还是短任务？基于对这些问题的思考，动态化线程池提供了多个维度的监控和告警能力，包括：线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等，既能帮助用户从多个维度分析线程池的使用情况，又能在出现问题第一时间通知到用户，从而避免故障或加速故障恢复。\n\n#### 1. 负载监控和告警\n\n线程池负载关注的核心问题是：基于当前线程池参数分配的资源够不够。对于这个问题，我们可以从事前和事中两个角度来看。事前，线程池定义了“活跃度”这个概念，来让用户在发生Reject异常之前能够感知线程池负载问题，线程池活跃度计算公式为：线程池活跃度 = activeCount/maximumPoolSize。这个公式代表当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高。事中，也可以从两方面来看线程池的过载判定条件，一个是发生了Reject异常，一个是队列中有等待任务（支持定制阈值）。以上两种情况发生了都会触发告警，告警信息会通过大象推送给服务所关联的负责人。\n\n![图22 大象告警通知](/images/04e73f7186a91d99181e1b5615ce9e4a318600.png)\n\n图22 大象告警通知\n\n#### 2. 任务级精细化监控\n\n在传统的线程池应用场景中，线程池中的任务执行情况对于用户来说是透明的。比如在一个具体的业务场景中，业务开发申请了一个线程池同时用于执行两种任务，一个是发消息任务、一个是发短信任务，这两类任务实际执行的频率和时长对于用户来说没有一个直观的感受，很可能这两类任务不适合共享一个线程池，但是由于用户无法感知，因此也无从优化。动态化线程池内部实现了任务级别的埋点，且允许为不同的业务任务指定具有业务含义的名称，线程池内部基于这个名称做Transaction打点，基于这个功能，用户可以看到线程池内部任务级别的执行情况，且区分业务，任务监控示意图如下图所示：\n\n![图23 线程池任务执行监控](/images/cd0b9445c3c93a866201b7cfb24d2ce7214776.png)\n\n图23 线程池任务执行监控\n\n#### 3. 运行时状态实时查看\n\n用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数，如下图所示：\n\n![图24 线程池实时运行情况](/images/aba8d9c09e6f054c7061ddd720a04a26147951.png)\n\n图24 线程池实时运行情况\n\n动态化线程池基于这几个接口封装了运行时状态实时查看的功能，用户基于这个功能可以了解线程池的实时状态，比如当前有多少个工作线程，执行了多少个任务，队列中等待的任务数等等。效果如下图所示：\n\n![图25 线程池实时运行情况](/images/38d5fbeaebd4998f3a30d44bd20b996f113233.png)\n\n图25 线程池实时运行情况\n\n### 3.4 实践总结\n\n面对业务中使用线程池遇到的实际问题，我们曾回到支持并发性问题本身来思考有没有取代线程池的方案，也曾尝试着去追求线程池参数设置的合理性，但面对业界方案具体落地的复杂性、可维护性以及真实运行环境的不确定性，我们在前两个方向上可谓“举步维艰”。最终，我们回到线程池参数动态化方向上探索，得出一个且可以解决业务问题的方案，虽然本质上还是没有逃离使用线程池的范畴，但是在成本和收益之间，算是取得了一个很好的平衡。成本在于实现动态化以及监控成本不高，收益在于：在不颠覆原有线程池使用方式的基础之上，从降低线程池参数修改的成本以及多维度监控这两个方面降低了故障发生的概率。希望本文提供的动态化线程池思路能对大家有帮助。\n\n## 四、参考资料\n\n- [1] JDK 1.8源码\n- [2][维基百科-线程池](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0)\n- [3] [更好的使用Java线程池](https://my.oschina.net/andylucc/blog/648127)\n- [4] [维基百科Pooling(Resource Management)](https://en.wikipedia.org/wiki/Pooling_(resource_management))\n- [5] [深入理解Java线程池：ThreadPoolExecutor](http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/)\n- [6]《Java并发编程实践》","source":"_posts/java/Java-thread-pool.md","raw":"---\ntitle: Java线程池实现原理及实践\ndate: 2020-05-22 16:55:27\ntags:\n    - java\n    - thread-pool\ncategories:\n    - java\n    - thread-pool\n---\n# Java线程池实现原理及实践\n\n随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。了解并合理使用线程池，是一个开发人员必修的基本功。\n\n本文开篇简述线程池概念和用途，接着结合线程池的源码，帮助读者领略线程池的设计思路，最后回归实践，通过案例讲述使用线程池遇到的问题，并给出了一种动态化线程池解决方案。\n\n## 一、写在前面\n\n### 1.1 线程池是什么\n\n线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。\n\n线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。\n\n而本文描述线程池是JDK中提供的ThreadPoolExecutor类。\n\n当然，使用线程池可以带来一系列好处：\n\n- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。\n- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。\n- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。\n- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。\n\n### 1.2 线程池解决的问题是什么\n\n线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：\n\n1. 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。\n2. 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。\n3. 系统无法合理管理内部的资源分布，会降低系统的稳定性。\n\n为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。\n\nPooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia\n\n“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。\n\n在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：\n\n1. 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。\n2. 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。\n3. 实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。\n\n在了解完“是什么”和“为什么”之后，下面我们来一起深入一下线程池的内部实现原理。\n\n## 二、线程池核心设计与实现\n\n在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。那么它的的详细设计与实现是什么样的呢？我们会在本章进行详细介绍。\n\n### 2.1 总体设计\n\nJava中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。\n\n![图1 ThreadPoolExecutor UML类图](/images/912883e51327e0c7a9d753d11896326511272.png)\n\n图1 ThreadPoolExecutor UML类图\n\nThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。\n\nThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：\n\n![图2 ThreadPoolExecutor运行流程](/images/thread-pool.png)\n\n图2 ThreadPoolExecutor运行流程\n\n线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。\n\n接下来，我们会按照以下三个部分去详细讲解线程池运行机制：\n\n1. 线程池如何维护自身状态。\n2. 线程池如何管理任务。\n3. 线程池如何管理线程。\n\n### 2.2 生命周期管理\n\n线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：\n\n```\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n```\n\n`ctl`这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。\n\n关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：\n\n```\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; } //计算当前运行状态\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }  //计算当前线程数量\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }   //通过状态和线程数生成ctl\n```\n\nThreadPoolExecutor的运行状态有5种，分别为：\n\n![img](https://p0.meituan.net/travelcube/62853fa44bfa47d63143babe3b5a4c6e82532.png)\n\n其生命周期转换如下入所示：\n\n![图3 线程池生命周期](/images/582d1606d57ff99aa0e5f8fc59c7819329028.png)\n\n图3 线程池生命周期\n\n### 2.3 任务执行机制\n\n**2.3.1 任务调度**\n\n任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。\n\n首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：\n\n1. 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。\n2. 如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务。\n3. 如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。\n4. 如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。\n5. 如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。\n\n其执行流程如下图所示：\n\n![图4 任务调度流程](/images/31bad766983e212431077ca8da92762050214.png)\n\n图4 任务调度流程\n\n**2.3.2 任务缓冲**\n\n任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。\n\n阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。\n\n下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：\n\n![图5 阻塞队列](/images/f4d89c87acf102b45be8ccf3ed83352a9497.png)\n\n图5 阻塞队列\n\n使用不同的队列可以实现不一样的任务存取策略。在这里，我们可以再介绍下阻塞队列的成员：\n\n![img](/images/725a3db5114d95675f2098c12dc331c3316963.png)\n\n**2.3.3 任务申请**\n\n由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。\n\n线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：\n\n![图6 获取任务流程图](/images/49d8041f8480aba5ef59079fcc7143b996706.png)\n\n图6 获取任务流程图\n\ngetTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。\n\n**2.3.4 任务拒绝**\n\n任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。\n\n拒绝策略是一个接口，其设计如下：\n\n```\npublic interface RejectedExecutionHandler {\n    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);\n}\n```\n\n用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：\n\n![img](/images/9ffb64cc4c64c0cb8d38dac01c89c905178456.png)\n\n2.4 Worker线程管理\n\n2.4.1 Worker线程\n\n线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码：\n\n```\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable{\n    final Thread thread;//Worker持有的线程\n    Runnable firstTask;//初始化的任务，可以为null\n}\n```\n\nWorker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。\n\nWorker执行任务的模型如下图所示：\n\n![图7 Worker执行任务](/images/03268b9dc49bd30bb63064421bb036bf90315.png)\n\n图7 Worker执行任务\n\n线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。\n\nWorker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。\n\n1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。\n\n在线程回收过程中就使用到了这种特性，回收过程如下图所示：\n\n![图8 线程池回收过程](/images/9d8dc9cebe59122127460f81a98894bb34085.png)\n\n图8 线程池回收过程\n\n**2.4.2 Worker线程增加**\n\n增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，其执行流程如下图所示：\n\n![图9 申请线程执行流程图](/images/49527b1bb385f0f43529e57b614f59ae145454.png)\n\n图9 申请线程执行流程图\n\n**2.4.3 Worker线程回收**\n\n线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。\n\n```\ntry {\n  while (task != null || (task = getTask()) != null) {\n    //执行任务\n  }\n} finally {\n  processWorkerExit(w, completedAbruptly);//获取不到任务时，主动回收自己\n}\n```\n\n线程回收的工作是在processWorkerExit方法完成的。\n\n![图10 线程销毁流程](/images/90ea093549782945f2c968403fdc39d415386.png)\n\n图10 线程销毁流程\n\n事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。\n\n**2.4.4 Worker线程执行任务**\n\n在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：\n\n1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。\n\n执行流程如下图所示：\n\n![图11 执行任务流程](/images/879edb4f06043d76cea27a3ff358cb1d45243.png)\n\n图11 执行任务流程\n\n## 三、线程池在业务中的实践\n\n### 3.1 业务背景\n\n在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。\n\n**场景1：快速响应用户请求**\n\n**描述**：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。\n\n**分析**：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。\n\n![图12 并行执行任务提升任务响应速度](/images/e9a363c8577f211577e4962e9110cb0226733.png)\n\n图12 并行执行任务提升任务响应速度\n\n**场景2：快速处理批量任务**\n\n**描述**：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。\n\n**分析**：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。\n\n![图13 并行执行任务提升批量任务执行速度](/images/1a1746f33bfdcb03da074d8539ebb2f367563.png)\n\n图13 并行执行任务提升批量任务执行速度\n\n### 3.2 实际问题及方案思考\n\n线程池使用面临的核心的问题在于：**线程池的参数并不好配置**。一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大，IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。\n\n关于线程池配置不合理引发的故障，公司内部有较多记录，下面举一些例子：\n\n**Case1**：2018年XX页面展示接口大量调用降级：\n\n**事故描述**：XX页面展示接口产生大量调用降级，数量级在几十到上百。\n\n**事故原因**：该服务展示接口内部逻辑使用线程池做并行计算，由于没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件，示意图如下：\n\n![图14 线程数核心设置过小引发RejectExecutionException](/images/1df932840b31f41931bb69e16be2932844240.png)\n\n图14 线程数核心设置过小引发RejectExecutionException\n\n**Case2**：2018年XX业务服务不可用S2级故障\n\n**事故描述**：XX业务提供的服务执行时间过长，作为上游服务整体超时，大量下游服务调用失败。\n\n**事故原因**：该服务处理请求内部逻辑使用线程池做资源隔离，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。示意图如下：\n\n![图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低](/images/668e3c90f4b918bfcead2f4280091e9757284.png)\n\n图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低\n\n业务中要使用线程池，而使用不当又会导致故障，那么我们怎样才能更好地使用线程池呢？针对这个问题，我们下面延展几个方向：\n\n**1. 能否不用线程池?**\n\n回到最初的问题，业务使用线程池是为了获取并发性，对于获取并发性，是否可以有什么其他的方案呢替代？我们尝试进行了一些其他方案的调研：\n\n![img](/images/56ab763273b2c03b2f1c37db7b150338414771.png)\n\n综合考虑，这些新的方案都能在某种情况下提升并行任务的性能，然而本次重点解决的问题是如何更简易、更安全地获得的并发性。另外，Actor模型的应用实际上甚少，只在Scala中使用广泛，协程框架在Java中维护的也不成熟。这三者现阶段都不是足够的易用，也并不能解决业务上现阶段的问题。\n\n**2. 追求参数设置合理性？**\n\n有没有一种计算公式，能够让开发同学很简易地计算出某种场景中的线程池应该是什么参数呢？\n\n带着这样的疑问，我们调研了业界的一些线程池参数配置方案：\n\n![img](/images/23a44974ff68a08261fb675242b83648181953.png)\n\n调研了以上业界方案后，我们并没有得出通用的线程池计算方式。并发任务的执行情况和任务类型相关，IO密集型和CPU密集型的任务运行起来的情况差异非常大，但这种占比是较难合理预估的，这导致很难有一个简单有效的通用公式帮我们直接计算出结果。\n\n**3. 线程池参数动态化？**\n\n尽管经过谨慎的评估，仍然不能够保证一次计算出来合适的参数，那么我们是否可以将修改线程池参数的成本降下来，这样至少可以发生故障的时候可以快速调整从而缩短故障恢复的时间呢？基于这个思考，我们是否可以将线程池的参数从代码中迁移到分布式配置中心上，实现线程池参数可动态配置和即时生效，线程池参数动态化前后的参数修改流程对比如下：\n\n![图16 动态修改线程池参数新旧流程对比](/images/c6caa5be64f39758ada0593b995d65fd25982.png)\n\n图16 动态修改线程池参数新旧流程对比\n\n基于以上三个方向对比，我们可以看出参数动态化方向简单有效。\n\n### 3.3 动态化线程池\n\n**3.3.1 整体设计**\n\n动态化线程池的核心设计包括以下三个方面：\n\n1. 简化线程池配置：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。\n2. 参数可动态修改：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。\n3. 增加线程池监控：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。\n\n![图17 动态化线程池整体设计](/images/4d5c410ad23782350cc9f980787151fd54144.png)\n\n图17 动态化线程池整体设计\n\n**3.3.2 功能架构**\n\n动态化线程池提供如下功能：\n\n**动态调参**：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。 **任务监控**：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95/99线等。 **负载告警**：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。 **操作监控**：创建/修改和删除线程池都会通知到应用的开发负责人。 **操作日志**：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。 **权限校验**：只有应用开发负责人才能够修改应用的线程池参数。\n\n![图18 动态化线程池功能架构](/images/6c0091e92e90f50f89fd83f3b9eb5472135718.png)\n\n图18 动态化线程池功能架构\n\n**参数动态化**\n\nJDK原生线程池ThreadPoolExecutor提供了如下几个public的setter方法，如下图所示：\n\n![图19 JDK 线程池参数设置接口](/images/efd32f1211e9cf0a3ca9d35b0dc5de8588353.png)\n\n图19 JDK 线程池参数设置接口\n\nJDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务，setCorePoolSize具体流程如下：\n\n![图20 setCorePoolSize方法执行流程](/images/9379fe1666818237f842138812bf63bd85645.png)\n\n图20 setCorePoolSize方法执行流程\n\n线程池内部会处理好当前状态做到平滑修改，其他几个方法限于篇幅，这里不一一介绍。重点是基于这几个public方法，我们只需要维护ThreadPoolExecutor的实例，并且在需要修改的时候拿到实例修改其参数即可。基于以上的思路，我们实现了线程池参数的动态化、线程池参数在管理平台可配置可修改，其效果图如下图所示：\n\n![图21 可动态修改线程池参数](/images/414ba7f3abd11e5f805c58635ae10988166121.png)\n\n图21 可动态修改线程池参数\n\n用户可以在管理平台上通过线程池的名字找到指定的线程池，然后对其参数进行修改，保存后会实时生效。目前支持的动态参数包括核心数、最大值、队列长度等。除此之外，在界面中，我们还能看到用户可以配置是否开启告警、队列等待任务告警阈值、活跃度告警等等。关于监控和告警，我们下面一节会对齐进行介绍。\n\n**线程池监控**\n\n除了参数动态化之外，为了更好地使用线程池，我们需要对线程池的运行状况有感知，比如当前线程池的负载是怎么样的？分配的资源够不够用？任务的执行情况是怎么样的？是长任务还是短任务？基于对这些问题的思考，动态化线程池提供了多个维度的监控和告警能力，包括：线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等，既能帮助用户从多个维度分析线程池的使用情况，又能在出现问题第一时间通知到用户，从而避免故障或加速故障恢复。\n\n#### 1. 负载监控和告警\n\n线程池负载关注的核心问题是：基于当前线程池参数分配的资源够不够。对于这个问题，我们可以从事前和事中两个角度来看。事前，线程池定义了“活跃度”这个概念，来让用户在发生Reject异常之前能够感知线程池负载问题，线程池活跃度计算公式为：线程池活跃度 = activeCount/maximumPoolSize。这个公式代表当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高。事中，也可以从两方面来看线程池的过载判定条件，一个是发生了Reject异常，一个是队列中有等待任务（支持定制阈值）。以上两种情况发生了都会触发告警，告警信息会通过大象推送给服务所关联的负责人。\n\n![图22 大象告警通知](/images/04e73f7186a91d99181e1b5615ce9e4a318600.png)\n\n图22 大象告警通知\n\n#### 2. 任务级精细化监控\n\n在传统的线程池应用场景中，线程池中的任务执行情况对于用户来说是透明的。比如在一个具体的业务场景中，业务开发申请了一个线程池同时用于执行两种任务，一个是发消息任务、一个是发短信任务，这两类任务实际执行的频率和时长对于用户来说没有一个直观的感受，很可能这两类任务不适合共享一个线程池，但是由于用户无法感知，因此也无从优化。动态化线程池内部实现了任务级别的埋点，且允许为不同的业务任务指定具有业务含义的名称，线程池内部基于这个名称做Transaction打点，基于这个功能，用户可以看到线程池内部任务级别的执行情况，且区分业务，任务监控示意图如下图所示：\n\n![图23 线程池任务执行监控](/images/cd0b9445c3c93a866201b7cfb24d2ce7214776.png)\n\n图23 线程池任务执行监控\n\n#### 3. 运行时状态实时查看\n\n用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数，如下图所示：\n\n![图24 线程池实时运行情况](/images/aba8d9c09e6f054c7061ddd720a04a26147951.png)\n\n图24 线程池实时运行情况\n\n动态化线程池基于这几个接口封装了运行时状态实时查看的功能，用户基于这个功能可以了解线程池的实时状态，比如当前有多少个工作线程，执行了多少个任务，队列中等待的任务数等等。效果如下图所示：\n\n![图25 线程池实时运行情况](/images/38d5fbeaebd4998f3a30d44bd20b996f113233.png)\n\n图25 线程池实时运行情况\n\n### 3.4 实践总结\n\n面对业务中使用线程池遇到的实际问题，我们曾回到支持并发性问题本身来思考有没有取代线程池的方案，也曾尝试着去追求线程池参数设置的合理性，但面对业界方案具体落地的复杂性、可维护性以及真实运行环境的不确定性，我们在前两个方向上可谓“举步维艰”。最终，我们回到线程池参数动态化方向上探索，得出一个且可以解决业务问题的方案，虽然本质上还是没有逃离使用线程池的范畴，但是在成本和收益之间，算是取得了一个很好的平衡。成本在于实现动态化以及监控成本不高，收益在于：在不颠覆原有线程池使用方式的基础之上，从降低线程池参数修改的成本以及多维度监控这两个方面降低了故障发生的概率。希望本文提供的动态化线程池思路能对大家有帮助。\n\n## 四、参考资料\n\n- [1] JDK 1.8源码\n- [2][维基百科-线程池](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0)\n- [3] [更好的使用Java线程池](https://my.oschina.net/andylucc/blog/648127)\n- [4] [维基百科Pooling(Resource Management)](https://en.wikipedia.org/wiki/Pooling_(resource_management))\n- [5] [深入理解Java线程池：ThreadPoolExecutor](http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/)\n- [6]《Java并发编程实践》","slug":"java/Java-thread-pool","published":1,"updated":"2020-05-22T08:59:38.696Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7mg007avgja1636brvz","content":"<h1 id=\"Java线程池实现原理及实践\"><a href=\"#Java线程池实现原理及实践\" class=\"headerlink\" title=\"Java线程池实现原理及实践\"></a>Java线程池实现原理及实践</h1><p>随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。了解并合理使用线程池，是一个开发人员必修的基本功。</p>\n<p>本文开篇简述线程池概念和用途，接着结合线程池的源码，帮助读者领略线程池的设计思路，最后回归实践，通过案例讲述使用线程池遇到的问题，并给出了一种动态化线程池解决方案。</p>\n<h2 id=\"一、写在前面\"><a href=\"#一、写在前面\" class=\"headerlink\" title=\"一、写在前面\"></a>一、写在前面</h2><h3 id=\"1-1-线程池是什么\"><a href=\"#1-1-线程池是什么\" class=\"headerlink\" title=\"1.1 线程池是什么\"></a>1.1 线程池是什么</h3><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。</p>\n<p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>\n<p>而本文描述线程池是JDK中提供的ThreadPoolExecutor类。</p>\n<p>当然，使用线程池可以带来一系列好处：</p>\n<ul>\n<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>\n<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>\n<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>\n<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li>\n</ul>\n<h3 id=\"1-2-线程池解决的问题是什么\"><a href=\"#1-2-线程池解决的问题是什么\" class=\"headerlink\" title=\"1.2 线程池解决的问题是什么\"></a>1.2 线程池解决的问题是什么</h3><p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p>\n<ol>\n<li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li>\n<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li>\n<li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li>\n</ol>\n<p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p>\n<p>Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia</p>\n<p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。</p>\n<p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p>\n<ol>\n<li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li>\n<li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li>\n<li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li>\n</ol>\n<p>在了解完“是什么”和“为什么”之后，下面我们来一起深入一下线程池的内部实现原理。</p>\n<h2 id=\"二、线程池核心设计与实现\"><a href=\"#二、线程池核心设计与实现\" class=\"headerlink\" title=\"二、线程池核心设计与实现\"></a>二、线程池核心设计与实现</h2><p>在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。那么它的的详细设计与实现是什么样的呢？我们会在本章进行详细介绍。</p>\n<h3 id=\"2-1-总体设计\"><a href=\"#2-1-总体设计\" class=\"headerlink\" title=\"2.1 总体设计\"></a>2.1 总体设计</h3><p>Java中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。</p>\n<p><img src=\"/images/912883e51327e0c7a9d753d11896326511272.png\" alt=\"图1 ThreadPoolExecutor UML类图\"></p>\n<p>图1 ThreadPoolExecutor UML类图</p>\n<p>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>\n<p>ThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：</p>\n<p><img src=\"/images/thread-pool.png\" alt=\"图2 ThreadPoolExecutor运行流程\"></p>\n<p>图2 ThreadPoolExecutor运行流程</p>\n<p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>\n<p>接下来，我们会按照以下三个部分去详细讲解线程池运行机制：</p>\n<ol>\n<li>线程池如何维护自身状态。</li>\n<li>线程池如何管理任务。</li>\n<li>线程池如何管理线程。</li>\n</ol>\n<h3 id=\"2-2-生命周期管理\"><a href=\"#2-2-生命周期管理\" class=\"headerlink\" title=\"2.2 生命周期管理\"></a>2.2 生命周期管理</h3><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br></pre></td></tr></table></figure>\n\n<p><code>ctl</code>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p>\n<p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125; &#x2F;&#x2F;计算当前运行状态</span><br><span class=\"line\">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;  &#x2F;&#x2F;计算当前线程数量</span><br><span class=\"line\">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;   &#x2F;&#x2F;通过状态和线程数生成ctl</span><br></pre></td></tr></table></figure>\n\n<p>ThreadPoolExecutor的运行状态有5种，分别为：</p>\n<p><img src=\"https://p0.meituan.net/travelcube/62853fa44bfa47d63143babe3b5a4c6e82532.png\" alt=\"img\"></p>\n<p>其生命周期转换如下入所示：</p>\n<p><img src=\"/images/582d1606d57ff99aa0e5f8fc59c7819329028.png\" alt=\"图3 线程池生命周期\"></p>\n<p>图3 线程池生命周期</p>\n<h3 id=\"2-3-任务执行机制\"><a href=\"#2-3-任务执行机制\" class=\"headerlink\" title=\"2.3 任务执行机制\"></a>2.3 任务执行机制</h3><p><strong>2.3.1 任务调度</strong></p>\n<p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。</p>\n<p>首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>\n<ol>\n<li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>\n<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>\n<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>\n<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>\n<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>\n</ol>\n<p>其执行流程如下图所示：</p>\n<p><img src=\"/images/31bad766983e212431077ca8da92762050214.png\" alt=\"图4 任务调度流程\"></p>\n<p>图4 任务调度流程</p>\n<p><strong>2.3.2 任务缓冲</strong></p>\n<p>任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>\n<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>\n<p>下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：</p>\n<p><img src=\"/images/f4d89c87acf102b45be8ccf3ed83352a9497.png\" alt=\"图5 阻塞队列\"></p>\n<p>图5 阻塞队列</p>\n<p>使用不同的队列可以实现不一样的任务存取策略。在这里，我们可以再介绍下阻塞队列的成员：</p>\n<p><img src=\"/images/725a3db5114d95675f2098c12dc331c3316963.png\" alt=\"img\"></p>\n<p><strong>2.3.3 任务申请</strong></p>\n<p>由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>\n<p>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：</p>\n<p><img src=\"/images/49d8041f8480aba5ef59079fcc7143b996706.png\" alt=\"图6 获取任务流程图\"></p>\n<p>图6 获取任务流程图</p>\n<p>getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p>\n<p><strong>2.3.4 任务拒绝</strong></p>\n<p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p>\n<p>拒绝策略是一个接口，其设计如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface RejectedExecutionHandler &#123;</span><br><span class=\"line\">    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：</p>\n<p><img src=\"/images/9ffb64cc4c64c0cb8d38dac01c89c905178456.png\" alt=\"img\"></p>\n<p>2.4 Worker线程管理</p>\n<p>2.4.1 Worker线程</p>\n<p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123;</span><br><span class=\"line\">    final Thread thread;&#x2F;&#x2F;Worker持有的线程</span><br><span class=\"line\">    Runnable firstTask;&#x2F;&#x2F;初始化的任务，可以为null</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。</p>\n<p>Worker执行任务的模型如下图所示：</p>\n<p><img src=\"/images/03268b9dc49bd30bb63064421bb036bf90315.png\" alt=\"图7 Worker执行任务\"></p>\n<p>图7 Worker执行任务</p>\n<p>线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。</p>\n<p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p>\n<p>1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</p>\n<p>在线程回收过程中就使用到了这种特性，回收过程如下图所示：</p>\n<p><img src=\"/images/9d8dc9cebe59122127460f81a98894bb34085.png\" alt=\"图8 线程池回收过程\"></p>\n<p>图8 线程池回收过程</p>\n<p><strong>2.4.2 Worker线程增加</strong></p>\n<p>增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，其执行流程如下图所示：</p>\n<p><img src=\"/images/49527b1bb385f0f43529e57b614f59ae145454.png\" alt=\"图9 申请线程执行流程图\"></p>\n<p>图9 申请线程执行流程图</p>\n<p><strong>2.4.3 Worker线程回收</strong></p>\n<p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;执行任务</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">  processWorkerExit(w, completedAbruptly);&#x2F;&#x2F;获取不到任务时，主动回收自己</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>线程回收的工作是在processWorkerExit方法完成的。</p>\n<p><img src=\"/images/90ea093549782945f2c968403fdc39d415386.png\" alt=\"图10 线程销毁流程\"></p>\n<p>图10 线程销毁流程</p>\n<p>事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p>\n<p><strong>2.4.4 Worker线程执行任务</strong></p>\n<p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：</p>\n<p>1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</p>\n<p>执行流程如下图所示：</p>\n<p><img src=\"/images/879edb4f06043d76cea27a3ff358cb1d45243.png\" alt=\"图11 执行任务流程\"></p>\n<p>图11 执行任务流程</p>\n<h2 id=\"三、线程池在业务中的实践\"><a href=\"#三、线程池在业务中的实践\" class=\"headerlink\" title=\"三、线程池在业务中的实践\"></a>三、线程池在业务中的实践</h2><h3 id=\"3-1-业务背景\"><a href=\"#3-1-业务背景\" class=\"headerlink\" title=\"3.1 业务背景\"></a>3.1 业务背景</h3><p>在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。</p>\n<p><strong>场景1：快速响应用户请求</strong></p>\n<p><strong>描述</strong>：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。</p>\n<p><strong>分析</strong>：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。</p>\n<p><img src=\"/images/e9a363c8577f211577e4962e9110cb0226733.png\" alt=\"图12 并行执行任务提升任务响应速度\"></p>\n<p>图12 并行执行任务提升任务响应速度</p>\n<p><strong>场景2：快速处理批量任务</strong></p>\n<p><strong>描述</strong>：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p>\n<p><strong>分析</strong>：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</p>\n<p><img src=\"/images/1a1746f33bfdcb03da074d8539ebb2f367563.png\" alt=\"图13 并行执行任务提升批量任务执行速度\"></p>\n<p>图13 并行执行任务提升批量任务执行速度</p>\n<h3 id=\"3-2-实际问题及方案思考\"><a href=\"#3-2-实际问题及方案思考\" class=\"headerlink\" title=\"3.2 实际问题及方案思考\"></a>3.2 实际问题及方案思考</h3><p>线程池使用面临的核心的问题在于：<strong>线程池的参数并不好配置</strong>。一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大，IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。</p>\n<p>关于线程池配置不合理引发的故障，公司内部有较多记录，下面举一些例子：</p>\n<p><strong>Case1</strong>：2018年XX页面展示接口大量调用降级：</p>\n<p><strong>事故描述</strong>：XX页面展示接口产生大量调用降级，数量级在几十到上百。</p>\n<p><strong>事故原因</strong>：该服务展示接口内部逻辑使用线程池做并行计算，由于没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件，示意图如下：</p>\n<p><img src=\"/images/1df932840b31f41931bb69e16be2932844240.png\" alt=\"图14 线程数核心设置过小引发RejectExecutionException\"></p>\n<p>图14 线程数核心设置过小引发RejectExecutionException</p>\n<p><strong>Case2</strong>：2018年XX业务服务不可用S2级故障</p>\n<p><strong>事故描述</strong>：XX业务提供的服务执行时间过长，作为上游服务整体超时，大量下游服务调用失败。</p>\n<p><strong>事故原因</strong>：该服务处理请求内部逻辑使用线程池做资源隔离，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。示意图如下：</p>\n<p><img src=\"/images/668e3c90f4b918bfcead2f4280091e9757284.png\" alt=\"图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低\"></p>\n<p>图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低</p>\n<p>业务中要使用线程池，而使用不当又会导致故障，那么我们怎样才能更好地使用线程池呢？针对这个问题，我们下面延展几个方向：</p>\n<p><strong>1. 能否不用线程池?</strong></p>\n<p>回到最初的问题，业务使用线程池是为了获取并发性，对于获取并发性，是否可以有什么其他的方案呢替代？我们尝试进行了一些其他方案的调研：</p>\n<p><img src=\"/images/56ab763273b2c03b2f1c37db7b150338414771.png\" alt=\"img\"></p>\n<p>综合考虑，这些新的方案都能在某种情况下提升并行任务的性能，然而本次重点解决的问题是如何更简易、更安全地获得的并发性。另外，Actor模型的应用实际上甚少，只在Scala中使用广泛，协程框架在Java中维护的也不成熟。这三者现阶段都不是足够的易用，也并不能解决业务上现阶段的问题。</p>\n<p><strong>2. 追求参数设置合理性？</strong></p>\n<p>有没有一种计算公式，能够让开发同学很简易地计算出某种场景中的线程池应该是什么参数呢？</p>\n<p>带着这样的疑问，我们调研了业界的一些线程池参数配置方案：</p>\n<p><img src=\"/images/23a44974ff68a08261fb675242b83648181953.png\" alt=\"img\"></p>\n<p>调研了以上业界方案后，我们并没有得出通用的线程池计算方式。并发任务的执行情况和任务类型相关，IO密集型和CPU密集型的任务运行起来的情况差异非常大，但这种占比是较难合理预估的，这导致很难有一个简单有效的通用公式帮我们直接计算出结果。</p>\n<p><strong>3. 线程池参数动态化？</strong></p>\n<p>尽管经过谨慎的评估，仍然不能够保证一次计算出来合适的参数，那么我们是否可以将修改线程池参数的成本降下来，这样至少可以发生故障的时候可以快速调整从而缩短故障恢复的时间呢？基于这个思考，我们是否可以将线程池的参数从代码中迁移到分布式配置中心上，实现线程池参数可动态配置和即时生效，线程池参数动态化前后的参数修改流程对比如下：</p>\n<p><img src=\"/images/c6caa5be64f39758ada0593b995d65fd25982.png\" alt=\"图16 动态修改线程池参数新旧流程对比\"></p>\n<p>图16 动态修改线程池参数新旧流程对比</p>\n<p>基于以上三个方向对比，我们可以看出参数动态化方向简单有效。</p>\n<h3 id=\"3-3-动态化线程池\"><a href=\"#3-3-动态化线程池\" class=\"headerlink\" title=\"3.3 动态化线程池\"></a>3.3 动态化线程池</h3><p><strong>3.3.1 整体设计</strong></p>\n<p>动态化线程池的核心设计包括以下三个方面：</p>\n<ol>\n<li>简化线程池配置：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。</li>\n<li>参数可动态修改：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。</li>\n<li>增加线程池监控：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。</li>\n</ol>\n<p><img src=\"/images/4d5c410ad23782350cc9f980787151fd54144.png\" alt=\"图17 动态化线程池整体设计\"></p>\n<p>图17 动态化线程池整体设计</p>\n<p><strong>3.3.2 功能架构</strong></p>\n<p>动态化线程池提供如下功能：</p>\n<p><strong>动态调参</strong>：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。 <strong>任务监控</strong>：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95/99线等。 <strong>负载告警</strong>：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。 <strong>操作监控</strong>：创建/修改和删除线程池都会通知到应用的开发负责人。 <strong>操作日志</strong>：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。 <strong>权限校验</strong>：只有应用开发负责人才能够修改应用的线程池参数。</p>\n<p><img src=\"/images/6c0091e92e90f50f89fd83f3b9eb5472135718.png\" alt=\"图18 动态化线程池功能架构\"></p>\n<p>图18 动态化线程池功能架构</p>\n<p><strong>参数动态化</strong></p>\n<p>JDK原生线程池ThreadPoolExecutor提供了如下几个public的setter方法，如下图所示：</p>\n<p><img src=\"/images/efd32f1211e9cf0a3ca9d35b0dc5de8588353.png\" alt=\"图19 JDK 线程池参数设置接口\"></p>\n<p>图19 JDK 线程池参数设置接口</p>\n<p>JDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务，setCorePoolSize具体流程如下：</p>\n<p><img src=\"/images/9379fe1666818237f842138812bf63bd85645.png\" alt=\"图20 setCorePoolSize方法执行流程\"></p>\n<p>图20 setCorePoolSize方法执行流程</p>\n<p>线程池内部会处理好当前状态做到平滑修改，其他几个方法限于篇幅，这里不一一介绍。重点是基于这几个public方法，我们只需要维护ThreadPoolExecutor的实例，并且在需要修改的时候拿到实例修改其参数即可。基于以上的思路，我们实现了线程池参数的动态化、线程池参数在管理平台可配置可修改，其效果图如下图所示：</p>\n<p><img src=\"/images/414ba7f3abd11e5f805c58635ae10988166121.png\" alt=\"图21 可动态修改线程池参数\"></p>\n<p>图21 可动态修改线程池参数</p>\n<p>用户可以在管理平台上通过线程池的名字找到指定的线程池，然后对其参数进行修改，保存后会实时生效。目前支持的动态参数包括核心数、最大值、队列长度等。除此之外，在界面中，我们还能看到用户可以配置是否开启告警、队列等待任务告警阈值、活跃度告警等等。关于监控和告警，我们下面一节会对齐进行介绍。</p>\n<p><strong>线程池监控</strong></p>\n<p>除了参数动态化之外，为了更好地使用线程池，我们需要对线程池的运行状况有感知，比如当前线程池的负载是怎么样的？分配的资源够不够用？任务的执行情况是怎么样的？是长任务还是短任务？基于对这些问题的思考，动态化线程池提供了多个维度的监控和告警能力，包括：线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等，既能帮助用户从多个维度分析线程池的使用情况，又能在出现问题第一时间通知到用户，从而避免故障或加速故障恢复。</p>\n<h4 id=\"1-负载监控和告警\"><a href=\"#1-负载监控和告警\" class=\"headerlink\" title=\"1. 负载监控和告警\"></a>1. 负载监控和告警</h4><p>线程池负载关注的核心问题是：基于当前线程池参数分配的资源够不够。对于这个问题，我们可以从事前和事中两个角度来看。事前，线程池定义了“活跃度”这个概念，来让用户在发生Reject异常之前能够感知线程池负载问题，线程池活跃度计算公式为：线程池活跃度 = activeCount/maximumPoolSize。这个公式代表当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高。事中，也可以从两方面来看线程池的过载判定条件，一个是发生了Reject异常，一个是队列中有等待任务（支持定制阈值）。以上两种情况发生了都会触发告警，告警信息会通过大象推送给服务所关联的负责人。</p>\n<p><img src=\"/images/04e73f7186a91d99181e1b5615ce9e4a318600.png\" alt=\"图22 大象告警通知\"></p>\n<p>图22 大象告警通知</p>\n<h4 id=\"2-任务级精细化监控\"><a href=\"#2-任务级精细化监控\" class=\"headerlink\" title=\"2. 任务级精细化监控\"></a>2. 任务级精细化监控</h4><p>在传统的线程池应用场景中，线程池中的任务执行情况对于用户来说是透明的。比如在一个具体的业务场景中，业务开发申请了一个线程池同时用于执行两种任务，一个是发消息任务、一个是发短信任务，这两类任务实际执行的频率和时长对于用户来说没有一个直观的感受，很可能这两类任务不适合共享一个线程池，但是由于用户无法感知，因此也无从优化。动态化线程池内部实现了任务级别的埋点，且允许为不同的业务任务指定具有业务含义的名称，线程池内部基于这个名称做Transaction打点，基于这个功能，用户可以看到线程池内部任务级别的执行情况，且区分业务，任务监控示意图如下图所示：</p>\n<p><img src=\"/images/cd0b9445c3c93a866201b7cfb24d2ce7214776.png\" alt=\"图23 线程池任务执行监控\"></p>\n<p>图23 线程池任务执行监控</p>\n<h4 id=\"3-运行时状态实时查看\"><a href=\"#3-运行时状态实时查看\" class=\"headerlink\" title=\"3. 运行时状态实时查看\"></a>3. 运行时状态实时查看</h4><p>用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数，如下图所示：</p>\n<p><img src=\"/images/aba8d9c09e6f054c7061ddd720a04a26147951.png\" alt=\"图24 线程池实时运行情况\"></p>\n<p>图24 线程池实时运行情况</p>\n<p>动态化线程池基于这几个接口封装了运行时状态实时查看的功能，用户基于这个功能可以了解线程池的实时状态，比如当前有多少个工作线程，执行了多少个任务，队列中等待的任务数等等。效果如下图所示：</p>\n<p><img src=\"/images/38d5fbeaebd4998f3a30d44bd20b996f113233.png\" alt=\"图25 线程池实时运行情况\"></p>\n<p>图25 线程池实时运行情况</p>\n<h3 id=\"3-4-实践总结\"><a href=\"#3-4-实践总结\" class=\"headerlink\" title=\"3.4 实践总结\"></a>3.4 实践总结</h3><p>面对业务中使用线程池遇到的实际问题，我们曾回到支持并发性问题本身来思考有没有取代线程池的方案，也曾尝试着去追求线程池参数设置的合理性，但面对业界方案具体落地的复杂性、可维护性以及真实运行环境的不确定性，我们在前两个方向上可谓“举步维艰”。最终，我们回到线程池参数动态化方向上探索，得出一个且可以解决业务问题的方案，虽然本质上还是没有逃离使用线程池的范畴，但是在成本和收益之间，算是取得了一个很好的平衡。成本在于实现动态化以及监控成本不高，收益在于：在不颠覆原有线程池使用方式的基础之上，从降低线程池参数修改的成本以及多维度监控这两个方面降低了故障发生的概率。希望本文提供的动态化线程池思路能对大家有帮助。</p>\n<h2 id=\"四、参考资料\"><a href=\"#四、参考资料\" class=\"headerlink\" title=\"四、参考资料\"></a>四、参考资料</h2><ul>\n<li>[1] JDK 1.8源码</li>\n<li>[2]<a href=\"https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0\" target=\"_blank\" rel=\"noopener\">维基百科-线程池</a></li>\n<li>[3] <a href=\"https://my.oschina.net/andylucc/blog/648127\" target=\"_blank\" rel=\"noopener\">更好的使用Java线程池</a></li>\n<li>[4] <a href=\"https://en.wikipedia.org/wiki/Pooling_(resource_management)\" target=\"_blank\" rel=\"noopener\">维基百科Pooling(Resource Management)</a></li>\n<li>[5] <a href=\"http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/\" target=\"_blank\" rel=\"noopener\">深入理解Java线程池：ThreadPoolExecutor</a></li>\n<li>[6]《Java并发编程实践》</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java线程池实现原理及实践\"><a href=\"#Java线程池实现原理及实践\" class=\"headerlink\" title=\"Java线程池实现原理及实践\"></a>Java线程池实现原理及实践</h1><p>随着计算机行业的飞速发展，摩尔定律逐渐失效，多核CPU成为主流。使用多线程并行计算逐渐成为开发人员提升服务器性能的基本武器。J.U.C提供的线程池：ThreadPoolExecutor类，帮助开发人员管理线程并方便地执行并行任务。了解并合理使用线程池，是一个开发人员必修的基本功。</p>\n<p>本文开篇简述线程池概念和用途，接着结合线程池的源码，帮助读者领略线程池的设计思路，最后回归实践，通过案例讲述使用线程池遇到的问题，并给出了一种动态化线程池解决方案。</p>\n<h2 id=\"一、写在前面\"><a href=\"#一、写在前面\" class=\"headerlink\" title=\"一、写在前面\"></a>一、写在前面</h2><h3 id=\"1-1-线程池是什么\"><a href=\"#1-1-线程池是什么\" class=\"headerlink\" title=\"1.1 线程池是什么\"></a>1.1 线程池是什么</h3><p>线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。</p>\n<p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p>\n<p>而本文描述线程池是JDK中提供的ThreadPoolExecutor类。</p>\n<p>当然，使用线程池可以带来一系列好处：</p>\n<ul>\n<li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。</li>\n<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。</li>\n<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</li>\n<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</li>\n</ul>\n<h3 id=\"1-2-线程池解决的问题是什么\"><a href=\"#1-2-线程池解决的问题是什么\" class=\"headerlink\" title=\"1.2 线程池解决的问题是什么\"></a>1.2 线程池解决的问题是什么</h3><p>线程池解决的核心问题就是资源管理问题。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来以下若干问题：</p>\n<ol>\n<li>频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。</li>\n<li>对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。</li>\n<li>系统无法合理管理内部的资源分布，会降低系统的稳定性。</li>\n</ol>\n<p>为解决资源分配这个问题，线程池采用了“池化”（Pooling）思想。池化，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。</p>\n<p>Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia</p>\n<p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。</p>\n<p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p>\n<ol>\n<li>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。</li>\n<li>连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。</li>\n<li>实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li>\n</ol>\n<p>在了解完“是什么”和“为什么”之后，下面我们来一起深入一下线程池的内部实现原理。</p>\n<h2 id=\"二、线程池核心设计与实现\"><a href=\"#二、线程池核心设计与实现\" class=\"headerlink\" title=\"二、线程池核心设计与实现\"></a>二、线程池核心设计与实现</h2><p>在前文中，我们了解到：线程池是一种通过“池化”思想，帮助我们管理线程而获取并发性的工具，在Java中的体现是ThreadPoolExecutor类。那么它的的详细设计与实现是什么样的呢？我们会在本章进行详细介绍。</p>\n<h3 id=\"2-1-总体设计\"><a href=\"#2-1-总体设计\" class=\"headerlink\" title=\"2.1 总体设计\"></a>2.1 总体设计</h3><p>Java中的线程池核心实现类是ThreadPoolExecutor，本章基于JDK 1.8的源码来分析Java线程池的核心设计与实现。我们首先来看一下ThreadPoolExecutor的UML类图，了解下ThreadPoolExecutor的继承关系。</p>\n<p><img src=\"/images/912883e51327e0c7a9d753d11896326511272.png\" alt=\"图1 ThreadPoolExecutor UML类图\"></p>\n<p>图1 ThreadPoolExecutor UML类图</p>\n<p>ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>\n<p>ThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：</p>\n<p><img src=\"/images/thread-pool.png\" alt=\"图2 ThreadPoolExecutor运行流程\"></p>\n<p>图2 ThreadPoolExecutor运行流程</p>\n<p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</p>\n<p>接下来，我们会按照以下三个部分去详细讲解线程池运行机制：</p>\n<ol>\n<li>线程池如何维护自身状态。</li>\n<li>线程池如何管理任务。</li>\n<li>线程池如何管理线程。</li>\n</ol>\n<h3 id=\"2-2-生命周期管理\"><a href=\"#2-2-生命周期管理\" class=\"headerlink\" title=\"2.2 生命周期管理\"></a>2.2 生命周期管理</h3><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br></pre></td></tr></table></figure>\n\n<p><code>ctl</code>这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。</p>\n<p>关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125; &#x2F;&#x2F;计算当前运行状态</span><br><span class=\"line\">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;  &#x2F;&#x2F;计算当前线程数量</span><br><span class=\"line\">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;   &#x2F;&#x2F;通过状态和线程数生成ctl</span><br></pre></td></tr></table></figure>\n\n<p>ThreadPoolExecutor的运行状态有5种，分别为：</p>\n<p><img src=\"https://p0.meituan.net/travelcube/62853fa44bfa47d63143babe3b5a4c6e82532.png\" alt=\"img\"></p>\n<p>其生命周期转换如下入所示：</p>\n<p><img src=\"/images/582d1606d57ff99aa0e5f8fc59c7819329028.png\" alt=\"图3 线程池生命周期\"></p>\n<p>图3 线程池生命周期</p>\n<h3 id=\"2-3-任务执行机制\"><a href=\"#2-3-任务执行机制\" class=\"headerlink\" title=\"2.3 任务执行机制\"></a>2.3 任务执行机制</h3><p><strong>2.3.1 任务调度</strong></p>\n<p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。</p>\n<p>首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：</p>\n<ol>\n<li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>\n<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>\n<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>\n<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>\n<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>\n</ol>\n<p>其执行流程如下图所示：</p>\n<p><img src=\"/images/31bad766983e212431077ca8da92762050214.png\" alt=\"图4 任务调度流程\"></p>\n<p>图4 任务调度流程</p>\n<p><strong>2.3.2 任务缓冲</strong></p>\n<p>任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>\n<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>\n<p>下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：</p>\n<p><img src=\"/images/f4d89c87acf102b45be8ccf3ed83352a9497.png\" alt=\"图5 阻塞队列\"></p>\n<p>图5 阻塞队列</p>\n<p>使用不同的队列可以实现不一样的任务存取策略。在这里，我们可以再介绍下阻塞队列的成员：</p>\n<p><img src=\"/images/725a3db5114d95675f2098c12dc331c3316963.png\" alt=\"img\"></p>\n<p><strong>2.3.3 任务申请</strong></p>\n<p>由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>\n<p>线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：</p>\n<p><img src=\"/images/49d8041f8480aba5ef59079fcc7143b996706.png\" alt=\"图6 获取任务流程图\"></p>\n<p>图6 获取任务流程图</p>\n<p>getTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。</p>\n<p><strong>2.3.4 任务拒绝</strong></p>\n<p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p>\n<p>拒绝策略是一个接口，其设计如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface RejectedExecutionHandler &#123;</span><br><span class=\"line\">    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：</p>\n<p><img src=\"/images/9ffb64cc4c64c0cb8d38dac01c89c905178456.png\" alt=\"img\"></p>\n<p>2.4 Worker线程管理</p>\n<p>2.4.1 Worker线程</p>\n<p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123;</span><br><span class=\"line\">    final Thread thread;&#x2F;&#x2F;Worker持有的线程</span><br><span class=\"line\">    Runnable firstTask;&#x2F;&#x2F;初始化的任务，可以为null</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。</p>\n<p>Worker执行任务的模型如下图所示：</p>\n<p><img src=\"/images/03268b9dc49bd30bb63064421bb036bf90315.png\" alt=\"图7 Worker执行任务\"></p>\n<p>图7 Worker执行任务</p>\n<p>线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。</p>\n<p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p>\n<p>1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</p>\n<p>在线程回收过程中就使用到了这种特性，回收过程如下图所示：</p>\n<p><img src=\"/images/9d8dc9cebe59122127460f81a98894bb34085.png\" alt=\"图8 线程池回收过程\"></p>\n<p>图8 线程池回收过程</p>\n<p><strong>2.4.2 Worker线程增加</strong></p>\n<p>增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，其执行流程如下图所示：</p>\n<p><img src=\"/images/49527b1bb385f0f43529e57b614f59ae145454.png\" alt=\"图9 申请线程执行流程图\"></p>\n<p>图9 申请线程执行流程图</p>\n<p><strong>2.4.3 Worker线程回收</strong></p>\n<p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">  while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;执行任务</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">  processWorkerExit(w, completedAbruptly);&#x2F;&#x2F;获取不到任务时，主动回收自己</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>线程回收的工作是在processWorkerExit方法完成的。</p>\n<p><img src=\"/images/90ea093549782945f2c968403fdc39d415386.png\" alt=\"图10 线程销毁流程\"></p>\n<p>图10 线程销毁流程</p>\n<p>事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。</p>\n<p><strong>2.4.4 Worker线程执行任务</strong></p>\n<p>在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：</p>\n<p>1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。</p>\n<p>执行流程如下图所示：</p>\n<p><img src=\"/images/879edb4f06043d76cea27a3ff358cb1d45243.png\" alt=\"图11 执行任务流程\"></p>\n<p>图11 执行任务流程</p>\n<h2 id=\"三、线程池在业务中的实践\"><a href=\"#三、线程池在业务中的实践\" class=\"headerlink\" title=\"三、线程池在业务中的实践\"></a>三、线程池在业务中的实践</h2><h3 id=\"3-1-业务背景\"><a href=\"#3-1-业务背景\" class=\"headerlink\" title=\"3.1 业务背景\"></a>3.1 业务背景</h3><p>在当今的互联网业界，为了最大程度利用CPU的多核性能，并行运算的能力是不可或缺的。通过线程池管理线程获取并发性是一个非常基础的操作，让我们来看两个典型的使用线程池获取并发性的场景。</p>\n<p><strong>场景1：快速响应用户请求</strong></p>\n<p><strong>描述</strong>：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。</p>\n<p><strong>分析</strong>：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。</p>\n<p><img src=\"/images/e9a363c8577f211577e4962e9110cb0226733.png\" alt=\"图12 并行执行任务提升任务响应速度\"></p>\n<p>图12 并行执行任务提升任务响应速度</p>\n<p><strong>场景2：快速处理批量任务</strong></p>\n<p><strong>描述</strong>：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p>\n<p><strong>分析</strong>：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</p>\n<p><img src=\"/images/1a1746f33bfdcb03da074d8539ebb2f367563.png\" alt=\"图13 并行执行任务提升批量任务执行速度\"></p>\n<p>图13 并行执行任务提升批量任务执行速度</p>\n<h3 id=\"3-2-实际问题及方案思考\"><a href=\"#3-2-实际问题及方案思考\" class=\"headerlink\" title=\"3.2 实际问题及方案思考\"></a>3.2 实际问题及方案思考</h3><p>线程池使用面临的核心的问题在于：<strong>线程池的参数并不好配置</strong>。一方面线程池的运行机制不是很好理解，配置合理需要强依赖开发人员的个人经验和知识；另一方面，线程池执行的情况和任务类型相关性较大，IO密集型和CPU密集型的任务运行起来的情况差异非常大，这导致业界并没有一些成熟的经验策略帮助开发人员参考。</p>\n<p>关于线程池配置不合理引发的故障，公司内部有较多记录，下面举一些例子：</p>\n<p><strong>Case1</strong>：2018年XX页面展示接口大量调用降级：</p>\n<p><strong>事故描述</strong>：XX页面展示接口产生大量调用降级，数量级在几十到上百。</p>\n<p><strong>事故原因</strong>：该服务展示接口内部逻辑使用线程池做并行计算，由于没有预估好调用的流量，导致最大核心数设置偏小，大量抛出RejectedExecutionException，触发接口降级条件，示意图如下：</p>\n<p><img src=\"/images/1df932840b31f41931bb69e16be2932844240.png\" alt=\"图14 线程数核心设置过小引发RejectExecutionException\"></p>\n<p>图14 线程数核心设置过小引发RejectExecutionException</p>\n<p><strong>Case2</strong>：2018年XX业务服务不可用S2级故障</p>\n<p><strong>事故描述</strong>：XX业务提供的服务执行时间过长，作为上游服务整体超时，大量下游服务调用失败。</p>\n<p><strong>事故原因</strong>：该服务处理请求内部逻辑使用线程池做资源隔离，由于队列设置过长，最大线程数设置失效，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。示意图如下：</p>\n<p><img src=\"/images/668e3c90f4b918bfcead2f4280091e9757284.png\" alt=\"图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低\"></p>\n<p>图15 线程池队列长度设置过长、corePoolSize设置过小导致任务执行速度低</p>\n<p>业务中要使用线程池，而使用不当又会导致故障，那么我们怎样才能更好地使用线程池呢？针对这个问题，我们下面延展几个方向：</p>\n<p><strong>1. 能否不用线程池?</strong></p>\n<p>回到最初的问题，业务使用线程池是为了获取并发性，对于获取并发性，是否可以有什么其他的方案呢替代？我们尝试进行了一些其他方案的调研：</p>\n<p><img src=\"/images/56ab763273b2c03b2f1c37db7b150338414771.png\" alt=\"img\"></p>\n<p>综合考虑，这些新的方案都能在某种情况下提升并行任务的性能，然而本次重点解决的问题是如何更简易、更安全地获得的并发性。另外，Actor模型的应用实际上甚少，只在Scala中使用广泛，协程框架在Java中维护的也不成熟。这三者现阶段都不是足够的易用，也并不能解决业务上现阶段的问题。</p>\n<p><strong>2. 追求参数设置合理性？</strong></p>\n<p>有没有一种计算公式，能够让开发同学很简易地计算出某种场景中的线程池应该是什么参数呢？</p>\n<p>带着这样的疑问，我们调研了业界的一些线程池参数配置方案：</p>\n<p><img src=\"/images/23a44974ff68a08261fb675242b83648181953.png\" alt=\"img\"></p>\n<p>调研了以上业界方案后，我们并没有得出通用的线程池计算方式。并发任务的执行情况和任务类型相关，IO密集型和CPU密集型的任务运行起来的情况差异非常大，但这种占比是较难合理预估的，这导致很难有一个简单有效的通用公式帮我们直接计算出结果。</p>\n<p><strong>3. 线程池参数动态化？</strong></p>\n<p>尽管经过谨慎的评估，仍然不能够保证一次计算出来合适的参数，那么我们是否可以将修改线程池参数的成本降下来，这样至少可以发生故障的时候可以快速调整从而缩短故障恢复的时间呢？基于这个思考，我们是否可以将线程池的参数从代码中迁移到分布式配置中心上，实现线程池参数可动态配置和即时生效，线程池参数动态化前后的参数修改流程对比如下：</p>\n<p><img src=\"/images/c6caa5be64f39758ada0593b995d65fd25982.png\" alt=\"图16 动态修改线程池参数新旧流程对比\"></p>\n<p>图16 动态修改线程池参数新旧流程对比</p>\n<p>基于以上三个方向对比，我们可以看出参数动态化方向简单有效。</p>\n<h3 id=\"3-3-动态化线程池\"><a href=\"#3-3-动态化线程池\" class=\"headerlink\" title=\"3.3 动态化线程池\"></a>3.3 动态化线程池</h3><p><strong>3.3.1 整体设计</strong></p>\n<p>动态化线程池的核心设计包括以下三个方面：</p>\n<ol>\n<li>简化线程池配置：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。</li>\n<li>参数可动态修改：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。</li>\n<li>增加线程池监控：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。</li>\n</ol>\n<p><img src=\"/images/4d5c410ad23782350cc9f980787151fd54144.png\" alt=\"图17 动态化线程池整体设计\"></p>\n<p>图17 动态化线程池整体设计</p>\n<p><strong>3.3.2 功能架构</strong></p>\n<p>动态化线程池提供如下功能：</p>\n<p><strong>动态调参</strong>：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。 <strong>任务监控</strong>：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95/99线等。 <strong>负载告警</strong>：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。 <strong>操作监控</strong>：创建/修改和删除线程池都会通知到应用的开发负责人。 <strong>操作日志</strong>：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。 <strong>权限校验</strong>：只有应用开发负责人才能够修改应用的线程池参数。</p>\n<p><img src=\"/images/6c0091e92e90f50f89fd83f3b9eb5472135718.png\" alt=\"图18 动态化线程池功能架构\"></p>\n<p>图18 动态化线程池功能架构</p>\n<p><strong>参数动态化</strong></p>\n<p>JDK原生线程池ThreadPoolExecutor提供了如下几个public的setter方法，如下图所示：</p>\n<p><img src=\"/images/efd32f1211e9cf0a3ca9d35b0dc5de8588353.png\" alt=\"图19 JDK 线程池参数设置接口\"></p>\n<p>图19 JDK 线程池参数设置接口</p>\n<p>JDK允许线程池使用方通过ThreadPoolExecutor的实例来动态设置线程池的核心策略，以setCorePoolSize为方法例，在运行期线程池使用方调用此方法设置corePoolSize之后，线程池会直接覆盖原来的corePoolSize值，并且基于当前值和原始值的比较结果采取不同的处理策略。对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务，setCorePoolSize具体流程如下：</p>\n<p><img src=\"/images/9379fe1666818237f842138812bf63bd85645.png\" alt=\"图20 setCorePoolSize方法执行流程\"></p>\n<p>图20 setCorePoolSize方法执行流程</p>\n<p>线程池内部会处理好当前状态做到平滑修改，其他几个方法限于篇幅，这里不一一介绍。重点是基于这几个public方法，我们只需要维护ThreadPoolExecutor的实例，并且在需要修改的时候拿到实例修改其参数即可。基于以上的思路，我们实现了线程池参数的动态化、线程池参数在管理平台可配置可修改，其效果图如下图所示：</p>\n<p><img src=\"/images/414ba7f3abd11e5f805c58635ae10988166121.png\" alt=\"图21 可动态修改线程池参数\"></p>\n<p>图21 可动态修改线程池参数</p>\n<p>用户可以在管理平台上通过线程池的名字找到指定的线程池，然后对其参数进行修改，保存后会实时生效。目前支持的动态参数包括核心数、最大值、队列长度等。除此之外，在界面中，我们还能看到用户可以配置是否开启告警、队列等待任务告警阈值、活跃度告警等等。关于监控和告警，我们下面一节会对齐进行介绍。</p>\n<p><strong>线程池监控</strong></p>\n<p>除了参数动态化之外，为了更好地使用线程池，我们需要对线程池的运行状况有感知，比如当前线程池的负载是怎么样的？分配的资源够不够用？任务的执行情况是怎么样的？是长任务还是短任务？基于对这些问题的思考，动态化线程池提供了多个维度的监控和告警能力，包括：线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等，既能帮助用户从多个维度分析线程池的使用情况，又能在出现问题第一时间通知到用户，从而避免故障或加速故障恢复。</p>\n<h4 id=\"1-负载监控和告警\"><a href=\"#1-负载监控和告警\" class=\"headerlink\" title=\"1. 负载监控和告警\"></a>1. 负载监控和告警</h4><p>线程池负载关注的核心问题是：基于当前线程池参数分配的资源够不够。对于这个问题，我们可以从事前和事中两个角度来看。事前，线程池定义了“活跃度”这个概念，来让用户在发生Reject异常之前能够感知线程池负载问题，线程池活跃度计算公式为：线程池活跃度 = activeCount/maximumPoolSize。这个公式代表当活跃线程数趋向于maximumPoolSize的时候，代表线程负载趋高。事中，也可以从两方面来看线程池的过载判定条件，一个是发生了Reject异常，一个是队列中有等待任务（支持定制阈值）。以上两种情况发生了都会触发告警，告警信息会通过大象推送给服务所关联的负责人。</p>\n<p><img src=\"/images/04e73f7186a91d99181e1b5615ce9e4a318600.png\" alt=\"图22 大象告警通知\"></p>\n<p>图22 大象告警通知</p>\n<h4 id=\"2-任务级精细化监控\"><a href=\"#2-任务级精细化监控\" class=\"headerlink\" title=\"2. 任务级精细化监控\"></a>2. 任务级精细化监控</h4><p>在传统的线程池应用场景中，线程池中的任务执行情况对于用户来说是透明的。比如在一个具体的业务场景中，业务开发申请了一个线程池同时用于执行两种任务，一个是发消息任务、一个是发短信任务，这两类任务实际执行的频率和时长对于用户来说没有一个直观的感受，很可能这两类任务不适合共享一个线程池，但是由于用户无法感知，因此也无从优化。动态化线程池内部实现了任务级别的埋点，且允许为不同的业务任务指定具有业务含义的名称，线程池内部基于这个名称做Transaction打点，基于这个功能，用户可以看到线程池内部任务级别的执行情况，且区分业务，任务监控示意图如下图所示：</p>\n<p><img src=\"/images/cd0b9445c3c93a866201b7cfb24d2ce7214776.png\" alt=\"图23 线程池任务执行监控\"></p>\n<p>图23 线程池任务执行监控</p>\n<h4 id=\"3-运行时状态实时查看\"><a href=\"#3-运行时状态实时查看\" class=\"headerlink\" title=\"3. 运行时状态实时查看\"></a>3. 运行时状态实时查看</h4><p>用户基于JDK原生线程池ThreadPoolExecutor提供的几个public的getter方法，可以读取到当前线程池的运行状态以及参数，如下图所示：</p>\n<p><img src=\"/images/aba8d9c09e6f054c7061ddd720a04a26147951.png\" alt=\"图24 线程池实时运行情况\"></p>\n<p>图24 线程池实时运行情况</p>\n<p>动态化线程池基于这几个接口封装了运行时状态实时查看的功能，用户基于这个功能可以了解线程池的实时状态，比如当前有多少个工作线程，执行了多少个任务，队列中等待的任务数等等。效果如下图所示：</p>\n<p><img src=\"/images/38d5fbeaebd4998f3a30d44bd20b996f113233.png\" alt=\"图25 线程池实时运行情况\"></p>\n<p>图25 线程池实时运行情况</p>\n<h3 id=\"3-4-实践总结\"><a href=\"#3-4-实践总结\" class=\"headerlink\" title=\"3.4 实践总结\"></a>3.4 实践总结</h3><p>面对业务中使用线程池遇到的实际问题，我们曾回到支持并发性问题本身来思考有没有取代线程池的方案，也曾尝试着去追求线程池参数设置的合理性，但面对业界方案具体落地的复杂性、可维护性以及真实运行环境的不确定性，我们在前两个方向上可谓“举步维艰”。最终，我们回到线程池参数动态化方向上探索，得出一个且可以解决业务问题的方案，虽然本质上还是没有逃离使用线程池的范畴，但是在成本和收益之间，算是取得了一个很好的平衡。成本在于实现动态化以及监控成本不高，收益在于：在不颠覆原有线程池使用方式的基础之上，从降低线程池参数修改的成本以及多维度监控这两个方面降低了故障发生的概率。希望本文提供的动态化线程池思路能对大家有帮助。</p>\n<h2 id=\"四、参考资料\"><a href=\"#四、参考资料\" class=\"headerlink\" title=\"四、参考资料\"></a>四、参考资料</h2><ul>\n<li>[1] JDK 1.8源码</li>\n<li>[2]<a href=\"https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0\" target=\"_blank\" rel=\"noopener\">维基百科-线程池</a></li>\n<li>[3] <a href=\"https://my.oschina.net/andylucc/blog/648127\" target=\"_blank\" rel=\"noopener\">更好的使用Java线程池</a></li>\n<li>[4] <a href=\"https://en.wikipedia.org/wiki/Pooling_(resource_management)\" target=\"_blank\" rel=\"noopener\">维基百科Pooling(Resource Management)</a></li>\n<li>[5] <a href=\"http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/\" target=\"_blank\" rel=\"noopener\">深入理解Java线程池：ThreadPoolExecutor</a></li>\n<li>[6]《Java并发编程实践》</li>\n</ul>\n"},{"title":"JDK8 parallelStream 与 fork/join 框架","date":"2020-05-12T17:09:49.000Z","_content":"\n## JDK1.8 parallelStream 与 fork/join 框架\n\n### 一、JDK8开启并行串行流\n\ntream是java8中新增加的一个特性,被java猿统称为流.\n\n　　Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。\n\n　　Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。\n\n　　而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：\n\n```java\n1.0-1.4 中的 java.lang.Thread  \n5.0 中的 java.util.concurrent  \n6.0 中的 Phasers 等  \n7.0 中的 Fork/Join 框架  \n8.0 中的 Lambda\n```\n\nStream 的另外一大特点是，数据源本身可以是无限的。\n\n#### 1.1 什么是parallelStream\n\nparallelStream其实就是一个并行执行的流.它通过默认的ForkJoinPool,可能提高你的多线程任务的速度.实际是多线程，注意线程安全问题\n\n　　在从stream和parallelStream方法中进行选择时,我们可以考虑以下几个问题：\n\n```\n　　1. 是否需要并行？  \n　　2. 任务之间是否是独立的？是否会引起任何竞态条件？  \n　　3. 结果是否取决于任务的调用顺序？  \n```\n\n　　对于问题1，需要弄清楚要解决的问题是什么，数据量有多大，计算的特点是什么？并不是所有的问题都适合使用并发程序来求解，比如当数据量不大时，顺序执行往往比并行执行更快。毕竟，准备线程池和其它相关资源也是需要时间的。但是，当任务涉及到I/O操作并且任务之间不互相依赖时，那么并行化就是一个不错的选择。通常而言，将这类程序并行化之后，执行速度会提升好几个等级。\n\n　　对于问题2，如果任务之间是独立的，并且代码中不涉及到对同一个对象的某个状态或者某个变量的更新操作，那么就表明代码是可以被并行化的。\n\n　　对于问题3，由于在并行环境中任务的执行顺序是不确定的，因此对于依赖于顺序的任务而言，并行化也许不能给出正确的结果。　　\n\n　　场景：默认值适用的场景是CPU密集型的，而一般的Web项目是IO密集型的（一般的Web项目都是需要跟数据库打交道的，针对数据库的操作主要就都是IO，而对CPU的消耗并不高）。\n\n　　当不能使用默认值的时候，需要开发人员额外去了解parallelStream的用法，如下：\n\n#### 1.2 parallelStream作用\n\nStream具有平行处理能力，处理的过程会分而治之，也就是将一个大任务切分成多个小任务，这表示每个任务都是一个操作，因此像以下的程式片段：\n\n```\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\nnumbers.parallelStream()\n       .forEach(out::println);  \n```\n\n　　得到的展示顺序不一定会是1、2、3、4、5、6、7、8、9，而可能是任意的顺序，就forEach()这个操作來讲，如果平行处理时，希望最后顺序是按照原来Stream的数据顺序，那可以调用forEachOrdered()。例如：\n\n```\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\nnumbers.parallelStream()\n       .forEachOrdered(out::println); \n```\n\n　　注意:如果forEachOrdered()中间有其他如filter()的中介操作，会试着平行化处理，然后最终forEachOrdered()会以原数据顺序处理，因此，使用forEachOrdered()这类的有序处理,可能会（或完全失去）失去平行化的一些优势，实际上中介操作亦有可能如此，例如sorted()方法。\n\n#### 1.3 开启串行流和并行流：\t\t\n\n```java\n    @Test\n    public void testStream() {\n        List<Integer> list = getList();\n\n        // 串行流\n        list.stream();\n        list.stream().sequential();\n\n        // 并行流\n        list.stream().parallel();\n        list.parallelStream().reduce(null);\n\n        // 串行流执行\n        list.stream().reduce((first, second) -> first+second);/\n\n        // 并行流执行\n        list.parallelStream().reduce((first, second) -> first+second);\n    }\n```\n\n#### 1.2 流处理\n\n因为比较关心并行流的实现，所以看并行流的代码：\n\njava.util.stream.ReduceOps.ReduceOp\n\n```java\nprivate static abstract class ReduceOp<T, R, S extends AccumulatingSink<T, R, S>>\n        implements TerminalOp<T, R> {\n    private final StreamShape inputShape;\n\n    /**\n     * Create a {@code ReduceOp} of the specified stream shape which uses\n     * the specified {@code Supplier} to create accumulating sinks.\n     *\n     * @param shape The shape of the stream pipeline\n     */\n    ReduceOp(StreamShape shape) {\n        inputShape = shape;\n    }\n\n    public abstract S makeSink();\n\n    @Override\n    public StreamShape inputShape() {\n        return inputShape;\n    }\n\n    @Override\n    public <P_IN> R evaluateSequential(PipelineHelper<T> helper,\n                                       Spliterator<P_IN> spliterator) {\n        return helper.wrapAndCopyInto(makeSink(), spliterator).get();\n    }\n\n    @Override\n    public <P_IN> R evaluateParallel(PipelineHelper<T> helper,\n                                     Spliterator<P_IN> spliterator) {\n        // 这里new出了一个 ReduceTask\n        return new ReduceTask<>(this, helper, spliterator).invoke().get();\n    }\n}\n```\n\n名称上看，这是个task任务（java.util.stream.ReduceOps.ReduceTask），再看下类图：\n\n![58929987340](/images/reduceTask-类图.png)\n\n看到类图结构加上熟悉fork/join框架，大概明白了stream的并行流实现了，借助于fork/join\n\n\n\n### 二、Fork/Join 框架\n\nFork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。\n\n它同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。\n\n![img](/images/forkjoin_任务拆分.png)\n\n\n\n#### 2.1分治法\n\n`ForkJoinPool`主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。\n\n　　典型的应用比如快速排序算法。这里的要点在于，ForkJoinPool需要使用相对少的线程来处理大量的任务。比如要对1000万个数据进行排序，那么会将这个任务分割成两个500万的排序任务和一个针对这两组500万数据的合并任务。以此类推，对于500万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于10时，会停止分割，转而使用插入排序对它们进行排序。那么到最后，所有的任务加起来会有大概2000000+个。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。\n\n　　所以当使用ThreadPoolExecutor时，使用分治法会存在问题，因为ThreadPoolExecutor中的线程无法像任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而使用ForkJoinPool时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。\n\n那么使用ThreadPoolExecutor或者ForkJoinPool，会有什么性能的差异呢？\n\n　　首先，使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用4个线程来完成超过200万个任务。但是，使用ThreadPoolExecutor时，是不可能完成的，因为ThreadPoolExecutor中的Thread无法选择优先执行子任务，需要完成200万个具有父子关系的任务时，也需要200万个线程，显然这是不可行的。\n\n​\t尝试改变JDK8的工作线程数量：\n\n```java\npublic static final String DEFAULT_FORK_JOIN_PARALLELISM = \"java.util.concurrent.ForkJoinPool.common.parallelism\";\n// 设置线程数\nSystem.setProperty(DEFAULT_FORK_JOIN_PARALLELISM, (Runtime.getRuntime().availableProcessors() * 2) + \"\");\n```\n\n\n\n#### 2.2 工作窃取法\n\n　　forkjoin最核心的地方就是利用了现代硬件设备多核,在一个操作时候会有空闲的cpu,那么如何利用好这个空闲的cpu就成了提高性能的关键,而这里我们要提到的工作窃取（work-stealing）算法就是整个forkjion框架的核心理念,工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。\n\n　　那么为什么需要使用工作窃取算法呢？\n\n　　假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。\n\n　　工作窃取的运行流程图如下：\n\n![img](/images/forkjoin_工作窃取（双端队列）.png)\n\n　　工作窃取算法的优点：充分利用线程进行并行计算，并减少了线程间的竞争；\n\n　　工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。\n\n\n\n#### 2.3 Fork/Join 涉及到的关键名称\n\n　　`ForkJoinPool`： 用来执行Task，或生成新的ForkJoinWorkerThread，执行 ForkJoinWorkerThread 间的 work-stealing 逻辑。ForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。\n\n　　`ForkJoinTask`： 执行具体的分支逻辑，声明以同步/异步方式进行执行\n\n　　`ForkJoinWorkerThread`： 是 ForkJoinPool 内的 worker thread，执行\n\n　　`ForkJoinTask`, 内部有 ForkJoinPool.WorkQueue来保存要执行的ForkJoinTask。\n\n　　`ForkJoinPool.WorkQueue`：保存要执行的ForkJoinTask。\n\n\n\n#### 2.4 Fork/Join框架的实现原理\n\n在Java的Fork/Join框架中，它提供了两个类来帮助我们完成任务分割以及执行任务并合并结果：\n\n　　1、`ForkJoinTask`：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：\n\n　　　　`RecursiveAction`：用于没有返回结果的任务。\n　　　　`RecursiveTask` ：用于有返回结果的任务。\n\n　　2、`ForkJoinPool` ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。\n\n　　`ForkJoinPool`由`ForkJoinTask`数组和`ForkJoinWorkerThread`数组组成，`ForkJoinTask`数组负责将存放程序提交给`ForkJoinPool`，而`ForkJoinWorkerThread`负责执行这些任务。\n\n基本思想\n\n　　`ForkJoinPool` 的每个工作线程都维护着一个工作队列（`WorkQueue`），这是一个双端队列（`Deque`），里面存放的对象是任务（`ForkJoinTask`）。\n\n　　每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 LIFO（**后进先出**） 方式，也就是说每次从队尾取出任务来执行。\n\n　　每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。\n\n　　在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。\n\n　　在既没有自己的任务，也没有可以窃取的任务时，进入休眠。\n\n\n\n##### 2.4.1 ForkJoinPool属性说明、工作队列说明、控制中心说明\n\n```java\n// Instance fields\n    volatile long ctl;                   // 控制中心：非常重要，看下图解析\n    volatile int runState;               // 负数是shutdown，其余都是2的次方\n    final int config;                    // 配置：二进制的低16位代表 并行度（parallelism），\n                                                                                    //高16位：mode可选FIFO_QUEUE（1 << 16）和LIFO_QUEUE（1 << 31），默认是LIFO_QUEUE\n    int indexSeed;                       // 生成worker的queue索引\n    volatile WorkQueue[] workQueues;     // main registry\n    final ForkJoinWorkerThreadFactory factory;\n    final UncaughtExceptionHandler ueh;  // per-worker UEH\n    final String workerNamePrefix;       // to create worker name string\n    volatile AtomicLong stealCounter;    // also used as sync monitor\n```\n\n\n\n###### 2.4.1.1 工作队列workQueues\n\n用于保存向ForkJoinPool提交的任务，而具体的执行由ForkJoinWorkerThread执行，而ForkJoinWorkerThreadFactory可以用于生产出ForkJoinWorkerThread：\n\n```java\npublic static interface ForkJoinWorkerThreadFactory {\n    /**\n        * Returns a new worker thread operating in the given pool.\n        *\n        * @param pool the pool this thread works in\n        * @return the new worker thread\n        * @throws NullPointerException if the pool is null\n        */\n    public ForkJoinWorkerThread newThread(ForkJoinPool pool);\n}\n```\n\n![img](/images/292888-20190913110608100-591376294.png)\n\n```java\n// Instance fields\nvolatile int scanState;    // 负数：inactive, 非负数：active, 其中奇数代表scanning\nint stackPred;             // sp = (int)ctl, 前一个队列栈的标示信息，包含版本号、是否激活、以及队列索引\nint nsteals;               // 窃取的任务数\nint hint;                  // 一个随机数，用来帮助任务窃取，在 helpXXXX()的方法中会用到\nint config;                // 配置：二进制的低16位代表 在 queue[] 中的索引，\n// 高16位：mode可选FIFO_QUEUE（1 << 16）和LIFO_QUEUE（1 << 31），默认是LIFO_QUEUE\nvolatile int qlock;        // 锁定标示位：1: locked, < 0: terminate; else 0\nvolatile int base;         // index of next slot for poll\nint top;                   // index of next slot for push\nForkJoinTask<?>[] array;   // 任务列表\n```\n\n###### 2.4.1.2 控制中心ctl\n\n![img](/images/292888-20190913111130827-1005682912.png)\n\n###### 2.4.1.3 方法说明\n\n队列与关键任务调用说明\n\n![img](/images/292888-20190913110836624-260052587.png)\n\n\n\n2.4.1.4 externalPush || externalSubmit\n\n```java\nfinal void externalPush(ForkJoinTask<?> task) {\n        WorkQueue[] ws; WorkQueue q; int m;\n        //我们以前常用的Random，在并发下，多个线程同时计算种子需要用到同一个原子变量。\n        //由于更新操作使用CAS，同时执行只有一个线程成功，其他线程的大量自旋造成性能损失，ThreadLocalRandom继承Random，对此进行了改进。\n                //ThreadLocalRandom运用了ThreadLocal，每个线程内部维护一个种子变量，多线程下计算新种子时使用线程自己的种子变量进行更新，避免了竞争。\n        int r = ThreadLocalRandom.getProbe();\n        int rs = runState;\n        // 外部提交的task，肯定会到偶数位下标的队列上\n        // SQMASK = 0x007e = 1111110，任何数和 SQMASK 进行 & 运算 都会是偶数\n        if ((ws = workQueues) != null && (m = (ws.length - 1)) >= 0 &&\n            (q = ws[m & r & SQMASK]) != null && r != 0 && rs > 0 &&\n            //队列上锁\n            U.compareAndSwapInt(q, QLOCK, 0, 1)) {\n            ForkJoinTask<?>[] a; int am, n, s;\n            if ((a = q.array) != null &&\n                (am = a.length - 1) > (n = (s = q.top) - q.base)) {\n                int j = ((am & s) << ASHIFT) + ABASE;\n                //把 task 放到队列的 top端\n                U.putOrderedObject(a, j, task);\n                U.putOrderedInt(q, QTOP, s + 1);\n                U.putIntVolatile(q, QLOCK, 0);\n                if (n <= 1)\n                    signalWork(ws, q);\n                return;\n            }\n            //队列解锁\n            U.compareAndSwapInt(q, QLOCK, 1, 0);\n        }\n        externalSubmit(task);\n    } \n```\n\n###### 2.4.1.5 registerWorker\n\n```java\nfinal WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        //......\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                // worker的queue肯定放在pool中的queue[]中的奇数下标\n                  // m = ws.lenght - 1, ws.lenght 肯定是偶数，则m 肯定是奇数\n                // 1的二进制位：00000001, 所以任何数 \"|\" 1 都是奇数\n                // 所以 奇数 & 奇数 ， 1&1 = 1，所以i肯定是奇数\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    // 如果下标已经有队列，则重新生成奇数下标\n                    // step肯定为偶数：EVENMASK：0xfffe：1111111111111110\n                      // 所以 奇数+偶数，奇偶性不变\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                //...\n            }\n        //......\n    }\n```\n\n\n\n###### 2.4.1.6 scan\n\n```java\nprivate ForkJoinTask<?> scan(WorkQueue w, int r) {\n        WorkQueue[] ws; int m;\n        if ((ws = workQueues) != null && (m = ws.length - 1) > 0 && w != null) {\n            int ss = w.scanState;                     // initially non-negative\n               // k = r & m 。 r是一个随机数，m 是 队列数组长度 - 1；用于定位去哪个 队列 窃取 task\n            for (int origin = r & m, k = origin, oldSum = 0, checkSum = 0;;) {\n                WorkQueue q; ForkJoinTask<?>[] a; ForkJoinTask<?> t;\n                int b, n; long c;\n                if ((q = ws[k]) != null) {\n                      // 如果有还没执行的task，尝试窃取队列q 中的base下标的 task。 即FIFO\n                    // i: 在内存中，b下标对应的对象的偏移值。 a.length - 1 的二进制位 永远是 0[1...]s，所以 (a.length - 1) & b = b，主要是保证了b不会越界\n                    if ((n = (b = q.base) - q.top) < 0 &&\n                        (a = q.array) != null) {      // non-empty\n                        long i = (((a.length - 1) & b) << ASHIFT) + ABASE;\n                        if ((t = ((ForkJoinTask<?>)\n                                  U.getObjectVolatile(a, i))) != null &&\n                            q.base == b) {\n                               // ss 是小偷的 scanState，大于0代表当前的worker是激活的\n                            if (ss >= 0) {\n                                  // 把 task 从 队列中取出来，然后队列的base+1，如果被窃取的队列中有多于1个的task，则尝试唤醒其他的worker\n                                if (U.compareAndSwapObject(a, i, t, null)) {\n                                    q.base = b + 1;\n                                    if (n < -1)       // signal others\n                                        signalWork(ws, q);\n                                    return t;\n                                }\n                            }\n                              // ss小于0代表当前的worker是未激活的，并且当前是第一次扫描，这时候尝试激活worker\n                            // oldSum: 上一次遍历周期的 base 值的和。\n                            // (int) c : 可以拿到当前栈顶的空闲worker。sp = (int) c\n                            else if (oldSum == 0 &&   // try to activate\n                                     w.scanState < 0)\n                                tryRelease(c = ctl, ws[m & (int)c], AC_UNIT);\n                        }\n                        if (ss < 0)                   // refresh\n                            ss = w.scanState;\n                        // 更新随机值，重新初始化所有控制变量，重新定位队列\n                        r ^= r << 1; r ^= r >>> 3; r ^= r << 10;\n                        origin = k = r & m;           // move and rescan\n                        oldSum = checkSum = 0;\n                        continue;\n                    }\n                    checkSum += b;\n                }\n                // 每次没有窃取到task的时候，都会k+1（k值不会超过m），当k遍历了一圈还没有steal到任务，则当前小偷worker是过剩的，则inactive这个小偷worker\n                if ((k = (k + 1) & m) == origin) {    // continue until stable\n                      // oldSum == (oldSum = checkSum) 实际上就是 oldSum == checkSum ， oldSum = checkSum\n                    // oldSum == checkSum 是判断 这个周期和上个周期 的base和是否一直，如果一直， 说明base可能没有变过\n                    if ((ss >= 0 || (ss == (ss = w.scanState))) &&\n                        oldSum == (oldSum = checkSum)) {\n                        if (ss < 0 || w.qlock < 0)    // already inactive\n                            break;\n                        int ns = ss | INACTIVE;       // try to inactivate\n                        long nc = ((SP_MASK & ns) |\n                                   (UC_MASK & ((c = ctl) - AC_UNIT)));\n                        // 维护 队列的 stack，可以指向前一个栈顶的队列\n                        w.stackPred = (int)c;         // hold prev stack top\n                        U.putInt(w, QSCANSTATE, ns);\n                        if (U.compareAndSwapLong(this, CTL, c, nc))\n                            ss = ns;\n                        else\n                            w.scanState = ss;         // back out\n                    }\n                    checkSum = 0;\n                }\n            }\n        }\n        return null;\n    }\n```\n\n###### 2.4.1.7 signalWork\n\n```java\nfinal void signalWork(WorkQueue[] ws, WorkQueue q) {\n        long c; int sp, i; WorkQueue v; Thread p;\n        // AC是负数，所以 active worker不足\n        while ((c = ctl) < 0L) {                       // too few active\n            // sp:第一位是0，没有版本号，没有inactive的worker\n            if ((sp = (int)c) == 0) {                  // no idle workers\n                //tc: tc不为0，就是代表 total worker - parallelism < 0, 所以需要添加worker\n                if ((c & ADD_WORKER) != 0L)            // too few workers\n                    tryAddWorker(c);\n                break;\n            }\n            if (ws == null)                            // unstarted/terminated\n                break;\n            // 取栈顶的worker，如果下标已经越界或queue为null，线程池都是终止了\n            if (ws.length <= (i = sp & SMASK))         // terminated\n                break;\n            if ((v = ws[i]) == null)                   // terminating\n                break;\n            // 新的scanState，版本+1，设置状态为激活，INACTIVE = 1 << 31，~INACTIVE = 01111111....\n            int vs = (sp + SS_SEQ) & ~INACTIVE;        // next scanState\n            // 确认 worker的 sp没有变化\n            int d = sp - v.scanState;                  // screen CAS\n            // 生成新的 ctl，(UC_MASK & (c + AC_UNIT))设置 高32位， (SP_MASK & v.stackPred)设置低32位\n            long nc = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & v.stackPred);\n            if (d == 0 && U.compareAndSwapLong(this, CTL, c, nc)) {\n                //激活worker\n                v.scanState = vs;                      // activate v\n                if ((p = v.parker) != null)\n                    U.unpark(p);\n                break;\n            }\n            //当前queue没有task 需要执行了，则停止signal\n            if (q != null && q.base == q.top)          // no more work\n                break;\n        }\n    }\n```\n\n###### 2.4.1.8 ForkJoinTask的fork方法实现原理\n\n当我们调用ForkJoinTask的fork方法时，程序会把任务放在ForkJoinWorkerThread的pushTask的workQueue中，异步地执行这个任务，然后立即返回结果，代码如下：\n\n```java\npublic final ForkJoinTask<V> fork() {\n    Thread t;\n    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n        ((ForkJoinWorkerThread)t).workQueue.push(this);\n    else\n        ForkJoinPool.common.externalPush(this);\n    return this;\n}\n```\n\n若当前线程是ForkJoinWorkerThread线程，则强制类型转换（向下转换）成ForkJoinWorkerThread，然后将任务push到这个线程负责的队列里面去，在ForkJoinWorkerThread类中有一个pool和一个workQueue字段：\n\n```java\n// 线程工作的ForkJoinPool\nfinal ForkJoinPool pool;                // the pool this thread works in\n// 工作窃取队列\nfinal ForkJoinPool.WorkQueue workQueue; // work-stealing mechanics\n```\n\npushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：\n\n```java\nfinal void push(ForkJoinTask<?> task) {\n    ForkJoinTask<?>[] a; ForkJoinPool p;\n    int b = base, s = top, n;\n    if ((a = array) != null) {    // ignore if queue removed\n        int m = a.length - 1;     // fenced write for task visibility\n        U.putOrderedObject(a, ((m & s) << ASHIFT) + ABASE, task);\n        U.putOrderedInt(this, QTOP, s + 1);\n        if ((n = s - b) <= 1) {\n            if ((p = pool) != null)\n                p.signalWork(p.workQueues, this);\n        }\n        else if (n >= m)\n            growArray();\n    }\n}\n```\n\n该方法的主要功能就是将当前任务存放在ForkJoinTask数组array里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。\n\n###### 2.4.1.9 ForkJoinTask的join方法实现原理\n\n```java\npublic final V join() {\n    int s;\n    if ((s = doJoin() & DONE_MASK) != NORMAL)\n        reportException(s);\n    return getRawResult();\n}\n```\n\n　　首先，它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有四种：已完成（NORMAL），被取消（CANCELLED），信号（SIGNAL）和出现异常（EXCEPTIONAL）：　　\n\n　　若状态不是NORMAL，则通过reportException(int)方法来处理状态：\n\n```java\nprivate void reportException(int s) {\n    if (s == CANCELLED)\n        throw new CancellationException();\n    if (s == EXCEPTIONAL)\n        rethrow(getThrowableException());\n}\n```\n\n\n\n- 如果任务状态是已完成，则直接返回任务结果。\n- 如果任务状态是被取消，则直接抛出CancellationException。\n- 如果任务状态是抛出异常，则直接抛出对应的异常。\n\n　　doJoin()方法的实现代码：\n\n```java\nprivate int doJoin() {\n    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;\n    return (s = status) < 0 ? s :\n        ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n        (w = (wt = (ForkJoinWorkerThread)t).workQueue).\n        tryUnpush(this) && (s = doExec()) < 0 ? s :\n        wt.pool.awaitJoin(w, this, 0L) :\n        externalAwaitDone();\n}\n```\n\n\n\n　　在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完了，如果执行完了，则直接返回任务状态，如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成了，则设置任务状态为NORMAL，如果出现异常，则纪录异常，并将任务状态设置为EXCEPTIONAL。\n\n　　执行任务是通过doExec()方法来完成的：\n\n```java\nfinal int doExec() {\n    int s; boolean completed;\n    if ((s = status) >= 0) {\n        try {\n            completed = exec();\n        } catch (Throwable rex) {\n            return setExceptionalCompletion(rex);\n        }\n        if (completed)\n            s = setCompletion(NORMAL);\n    }\n    return s;\n}\n```\n\n真正的执行过程是由exec()方法来完成的：\n\n```java\nprotected abstract boolean exec();\n```\n\n这就是我们需要重写的方法，若是我们的任务继承自RecursiveAction，则我们需要重写RecursiveAction的compute()方法：\n\n```java\npublic abstract class RecursiveAction extends ForkJoinTask<Void> {\n    private static final long serialVersionUID = 5232453952276485070L;\n \n    /**\n     * The main computation performed by this task.\n     */\n    protected abstract void compute();\n \n    /**\n     * Always returns {@code null}.\n     *\n     * @return {@code null} always\n     */\n    public final Void getRawResult() { return null; }\n \n    /**\n     * Requires null completion value.\n     */\n    protected final void setRawResult(Void mustBeNull) { }\n \n    /**\n     * Implements execution conventions for RecursiveActions.\n     */\n    protected final boolean exec() {\n        compute();\n        return true;\n    }\n}\n```\n\n若是我们的任务继承自RecursiveTask，则我们同样需要重写RecursiveTask的compute()方法：\n\n```java\npublic abstract class RecursiveTask<V> extends ForkJoinTask<V> {\n    private static final long serialVersionUID = 5232453952276485270L;\n \n    /**\n     * The result of the computation.\n     */\n    V result;\n \n    /**\n     * The main computation performed by this task.\n     * @return the result of the computation\n     */\n    protected abstract V compute();\n \n    public final V getRawResult() {\n        return result;\n    }\n \n    protected final void setRawResult(V value) {\n        result = value;\n    }\n \n    /**\n     * Implements execution conventions for RecursiveTask.\n     */\n    protected final boolean exec() {\n        result = compute();\n        return true;\n    }\n}\n```\n\n通过上面的分析可知，执行我们的业务代码是在调用了join()之后的，也就是说，fork仅仅是分割任务，只有当我们执行join的时候，我们的任务才会被执行。\n\n##### 2.4.2 异常处理\n\nForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码：\n\n```java\nif(task.isCompletedAbnormally()){\n    System.out.println(task.getException());\n}\n```\n\ngetException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。\n\n```java\npublic final Throwable getException() {\n        int s = status & DONE_MASK;\n        return ((s >= NORMAL)    ? null :\n                (s == CANCELLED) ? new CancellationException() :\n                getThrowableException());\n}\n```\n\n\n\n##### 2.4.2forkjoin 的使用\n\n　ForkJoinPool 使用submit 或 invoke 提交的区别：invoke是同步执行，调用之后需要等待任务完成，才能执行后面的代码；submit是异步执行，只有在Future调用get的时候会阻塞。\n\n　　这里继承的是RecursiveTask 适用于有返回值的场景；还可以继承RecursiveAction，适合于没有返回值的场景\n\n　　执行子任务调用fork方法并不是最佳的选择，最佳的选择是invokeAll方法。\n\n##### 2.4.3 示例代码\n\n   这个示例是在做某支付任务异步解耦后的业务逻辑校验，这个是一个接收返回的任务 `RecursiveTask`：\n\n```java\nclass CheckTask extends RecursiveTask<Integer> {\n\t\t/**\n\t\t*  这个是阈值，具体任务列表拆分到什么程度再开始执行\n\t\t**/\n        private int threshold = 10;\n\n    \t/**\n    \t*\t这个是当前处理的集合列表\n    \t**/\n        private List<CbVaPaymentFileContent> list;\n\n        /**\n        * 初始化任务对象\n        **/\n        private CheckTask(int threshold, List<CbVaPaymentFileContent> list) {\n            if (null == list) throw new IllegalArgumentException(\"[list] is null.\");\n            this.threshold = threshold <= 0 ? this.threshold : threshold;\n//            this.threshold = list.size() / Runtime.getRuntime().availableProcessors();\n            this.list = list;\n        }\n\n        @Override\n        protected Integer compute() {\n            if (list.size() <= threshold) {\n                // 处理\n                int count = 0;\n                for (CbVaPaymentFileContent content : list) {\n                    count += process(content);\n                }\n                return count;\n            } else {\n                // 分解\n                int middle = list.size() / 2;\n                List<CbVaPaymentFileContent> leftList = list.subList(0, middle);\n                List<CbVaPaymentFileContent> rightList = list.subList(middle, list.size());\n                CheckTask left = new CheckTask(threshold, leftList);\n                CheckTask right = new CheckTask(threshold, rightList);\n                // left.fork();\n                // right.fork();\n                \n                // 这两个方法，使用invokeAll方法的主要原因是为了充分利用线程池，在invokeAll的N个任务中，其中N-1个任务会使用fork()交给其它线程执行，但是，它还会留一个任务自己执行，这样，就充分利用了线程池，保证没有空闲的不干活的线程。\n                invokeAll(left, right);\n\n                // 结合\n                return left.join() + right.join();\n            }\n        }\n\n    }\n```\n\n　　该代码就是通过Fork/Join框架来计算数组的和，计算耗时4031毫秒。通过该代码作为应用示例主要是为了告诉大家，使用Fork/Join模型的正确方式，在源代码中可以看到，SumTask继承自RecursiveTask，重写的compute方法为：\n\n　　compute()方法使用了invokeAll方法来分解任务，而不是它下面的subtask1.fork();\n\n　　这两个方法，使用invokeAll方法的主要原因是为了充分利用线程池，在invokeAll的N个任务中，其中N-1个任务会使用fork()交给其它线程执行，但是，它还会留一个任务自己执行，这样，就充分利用了线程池，保证没有空闲的不干活的线程。\n\n　　若是采用另外一种方式来运行，程序的运行时间为6028毫秒，可以看到，明显比invokeAll方式慢了很多。\n\n##### 2.4.3 JDK8中的最佳实践\n\n##### 2.4.3.1 通过forkjoin来看parallelStream\n\n在Java 8引入了自动并行化的概念。它能够让一部分Java代码自动地以并行的方式执行，即使用了ForkJoinPool的ParallelStream。　　\n\n　　Java 8为ForkJoinPool添加了一个通用线程池，这个线程池用来处理那些没有被显式提交到任何线程池的任务。它是ForkJoinPool类型上的一个静态元素，它拥有的默认线程数量等于运行计算机上的处理器数量。当调用Arrays类上添加的新方法时，自动并行化就会发生。比如用来排序一个数组的并行快速排序，用来对一个数组中的元素进行并行遍历。自动并行化也被运用在Java 8新添加的Stream API中。\n\n　　一般ForkJoinPool中的通用线程池处理，也可以使用ThreadPoolExecutor完成，但是就代码的可读性和代码量而言，使用ForkJoinPool明显更胜一筹。\n\n##### 2.4.3.2 线程池数量\n\n​\t**1、系统CPU数量：[如机器8核，即8]**\n\n```\nRuntime.getRuntime().availableProcessors()\n```\n\n　　**2、parallelStream默认的并发线程数:【parallelStream核心使用ForkJoinPool实现，故如下】【输出是7个】**\n\n```\nForkJoinPool.getCommonPoolParallelism()\n```\n\n　　**3、为什么parallelStream默认的并发线程数要比CPU处理器的数量少1个？**\n\n　　　　因为最优的策略是每个CPU处理器分配一个线程，然而主线程也算一个线程，所以要占一个名额。如果只有1个CPU，默认的并发线程数就是1\n\n　　**4、修改默认并发数**\n\n　　　　默认的并发线程数不可以反复修改。因为`java.util.concurrent.ForkJoinPool.common.parallelism`是`final`类型的，整个JVM中只允许设置一次。多次修改以第一次为主\n\n　　　　1、系统property\n\n```\n        System.setProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\", \"20\");\n        System.out.println(ForkJoinPool.getCommonPoolParallelism());\n```\n\n　　　　2、当然上述参数也可以通过jvm设置系统属性：-Djava.util.concurrent.ForkJoinPool.common.parallelism=N （N为线程数量）　　\n\n　　**5、既然默认的并发线程数不能反复修改，进行不同线程数量的并发测试，可以引入`ForkJoinPool`。用法如下**：\n\n```\n    @Test\n    public void testSetParallelMutli() throws ExecutionException, InterruptedException {\n        int[] threadCountArr = {2, 4, 6};\n        List<Integer> para = new ArrayList<>();\n        for (int i = 0; i < 7; i++) {\n            para.add(i);\n\n        }\n        for (int threadCount : threadCountArr) {\n            new ForkJoinPool(threadCount).submit(() -> {//多线程任务\n                System.out.println(Thread.currentThread().getName());\n            }).get();\n        }\n    }\n```\n\n　　　　使用get 是为了阻塞 得到结果；如果主线程没有关闭的情况下可以不用get\n\n\n\n##### 2.4.3.2 测试示例\n\n**实际应用示例**\n\n```java\nlogger.info(\"[消息补偿任务-并行执行]开始，本次预处理总数为[{}]\", list.size());\n\n// 手动扩容下,当然这个综合考虑使用\nSystem.setProperty(DEFAULT_FORK_JOIN_PARALLELISM, (Runtime.getRuntime().availableProcessors() * appConfig.getMutiple()) + \"\");\n\n/**\n * 拆分任务到JobSender\n *  {@link Stream#reduce(Object, BiFunction, BinaryOperator)}\n *  <p>\n *      reduce.Object --> 初始值，只是为了来初始化参数类型\n *      reduce.BiFunction.apply(T t, U u) -->  t表示当前值， u表示当前操作对象\n *      reduce.BinaryOperator(T t, U u) --> t=u=初始值类型，用来合并结果的\n *  </p>\n */\nint total = list.parallelStream().filter(op -> lockAdaptor.lock(op.getId(), LockAdaptor.DEFAULT_TIMEOUT)).reduce(0, (cur, channel) -> {\n    // 构建发送器 + 并处理\n    int ava;\n    try {\n        ava = (jobSenderFactory.getSender(channel).process().dealSuccess() ? 1 : 0);\n    } finally {\n        // 解锁\n        lockAdaptor.unlock(channel.getId());\n    }\n    return cur + ava;\n}, (a, b) -> a + b);\nlogger.info(\"[消息补偿任务-并行执行]结束，本次预处理总数为[{}]， 成功总数[{}], 未成功总数[{}]\", list.size(), total, list.size() - total);\n```\n\n1、测试一、8核机器，每个任务均耗时2秒，一共16个任务\n\n```\n    @Test\n    public void testSetParallelMutli2() throws ExecutionException, InterruptedException {\n        List<Integer> para = new ArrayList<>();\n        for (int i = 0; i < 16; i++) {\n            para.add(i);\n\n        }\n        para.parallelStream().forEach(i -> {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(LocalDateTime.now() + \"||\" + Thread.currentThread().getName() + \":\" + i);\n        });\n    }\n```\n\n　　输出\n\n```\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-1:5\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-6:1\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-2:14\n2019-09-13T10:51:04.344||main:10\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-4:13\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-3:2\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-7:4\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-5:7\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-4:3\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-6:0\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-1:12\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-2:15\n2019-09-13T10:51:06.350||main:11\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-5:8\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-3:6\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-7:9\n```\n\n　　结论：会有7个 ForkJoinPool.commonPool-worker 线程和1个主线程main一起执行任务。并且8个一组一组执行，每个线程执行了两个任务。\n\n2、测试二、8核机器，每个任务耗时2秒内随机，一共16个任务 \n\n```\n    @Test\n    public void testSetParallelMutli2() throws ExecutionException, InterruptedException {\n        List<Integer> para = new ArrayList<>();\n        for (int i = 0; i < 16; i++) {\n            para.add(i);\n\n        }\n        para.parallelStream().forEach(i -> {\n            try {\n//                Thread.sleep(2000);\n                Thread.sleep(new Random().nextInt(2000));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(LocalDateTime.now() + \"||\" + Thread.currentThread().getName() + \":\" + i);\n        });\n    }\n```\n\n输出\n\n```\n2019-09-13T10:54:01.486||ForkJoinPool.commonPool-worker-5:7\n2019-09-13T10:54:01.751||main:10\n2019-09-13T10:54:01.774||main:11\n2019-09-13T10:54:01.862||ForkJoinPool.commonPool-worker-5:6\n2019-09-13T10:54:02.203||ForkJoinPool.commonPool-worker-5:15\n2019-09-13T10:54:02.285||ForkJoinPool.commonPool-worker-6:1\n2019-09-13T10:54:02.407||ForkJoinPool.commonPool-worker-6:0\n2019-09-13T10:54:02.479||ForkJoinPool.commonPool-worker-1:5\n2019-09-13T10:54:02.496||ForkJoinPool.commonPool-worker-2:14\n2019-09-13T10:54:02.518||ForkJoinPool.commonPool-worker-4:13\n2019-09-13T10:54:02.732||main:9\n2019-09-13T10:54:02.740||ForkJoinPool.commonPool-worker-7:4\n2019-09-13T10:54:02.791||ForkJoinPool.commonPool-worker-3:2\n2019-09-13T10:54:03.178||ForkJoinPool.commonPool-worker-5:12\n2019-09-13T10:54:03.743||ForkJoinPool.commonPool-worker-1:8\n2019-09-13T10:54:04.003||ForkJoinPool.commonPool-worker-6:3\n```\n\n　　结论：会有7个 ForkJoinPool.commonPool-worker 线程和1个主线程main一起执行任务。并且是强占式【工作窃取法】的执行任务：如上线程5、主线程执行了各3个任务，其他有2个或一个的。\n\n3、示例三、接收消息队列消息，每次消息个数n个，每个消息是一个100个的list<String>,接收时候使用parallelStream消费并发处理\n\n发送消息\n\n```\n    @Test\n    public void testMq() throws Exception {\n        for (int j = 0; j < 1; j++) {\n            List<String> list = Lists.newArrayList();\n            for (int i = 0; i < 100; i++) {\n                list.add(j+\"___________\"+i);\n            }\n            producerMessageService.sendMessage(\"test_parallel\", UUID.randomUUID().toString(), JSON.toJSONString(list));\n            Thread.sleep(1000);\n        }\n        logger.error(\"=======================================================生产 ok\");\n\n        Thread.sleep(2000000000);\n    }\n```\n\n接收消费\n\n```\n    @Override\n    public void onMessage(List<Message> messages) throws Exception {\n        if (messages == null || messages.isEmpty()) {\n            return;\n        }\n\n        for (int i = 0; i < messages.size(); i++) {\n            Message message = messages.get(i);\n            logger.info(String.format(\"收到一条消息,消息主题（队列名）：%s,内容是：%s\", message.getTopic(), message.getText()));\n\n\n            List<String> strings = JSONArray.parseArray(message.getText(), String.class);\n            strings.parallelStream().forEach(p -> {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                logger.error(LocalDateTime.now() + \"_______________\" + Thread.currentThread().getName() + \":\" + p);\n            });\n        }\n    }\n```\n\n　　说明：\n\n　　　　发送消息，1s后会发送完毕，此时如果有订阅就会出现一条消息积压。\n\n　　　　订阅消息者，订阅后会收到词条消息，此时如果正常执行完毕（不论使用不使用多线程）消息积压就没有了，因为一般消息监听会在方法正常执行完毕后，使用消息Id将此条消息从订阅队列中移除。\n\n　　　　　　接收到1条消息，里面会有一个jsonstring，反序列化为List，大小是100，交给parallelStream处理，此时会有8个线程处理【如果是8核机器】，处理速度大约是2秒8个。其余的92进入workQueue中等待处理。\n\n　　　　　　此时如果程序中断，订阅的消息不会被消费使用，下次重连时，需要做已处理消息的去重。\n\n　　　　　　此时如果有新消息发送过来，也会在积压中，不会被消息消费。\n\n 4、示例四、从a中100个数找出整除5的\n\n```\n    @Test\n    public void testExec() throws ExecutionException, InterruptedException {\n        List<Integer> a = Lists.newArrayList();\n        for (int i = 0; i < 100; i++) {\n            a.add(i);\n        }\n        List<Integer> b = Lists.newArrayList();\n        a.parallelStream().forEach(p -> {\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (p % 5 == 0) {\n                b.add(p);\n            }\n        });\n        System.out.println(\"===========\"+b.size());\n        b.forEach(p -> System.out.print(p+\" \"));\n    }\n```\n\n输出：正确应该是20\n\n```\n===========18\n15 90 45 30 25 35 85 75 0 40 5 80 95 20 60 70 50 55 \n```\n\n \n\n对此运行结果不一致，以及会有多线程问题\n\n```\njava.lang.ArrayIndexOutOfBoundsException\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n　　……\n\nCaused by: java.lang.ArrayIndexOutOfBoundsException: 15\n    at java.util.ArrayList.add(ArrayList.java:463)\n    at com.github.bjlhx15.common.thread.juc.collection.jdk8stream.TStreamTest.lambda$testExec$6(TStreamTest.java:118)\n    at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)\n    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382)\n    at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\n    at java.util.stream.ForEachOps$ForEachTask.compute(ForEachOps.java:291)\n```\n\n \n\n原因：parallelStream 并行执行，多线程异步，可能没有b添加完毕就遍历，ArrayList不是线程安全的\n\n修正：\n\n　　方案一、在遍历前，需全部执行完毕【串行】\n\n　　　　将 parallelStream 改为 stream串行处理【不可取，处理速度慢】\n\n　　方案二、在遍历前，需全部执行完毕\n\n　　　　继承 RecursiveTask或者RecursiveAction写任务　　　　\n\n　　方案三、将ArrayList替换安全集合CopyOnWriteArrayLIst\n\n```\n        List<Integer> b = Lists.newCopyOnWriteArrayList();\n```\n\n　　　　此时运行就会出现正确结果。按理说应该会有结果不准确问题吧。但是没有，个人理解，因为是每次8个同时执行，所以即使最后一次主线程提前结束，也有其他线程在锁着b，所以最后执行b的操作会有等待","source":"_posts/java/thread-forkJoin.md","raw":"---\ntitle: JDK8 parallelStream 与 fork/join 框架\ndate: 2020-05-13 01:09:49\ntags:\n    - java\n    - thread\n    - synchronized/lock\n    - ThreadPoolExecutor\n    - fork/join\n    - schedule\ncategories:\n    - java\n    - thread\n    - fork/join\n---\n\n## JDK1.8 parallelStream 与 fork/join 框架\n\n### 一、JDK8开启并行串行流\n\ntream是java8中新增加的一个特性,被java猿统称为流.\n\n　　Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。\n\n　　Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。\n\n　　而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：\n\n```java\n1.0-1.4 中的 java.lang.Thread  \n5.0 中的 java.util.concurrent  \n6.0 中的 Phasers 等  \n7.0 中的 Fork/Join 框架  \n8.0 中的 Lambda\n```\n\nStream 的另外一大特点是，数据源本身可以是无限的。\n\n#### 1.1 什么是parallelStream\n\nparallelStream其实就是一个并行执行的流.它通过默认的ForkJoinPool,可能提高你的多线程任务的速度.实际是多线程，注意线程安全问题\n\n　　在从stream和parallelStream方法中进行选择时,我们可以考虑以下几个问题：\n\n```\n　　1. 是否需要并行？  \n　　2. 任务之间是否是独立的？是否会引起任何竞态条件？  \n　　3. 结果是否取决于任务的调用顺序？  \n```\n\n　　对于问题1，需要弄清楚要解决的问题是什么，数据量有多大，计算的特点是什么？并不是所有的问题都适合使用并发程序来求解，比如当数据量不大时，顺序执行往往比并行执行更快。毕竟，准备线程池和其它相关资源也是需要时间的。但是，当任务涉及到I/O操作并且任务之间不互相依赖时，那么并行化就是一个不错的选择。通常而言，将这类程序并行化之后，执行速度会提升好几个等级。\n\n　　对于问题2，如果任务之间是独立的，并且代码中不涉及到对同一个对象的某个状态或者某个变量的更新操作，那么就表明代码是可以被并行化的。\n\n　　对于问题3，由于在并行环境中任务的执行顺序是不确定的，因此对于依赖于顺序的任务而言，并行化也许不能给出正确的结果。　　\n\n　　场景：默认值适用的场景是CPU密集型的，而一般的Web项目是IO密集型的（一般的Web项目都是需要跟数据库打交道的，针对数据库的操作主要就都是IO，而对CPU的消耗并不高）。\n\n　　当不能使用默认值的时候，需要开发人员额外去了解parallelStream的用法，如下：\n\n#### 1.2 parallelStream作用\n\nStream具有平行处理能力，处理的过程会分而治之，也就是将一个大任务切分成多个小任务，这表示每个任务都是一个操作，因此像以下的程式片段：\n\n```\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\nnumbers.parallelStream()\n       .forEach(out::println);  \n```\n\n　　得到的展示顺序不一定会是1、2、3、4、5、6、7、8、9，而可能是任意的顺序，就forEach()这个操作來讲，如果平行处理时，希望最后顺序是按照原来Stream的数据顺序，那可以调用forEachOrdered()。例如：\n\n```\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\nnumbers.parallelStream()\n       .forEachOrdered(out::println); \n```\n\n　　注意:如果forEachOrdered()中间有其他如filter()的中介操作，会试着平行化处理，然后最终forEachOrdered()会以原数据顺序处理，因此，使用forEachOrdered()这类的有序处理,可能会（或完全失去）失去平行化的一些优势，实际上中介操作亦有可能如此，例如sorted()方法。\n\n#### 1.3 开启串行流和并行流：\t\t\n\n```java\n    @Test\n    public void testStream() {\n        List<Integer> list = getList();\n\n        // 串行流\n        list.stream();\n        list.stream().sequential();\n\n        // 并行流\n        list.stream().parallel();\n        list.parallelStream().reduce(null);\n\n        // 串行流执行\n        list.stream().reduce((first, second) -> first+second);/\n\n        // 并行流执行\n        list.parallelStream().reduce((first, second) -> first+second);\n    }\n```\n\n#### 1.2 流处理\n\n因为比较关心并行流的实现，所以看并行流的代码：\n\njava.util.stream.ReduceOps.ReduceOp\n\n```java\nprivate static abstract class ReduceOp<T, R, S extends AccumulatingSink<T, R, S>>\n        implements TerminalOp<T, R> {\n    private final StreamShape inputShape;\n\n    /**\n     * Create a {@code ReduceOp} of the specified stream shape which uses\n     * the specified {@code Supplier} to create accumulating sinks.\n     *\n     * @param shape The shape of the stream pipeline\n     */\n    ReduceOp(StreamShape shape) {\n        inputShape = shape;\n    }\n\n    public abstract S makeSink();\n\n    @Override\n    public StreamShape inputShape() {\n        return inputShape;\n    }\n\n    @Override\n    public <P_IN> R evaluateSequential(PipelineHelper<T> helper,\n                                       Spliterator<P_IN> spliterator) {\n        return helper.wrapAndCopyInto(makeSink(), spliterator).get();\n    }\n\n    @Override\n    public <P_IN> R evaluateParallel(PipelineHelper<T> helper,\n                                     Spliterator<P_IN> spliterator) {\n        // 这里new出了一个 ReduceTask\n        return new ReduceTask<>(this, helper, spliterator).invoke().get();\n    }\n}\n```\n\n名称上看，这是个task任务（java.util.stream.ReduceOps.ReduceTask），再看下类图：\n\n![58929987340](/images/reduceTask-类图.png)\n\n看到类图结构加上熟悉fork/join框架，大概明白了stream的并行流实现了，借助于fork/join\n\n\n\n### 二、Fork/Join 框架\n\nFork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。\n\n它同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。\n\n![img](/images/forkjoin_任务拆分.png)\n\n\n\n#### 2.1分治法\n\n`ForkJoinPool`主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。\n\n　　典型的应用比如快速排序算法。这里的要点在于，ForkJoinPool需要使用相对少的线程来处理大量的任务。比如要对1000万个数据进行排序，那么会将这个任务分割成两个500万的排序任务和一个针对这两组500万数据的合并任务。以此类推，对于500万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于10时，会停止分割，转而使用插入排序对它们进行排序。那么到最后，所有的任务加起来会有大概2000000+个。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。\n\n　　所以当使用ThreadPoolExecutor时，使用分治法会存在问题，因为ThreadPoolExecutor中的线程无法像任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而使用ForkJoinPool时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。\n\n那么使用ThreadPoolExecutor或者ForkJoinPool，会有什么性能的差异呢？\n\n　　首先，使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用4个线程来完成超过200万个任务。但是，使用ThreadPoolExecutor时，是不可能完成的，因为ThreadPoolExecutor中的Thread无法选择优先执行子任务，需要完成200万个具有父子关系的任务时，也需要200万个线程，显然这是不可行的。\n\n​\t尝试改变JDK8的工作线程数量：\n\n```java\npublic static final String DEFAULT_FORK_JOIN_PARALLELISM = \"java.util.concurrent.ForkJoinPool.common.parallelism\";\n// 设置线程数\nSystem.setProperty(DEFAULT_FORK_JOIN_PARALLELISM, (Runtime.getRuntime().availableProcessors() * 2) + \"\");\n```\n\n\n\n#### 2.2 工作窃取法\n\n　　forkjoin最核心的地方就是利用了现代硬件设备多核,在一个操作时候会有空闲的cpu,那么如何利用好这个空闲的cpu就成了提高性能的关键,而这里我们要提到的工作窃取（work-stealing）算法就是整个forkjion框架的核心理念,工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。\n\n　　那么为什么需要使用工作窃取算法呢？\n\n　　假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。\n\n　　工作窃取的运行流程图如下：\n\n![img](/images/forkjoin_工作窃取（双端队列）.png)\n\n　　工作窃取算法的优点：充分利用线程进行并行计算，并减少了线程间的竞争；\n\n　　工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。\n\n\n\n#### 2.3 Fork/Join 涉及到的关键名称\n\n　　`ForkJoinPool`： 用来执行Task，或生成新的ForkJoinWorkerThread，执行 ForkJoinWorkerThread 间的 work-stealing 逻辑。ForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。\n\n　　`ForkJoinTask`： 执行具体的分支逻辑，声明以同步/异步方式进行执行\n\n　　`ForkJoinWorkerThread`： 是 ForkJoinPool 内的 worker thread，执行\n\n　　`ForkJoinTask`, 内部有 ForkJoinPool.WorkQueue来保存要执行的ForkJoinTask。\n\n　　`ForkJoinPool.WorkQueue`：保存要执行的ForkJoinTask。\n\n\n\n#### 2.4 Fork/Join框架的实现原理\n\n在Java的Fork/Join框架中，它提供了两个类来帮助我们完成任务分割以及执行任务并合并结果：\n\n　　1、`ForkJoinTask`：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：\n\n　　　　`RecursiveAction`：用于没有返回结果的任务。\n　　　　`RecursiveTask` ：用于有返回结果的任务。\n\n　　2、`ForkJoinPool` ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。\n\n　　`ForkJoinPool`由`ForkJoinTask`数组和`ForkJoinWorkerThread`数组组成，`ForkJoinTask`数组负责将存放程序提交给`ForkJoinPool`，而`ForkJoinWorkerThread`负责执行这些任务。\n\n基本思想\n\n　　`ForkJoinPool` 的每个工作线程都维护着一个工作队列（`WorkQueue`），这是一个双端队列（`Deque`），里面存放的对象是任务（`ForkJoinTask`）。\n\n　　每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 LIFO（**后进先出**） 方式，也就是说每次从队尾取出任务来执行。\n\n　　每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。\n\n　　在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。\n\n　　在既没有自己的任务，也没有可以窃取的任务时，进入休眠。\n\n\n\n##### 2.4.1 ForkJoinPool属性说明、工作队列说明、控制中心说明\n\n```java\n// Instance fields\n    volatile long ctl;                   // 控制中心：非常重要，看下图解析\n    volatile int runState;               // 负数是shutdown，其余都是2的次方\n    final int config;                    // 配置：二进制的低16位代表 并行度（parallelism），\n                                                                                    //高16位：mode可选FIFO_QUEUE（1 << 16）和LIFO_QUEUE（1 << 31），默认是LIFO_QUEUE\n    int indexSeed;                       // 生成worker的queue索引\n    volatile WorkQueue[] workQueues;     // main registry\n    final ForkJoinWorkerThreadFactory factory;\n    final UncaughtExceptionHandler ueh;  // per-worker UEH\n    final String workerNamePrefix;       // to create worker name string\n    volatile AtomicLong stealCounter;    // also used as sync monitor\n```\n\n\n\n###### 2.4.1.1 工作队列workQueues\n\n用于保存向ForkJoinPool提交的任务，而具体的执行由ForkJoinWorkerThread执行，而ForkJoinWorkerThreadFactory可以用于生产出ForkJoinWorkerThread：\n\n```java\npublic static interface ForkJoinWorkerThreadFactory {\n    /**\n        * Returns a new worker thread operating in the given pool.\n        *\n        * @param pool the pool this thread works in\n        * @return the new worker thread\n        * @throws NullPointerException if the pool is null\n        */\n    public ForkJoinWorkerThread newThread(ForkJoinPool pool);\n}\n```\n\n![img](/images/292888-20190913110608100-591376294.png)\n\n```java\n// Instance fields\nvolatile int scanState;    // 负数：inactive, 非负数：active, 其中奇数代表scanning\nint stackPred;             // sp = (int)ctl, 前一个队列栈的标示信息，包含版本号、是否激活、以及队列索引\nint nsteals;               // 窃取的任务数\nint hint;                  // 一个随机数，用来帮助任务窃取，在 helpXXXX()的方法中会用到\nint config;                // 配置：二进制的低16位代表 在 queue[] 中的索引，\n// 高16位：mode可选FIFO_QUEUE（1 << 16）和LIFO_QUEUE（1 << 31），默认是LIFO_QUEUE\nvolatile int qlock;        // 锁定标示位：1: locked, < 0: terminate; else 0\nvolatile int base;         // index of next slot for poll\nint top;                   // index of next slot for push\nForkJoinTask<?>[] array;   // 任务列表\n```\n\n###### 2.4.1.2 控制中心ctl\n\n![img](/images/292888-20190913111130827-1005682912.png)\n\n###### 2.4.1.3 方法说明\n\n队列与关键任务调用说明\n\n![img](/images/292888-20190913110836624-260052587.png)\n\n\n\n2.4.1.4 externalPush || externalSubmit\n\n```java\nfinal void externalPush(ForkJoinTask<?> task) {\n        WorkQueue[] ws; WorkQueue q; int m;\n        //我们以前常用的Random，在并发下，多个线程同时计算种子需要用到同一个原子变量。\n        //由于更新操作使用CAS，同时执行只有一个线程成功，其他线程的大量自旋造成性能损失，ThreadLocalRandom继承Random，对此进行了改进。\n                //ThreadLocalRandom运用了ThreadLocal，每个线程内部维护一个种子变量，多线程下计算新种子时使用线程自己的种子变量进行更新，避免了竞争。\n        int r = ThreadLocalRandom.getProbe();\n        int rs = runState;\n        // 外部提交的task，肯定会到偶数位下标的队列上\n        // SQMASK = 0x007e = 1111110，任何数和 SQMASK 进行 & 运算 都会是偶数\n        if ((ws = workQueues) != null && (m = (ws.length - 1)) >= 0 &&\n            (q = ws[m & r & SQMASK]) != null && r != 0 && rs > 0 &&\n            //队列上锁\n            U.compareAndSwapInt(q, QLOCK, 0, 1)) {\n            ForkJoinTask<?>[] a; int am, n, s;\n            if ((a = q.array) != null &&\n                (am = a.length - 1) > (n = (s = q.top) - q.base)) {\n                int j = ((am & s) << ASHIFT) + ABASE;\n                //把 task 放到队列的 top端\n                U.putOrderedObject(a, j, task);\n                U.putOrderedInt(q, QTOP, s + 1);\n                U.putIntVolatile(q, QLOCK, 0);\n                if (n <= 1)\n                    signalWork(ws, q);\n                return;\n            }\n            //队列解锁\n            U.compareAndSwapInt(q, QLOCK, 1, 0);\n        }\n        externalSubmit(task);\n    } \n```\n\n###### 2.4.1.5 registerWorker\n\n```java\nfinal WorkQueue registerWorker(ForkJoinWorkerThread wt) {\n        //......\n            if ((ws = workQueues) != null && (n = ws.length) > 0) {\n                int s = indexSeed += SEED_INCREMENT;  // unlikely to collide\n                int m = n - 1;\n                // worker的queue肯定放在pool中的queue[]中的奇数下标\n                  // m = ws.lenght - 1, ws.lenght 肯定是偶数，则m 肯定是奇数\n                // 1的二进制位：00000001, 所以任何数 \"|\" 1 都是奇数\n                // 所以 奇数 & 奇数 ， 1&1 = 1，所以i肯定是奇数\n                i = ((s << 1) | 1) & m;               // odd-numbered indices\n                if (ws[i] != null) {                  // collision\n                    int probes = 0;                   // step by approx half n\n                    int step = (n <= 4) ? 2 : ((n >>> 1) & EVENMASK) + 2;\n                    // 如果下标已经有队列，则重新生成奇数下标\n                    // step肯定为偶数：EVENMASK：0xfffe：1111111111111110\n                      // 所以 奇数+偶数，奇偶性不变\n                    while (ws[i = (i + step) & m] != null) {\n                        if (++probes >= n) {\n                            workQueues = ws = Arrays.copyOf(ws, n <<= 1);\n                            m = n - 1;\n                            probes = 0;\n                        }\n                    }\n                }\n                //...\n            }\n        //......\n    }\n```\n\n\n\n###### 2.4.1.6 scan\n\n```java\nprivate ForkJoinTask<?> scan(WorkQueue w, int r) {\n        WorkQueue[] ws; int m;\n        if ((ws = workQueues) != null && (m = ws.length - 1) > 0 && w != null) {\n            int ss = w.scanState;                     // initially non-negative\n               // k = r & m 。 r是一个随机数，m 是 队列数组长度 - 1；用于定位去哪个 队列 窃取 task\n            for (int origin = r & m, k = origin, oldSum = 0, checkSum = 0;;) {\n                WorkQueue q; ForkJoinTask<?>[] a; ForkJoinTask<?> t;\n                int b, n; long c;\n                if ((q = ws[k]) != null) {\n                      // 如果有还没执行的task，尝试窃取队列q 中的base下标的 task。 即FIFO\n                    // i: 在内存中，b下标对应的对象的偏移值。 a.length - 1 的二进制位 永远是 0[1...]s，所以 (a.length - 1) & b = b，主要是保证了b不会越界\n                    if ((n = (b = q.base) - q.top) < 0 &&\n                        (a = q.array) != null) {      // non-empty\n                        long i = (((a.length - 1) & b) << ASHIFT) + ABASE;\n                        if ((t = ((ForkJoinTask<?>)\n                                  U.getObjectVolatile(a, i))) != null &&\n                            q.base == b) {\n                               // ss 是小偷的 scanState，大于0代表当前的worker是激活的\n                            if (ss >= 0) {\n                                  // 把 task 从 队列中取出来，然后队列的base+1，如果被窃取的队列中有多于1个的task，则尝试唤醒其他的worker\n                                if (U.compareAndSwapObject(a, i, t, null)) {\n                                    q.base = b + 1;\n                                    if (n < -1)       // signal others\n                                        signalWork(ws, q);\n                                    return t;\n                                }\n                            }\n                              // ss小于0代表当前的worker是未激活的，并且当前是第一次扫描，这时候尝试激活worker\n                            // oldSum: 上一次遍历周期的 base 值的和。\n                            // (int) c : 可以拿到当前栈顶的空闲worker。sp = (int) c\n                            else if (oldSum == 0 &&   // try to activate\n                                     w.scanState < 0)\n                                tryRelease(c = ctl, ws[m & (int)c], AC_UNIT);\n                        }\n                        if (ss < 0)                   // refresh\n                            ss = w.scanState;\n                        // 更新随机值，重新初始化所有控制变量，重新定位队列\n                        r ^= r << 1; r ^= r >>> 3; r ^= r << 10;\n                        origin = k = r & m;           // move and rescan\n                        oldSum = checkSum = 0;\n                        continue;\n                    }\n                    checkSum += b;\n                }\n                // 每次没有窃取到task的时候，都会k+1（k值不会超过m），当k遍历了一圈还没有steal到任务，则当前小偷worker是过剩的，则inactive这个小偷worker\n                if ((k = (k + 1) & m) == origin) {    // continue until stable\n                      // oldSum == (oldSum = checkSum) 实际上就是 oldSum == checkSum ， oldSum = checkSum\n                    // oldSum == checkSum 是判断 这个周期和上个周期 的base和是否一直，如果一直， 说明base可能没有变过\n                    if ((ss >= 0 || (ss == (ss = w.scanState))) &&\n                        oldSum == (oldSum = checkSum)) {\n                        if (ss < 0 || w.qlock < 0)    // already inactive\n                            break;\n                        int ns = ss | INACTIVE;       // try to inactivate\n                        long nc = ((SP_MASK & ns) |\n                                   (UC_MASK & ((c = ctl) - AC_UNIT)));\n                        // 维护 队列的 stack，可以指向前一个栈顶的队列\n                        w.stackPred = (int)c;         // hold prev stack top\n                        U.putInt(w, QSCANSTATE, ns);\n                        if (U.compareAndSwapLong(this, CTL, c, nc))\n                            ss = ns;\n                        else\n                            w.scanState = ss;         // back out\n                    }\n                    checkSum = 0;\n                }\n            }\n        }\n        return null;\n    }\n```\n\n###### 2.4.1.7 signalWork\n\n```java\nfinal void signalWork(WorkQueue[] ws, WorkQueue q) {\n        long c; int sp, i; WorkQueue v; Thread p;\n        // AC是负数，所以 active worker不足\n        while ((c = ctl) < 0L) {                       // too few active\n            // sp:第一位是0，没有版本号，没有inactive的worker\n            if ((sp = (int)c) == 0) {                  // no idle workers\n                //tc: tc不为0，就是代表 total worker - parallelism < 0, 所以需要添加worker\n                if ((c & ADD_WORKER) != 0L)            // too few workers\n                    tryAddWorker(c);\n                break;\n            }\n            if (ws == null)                            // unstarted/terminated\n                break;\n            // 取栈顶的worker，如果下标已经越界或queue为null，线程池都是终止了\n            if (ws.length <= (i = sp & SMASK))         // terminated\n                break;\n            if ((v = ws[i]) == null)                   // terminating\n                break;\n            // 新的scanState，版本+1，设置状态为激活，INACTIVE = 1 << 31，~INACTIVE = 01111111....\n            int vs = (sp + SS_SEQ) & ~INACTIVE;        // next scanState\n            // 确认 worker的 sp没有变化\n            int d = sp - v.scanState;                  // screen CAS\n            // 生成新的 ctl，(UC_MASK & (c + AC_UNIT))设置 高32位， (SP_MASK & v.stackPred)设置低32位\n            long nc = (UC_MASK & (c + AC_UNIT)) | (SP_MASK & v.stackPred);\n            if (d == 0 && U.compareAndSwapLong(this, CTL, c, nc)) {\n                //激活worker\n                v.scanState = vs;                      // activate v\n                if ((p = v.parker) != null)\n                    U.unpark(p);\n                break;\n            }\n            //当前queue没有task 需要执行了，则停止signal\n            if (q != null && q.base == q.top)          // no more work\n                break;\n        }\n    }\n```\n\n###### 2.4.1.8 ForkJoinTask的fork方法实现原理\n\n当我们调用ForkJoinTask的fork方法时，程序会把任务放在ForkJoinWorkerThread的pushTask的workQueue中，异步地执行这个任务，然后立即返回结果，代码如下：\n\n```java\npublic final ForkJoinTask<V> fork() {\n    Thread t;\n    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n        ((ForkJoinWorkerThread)t).workQueue.push(this);\n    else\n        ForkJoinPool.common.externalPush(this);\n    return this;\n}\n```\n\n若当前线程是ForkJoinWorkerThread线程，则强制类型转换（向下转换）成ForkJoinWorkerThread，然后将任务push到这个线程负责的队列里面去，在ForkJoinWorkerThread类中有一个pool和一个workQueue字段：\n\n```java\n// 线程工作的ForkJoinPool\nfinal ForkJoinPool pool;                // the pool this thread works in\n// 工作窃取队列\nfinal ForkJoinPool.WorkQueue workQueue; // work-stealing mechanics\n```\n\npushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：\n\n```java\nfinal void push(ForkJoinTask<?> task) {\n    ForkJoinTask<?>[] a; ForkJoinPool p;\n    int b = base, s = top, n;\n    if ((a = array) != null) {    // ignore if queue removed\n        int m = a.length - 1;     // fenced write for task visibility\n        U.putOrderedObject(a, ((m & s) << ASHIFT) + ABASE, task);\n        U.putOrderedInt(this, QTOP, s + 1);\n        if ((n = s - b) <= 1) {\n            if ((p = pool) != null)\n                p.signalWork(p.workQueues, this);\n        }\n        else if (n >= m)\n            growArray();\n    }\n}\n```\n\n该方法的主要功能就是将当前任务存放在ForkJoinTask数组array里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。\n\n###### 2.4.1.9 ForkJoinTask的join方法实现原理\n\n```java\npublic final V join() {\n    int s;\n    if ((s = doJoin() & DONE_MASK) != NORMAL)\n        reportException(s);\n    return getRawResult();\n}\n```\n\n　　首先，它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有四种：已完成（NORMAL），被取消（CANCELLED），信号（SIGNAL）和出现异常（EXCEPTIONAL）：　　\n\n　　若状态不是NORMAL，则通过reportException(int)方法来处理状态：\n\n```java\nprivate void reportException(int s) {\n    if (s == CANCELLED)\n        throw new CancellationException();\n    if (s == EXCEPTIONAL)\n        rethrow(getThrowableException());\n}\n```\n\n\n\n- 如果任务状态是已完成，则直接返回任务结果。\n- 如果任务状态是被取消，则直接抛出CancellationException。\n- 如果任务状态是抛出异常，则直接抛出对应的异常。\n\n　　doJoin()方法的实现代码：\n\n```java\nprivate int doJoin() {\n    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;\n    return (s = status) < 0 ? s :\n        ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n        (w = (wt = (ForkJoinWorkerThread)t).workQueue).\n        tryUnpush(this) && (s = doExec()) < 0 ? s :\n        wt.pool.awaitJoin(w, this, 0L) :\n        externalAwaitDone();\n}\n```\n\n\n\n　　在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完了，如果执行完了，则直接返回任务状态，如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成了，则设置任务状态为NORMAL，如果出现异常，则纪录异常，并将任务状态设置为EXCEPTIONAL。\n\n　　执行任务是通过doExec()方法来完成的：\n\n```java\nfinal int doExec() {\n    int s; boolean completed;\n    if ((s = status) >= 0) {\n        try {\n            completed = exec();\n        } catch (Throwable rex) {\n            return setExceptionalCompletion(rex);\n        }\n        if (completed)\n            s = setCompletion(NORMAL);\n    }\n    return s;\n}\n```\n\n真正的执行过程是由exec()方法来完成的：\n\n```java\nprotected abstract boolean exec();\n```\n\n这就是我们需要重写的方法，若是我们的任务继承自RecursiveAction，则我们需要重写RecursiveAction的compute()方法：\n\n```java\npublic abstract class RecursiveAction extends ForkJoinTask<Void> {\n    private static final long serialVersionUID = 5232453952276485070L;\n \n    /**\n     * The main computation performed by this task.\n     */\n    protected abstract void compute();\n \n    /**\n     * Always returns {@code null}.\n     *\n     * @return {@code null} always\n     */\n    public final Void getRawResult() { return null; }\n \n    /**\n     * Requires null completion value.\n     */\n    protected final void setRawResult(Void mustBeNull) { }\n \n    /**\n     * Implements execution conventions for RecursiveActions.\n     */\n    protected final boolean exec() {\n        compute();\n        return true;\n    }\n}\n```\n\n若是我们的任务继承自RecursiveTask，则我们同样需要重写RecursiveTask的compute()方法：\n\n```java\npublic abstract class RecursiveTask<V> extends ForkJoinTask<V> {\n    private static final long serialVersionUID = 5232453952276485270L;\n \n    /**\n     * The result of the computation.\n     */\n    V result;\n \n    /**\n     * The main computation performed by this task.\n     * @return the result of the computation\n     */\n    protected abstract V compute();\n \n    public final V getRawResult() {\n        return result;\n    }\n \n    protected final void setRawResult(V value) {\n        result = value;\n    }\n \n    /**\n     * Implements execution conventions for RecursiveTask.\n     */\n    protected final boolean exec() {\n        result = compute();\n        return true;\n    }\n}\n```\n\n通过上面的分析可知，执行我们的业务代码是在调用了join()之后的，也就是说，fork仅仅是分割任务，只有当我们执行join的时候，我们的任务才会被执行。\n\n##### 2.4.2 异常处理\n\nForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码：\n\n```java\nif(task.isCompletedAbnormally()){\n    System.out.println(task.getException());\n}\n```\n\ngetException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。\n\n```java\npublic final Throwable getException() {\n        int s = status & DONE_MASK;\n        return ((s >= NORMAL)    ? null :\n                (s == CANCELLED) ? new CancellationException() :\n                getThrowableException());\n}\n```\n\n\n\n##### 2.4.2forkjoin 的使用\n\n　ForkJoinPool 使用submit 或 invoke 提交的区别：invoke是同步执行，调用之后需要等待任务完成，才能执行后面的代码；submit是异步执行，只有在Future调用get的时候会阻塞。\n\n　　这里继承的是RecursiveTask 适用于有返回值的场景；还可以继承RecursiveAction，适合于没有返回值的场景\n\n　　执行子任务调用fork方法并不是最佳的选择，最佳的选择是invokeAll方法。\n\n##### 2.4.3 示例代码\n\n   这个示例是在做某支付任务异步解耦后的业务逻辑校验，这个是一个接收返回的任务 `RecursiveTask`：\n\n```java\nclass CheckTask extends RecursiveTask<Integer> {\n\t\t/**\n\t\t*  这个是阈值，具体任务列表拆分到什么程度再开始执行\n\t\t**/\n        private int threshold = 10;\n\n    \t/**\n    \t*\t这个是当前处理的集合列表\n    \t**/\n        private List<CbVaPaymentFileContent> list;\n\n        /**\n        * 初始化任务对象\n        **/\n        private CheckTask(int threshold, List<CbVaPaymentFileContent> list) {\n            if (null == list) throw new IllegalArgumentException(\"[list] is null.\");\n            this.threshold = threshold <= 0 ? this.threshold : threshold;\n//            this.threshold = list.size() / Runtime.getRuntime().availableProcessors();\n            this.list = list;\n        }\n\n        @Override\n        protected Integer compute() {\n            if (list.size() <= threshold) {\n                // 处理\n                int count = 0;\n                for (CbVaPaymentFileContent content : list) {\n                    count += process(content);\n                }\n                return count;\n            } else {\n                // 分解\n                int middle = list.size() / 2;\n                List<CbVaPaymentFileContent> leftList = list.subList(0, middle);\n                List<CbVaPaymentFileContent> rightList = list.subList(middle, list.size());\n                CheckTask left = new CheckTask(threshold, leftList);\n                CheckTask right = new CheckTask(threshold, rightList);\n                // left.fork();\n                // right.fork();\n                \n                // 这两个方法，使用invokeAll方法的主要原因是为了充分利用线程池，在invokeAll的N个任务中，其中N-1个任务会使用fork()交给其它线程执行，但是，它还会留一个任务自己执行，这样，就充分利用了线程池，保证没有空闲的不干活的线程。\n                invokeAll(left, right);\n\n                // 结合\n                return left.join() + right.join();\n            }\n        }\n\n    }\n```\n\n　　该代码就是通过Fork/Join框架来计算数组的和，计算耗时4031毫秒。通过该代码作为应用示例主要是为了告诉大家，使用Fork/Join模型的正确方式，在源代码中可以看到，SumTask继承自RecursiveTask，重写的compute方法为：\n\n　　compute()方法使用了invokeAll方法来分解任务，而不是它下面的subtask1.fork();\n\n　　这两个方法，使用invokeAll方法的主要原因是为了充分利用线程池，在invokeAll的N个任务中，其中N-1个任务会使用fork()交给其它线程执行，但是，它还会留一个任务自己执行，这样，就充分利用了线程池，保证没有空闲的不干活的线程。\n\n　　若是采用另外一种方式来运行，程序的运行时间为6028毫秒，可以看到，明显比invokeAll方式慢了很多。\n\n##### 2.4.3 JDK8中的最佳实践\n\n##### 2.4.3.1 通过forkjoin来看parallelStream\n\n在Java 8引入了自动并行化的概念。它能够让一部分Java代码自动地以并行的方式执行，即使用了ForkJoinPool的ParallelStream。　　\n\n　　Java 8为ForkJoinPool添加了一个通用线程池，这个线程池用来处理那些没有被显式提交到任何线程池的任务。它是ForkJoinPool类型上的一个静态元素，它拥有的默认线程数量等于运行计算机上的处理器数量。当调用Arrays类上添加的新方法时，自动并行化就会发生。比如用来排序一个数组的并行快速排序，用来对一个数组中的元素进行并行遍历。自动并行化也被运用在Java 8新添加的Stream API中。\n\n　　一般ForkJoinPool中的通用线程池处理，也可以使用ThreadPoolExecutor完成，但是就代码的可读性和代码量而言，使用ForkJoinPool明显更胜一筹。\n\n##### 2.4.3.2 线程池数量\n\n​\t**1、系统CPU数量：[如机器8核，即8]**\n\n```\nRuntime.getRuntime().availableProcessors()\n```\n\n　　**2、parallelStream默认的并发线程数:【parallelStream核心使用ForkJoinPool实现，故如下】【输出是7个】**\n\n```\nForkJoinPool.getCommonPoolParallelism()\n```\n\n　　**3、为什么parallelStream默认的并发线程数要比CPU处理器的数量少1个？**\n\n　　　　因为最优的策略是每个CPU处理器分配一个线程，然而主线程也算一个线程，所以要占一个名额。如果只有1个CPU，默认的并发线程数就是1\n\n　　**4、修改默认并发数**\n\n　　　　默认的并发线程数不可以反复修改。因为`java.util.concurrent.ForkJoinPool.common.parallelism`是`final`类型的，整个JVM中只允许设置一次。多次修改以第一次为主\n\n　　　　1、系统property\n\n```\n        System.setProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\", \"20\");\n        System.out.println(ForkJoinPool.getCommonPoolParallelism());\n```\n\n　　　　2、当然上述参数也可以通过jvm设置系统属性：-Djava.util.concurrent.ForkJoinPool.common.parallelism=N （N为线程数量）　　\n\n　　**5、既然默认的并发线程数不能反复修改，进行不同线程数量的并发测试，可以引入`ForkJoinPool`。用法如下**：\n\n```\n    @Test\n    public void testSetParallelMutli() throws ExecutionException, InterruptedException {\n        int[] threadCountArr = {2, 4, 6};\n        List<Integer> para = new ArrayList<>();\n        for (int i = 0; i < 7; i++) {\n            para.add(i);\n\n        }\n        for (int threadCount : threadCountArr) {\n            new ForkJoinPool(threadCount).submit(() -> {//多线程任务\n                System.out.println(Thread.currentThread().getName());\n            }).get();\n        }\n    }\n```\n\n　　　　使用get 是为了阻塞 得到结果；如果主线程没有关闭的情况下可以不用get\n\n\n\n##### 2.4.3.2 测试示例\n\n**实际应用示例**\n\n```java\nlogger.info(\"[消息补偿任务-并行执行]开始，本次预处理总数为[{}]\", list.size());\n\n// 手动扩容下,当然这个综合考虑使用\nSystem.setProperty(DEFAULT_FORK_JOIN_PARALLELISM, (Runtime.getRuntime().availableProcessors() * appConfig.getMutiple()) + \"\");\n\n/**\n * 拆分任务到JobSender\n *  {@link Stream#reduce(Object, BiFunction, BinaryOperator)}\n *  <p>\n *      reduce.Object --> 初始值，只是为了来初始化参数类型\n *      reduce.BiFunction.apply(T t, U u) -->  t表示当前值， u表示当前操作对象\n *      reduce.BinaryOperator(T t, U u) --> t=u=初始值类型，用来合并结果的\n *  </p>\n */\nint total = list.parallelStream().filter(op -> lockAdaptor.lock(op.getId(), LockAdaptor.DEFAULT_TIMEOUT)).reduce(0, (cur, channel) -> {\n    // 构建发送器 + 并处理\n    int ava;\n    try {\n        ava = (jobSenderFactory.getSender(channel).process().dealSuccess() ? 1 : 0);\n    } finally {\n        // 解锁\n        lockAdaptor.unlock(channel.getId());\n    }\n    return cur + ava;\n}, (a, b) -> a + b);\nlogger.info(\"[消息补偿任务-并行执行]结束，本次预处理总数为[{}]， 成功总数[{}], 未成功总数[{}]\", list.size(), total, list.size() - total);\n```\n\n1、测试一、8核机器，每个任务均耗时2秒，一共16个任务\n\n```\n    @Test\n    public void testSetParallelMutli2() throws ExecutionException, InterruptedException {\n        List<Integer> para = new ArrayList<>();\n        for (int i = 0; i < 16; i++) {\n            para.add(i);\n\n        }\n        para.parallelStream().forEach(i -> {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(LocalDateTime.now() + \"||\" + Thread.currentThread().getName() + \":\" + i);\n        });\n    }\n```\n\n　　输出\n\n```\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-1:5\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-6:1\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-2:14\n2019-09-13T10:51:04.344||main:10\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-4:13\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-3:2\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-7:4\n2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-5:7\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-4:3\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-6:0\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-1:12\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-2:15\n2019-09-13T10:51:06.350||main:11\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-5:8\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-3:6\n2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-7:9\n```\n\n　　结论：会有7个 ForkJoinPool.commonPool-worker 线程和1个主线程main一起执行任务。并且8个一组一组执行，每个线程执行了两个任务。\n\n2、测试二、8核机器，每个任务耗时2秒内随机，一共16个任务 \n\n```\n    @Test\n    public void testSetParallelMutli2() throws ExecutionException, InterruptedException {\n        List<Integer> para = new ArrayList<>();\n        for (int i = 0; i < 16; i++) {\n            para.add(i);\n\n        }\n        para.parallelStream().forEach(i -> {\n            try {\n//                Thread.sleep(2000);\n                Thread.sleep(new Random().nextInt(2000));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(LocalDateTime.now() + \"||\" + Thread.currentThread().getName() + \":\" + i);\n        });\n    }\n```\n\n输出\n\n```\n2019-09-13T10:54:01.486||ForkJoinPool.commonPool-worker-5:7\n2019-09-13T10:54:01.751||main:10\n2019-09-13T10:54:01.774||main:11\n2019-09-13T10:54:01.862||ForkJoinPool.commonPool-worker-5:6\n2019-09-13T10:54:02.203||ForkJoinPool.commonPool-worker-5:15\n2019-09-13T10:54:02.285||ForkJoinPool.commonPool-worker-6:1\n2019-09-13T10:54:02.407||ForkJoinPool.commonPool-worker-6:0\n2019-09-13T10:54:02.479||ForkJoinPool.commonPool-worker-1:5\n2019-09-13T10:54:02.496||ForkJoinPool.commonPool-worker-2:14\n2019-09-13T10:54:02.518||ForkJoinPool.commonPool-worker-4:13\n2019-09-13T10:54:02.732||main:9\n2019-09-13T10:54:02.740||ForkJoinPool.commonPool-worker-7:4\n2019-09-13T10:54:02.791||ForkJoinPool.commonPool-worker-3:2\n2019-09-13T10:54:03.178||ForkJoinPool.commonPool-worker-5:12\n2019-09-13T10:54:03.743||ForkJoinPool.commonPool-worker-1:8\n2019-09-13T10:54:04.003||ForkJoinPool.commonPool-worker-6:3\n```\n\n　　结论：会有7个 ForkJoinPool.commonPool-worker 线程和1个主线程main一起执行任务。并且是强占式【工作窃取法】的执行任务：如上线程5、主线程执行了各3个任务，其他有2个或一个的。\n\n3、示例三、接收消息队列消息，每次消息个数n个，每个消息是一个100个的list<String>,接收时候使用parallelStream消费并发处理\n\n发送消息\n\n```\n    @Test\n    public void testMq() throws Exception {\n        for (int j = 0; j < 1; j++) {\n            List<String> list = Lists.newArrayList();\n            for (int i = 0; i < 100; i++) {\n                list.add(j+\"___________\"+i);\n            }\n            producerMessageService.sendMessage(\"test_parallel\", UUID.randomUUID().toString(), JSON.toJSONString(list));\n            Thread.sleep(1000);\n        }\n        logger.error(\"=======================================================生产 ok\");\n\n        Thread.sleep(2000000000);\n    }\n```\n\n接收消费\n\n```\n    @Override\n    public void onMessage(List<Message> messages) throws Exception {\n        if (messages == null || messages.isEmpty()) {\n            return;\n        }\n\n        for (int i = 0; i < messages.size(); i++) {\n            Message message = messages.get(i);\n            logger.info(String.format(\"收到一条消息,消息主题（队列名）：%s,内容是：%s\", message.getTopic(), message.getText()));\n\n\n            List<String> strings = JSONArray.parseArray(message.getText(), String.class);\n            strings.parallelStream().forEach(p -> {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                logger.error(LocalDateTime.now() + \"_______________\" + Thread.currentThread().getName() + \":\" + p);\n            });\n        }\n    }\n```\n\n　　说明：\n\n　　　　发送消息，1s后会发送完毕，此时如果有订阅就会出现一条消息积压。\n\n　　　　订阅消息者，订阅后会收到词条消息，此时如果正常执行完毕（不论使用不使用多线程）消息积压就没有了，因为一般消息监听会在方法正常执行完毕后，使用消息Id将此条消息从订阅队列中移除。\n\n　　　　　　接收到1条消息，里面会有一个jsonstring，反序列化为List，大小是100，交给parallelStream处理，此时会有8个线程处理【如果是8核机器】，处理速度大约是2秒8个。其余的92进入workQueue中等待处理。\n\n　　　　　　此时如果程序中断，订阅的消息不会被消费使用，下次重连时，需要做已处理消息的去重。\n\n　　　　　　此时如果有新消息发送过来，也会在积压中，不会被消息消费。\n\n 4、示例四、从a中100个数找出整除5的\n\n```\n    @Test\n    public void testExec() throws ExecutionException, InterruptedException {\n        List<Integer> a = Lists.newArrayList();\n        for (int i = 0; i < 100; i++) {\n            a.add(i);\n        }\n        List<Integer> b = Lists.newArrayList();\n        a.parallelStream().forEach(p -> {\n            try {\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (p % 5 == 0) {\n                b.add(p);\n            }\n        });\n        System.out.println(\"===========\"+b.size());\n        b.forEach(p -> System.out.print(p+\" \"));\n    }\n```\n\n输出：正确应该是20\n\n```\n===========18\n15 90 45 30 25 35 85 75 0 40 5 80 95 20 60 70 50 55 \n```\n\n \n\n对此运行结果不一致，以及会有多线程问题\n\n```\njava.lang.ArrayIndexOutOfBoundsException\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n　　……\n\nCaused by: java.lang.ArrayIndexOutOfBoundsException: 15\n    at java.util.ArrayList.add(ArrayList.java:463)\n    at com.github.bjlhx15.common.thread.juc.collection.jdk8stream.TStreamTest.lambda$testExec$6(TStreamTest.java:118)\n    at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)\n    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382)\n    at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)\n    at java.util.stream.ForEachOps$ForEachTask.compute(ForEachOps.java:291)\n```\n\n \n\n原因：parallelStream 并行执行，多线程异步，可能没有b添加完毕就遍历，ArrayList不是线程安全的\n\n修正：\n\n　　方案一、在遍历前，需全部执行完毕【串行】\n\n　　　　将 parallelStream 改为 stream串行处理【不可取，处理速度慢】\n\n　　方案二、在遍历前，需全部执行完毕\n\n　　　　继承 RecursiveTask或者RecursiveAction写任务　　　　\n\n　　方案三、将ArrayList替换安全集合CopyOnWriteArrayLIst\n\n```\n        List<Integer> b = Lists.newCopyOnWriteArrayList();\n```\n\n　　　　此时运行就会出现正确结果。按理说应该会有结果不准确问题吧。但是没有，个人理解，因为是每次8个同时执行，所以即使最后一次主线程提前结束，也有其他线程在锁着b，所以最后执行b的操作会有等待","slug":"java/thread-forkJoin","published":1,"updated":"2020-05-12T17:11:50.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcbaj7mm007rvgja2nk6etj4","content":"<h2 id=\"JDK1-8-parallelStream-与-fork-join-框架\"><a href=\"#JDK1-8-parallelStream-与-fork-join-框架\" class=\"headerlink\" title=\"JDK1.8 parallelStream 与 fork/join 框架\"></a>JDK1.8 parallelStream 与 fork/join 框架</h2><h3 id=\"一、JDK8开启并行串行流\"><a href=\"#一、JDK8开启并行串行流\" class=\"headerlink\" title=\"一、JDK8开启并行串行流\"></a>一、JDK8开启并行串行流</h3><p>tream是java8中新增加的一个特性,被java猿统称为流.</p>\n<p>　　Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>\n<p>　　Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p>\n<p>　　而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.0</span>-<span class=\"number\">1.4</span> 中的 java.lang.Thread  </span><br><span class=\"line\"><span class=\"number\">5.0</span> 中的 java.util.concurrent  </span><br><span class=\"line\"><span class=\"number\">6.0</span> 中的 Phasers 等  </span><br><span class=\"line\"><span class=\"number\">7.0</span> 中的 Fork/Join 框架  </span><br><span class=\"line\"><span class=\"number\">8.0</span> 中的 Lambda</span><br></pre></td></tr></table></figure>\n\n<p>Stream 的另外一大特点是，数据源本身可以是无限的。</p>\n<h4 id=\"1-1-什么是parallelStream\"><a href=\"#1-1-什么是parallelStream\" class=\"headerlink\" title=\"1.1 什么是parallelStream\"></a>1.1 什么是parallelStream</h4><p>parallelStream其实就是一个并行执行的流.它通过默认的ForkJoinPool,可能提高你的多线程任务的速度.实际是多线程，注意线程安全问题</p>\n<p>　　在从stream和parallelStream方法中进行选择时,我们可以考虑以下几个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　1. 是否需要并行？  </span><br><span class=\"line\">　　2. 任务之间是否是独立的？是否会引起任何竞态条件？  </span><br><span class=\"line\">　　3. 结果是否取决于任务的调用顺序？</span><br></pre></td></tr></table></figure>\n\n<p>　　对于问题1，需要弄清楚要解决的问题是什么，数据量有多大，计算的特点是什么？并不是所有的问题都适合使用并发程序来求解，比如当数据量不大时，顺序执行往往比并行执行更快。毕竟，准备线程池和其它相关资源也是需要时间的。但是，当任务涉及到I/O操作并且任务之间不互相依赖时，那么并行化就是一个不错的选择。通常而言，将这类程序并行化之后，执行速度会提升好几个等级。</p>\n<p>　　对于问题2，如果任务之间是独立的，并且代码中不涉及到对同一个对象的某个状态或者某个变量的更新操作，那么就表明代码是可以被并行化的。</p>\n<p>　　对于问题3，由于在并行环境中任务的执行顺序是不确定的，因此对于依赖于顺序的任务而言，并行化也许不能给出正确的结果。　　</p>\n<p>　　场景：默认值适用的场景是CPU密集型的，而一般的Web项目是IO密集型的（一般的Web项目都是需要跟数据库打交道的，针对数据库的操作主要就都是IO，而对CPU的消耗并不高）。</p>\n<p>　　当不能使用默认值的时候，需要开发人员额外去了解parallelStream的用法，如下：</p>\n<h4 id=\"1-2-parallelStream作用\"><a href=\"#1-2-parallelStream作用\" class=\"headerlink\" title=\"1.2 parallelStream作用\"></a>1.2 parallelStream作用</h4><p>Stream具有平行处理能力，处理的过程会分而治之，也就是将一个大任务切分成多个小任务，这表示每个任务都是一个操作，因此像以下的程式片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class=\"line\">numbers.parallelStream()</span><br><span class=\"line\">       .forEach(out::println);</span><br></pre></td></tr></table></figure>\n\n<p>　　得到的展示顺序不一定会是1、2、3、4、5、6、7、8、9，而可能是任意的顺序，就forEach()这个操作來讲，如果平行处理时，希望最后顺序是按照原来Stream的数据顺序，那可以调用forEachOrdered()。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class=\"line\">numbers.parallelStream()</span><br><span class=\"line\">       .forEachOrdered(out::println);</span><br></pre></td></tr></table></figure>\n\n<p>　　注意:如果forEachOrdered()中间有其他如filter()的中介操作，会试着平行化处理，然后最终forEachOrdered()会以原数据顺序处理，因此，使用forEachOrdered()这类的有序处理,可能会（或完全失去）失去平行化的一些优势，实际上中介操作亦有可能如此，例如sorted()方法。</p>\n<h4 id=\"1-3-开启串行流和并行流：\"><a href=\"#1-3-开启串行流和并行流：\" class=\"headerlink\" title=\"1.3 开启串行流和并行流：\"></a>1.3 开启串行流和并行流：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testStream</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; list = getList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 串行流</span></span><br><span class=\"line\">    list.stream();</span><br><span class=\"line\">    list.stream().sequential();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 并行流</span></span><br><span class=\"line\">    list.stream().parallel();</span><br><span class=\"line\">    list.parallelStream().reduce(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 串行流执行</span></span><br><span class=\"line\">    list.stream().reduce((first, second) -&gt; first+second);/</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 并行流执行</span></span><br><span class=\"line\">    list.parallelStream().reduce((first, second) -&gt; first+second);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-流处理\"><a href=\"#1-2-流处理\" class=\"headerlink\" title=\"1.2 流处理\"></a>1.2 流处理</h4><p>因为比较关心并行流的实现，所以看并行流的代码：</p>\n<p>java.util.stream.ReduceOps.ReduceOp</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReduceOp</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>, <span class=\"title\">S</span> <span class=\"keyword\">extends</span> <span class=\"title\">AccumulatingSink</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>, <span class=\"title\">S</span>&gt;&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">TerminalOp</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StreamShape inputShape;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Create a &#123;<span class=\"doctag\">@code</span> ReduceOp&#125; of the specified stream shape which uses</span></span><br><span class=\"line\"><span class=\"comment\">     * the specified &#123;<span class=\"doctag\">@code</span> Supplier&#125; to create accumulating sinks.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> shape The shape of the stream pipeline</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    ReduceOp(StreamShape shape) &#123;</span><br><span class=\"line\">        inputShape = shape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> S <span class=\"title\">makeSink</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> StreamShape <span class=\"title\">inputShape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inputShape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;P_IN&gt; <span class=\"function\">R <span class=\"title\">evaluateSequential</span><span class=\"params\">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper.wrapAndCopyInto(makeSink(), spliterator).get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;P_IN&gt; <span class=\"function\">R <span class=\"title\">evaluateParallel</span><span class=\"params\">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                     Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里new出了一个 ReduceTask</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ReduceTask&lt;&gt;(<span class=\"keyword\">this</span>, helper, spliterator).invoke().get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>名称上看，这是个task任务（java.util.stream.ReduceOps.ReduceTask），再看下类图：</p>\n<p><img src=\"/images/reduceTask-%E7%B1%BB%E5%9B%BE.png\" alt=\"58929987340\"></p>\n<p>看到类图结构加上熟悉fork/join框架，大概明白了stream的并行流实现了，借助于fork/join</p>\n<h3 id=\"二、Fork-Join-框架\"><a href=\"#二、Fork-Join-框架\" class=\"headerlink\" title=\"二、Fork/Join 框架\"></a>二、Fork/Join 框架</h3><p>Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>\n<p>它同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。</p>\n<p><img src=\"/images/forkjoin_%E4%BB%BB%E5%8A%A1%E6%8B%86%E5%88%86.png\" alt=\"img\"></p>\n<h4 id=\"2-1分治法\"><a href=\"#2-1分治法\" class=\"headerlink\" title=\"2.1分治法\"></a>2.1分治法</h4><p><code>ForkJoinPool</code>主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。</p>\n<p>　　典型的应用比如快速排序算法。这里的要点在于，ForkJoinPool需要使用相对少的线程来处理大量的任务。比如要对1000万个数据进行排序，那么会将这个任务分割成两个500万的排序任务和一个针对这两组500万数据的合并任务。以此类推，对于500万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于10时，会停止分割，转而使用插入排序对它们进行排序。那么到最后，所有的任务加起来会有大概2000000+个。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。</p>\n<p>　　所以当使用ThreadPoolExecutor时，使用分治法会存在问题，因为ThreadPoolExecutor中的线程无法像任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而使用ForkJoinPool时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。</p>\n<p>那么使用ThreadPoolExecutor或者ForkJoinPool，会有什么性能的差异呢？</p>\n<p>　　首先，使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用4个线程来完成超过200万个任务。但是，使用ThreadPoolExecutor时，是不可能完成的，因为ThreadPoolExecutor中的Thread无法选择优先执行子任务，需要完成200万个具有父子关系的任务时，也需要200万个线程，显然这是不可行的。</p>\n<p>​    尝试改变JDK8的工作线程数量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_FORK_JOIN_PARALLELISM = <span class=\"string\">\"java.util.concurrent.ForkJoinPool.common.parallelism\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 设置线程数</span></span><br><span class=\"line\">System.setProperty(DEFAULT_FORK_JOIN_PARALLELISM, (Runtime.getRuntime().availableProcessors() * <span class=\"number\">2</span>) + <span class=\"string\">\"\"</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-工作窃取法\"><a href=\"#2-2-工作窃取法\" class=\"headerlink\" title=\"2.2 工作窃取法\"></a>2.2 工作窃取法</h4><p>　　forkjoin最核心的地方就是利用了现代硬件设备多核,在一个操作时候会有空闲的cpu,那么如何利用好这个空闲的cpu就成了提高性能的关键,而这里我们要提到的工作窃取（work-stealing）算法就是整个forkjion框架的核心理念,工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</p>\n<p>　　那么为什么需要使用工作窃取算法呢？</p>\n<p>　　假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>\n<p>　　工作窃取的运行流程图如下：</p>\n<p><img src=\"/images/forkjoin_%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%EF%BC%88%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%EF%BC%89.png\" alt=\"img\"></p>\n<p>　　工作窃取算法的优点：充分利用线程进行并行计算，并减少了线程间的竞争；</p>\n<p>　　工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>\n<h4 id=\"2-3-Fork-Join-涉及到的关键名称\"><a href=\"#2-3-Fork-Join-涉及到的关键名称\" class=\"headerlink\" title=\"2.3 Fork/Join 涉及到的关键名称\"></a>2.3 Fork/Join 涉及到的关键名称</h4><p>　　<code>ForkJoinPool</code>： 用来执行Task，或生成新的ForkJoinWorkerThread，执行 ForkJoinWorkerThread 间的 work-stealing 逻辑。ForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。</p>\n<p>　　<code>ForkJoinTask</code>： 执行具体的分支逻辑，声明以同步/异步方式进行执行</p>\n<p>　　<code>ForkJoinWorkerThread</code>： 是 ForkJoinPool 内的 worker thread，执行</p>\n<p>　　<code>ForkJoinTask</code>, 内部有 ForkJoinPool.WorkQueue来保存要执行的ForkJoinTask。</p>\n<p>　　<code>ForkJoinPool.WorkQueue</code>：保存要执行的ForkJoinTask。</p>\n<h4 id=\"2-4-Fork-Join框架的实现原理\"><a href=\"#2-4-Fork-Join框架的实现原理\" class=\"headerlink\" title=\"2.4 Fork/Join框架的实现原理\"></a>2.4 Fork/Join框架的实现原理</h4><p>在Java的Fork/Join框架中，它提供了两个类来帮助我们完成任务分割以及执行任务并合并结果：</p>\n<p>　　1、<code>ForkJoinTask</code>：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：</p>\n<p>　　　　<code>RecursiveAction</code>：用于没有返回结果的任务。<br>　　　　<code>RecursiveTask</code> ：用于有返回结果的任务。</p>\n<p>　　2、<code>ForkJoinPool</code> ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p>\n<p>　　<code>ForkJoinPool</code>由<code>ForkJoinTask</code>数组和<code>ForkJoinWorkerThread</code>数组组成，<code>ForkJoinTask</code>数组负责将存放程序提交给<code>ForkJoinPool</code>，而<code>ForkJoinWorkerThread</code>负责执行这些任务。</p>\n<p>基本思想</p>\n<p>　　<code>ForkJoinPool</code> 的每个工作线程都维护着一个工作队列（<code>WorkQueue</code>），这是一个双端队列（<code>Deque</code>），里面存放的对象是任务（<code>ForkJoinTask</code>）。</p>\n<p>　　每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 LIFO（<strong>后进先出</strong>） 方式，也就是说每次从队尾取出任务来执行。</p>\n<p>　　每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。</p>\n<p>　　在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。</p>\n<p>　　在既没有自己的任务，也没有可以窃取的任务时，进入休眠。</p>\n<h5 id=\"2-4-1-ForkJoinPool属性说明、工作队列说明、控制中心说明\"><a href=\"#2-4-1-ForkJoinPool属性说明、工作队列说明、控制中心说明\" class=\"headerlink\" title=\"2.4.1 ForkJoinPool属性说明、工作队列说明、控制中心说明\"></a>2.4.1 ForkJoinPool属性说明、工作队列说明、控制中心说明</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Instance fields</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> ctl;                   <span class=\"comment\">// 控制中心：非常重要，看下图解析</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> runState;               <span class=\"comment\">// 负数是shutdown，其余都是2的次方</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> config;                    <span class=\"comment\">// 配置：二进制的低16位代表 并行度（parallelism），</span></span><br><span class=\"line\">                                                                                    <span class=\"comment\">//高16位：mode可选FIFO_QUEUE（1 &lt;&lt; 16）和LIFO_QUEUE（1 &lt;&lt; 31），默认是LIFO_QUEUE</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> indexSeed;                       <span class=\"comment\">// 生成worker的queue索引</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> WorkQueue[] workQueues;     <span class=\"comment\">// main registry</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ForkJoinWorkerThreadFactory factory;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> UncaughtExceptionHandler ueh;  <span class=\"comment\">// per-worker UEH</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String workerNamePrefix;       <span class=\"comment\">// to create worker name string</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> AtomicLong stealCounter;    <span class=\"comment\">// also used as sync monitor</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"2-4-1-1-工作队列workQueues\"><a href=\"#2-4-1-1-工作队列workQueues\" class=\"headerlink\" title=\"2.4.1.1 工作队列workQueues\"></a>2.4.1.1 工作队列workQueues</h6><p>用于保存向ForkJoinPool提交的任务，而具体的执行由ForkJoinWorkerThread执行，而ForkJoinWorkerThreadFactory可以用于生产出ForkJoinWorkerThread：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * Returns a new worker thread operating in the given pool.</span></span><br><span class=\"line\"><span class=\"comment\">        *</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> pool the pool this thread works in</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@return</span> the new worker thread</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@throws</span> NullPointerException if the pool is null</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ForkJoinWorkerThread <span class=\"title\">newThread</span><span class=\"params\">(ForkJoinPool pool)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/292888-20190913110608100-591376294.png\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Instance fields</span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> scanState;    <span class=\"comment\">// 负数：inactive, 非负数：active, 其中奇数代表scanning</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> stackPred;             <span class=\"comment\">// sp = (int)ctl, 前一个队列栈的标示信息，包含版本号、是否激活、以及队列索引</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> nsteals;               <span class=\"comment\">// 窃取的任务数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> hint;                  <span class=\"comment\">// 一个随机数，用来帮助任务窃取，在 helpXXXX()的方法中会用到</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> config;                <span class=\"comment\">// 配置：二进制的低16位代表 在 queue[] 中的索引，</span></span><br><span class=\"line\"><span class=\"comment\">// 高16位：mode可选FIFO_QUEUE（1 &lt;&lt; 16）和LIFO_QUEUE（1 &lt;&lt; 31），默认是LIFO_QUEUE</span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> qlock;        <span class=\"comment\">// 锁定标示位：1: locked, &lt; 0: terminate; else 0</span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> base;         <span class=\"comment\">// index of next slot for poll</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> top;                   <span class=\"comment\">// index of next slot for push</span></span><br><span class=\"line\">ForkJoinTask&lt;?&gt;[] array;   <span class=\"comment\">// 任务列表</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-4-1-2-控制中心ctl\"><a href=\"#2-4-1-2-控制中心ctl\" class=\"headerlink\" title=\"2.4.1.2 控制中心ctl\"></a>2.4.1.2 控制中心ctl</h6><p><img src=\"/images/292888-20190913111130827-1005682912.png\" alt=\"img\"></p>\n<h6 id=\"2-4-1-3-方法说明\"><a href=\"#2-4-1-3-方法说明\" class=\"headerlink\" title=\"2.4.1.3 方法说明\"></a>2.4.1.3 方法说明</h6><p>队列与关键任务调用说明</p>\n<p><img src=\"/images/292888-20190913110836624-260052587.png\" alt=\"img\"></p>\n<p>2.4.1.4 externalPush || externalSubmit</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">externalPush</span><span class=\"params\">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class=\"line\">        WorkQueue[] ws; WorkQueue q; <span class=\"keyword\">int</span> m;</span><br><span class=\"line\">        <span class=\"comment\">//我们以前常用的Random，在并发下，多个线程同时计算种子需要用到同一个原子变量。</span></span><br><span class=\"line\">        <span class=\"comment\">//由于更新操作使用CAS，同时执行只有一个线程成功，其他线程的大量自旋造成性能损失，ThreadLocalRandom继承Random，对此进行了改进。</span></span><br><span class=\"line\">                <span class=\"comment\">//ThreadLocalRandom运用了ThreadLocal，每个线程内部维护一个种子变量，多线程下计算新种子时使用线程自己的种子变量进行更新，避免了竞争。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runState;</span><br><span class=\"line\">        <span class=\"comment\">// 外部提交的task，肯定会到偶数位下标的队列上</span></span><br><span class=\"line\">        <span class=\"comment\">// SQMASK = 0x007e = 1111110，任何数和 SQMASK 进行 &amp; 运算 都会是偶数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((ws = workQueues) != <span class=\"keyword\">null</span> &amp;&amp; (m = (ws.length - <span class=\"number\">1</span>)) &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (q = ws[m &amp; r &amp; SQMASK]) != <span class=\"keyword\">null</span> &amp;&amp; r != <span class=\"number\">0</span> &amp;&amp; rs &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            <span class=\"comment\">//队列上锁</span></span><br><span class=\"line\">            U.compareAndSwapInt(q, QLOCK, <span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            ForkJoinTask&lt;?&gt;[] a; <span class=\"keyword\">int</span> am, n, s;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((a = q.array) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                (am = a.length - <span class=\"number\">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class=\"line\">                <span class=\"comment\">//把 task 放到队列的 top端</span></span><br><span class=\"line\">                U.putOrderedObject(a, j, task);</span><br><span class=\"line\">                U.putOrderedInt(q, QTOP, s + <span class=\"number\">1</span>);</span><br><span class=\"line\">                U.putIntVolatile(q, QLOCK, <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">                    signalWork(ws, q);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//队列解锁</span></span><br><span class=\"line\">            U.compareAndSwapInt(q, QLOCK, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        externalSubmit(task);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-4-1-5-registerWorker\"><a href=\"#2-4-1-5-registerWorker\" class=\"headerlink\" title=\"2.4.1.5 registerWorker\"></a>2.4.1.5 registerWorker</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> WorkQueue <span class=\"title\">registerWorker</span><span class=\"params\">(ForkJoinWorkerThread wt)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//......</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((ws = workQueues) != <span class=\"keyword\">null</span> &amp;&amp; (n = ws.length) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> s = indexSeed += SEED_INCREMENT;  <span class=\"comment\">// unlikely to collide</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> m = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// worker的queue肯定放在pool中的queue[]中的奇数下标</span></span><br><span class=\"line\">                  <span class=\"comment\">// m = ws.lenght - 1, ws.lenght 肯定是偶数，则m 肯定是奇数</span></span><br><span class=\"line\">                <span class=\"comment\">// 1的二进制位：00000001, 所以任何数 \"|\" 1 都是奇数</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以 奇数 &amp; 奇数 ， 1&amp;1 = 1，所以i肯定是奇数</span></span><br><span class=\"line\">                i = ((s &lt;&lt; <span class=\"number\">1</span>) | <span class=\"number\">1</span>) &amp; m;               <span class=\"comment\">// odd-numbered indices</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ws[i] != <span class=\"keyword\">null</span>) &#123;                  <span class=\"comment\">// collision</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> probes = <span class=\"number\">0</span>;                   <span class=\"comment\">// step by approx half n</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> step = (n &lt;= <span class=\"number\">4</span>) ? <span class=\"number\">2</span> : ((n &gt;&gt;&gt; <span class=\"number\">1</span>) &amp; EVENMASK) + <span class=\"number\">2</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果下标已经有队列，则重新生成奇数下标</span></span><br><span class=\"line\">                    <span class=\"comment\">// step肯定为偶数：EVENMASK：0xfffe：1111111111111110</span></span><br><span class=\"line\">                      <span class=\"comment\">// 所以 奇数+偶数，奇偶性不变</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (ws[i = (i + step) &amp; m] != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (++probes &gt;= n) &#123;</span><br><span class=\"line\">                            workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class=\"number\">1</span>);</span><br><span class=\"line\">                            m = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">                            probes = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"comment\">//......</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"2-4-1-6-scan\"><a href=\"#2-4-1-6-scan\" class=\"headerlink\" title=\"2.4.1.6 scan\"></a>2.4.1.6 scan</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class=\"keyword\">int</span> r) &#123;</span><br><span class=\"line\">        WorkQueue[] ws; <span class=\"keyword\">int</span> m;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((ws = workQueues) != <span class=\"keyword\">null</span> &amp;&amp; (m = ws.length - <span class=\"number\">1</span>) &gt; <span class=\"number\">0</span> &amp;&amp; w != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ss = w.scanState;                     <span class=\"comment\">// initially non-negative</span></span><br><span class=\"line\">               <span class=\"comment\">// k = r &amp; m 。 r是一个随机数，m 是 队列数组长度 - 1；用于定位去哪个 队列 窃取 task</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> origin = r &amp; m, k = origin, oldSum = <span class=\"number\">0</span>, checkSum = <span class=\"number\">0</span>;;) &#123;</span><br><span class=\"line\">                WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> b, n; <span class=\"keyword\">long</span> c;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((q = ws[k]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                      <span class=\"comment\">// 如果有还没执行的task，尝试窃取队列q 中的base下标的 task。 即FIFO</span></span><br><span class=\"line\">                    <span class=\"comment\">// i: 在内存中，b下标对应的对象的偏移值。 a.length - 1 的二进制位 永远是 0[1...]s，所以 (a.length - 1) &amp; b = b，主要是保证了b不会越界</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((n = (b = q.base) - q.top) &lt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                        (a = q.array) != <span class=\"keyword\">null</span>) &#123;      <span class=\"comment\">// non-empty</span></span><br><span class=\"line\">                        <span class=\"keyword\">long</span> i = (((a.length - <span class=\"number\">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class=\"line\">                                  U.getObjectVolatile(a, i))) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                            q.base == b) &#123;</span><br><span class=\"line\">                               <span class=\"comment\">// ss 是小偷的 scanState，大于0代表当前的worker是激活的</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (ss &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                  <span class=\"comment\">// 把 task 从 队列中取出来，然后队列的base+1，如果被窃取的队列中有多于1个的task，则尝试唤醒其他的worker</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (U.compareAndSwapObject(a, i, t, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                                    q.base = b + <span class=\"number\">1</span>;</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (n &lt; -<span class=\"number\">1</span>)       <span class=\"comment\">// signal others</span></span><br><span class=\"line\">                                        signalWork(ws, q);</span><br><span class=\"line\">                                    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                              <span class=\"comment\">// ss小于0代表当前的worker是未激活的，并且当前是第一次扫描，这时候尝试激活worker</span></span><br><span class=\"line\">                            <span class=\"comment\">// oldSum: 上一次遍历周期的 base 值的和。</span></span><br><span class=\"line\">                            <span class=\"comment\">// (int) c : 可以拿到当前栈顶的空闲worker。sp = (int) c</span></span><br><span class=\"line\">                            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldSum == <span class=\"number\">0</span> &amp;&amp;   <span class=\"comment\">// try to activate</span></span><br><span class=\"line\">                                     w.scanState &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                                tryRelease(c = ctl, ws[m &amp; (<span class=\"keyword\">int</span>)c], AC_UNIT);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (ss &lt; <span class=\"number\">0</span>)                   <span class=\"comment\">// refresh</span></span><br><span class=\"line\">                            ss = w.scanState;</span><br><span class=\"line\">                        <span class=\"comment\">// 更新随机值，重新初始化所有控制变量，重新定位队列</span></span><br><span class=\"line\">                        r ^= r &lt;&lt; <span class=\"number\">1</span>; r ^= r &gt;&gt;&gt; <span class=\"number\">3</span>; r ^= r &lt;&lt; <span class=\"number\">10</span>;</span><br><span class=\"line\">                        origin = k = r &amp; m;           <span class=\"comment\">// move and rescan</span></span><br><span class=\"line\">                        oldSum = checkSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    checkSum += b;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 每次没有窃取到task的时候，都会k+1（k值不会超过m），当k遍历了一圈还没有steal到任务，则当前小偷worker是过剩的，则inactive这个小偷worker</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((k = (k + <span class=\"number\">1</span>) &amp; m) == origin) &#123;    <span class=\"comment\">// continue until stable</span></span><br><span class=\"line\">                      <span class=\"comment\">// oldSum == (oldSum = checkSum) 实际上就是 oldSum == checkSum ， oldSum = checkSum</span></span><br><span class=\"line\">                    <span class=\"comment\">// oldSum == checkSum 是判断 这个周期和上个周期 的base和是否一直，如果一直， 说明base可能没有变过</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((ss &gt;= <span class=\"number\">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class=\"line\">                        oldSum == (oldSum = checkSum)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (ss &lt; <span class=\"number\">0</span> || w.qlock &lt; <span class=\"number\">0</span>)    <span class=\"comment\">// already inactive</span></span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> ns = ss | INACTIVE;       <span class=\"comment\">// try to inactivate</span></span><br><span class=\"line\">                        <span class=\"keyword\">long</span> nc = ((SP_MASK &amp; ns) |</span><br><span class=\"line\">                                   (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class=\"line\">                        <span class=\"comment\">// 维护 队列的 stack，可以指向前一个栈顶的队列</span></span><br><span class=\"line\">                        w.stackPred = (<span class=\"keyword\">int</span>)c;         <span class=\"comment\">// hold prev stack top</span></span><br><span class=\"line\">                        U.putInt(w, QSCANSTATE, ns);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (U.compareAndSwapLong(<span class=\"keyword\">this</span>, CTL, c, nc))</span><br><span class=\"line\">                            ss = ns;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            w.scanState = ss;         <span class=\"comment\">// back out</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    checkSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-4-1-7-signalWork\"><a href=\"#2-4-1-7-signalWork\" class=\"headerlink\" title=\"2.4.1.7 signalWork\"></a>2.4.1.7 signalWork</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">signalWork</span><span class=\"params\">(WorkQueue[] ws, WorkQueue q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> c; <span class=\"keyword\">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class=\"line\">        <span class=\"comment\">// AC是负数，所以 active worker不足</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((c = ctl) &lt; <span class=\"number\">0L</span>) &#123;                       <span class=\"comment\">// too few active</span></span><br><span class=\"line\">            <span class=\"comment\">// sp:第一位是0，没有版本号，没有inactive的worker</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((sp = (<span class=\"keyword\">int</span>)c) == <span class=\"number\">0</span>) &#123;                  <span class=\"comment\">// no idle workers</span></span><br><span class=\"line\">                <span class=\"comment\">//tc: tc不为0，就是代表 total worker - parallelism &lt; 0, 所以需要添加worker</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((c &amp; ADD_WORKER) != <span class=\"number\">0L</span>)            <span class=\"comment\">// too few workers</span></span><br><span class=\"line\">                    tryAddWorker(c);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == <span class=\"keyword\">null</span>)                            <span class=\"comment\">// unstarted/terminated</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 取栈顶的worker，如果下标已经越界或queue为null，线程池都是终止了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class=\"comment\">// terminated</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((v = ws[i]) == <span class=\"keyword\">null</span>)                   <span class=\"comment\">// terminating</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 新的scanState，版本+1，设置状态为激活，INACTIVE = 1 &lt;&lt; 31，~INACTIVE = 01111111....</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE;        <span class=\"comment\">// next scanState</span></span><br><span class=\"line\">            <span class=\"comment\">// 确认 worker的 sp没有变化</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> d = sp - v.scanState;                  <span class=\"comment\">// screen CAS</span></span><br><span class=\"line\">            <span class=\"comment\">// 生成新的 ctl，(UC_MASK &amp; (c + AC_UNIT))设置 高32位， (SP_MASK &amp; v.stackPred)设置低32位</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (d == <span class=\"number\">0</span> &amp;&amp; U.compareAndSwapLong(<span class=\"keyword\">this</span>, CTL, c, nc)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//激活worker</span></span><br><span class=\"line\">                v.scanState = vs;                      <span class=\"comment\">// activate v</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((p = v.parker) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    U.unpark(p);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//当前queue没有task 需要执行了，则停止signal</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q != <span class=\"keyword\">null</span> &amp;&amp; q.base == q.top)          <span class=\"comment\">// no more work</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-4-1-8-ForkJoinTask的fork方法实现原理\"><a href=\"#2-4-1-8-ForkJoinTask的fork方法实现原理\" class=\"headerlink\" title=\"2.4.1.8 ForkJoinTask的fork方法实现原理\"></a>2.4.1.8 ForkJoinTask的fork方法实现原理</h6><p>当我们调用ForkJoinTask的fork方法时，程序会把任务放在ForkJoinWorkerThread的pushTask的workQueue中，异步地执行这个任务，然后立即返回结果，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ForkJoinTask&lt;V&gt; <span class=\"title\">fork</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((t = Thread.currentThread()) <span class=\"keyword\">instanceof</span> ForkJoinWorkerThread)</span><br><span class=\"line\">        ((ForkJoinWorkerThread)t).workQueue.push(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        ForkJoinPool.common.externalPush(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>若当前线程是ForkJoinWorkerThread线程，则强制类型转换（向下转换）成ForkJoinWorkerThread，然后将任务push到这个线程负责的队列里面去，在ForkJoinWorkerThread类中有一个pool和一个workQueue字段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程工作的ForkJoinPool</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ForkJoinPool pool;                <span class=\"comment\">// the pool this thread works in</span></span><br><span class=\"line\"><span class=\"comment\">// 工作窃取队列</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ForkJoinPool.WorkQueue workQueue; <span class=\"comment\">// work-stealing mechanics</span></span><br></pre></td></tr></table></figure>\n\n<p>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class=\"line\">    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = base, s = top, n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((a = array) != <span class=\"keyword\">null</span>) &#123;    <span class=\"comment\">// ignore if queue removed</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = a.length - <span class=\"number\">1</span>;     <span class=\"comment\">// fenced write for task visibility</span></span><br><span class=\"line\">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class=\"line\">        U.putOrderedInt(<span class=\"keyword\">this</span>, QTOP, s + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((n = s - b) &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((p = pool) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                p.signalWork(p.workQueues, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &gt;= m)</span><br><span class=\"line\">            growArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该方法的主要功能就是将当前任务存放在ForkJoinTask数组array里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。</p>\n<h6 id=\"2-4-1-9-ForkJoinTask的join方法实现原理\"><a href=\"#2-4-1-9-ForkJoinTask的join方法实现原理\" class=\"headerlink\" title=\"2.4.1.9 ForkJoinTask的join方法实现原理\"></a>2.4.1.9 ForkJoinTask的join方法实现原理</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">join</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class=\"line\">        reportException(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getRawResult();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>　　首先，它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有四种：已完成（NORMAL），被取消（CANCELLED），信号（SIGNAL）和出现异常（EXCEPTIONAL）：　　</p>\n<p>　　若状态不是NORMAL，则通过reportException(int)方法来处理状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">reportException</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == CANCELLED)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CancellationException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == EXCEPTIONAL)</span><br><span class=\"line\">        rethrow(getThrowableException());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>如果任务状态是已完成，则直接返回任务结果。</li>\n<li>如果任务状态是被取消，则直接抛出CancellationException。</li>\n<li>如果任务状态是抛出异常，则直接抛出对应的异常。</li>\n</ul>\n<p>　　doJoin()方法的实现代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">doJoin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (s = status) &lt; <span class=\"number\">0</span> ? s :</span><br><span class=\"line\">        ((t = Thread.currentThread()) <span class=\"keyword\">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class=\"line\">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class=\"line\">        tryUnpush(<span class=\"keyword\">this</span>) &amp;&amp; (s = doExec()) &lt; <span class=\"number\">0</span> ? s :</span><br><span class=\"line\">        wt.pool.awaitJoin(w, <span class=\"keyword\">this</span>, <span class=\"number\">0L</span>) :</span><br><span class=\"line\">        externalAwaitDone();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>　　在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完了，如果执行完了，则直接返回任务状态，如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成了，则设置任务状态为NORMAL，如果出现异常，则纪录异常，并将任务状态设置为EXCEPTIONAL。</p>\n<p>　　执行任务是通过doExec()方法来完成的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">doExec</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s; <span class=\"keyword\">boolean</span> completed;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((s = status) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            completed = exec();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable rex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> setExceptionalCompletion(rex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (completed)</span><br><span class=\"line\">            s = setCompletion(NORMAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>真正的执行过程是由exec()方法来完成的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exec</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>这就是我们需要重写的方法，若是我们的任务继承自RecursiveAction，则我们需要重写RecursiveAction的compute()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecursiveAction</span> <span class=\"keyword\">extends</span> <span class=\"title\">ForkJoinTask</span>&lt;<span class=\"title\">Void</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">5232453952276485070L</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The main computation performed by this task.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">compute</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Always returns &#123;<span class=\"doctag\">@code</span> null&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> null&#125; always</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Void <span class=\"title\">getRawResult</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Requires null completion value.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setRawResult</span><span class=\"params\">(Void mustBeNull)</span> </span>&#123; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Implements execution conventions for RecursiveActions.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exec</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        compute();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>若是我们的任务继承自RecursiveTask，则我们同样需要重写RecursiveTask的compute()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecursiveTask</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ForkJoinTask</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">5232453952276485270L</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The result of the computation.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    V result;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The main computation performed by this task.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the result of the computation</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> V <span class=\"title\">compute</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getRawResult</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setRawResult</span><span class=\"params\">(V value)</span> </span>&#123;</span><br><span class=\"line\">        result = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Implements execution conventions for RecursiveTask.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exec</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        result = compute();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的分析可知，执行我们的业务代码是在调用了join()之后的，也就是说，fork仅仅是分割任务，只有当我们执行join的时候，我们的任务才会被执行。</p>\n<h5 id=\"2-4-2-异常处理\"><a href=\"#2-4-2-异常处理\" class=\"headerlink\" title=\"2.4.2 异常处理\"></a>2.4.2 异常处理</h5><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(task.isCompletedAbnormally())&#123;</span><br><span class=\"line\">    System.out.println(task.getException());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Throwable <span class=\"title\">getException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = status &amp; DONE_MASK;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((s &gt;= NORMAL)    ? <span class=\"keyword\">null</span> :</span><br><span class=\"line\">                (s == CANCELLED) ? <span class=\"keyword\">new</span> CancellationException() :</span><br><span class=\"line\">                getThrowableException());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2-4-2forkjoin-的使用\"><a href=\"#2-4-2forkjoin-的使用\" class=\"headerlink\" title=\"2.4.2forkjoin 的使用\"></a>2.4.2forkjoin 的使用</h5><p>　ForkJoinPool 使用submit 或 invoke 提交的区别：invoke是同步执行，调用之后需要等待任务完成，才能执行后面的代码；submit是异步执行，只有在Future调用get的时候会阻塞。</p>\n<p>　　这里继承的是RecursiveTask 适用于有返回值的场景；还可以继承RecursiveAction，适合于没有返回值的场景</p>\n<p>　　执行子任务调用fork方法并不是最佳的选择，最佳的选择是invokeAll方法。</p>\n<h5 id=\"2-4-3-示例代码\"><a href=\"#2-4-3-示例代码\" class=\"headerlink\" title=\"2.4.3 示例代码\"></a>2.4.3 示例代码</h5><p>   这个示例是在做某支付任务异步解耦后的业务逻辑校验，这个是一个接收返回的任务 <code>RecursiveTask</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CheckTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecursiveTask</span>&lt;<span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t*  这个是阈值，具体任务列表拆分到什么程度再开始执行</span></span><br><span class=\"line\"><span class=\"comment\">\t\t**/</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    \t*\t这个是当前处理的集合列表</span></span><br><span class=\"line\"><span class=\"comment\">    \t**/</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> List&lt;CbVaPaymentFileContent&gt; list;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 初始化任务对象</span></span><br><span class=\"line\"><span class=\"comment\">        **/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">CheckTask</span><span class=\"params\">(<span class=\"keyword\">int</span> threshold, List&lt;CbVaPaymentFileContent&gt; list)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == list) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"[list] is null.\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.threshold = threshold &lt;= <span class=\"number\">0</span> ? <span class=\"keyword\">this</span>.threshold : threshold;</span><br><span class=\"line\"><span class=\"comment\">//            this.threshold = list.size() / Runtime.getRuntime().availableProcessors();</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.list = list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">compute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list.size() &lt;= threshold) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 处理</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (CbVaPaymentFileContent content : list) &#123;</span><br><span class=\"line\">                    count += process(content);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 分解</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> middle = list.size() / <span class=\"number\">2</span>;</span><br><span class=\"line\">                List&lt;CbVaPaymentFileContent&gt; leftList = list.subList(<span class=\"number\">0</span>, middle);</span><br><span class=\"line\">                List&lt;CbVaPaymentFileContent&gt; rightList = list.subList(middle, list.size());</span><br><span class=\"line\">                CheckTask left = <span class=\"keyword\">new</span> CheckTask(threshold, leftList);</span><br><span class=\"line\">                CheckTask right = <span class=\"keyword\">new</span> CheckTask(threshold, rightList);</span><br><span class=\"line\">                <span class=\"comment\">// left.fork();</span></span><br><span class=\"line\">                <span class=\"comment\">// right.fork();</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 这两个方法，使用invokeAll方法的主要原因是为了充分利用线程池，在invokeAll的N个任务中，其中N-1个任务会使用fork()交给其它线程执行，但是，它还会留一个任务自己执行，这样，就充分利用了线程池，保证没有空闲的不干活的线程。</span></span><br><span class=\"line\">                invokeAll(left, right);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 结合</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> left.join() + right.join();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>　　该代码就是通过Fork/Join框架来计算数组的和，计算耗时4031毫秒。通过该代码作为应用示例主要是为了告诉大家，使用Fork/Join模型的正确方式，在源代码中可以看到，SumTask继承自RecursiveTask，重写的compute方法为：</p>\n<p>　　compute()方法使用了invokeAll方法来分解任务，而不是它下面的subtask1.fork();</p>\n<p>　　这两个方法，使用invokeAll方法的主要原因是为了充分利用线程池，在invokeAll的N个任务中，其中N-1个任务会使用fork()交给其它线程执行，但是，它还会留一个任务自己执行，这样，就充分利用了线程池，保证没有空闲的不干活的线程。</p>\n<p>　　若是采用另外一种方式来运行，程序的运行时间为6028毫秒，可以看到，明显比invokeAll方式慢了很多。</p>\n<h5 id=\"2-4-3-JDK8中的最佳实践\"><a href=\"#2-4-3-JDK8中的最佳实践\" class=\"headerlink\" title=\"2.4.3 JDK8中的最佳实践\"></a>2.4.3 JDK8中的最佳实践</h5><h5 id=\"2-4-3-1-通过forkjoin来看parallelStream\"><a href=\"#2-4-3-1-通过forkjoin来看parallelStream\" class=\"headerlink\" title=\"2.4.3.1 通过forkjoin来看parallelStream\"></a>2.4.3.1 通过forkjoin来看parallelStream</h5><p>在Java 8引入了自动并行化的概念。它能够让一部分Java代码自动地以并行的方式执行，即使用了ForkJoinPool的ParallelStream。　　</p>\n<p>　　Java 8为ForkJoinPool添加了一个通用线程池，这个线程池用来处理那些没有被显式提交到任何线程池的任务。它是ForkJoinPool类型上的一个静态元素，它拥有的默认线程数量等于运行计算机上的处理器数量。当调用Arrays类上添加的新方法时，自动并行化就会发生。比如用来排序一个数组的并行快速排序，用来对一个数组中的元素进行并行遍历。自动并行化也被运用在Java 8新添加的Stream API中。</p>\n<p>　　一般ForkJoinPool中的通用线程池处理，也可以使用ThreadPoolExecutor完成，但是就代码的可读性和代码量而言，使用ForkJoinPool明显更胜一筹。</p>\n<h5 id=\"2-4-3-2-线程池数量\"><a href=\"#2-4-3-2-线程池数量\" class=\"headerlink\" title=\"2.4.3.2 线程池数量\"></a>2.4.3.2 线程池数量</h5><p>​    <strong>1、系统CPU数量：[如机器8核，即8]</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure>\n\n<p>　　<strong>2、parallelStream默认的并发线程数:【parallelStream核心使用ForkJoinPool实现，故如下】【输出是7个】</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ForkJoinPool.getCommonPoolParallelism()</span><br></pre></td></tr></table></figure>\n\n<p>　　<strong>3、为什么parallelStream默认的并发线程数要比CPU处理器的数量少1个？</strong></p>\n<p>　　　　因为最优的策略是每个CPU处理器分配一个线程，然而主线程也算一个线程，所以要占一个名额。如果只有1个CPU，默认的并发线程数就是1</p>\n<p>　　<strong>4、修改默认并发数</strong></p>\n<p>　　　　默认的并发线程数不可以反复修改。因为<code>java.util.concurrent.ForkJoinPool.common.parallelism</code>是<code>final</code>类型的，整个JVM中只允许设置一次。多次修改以第一次为主</p>\n<p>　　　　1、系统property</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, &quot;20&quot;);</span><br><span class=\"line\">System.out.println(ForkJoinPool.getCommonPoolParallelism());</span><br></pre></td></tr></table></figure>\n\n<p>　　　　2、当然上述参数也可以通过jvm设置系统属性：-Djava.util.concurrent.ForkJoinPool.common.parallelism=N （N为线程数量）　　</p>\n<p>　　<strong>5、既然默认的并发线程数不能反复修改，进行不同线程数量的并发测试，可以引入<code>ForkJoinPool</code>。用法如下</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testSetParallelMutli() throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">    int[] threadCountArr &#x3D; &#123;2, 4, 6&#125;;</span><br><span class=\"line\">    List&lt;Integer&gt; para &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; 7; i++) &#123;</span><br><span class=\"line\">        para.add(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int threadCount : threadCountArr) &#123;</span><br><span class=\"line\">        new ForkJoinPool(threadCount).submit(() -&gt; &#123;&#x2F;&#x2F;多线程任务</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;).get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>　　　　使用get 是为了阻塞 得到结果；如果主线程没有关闭的情况下可以不用get</p>\n<h5 id=\"2-4-3-2-测试示例\"><a href=\"#2-4-3-2-测试示例\" class=\"headerlink\" title=\"2.4.3.2 测试示例\"></a>2.4.3.2 测试示例</h5><p><strong>实际应用示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logger.info(<span class=\"string\">\"[消息补偿任务-并行执行]开始，本次预处理总数为[&#123;&#125;]\"</span>, list.size());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 手动扩容下,当然这个综合考虑使用</span></span><br><span class=\"line\">System.setProperty(DEFAULT_FORK_JOIN_PARALLELISM, (Runtime.getRuntime().availableProcessors() * appConfig.getMutiple()) + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 拆分任务到JobSender</span></span><br><span class=\"line\"><span class=\"comment\"> *  &#123;<span class=\"doctag\">@link</span> Stream#reduce(Object, BiFunction, BinaryOperator)&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *  &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *      reduce.Object --&gt; 初始值，只是为了来初始化参数类型</span></span><br><span class=\"line\"><span class=\"comment\"> *      reduce.BiFunction.apply(T t, U u) --&gt;  t表示当前值， u表示当前操作对象</span></span><br><span class=\"line\"><span class=\"comment\"> *      reduce.BinaryOperator(T t, U u) --&gt; t=u=初始值类型，用来合并结果的</span></span><br><span class=\"line\"><span class=\"comment\"> *  &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> total = list.parallelStream().filter(op -&gt; lockAdaptor.lock(op.getId(), LockAdaptor.DEFAULT_TIMEOUT)).reduce(<span class=\"number\">0</span>, (cur, channel) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建发送器 + 并处理</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ava;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ava = (jobSenderFactory.getSender(channel).process().dealSuccess() ? <span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">        lockAdaptor.unlock(channel.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur + ava;</span><br><span class=\"line\">&#125;, (a, b) -&gt; a + b);</span><br><span class=\"line\">logger.info(<span class=\"string\">\"[消息补偿任务-并行执行]结束，本次预处理总数为[&#123;&#125;]， 成功总数[&#123;&#125;], 未成功总数[&#123;&#125;]\"</span>, list.size(), total, list.size() - total);</span><br></pre></td></tr></table></figure>\n\n<p>1、测试一、8核机器，每个任务均耗时2秒，一共16个任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testSetParallelMutli2() throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">    List&lt;Integer&gt; para &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; 16; i++) &#123;</span><br><span class=\"line\">        para.add(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    para.parallelStream().forEach(i -&gt; &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(2000);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(LocalDateTime.now() + &quot;||&quot; + Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>　　输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-1:5</span><br><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-6:1</span><br><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-2:14</span><br><span class=\"line\">2019-09-13T10:51:04.344||main:10</span><br><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-4:13</span><br><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-3:2</span><br><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-7:4</span><br><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-5:7</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-4:3</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-6:0</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-1:12</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-2:15</span><br><span class=\"line\">2019-09-13T10:51:06.350||main:11</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-5:8</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-3:6</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-7:9</span><br></pre></td></tr></table></figure>\n\n<p>　　结论：会有7个 ForkJoinPool.commonPool-worker 线程和1个主线程main一起执行任务。并且8个一组一组执行，每个线程执行了两个任务。</p>\n<p>2、测试二、8核机器，每个任务耗时2秒内随机，一共16个任务 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testSetParallelMutli2() throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; para &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i &#x3D; 0; i &lt; 16; i++) &#123;</span><br><span class=\"line\">            para.add(i);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        para.parallelStream().forEach(i -&gt; &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">&#x2F;&#x2F;                Thread.sleep(2000);</span><br><span class=\"line\">                Thread.sleep(new Random().nextInt(2000));</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(LocalDateTime.now() + &quot;||&quot; + Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-09-13T10:54:01.486||ForkJoinPool.commonPool-worker-5:7</span><br><span class=\"line\">2019-09-13T10:54:01.751||main:10</span><br><span class=\"line\">2019-09-13T10:54:01.774||main:11</span><br><span class=\"line\">2019-09-13T10:54:01.862||ForkJoinPool.commonPool-worker-5:6</span><br><span class=\"line\">2019-09-13T10:54:02.203||ForkJoinPool.commonPool-worker-5:15</span><br><span class=\"line\">2019-09-13T10:54:02.285||ForkJoinPool.commonPool-worker-6:1</span><br><span class=\"line\">2019-09-13T10:54:02.407||ForkJoinPool.commonPool-worker-6:0</span><br><span class=\"line\">2019-09-13T10:54:02.479||ForkJoinPool.commonPool-worker-1:5</span><br><span class=\"line\">2019-09-13T10:54:02.496||ForkJoinPool.commonPool-worker-2:14</span><br><span class=\"line\">2019-09-13T10:54:02.518||ForkJoinPool.commonPool-worker-4:13</span><br><span class=\"line\">2019-09-13T10:54:02.732||main:9</span><br><span class=\"line\">2019-09-13T10:54:02.740||ForkJoinPool.commonPool-worker-7:4</span><br><span class=\"line\">2019-09-13T10:54:02.791||ForkJoinPool.commonPool-worker-3:2</span><br><span class=\"line\">2019-09-13T10:54:03.178||ForkJoinPool.commonPool-worker-5:12</span><br><span class=\"line\">2019-09-13T10:54:03.743||ForkJoinPool.commonPool-worker-1:8</span><br><span class=\"line\">2019-09-13T10:54:04.003||ForkJoinPool.commonPool-worker-6:3</span><br></pre></td></tr></table></figure>\n\n<p>　　结论：会有7个 ForkJoinPool.commonPool-worker 线程和1个主线程main一起执行任务。并且是强占式【工作窃取法】的执行任务：如上线程5、主线程执行了各3个任务，其他有2个或一个的。</p>\n<p>3、示例三、接收消息队列消息，每次消息个数n个，每个消息是一个100个的list<String>,接收时候使用parallelStream消费并发处理</p>\n<p>发送消息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testMq() throws Exception &#123;</span><br><span class=\"line\">    for (int j &#x3D; 0; j &lt; 1; j++) &#123;</span><br><span class=\"line\">        List&lt;String&gt; list &#x3D; Lists.newArrayList();</span><br><span class=\"line\">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">            list.add(j+&quot;___________&quot;+i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producerMessageService.sendMessage(&quot;test_parallel&quot;, UUID.randomUUID().toString(), JSON.toJSONString(list));</span><br><span class=\"line\">        Thread.sleep(1000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    logger.error(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;生产 ok&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Thread.sleep(2000000000);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接收消费</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onMessage(List&lt;Message&gt; messages) throws Exception &#123;</span><br><span class=\"line\">    if (messages &#x3D;&#x3D; null || messages.isEmpty()) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; messages.size(); i++) &#123;</span><br><span class=\"line\">        Message message &#x3D; messages.get(i);</span><br><span class=\"line\">        logger.info(String.format(&quot;收到一条消息,消息主题（队列名）：%s,内容是：%s&quot;, message.getTopic(), message.getText()));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; strings &#x3D; JSONArray.parseArray(message.getText(), String.class);</span><br><span class=\"line\">        strings.parallelStream().forEach(p -&gt; &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(2000);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            logger.error(LocalDateTime.now() + &quot;_______________&quot; + Thread.currentThread().getName() + &quot;:&quot; + p);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>　　说明：</p>\n<p>　　　　发送消息，1s后会发送完毕，此时如果有订阅就会出现一条消息积压。</p>\n<p>　　　　订阅消息者，订阅后会收到词条消息，此时如果正常执行完毕（不论使用不使用多线程）消息积压就没有了，因为一般消息监听会在方法正常执行完毕后，使用消息Id将此条消息从订阅队列中移除。</p>\n<p>　　　　　　接收到1条消息，里面会有一个jsonstring，反序列化为List，大小是100，交给parallelStream处理，此时会有8个线程处理【如果是8核机器】，处理速度大约是2秒8个。其余的92进入workQueue中等待处理。</p>\n<p>　　　　　　此时如果程序中断，订阅的消息不会被消费使用，下次重连时，需要做已处理消息的去重。</p>\n<p>　　　　　　此时如果有新消息发送过来，也会在积压中，不会被消息消费。</p>\n<p> 4、示例四、从a中100个数找出整除5的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testExec() throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">    List&lt;Integer&gt; a &#x3D; Lists.newArrayList();</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">        a.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;Integer&gt; b &#x3D; Lists.newArrayList();</span><br><span class=\"line\">    a.parallelStream().forEach(p -&gt; &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(100);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (p % 5 &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">            b.add(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;+b.size());</span><br><span class=\"line\">    b.forEach(p -&gt; System.out.print(p+&quot; &quot;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：正确应该是20</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;18</span><br><span class=\"line\">15 90 45 30 25 35 85 75 0 40 5 80 95 20 60 70 50 55</span><br></pre></td></tr></table></figure>\n\n\n\n<p>对此运行结果不一致，以及会有多线程问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.ArrayIndexOutOfBoundsException</span><br><span class=\"line\">    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class=\"line\">　　……</span><br><span class=\"line\"></span><br><span class=\"line\">Caused by: java.lang.ArrayIndexOutOfBoundsException: 15</span><br><span class=\"line\">    at java.util.ArrayList.add(ArrayList.java:463)</span><br><span class=\"line\">    at com.github.bjlhx15.common.thread.juc.collection.jdk8stream.TStreamTest.lambda$testExec$6(TStreamTest.java:118)</span><br><span class=\"line\">    at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)</span><br><span class=\"line\">    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382)</span><br><span class=\"line\">    at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)</span><br><span class=\"line\">    at java.util.stream.ForEachOps$ForEachTask.compute(ForEachOps.java:291)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>原因：parallelStream 并行执行，多线程异步，可能没有b添加完毕就遍历，ArrayList不是线程安全的</p>\n<p>修正：</p>\n<p>　　方案一、在遍历前，需全部执行完毕【串行】</p>\n<p>　　　　将 parallelStream 改为 stream串行处理【不可取，处理速度慢】</p>\n<p>　　方案二、在遍历前，需全部执行完毕</p>\n<p>　　　　继承 RecursiveTask或者RecursiveAction写任务　　　　</p>\n<p>　　方案三、将ArrayList替换安全集合CopyOnWriteArrayLIst</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; b &#x3D; Lists.newCopyOnWriteArrayList();</span><br></pre></td></tr></table></figure>\n\n<p>　　　　此时运行就会出现正确结果。按理说应该会有结果不准确问题吧。但是没有，个人理解，因为是每次8个同时执行，所以即使最后一次主线程提前结束，也有其他线程在锁着b，所以最后执行b的操作会有等待</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"JDK1-8-parallelStream-与-fork-join-框架\"><a href=\"#JDK1-8-parallelStream-与-fork-join-框架\" class=\"headerlink\" title=\"JDK1.8 parallelStream 与 fork/join 框架\"></a>JDK1.8 parallelStream 与 fork/join 框架</h2><h3 id=\"一、JDK8开启并行串行流\"><a href=\"#一、JDK8开启并行串行流\" class=\"headerlink\" title=\"一、JDK8开启并行串行流\"></a>一、JDK8开启并行串行流</h3><p>tream是java8中新增加的一个特性,被java猿统称为流.</p>\n<p>　　Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>\n<p>　　Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p>\n<p>　　而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.0</span>-<span class=\"number\">1.4</span> 中的 java.lang.Thread  </span><br><span class=\"line\"><span class=\"number\">5.0</span> 中的 java.util.concurrent  </span><br><span class=\"line\"><span class=\"number\">6.0</span> 中的 Phasers 等  </span><br><span class=\"line\"><span class=\"number\">7.0</span> 中的 Fork/Join 框架  </span><br><span class=\"line\"><span class=\"number\">8.0</span> 中的 Lambda</span><br></pre></td></tr></table></figure>\n\n<p>Stream 的另外一大特点是，数据源本身可以是无限的。</p>\n<h4 id=\"1-1-什么是parallelStream\"><a href=\"#1-1-什么是parallelStream\" class=\"headerlink\" title=\"1.1 什么是parallelStream\"></a>1.1 什么是parallelStream</h4><p>parallelStream其实就是一个并行执行的流.它通过默认的ForkJoinPool,可能提高你的多线程任务的速度.实际是多线程，注意线程安全问题</p>\n<p>　　在从stream和parallelStream方法中进行选择时,我们可以考虑以下几个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　1. 是否需要并行？  </span><br><span class=\"line\">　　2. 任务之间是否是独立的？是否会引起任何竞态条件？  </span><br><span class=\"line\">　　3. 结果是否取决于任务的调用顺序？</span><br></pre></td></tr></table></figure>\n\n<p>　　对于问题1，需要弄清楚要解决的问题是什么，数据量有多大，计算的特点是什么？并不是所有的问题都适合使用并发程序来求解，比如当数据量不大时，顺序执行往往比并行执行更快。毕竟，准备线程池和其它相关资源也是需要时间的。但是，当任务涉及到I/O操作并且任务之间不互相依赖时，那么并行化就是一个不错的选择。通常而言，将这类程序并行化之后，执行速度会提升好几个等级。</p>\n<p>　　对于问题2，如果任务之间是独立的，并且代码中不涉及到对同一个对象的某个状态或者某个变量的更新操作，那么就表明代码是可以被并行化的。</p>\n<p>　　对于问题3，由于在并行环境中任务的执行顺序是不确定的，因此对于依赖于顺序的任务而言，并行化也许不能给出正确的结果。　　</p>\n<p>　　场景：默认值适用的场景是CPU密集型的，而一般的Web项目是IO密集型的（一般的Web项目都是需要跟数据库打交道的，针对数据库的操作主要就都是IO，而对CPU的消耗并不高）。</p>\n<p>　　当不能使用默认值的时候，需要开发人员额外去了解parallelStream的用法，如下：</p>\n<h4 id=\"1-2-parallelStream作用\"><a href=\"#1-2-parallelStream作用\" class=\"headerlink\" title=\"1.2 parallelStream作用\"></a>1.2 parallelStream作用</h4><p>Stream具有平行处理能力，处理的过程会分而治之，也就是将一个大任务切分成多个小任务，这表示每个任务都是一个操作，因此像以下的程式片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class=\"line\">numbers.parallelStream()</span><br><span class=\"line\">       .forEach(out::println);</span><br></pre></td></tr></table></figure>\n\n<p>　　得到的展示顺序不一定会是1、2、3、4、5、6、7、8、9，而可能是任意的顺序，就forEach()这个操作來讲，如果平行处理时，希望最后顺序是按照原来Stream的数据顺序，那可以调用forEachOrdered()。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class=\"line\">numbers.parallelStream()</span><br><span class=\"line\">       .forEachOrdered(out::println);</span><br></pre></td></tr></table></figure>\n\n<p>　　注意:如果forEachOrdered()中间有其他如filter()的中介操作，会试着平行化处理，然后最终forEachOrdered()会以原数据顺序处理，因此，使用forEachOrdered()这类的有序处理,可能会（或完全失去）失去平行化的一些优势，实际上中介操作亦有可能如此，例如sorted()方法。</p>\n<h4 id=\"1-3-开启串行流和并行流：\"><a href=\"#1-3-开启串行流和并行流：\" class=\"headerlink\" title=\"1.3 开启串行流和并行流：\"></a>1.3 开启串行流和并行流：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testStream</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; list = getList();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 串行流</span></span><br><span class=\"line\">    list.stream();</span><br><span class=\"line\">    list.stream().sequential();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 并行流</span></span><br><span class=\"line\">    list.stream().parallel();</span><br><span class=\"line\">    list.parallelStream().reduce(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 串行流执行</span></span><br><span class=\"line\">    list.stream().reduce((first, second) -&gt; first+second);/</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 并行流执行</span></span><br><span class=\"line\">    list.parallelStream().reduce((first, second) -&gt; first+second);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-流处理\"><a href=\"#1-2-流处理\" class=\"headerlink\" title=\"1.2 流处理\"></a>1.2 流处理</h4><p>因为比较关心并行流的实现，所以看并行流的代码：</p>\n<p>java.util.stream.ReduceOps.ReduceOp</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReduceOp</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>, <span class=\"title\">S</span> <span class=\"keyword\">extends</span> <span class=\"title\">AccumulatingSink</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>, <span class=\"title\">S</span>&gt;&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">TerminalOp</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StreamShape inputShape;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Create a &#123;<span class=\"doctag\">@code</span> ReduceOp&#125; of the specified stream shape which uses</span></span><br><span class=\"line\"><span class=\"comment\">     * the specified &#123;<span class=\"doctag\">@code</span> Supplier&#125; to create accumulating sinks.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> shape The shape of the stream pipeline</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    ReduceOp(StreamShape shape) &#123;</span><br><span class=\"line\">        inputShape = shape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> S <span class=\"title\">makeSink</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> StreamShape <span class=\"title\">inputShape</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> inputShape;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;P_IN&gt; <span class=\"function\">R <span class=\"title\">evaluateSequential</span><span class=\"params\">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper.wrapAndCopyInto(makeSink(), spliterator).get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;P_IN&gt; <span class=\"function\">R <span class=\"title\">evaluateParallel</span><span class=\"params\">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                     Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里new出了一个 ReduceTask</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ReduceTask&lt;&gt;(<span class=\"keyword\">this</span>, helper, spliterator).invoke().get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>名称上看，这是个task任务（java.util.stream.ReduceOps.ReduceTask），再看下类图：</p>\n<p><img src=\"/images/reduceTask-%E7%B1%BB%E5%9B%BE.png\" alt=\"58929987340\"></p>\n<p>看到类图结构加上熟悉fork/join框架，大概明白了stream的并行流实现了，借助于fork/join</p>\n<h3 id=\"二、Fork-Join-框架\"><a href=\"#二、Fork-Join-框架\" class=\"headerlink\" title=\"二、Fork/Join 框架\"></a>二、Fork/Join 框架</h3><p>Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>\n<p>它同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。</p>\n<p><img src=\"/images/forkjoin_%E4%BB%BB%E5%8A%A1%E6%8B%86%E5%88%86.png\" alt=\"img\"></p>\n<h4 id=\"2-1分治法\"><a href=\"#2-1分治法\" class=\"headerlink\" title=\"2.1分治法\"></a>2.1分治法</h4><p><code>ForkJoinPool</code>主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。</p>\n<p>　　典型的应用比如快速排序算法。这里的要点在于，ForkJoinPool需要使用相对少的线程来处理大量的任务。比如要对1000万个数据进行排序，那么会将这个任务分割成两个500万的排序任务和一个针对这两组500万数据的合并任务。以此类推，对于500万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于10时，会停止分割，转而使用插入排序对它们进行排序。那么到最后，所有的任务加起来会有大概2000000+个。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。</p>\n<p>　　所以当使用ThreadPoolExecutor时，使用分治法会存在问题，因为ThreadPoolExecutor中的线程无法像任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而使用ForkJoinPool时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。</p>\n<p>那么使用ThreadPoolExecutor或者ForkJoinPool，会有什么性能的差异呢？</p>\n<p>　　首先，使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用4个线程来完成超过200万个任务。但是，使用ThreadPoolExecutor时，是不可能完成的，因为ThreadPoolExecutor中的Thread无法选择优先执行子任务，需要完成200万个具有父子关系的任务时，也需要200万个线程，显然这是不可行的。</p>\n<p>​    尝试改变JDK8的工作线程数量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_FORK_JOIN_PARALLELISM = <span class=\"string\">\"java.util.concurrent.ForkJoinPool.common.parallelism\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 设置线程数</span></span><br><span class=\"line\">System.setProperty(DEFAULT_FORK_JOIN_PARALLELISM, (Runtime.getRuntime().availableProcessors() * <span class=\"number\">2</span>) + <span class=\"string\">\"\"</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-2-工作窃取法\"><a href=\"#2-2-工作窃取法\" class=\"headerlink\" title=\"2.2 工作窃取法\"></a>2.2 工作窃取法</h4><p>　　forkjoin最核心的地方就是利用了现代硬件设备多核,在一个操作时候会有空闲的cpu,那么如何利用好这个空闲的cpu就成了提高性能的关键,而这里我们要提到的工作窃取（work-stealing）算法就是整个forkjion框架的核心理念,工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</p>\n<p>　　那么为什么需要使用工作窃取算法呢？</p>\n<p>　　假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>\n<p>　　工作窃取的运行流程图如下：</p>\n<p><img src=\"/images/forkjoin_%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%EF%BC%88%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%EF%BC%89.png\" alt=\"img\"></p>\n<p>　　工作窃取算法的优点：充分利用线程进行并行计算，并减少了线程间的竞争；</p>\n<p>　　工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>\n<h4 id=\"2-3-Fork-Join-涉及到的关键名称\"><a href=\"#2-3-Fork-Join-涉及到的关键名称\" class=\"headerlink\" title=\"2.3 Fork/Join 涉及到的关键名称\"></a>2.3 Fork/Join 涉及到的关键名称</h4><p>　　<code>ForkJoinPool</code>： 用来执行Task，或生成新的ForkJoinWorkerThread，执行 ForkJoinWorkerThread 间的 work-stealing 逻辑。ForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。</p>\n<p>　　<code>ForkJoinTask</code>： 执行具体的分支逻辑，声明以同步/异步方式进行执行</p>\n<p>　　<code>ForkJoinWorkerThread</code>： 是 ForkJoinPool 内的 worker thread，执行</p>\n<p>　　<code>ForkJoinTask</code>, 内部有 ForkJoinPool.WorkQueue来保存要执行的ForkJoinTask。</p>\n<p>　　<code>ForkJoinPool.WorkQueue</code>：保存要执行的ForkJoinTask。</p>\n<h4 id=\"2-4-Fork-Join框架的实现原理\"><a href=\"#2-4-Fork-Join框架的实现原理\" class=\"headerlink\" title=\"2.4 Fork/Join框架的实现原理\"></a>2.4 Fork/Join框架的实现原理</h4><p>在Java的Fork/Join框架中，它提供了两个类来帮助我们完成任务分割以及执行任务并合并结果：</p>\n<p>　　1、<code>ForkJoinTask</code>：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：</p>\n<p>　　　　<code>RecursiveAction</code>：用于没有返回结果的任务。<br>　　　　<code>RecursiveTask</code> ：用于有返回结果的任务。</p>\n<p>　　2、<code>ForkJoinPool</code> ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p>\n<p>　　<code>ForkJoinPool</code>由<code>ForkJoinTask</code>数组和<code>ForkJoinWorkerThread</code>数组组成，<code>ForkJoinTask</code>数组负责将存放程序提交给<code>ForkJoinPool</code>，而<code>ForkJoinWorkerThread</code>负责执行这些任务。</p>\n<p>基本思想</p>\n<p>　　<code>ForkJoinPool</code> 的每个工作线程都维护着一个工作队列（<code>WorkQueue</code>），这是一个双端队列（<code>Deque</code>），里面存放的对象是任务（<code>ForkJoinTask</code>）。</p>\n<p>　　每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 LIFO（<strong>后进先出</strong>） 方式，也就是说每次从队尾取出任务来执行。</p>\n<p>　　每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。</p>\n<p>　　在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。</p>\n<p>　　在既没有自己的任务，也没有可以窃取的任务时，进入休眠。</p>\n<h5 id=\"2-4-1-ForkJoinPool属性说明、工作队列说明、控制中心说明\"><a href=\"#2-4-1-ForkJoinPool属性说明、工作队列说明、控制中心说明\" class=\"headerlink\" title=\"2.4.1 ForkJoinPool属性说明、工作队列说明、控制中心说明\"></a>2.4.1 ForkJoinPool属性说明、工作队列说明、控制中心说明</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Instance fields</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> ctl;                   <span class=\"comment\">// 控制中心：非常重要，看下图解析</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> runState;               <span class=\"comment\">// 负数是shutdown，其余都是2的次方</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> config;                    <span class=\"comment\">// 配置：二进制的低16位代表 并行度（parallelism），</span></span><br><span class=\"line\">                                                                                    <span class=\"comment\">//高16位：mode可选FIFO_QUEUE（1 &lt;&lt; 16）和LIFO_QUEUE（1 &lt;&lt; 31），默认是LIFO_QUEUE</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> indexSeed;                       <span class=\"comment\">// 生成worker的queue索引</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> WorkQueue[] workQueues;     <span class=\"comment\">// main registry</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ForkJoinWorkerThreadFactory factory;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> UncaughtExceptionHandler ueh;  <span class=\"comment\">// per-worker UEH</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String workerNamePrefix;       <span class=\"comment\">// to create worker name string</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> AtomicLong stealCounter;    <span class=\"comment\">// also used as sync monitor</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"2-4-1-1-工作队列workQueues\"><a href=\"#2-4-1-1-工作队列workQueues\" class=\"headerlink\" title=\"2.4.1.1 工作队列workQueues\"></a>2.4.1.1 工作队列workQueues</h6><p>用于保存向ForkJoinPool提交的任务，而具体的执行由ForkJoinWorkerThread执行，而ForkJoinWorkerThreadFactory可以用于生产出ForkJoinWorkerThread：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * Returns a new worker thread operating in the given pool.</span></span><br><span class=\"line\"><span class=\"comment\">        *</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@param</span> pool the pool this thread works in</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@return</span> the new worker thread</span></span><br><span class=\"line\"><span class=\"comment\">        * <span class=\"doctag\">@throws</span> NullPointerException if the pool is null</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ForkJoinWorkerThread <span class=\"title\">newThread</span><span class=\"params\">(ForkJoinPool pool)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/292888-20190913110608100-591376294.png\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Instance fields</span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> scanState;    <span class=\"comment\">// 负数：inactive, 非负数：active, 其中奇数代表scanning</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> stackPred;             <span class=\"comment\">// sp = (int)ctl, 前一个队列栈的标示信息，包含版本号、是否激活、以及队列索引</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> nsteals;               <span class=\"comment\">// 窃取的任务数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> hint;                  <span class=\"comment\">// 一个随机数，用来帮助任务窃取，在 helpXXXX()的方法中会用到</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> config;                <span class=\"comment\">// 配置：二进制的低16位代表 在 queue[] 中的索引，</span></span><br><span class=\"line\"><span class=\"comment\">// 高16位：mode可选FIFO_QUEUE（1 &lt;&lt; 16）和LIFO_QUEUE（1 &lt;&lt; 31），默认是LIFO_QUEUE</span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> qlock;        <span class=\"comment\">// 锁定标示位：1: locked, &lt; 0: terminate; else 0</span></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> base;         <span class=\"comment\">// index of next slot for poll</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> top;                   <span class=\"comment\">// index of next slot for push</span></span><br><span class=\"line\">ForkJoinTask&lt;?&gt;[] array;   <span class=\"comment\">// 任务列表</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-4-1-2-控制中心ctl\"><a href=\"#2-4-1-2-控制中心ctl\" class=\"headerlink\" title=\"2.4.1.2 控制中心ctl\"></a>2.4.1.2 控制中心ctl</h6><p><img src=\"/images/292888-20190913111130827-1005682912.png\" alt=\"img\"></p>\n<h6 id=\"2-4-1-3-方法说明\"><a href=\"#2-4-1-3-方法说明\" class=\"headerlink\" title=\"2.4.1.3 方法说明\"></a>2.4.1.3 方法说明</h6><p>队列与关键任务调用说明</p>\n<p><img src=\"/images/292888-20190913110836624-260052587.png\" alt=\"img\"></p>\n<p>2.4.1.4 externalPush || externalSubmit</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">externalPush</span><span class=\"params\">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class=\"line\">        WorkQueue[] ws; WorkQueue q; <span class=\"keyword\">int</span> m;</span><br><span class=\"line\">        <span class=\"comment\">//我们以前常用的Random，在并发下，多个线程同时计算种子需要用到同一个原子变量。</span></span><br><span class=\"line\">        <span class=\"comment\">//由于更新操作使用CAS，同时执行只有一个线程成功，其他线程的大量自旋造成性能损失，ThreadLocalRandom继承Random，对此进行了改进。</span></span><br><span class=\"line\">                <span class=\"comment\">//ThreadLocalRandom运用了ThreadLocal，每个线程内部维护一个种子变量，多线程下计算新种子时使用线程自己的种子变量进行更新，避免了竞争。</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runState;</span><br><span class=\"line\">        <span class=\"comment\">// 外部提交的task，肯定会到偶数位下标的队列上</span></span><br><span class=\"line\">        <span class=\"comment\">// SQMASK = 0x007e = 1111110，任何数和 SQMASK 进行 &amp; 运算 都会是偶数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((ws = workQueues) != <span class=\"keyword\">null</span> &amp;&amp; (m = (ws.length - <span class=\"number\">1</span>)) &gt;= <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            (q = ws[m &amp; r &amp; SQMASK]) != <span class=\"keyword\">null</span> &amp;&amp; r != <span class=\"number\">0</span> &amp;&amp; rs &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">            <span class=\"comment\">//队列上锁</span></span><br><span class=\"line\">            U.compareAndSwapInt(q, QLOCK, <span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            ForkJoinTask&lt;?&gt;[] a; <span class=\"keyword\">int</span> am, n, s;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((a = q.array) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                (am = a.length - <span class=\"number\">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class=\"line\">                <span class=\"comment\">//把 task 放到队列的 top端</span></span><br><span class=\"line\">                U.putOrderedObject(a, j, task);</span><br><span class=\"line\">                U.putOrderedInt(q, QTOP, s + <span class=\"number\">1</span>);</span><br><span class=\"line\">                U.putIntVolatile(q, QLOCK, <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">                    signalWork(ws, q);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//队列解锁</span></span><br><span class=\"line\">            U.compareAndSwapInt(q, QLOCK, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        externalSubmit(task);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-4-1-5-registerWorker\"><a href=\"#2-4-1-5-registerWorker\" class=\"headerlink\" title=\"2.4.1.5 registerWorker\"></a>2.4.1.5 registerWorker</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> WorkQueue <span class=\"title\">registerWorker</span><span class=\"params\">(ForkJoinWorkerThread wt)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//......</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((ws = workQueues) != <span class=\"keyword\">null</span> &amp;&amp; (n = ws.length) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> s = indexSeed += SEED_INCREMENT;  <span class=\"comment\">// unlikely to collide</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> m = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// worker的queue肯定放在pool中的queue[]中的奇数下标</span></span><br><span class=\"line\">                  <span class=\"comment\">// m = ws.lenght - 1, ws.lenght 肯定是偶数，则m 肯定是奇数</span></span><br><span class=\"line\">                <span class=\"comment\">// 1的二进制位：00000001, 所以任何数 \"|\" 1 都是奇数</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以 奇数 &amp; 奇数 ， 1&amp;1 = 1，所以i肯定是奇数</span></span><br><span class=\"line\">                i = ((s &lt;&lt; <span class=\"number\">1</span>) | <span class=\"number\">1</span>) &amp; m;               <span class=\"comment\">// odd-numbered indices</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ws[i] != <span class=\"keyword\">null</span>) &#123;                  <span class=\"comment\">// collision</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> probes = <span class=\"number\">0</span>;                   <span class=\"comment\">// step by approx half n</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> step = (n &lt;= <span class=\"number\">4</span>) ? <span class=\"number\">2</span> : ((n &gt;&gt;&gt; <span class=\"number\">1</span>) &amp; EVENMASK) + <span class=\"number\">2</span>;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果下标已经有队列，则重新生成奇数下标</span></span><br><span class=\"line\">                    <span class=\"comment\">// step肯定为偶数：EVENMASK：0xfffe：1111111111111110</span></span><br><span class=\"line\">                      <span class=\"comment\">// 所以 奇数+偶数，奇偶性不变</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (ws[i = (i + step) &amp; m] != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (++probes &gt;= n) &#123;</span><br><span class=\"line\">                            workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class=\"number\">1</span>);</span><br><span class=\"line\">                            m = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">                            probes = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"comment\">//......</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h6 id=\"2-4-1-6-scan\"><a href=\"#2-4-1-6-scan\" class=\"headerlink\" title=\"2.4.1.6 scan\"></a>2.4.1.6 scan</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class=\"keyword\">int</span> r) &#123;</span><br><span class=\"line\">        WorkQueue[] ws; <span class=\"keyword\">int</span> m;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((ws = workQueues) != <span class=\"keyword\">null</span> &amp;&amp; (m = ws.length - <span class=\"number\">1</span>) &gt; <span class=\"number\">0</span> &amp;&amp; w != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ss = w.scanState;                     <span class=\"comment\">// initially non-negative</span></span><br><span class=\"line\">               <span class=\"comment\">// k = r &amp; m 。 r是一个随机数，m 是 队列数组长度 - 1；用于定位去哪个 队列 窃取 task</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> origin = r &amp; m, k = origin, oldSum = <span class=\"number\">0</span>, checkSum = <span class=\"number\">0</span>;;) &#123;</span><br><span class=\"line\">                WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> b, n; <span class=\"keyword\">long</span> c;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((q = ws[k]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                      <span class=\"comment\">// 如果有还没执行的task，尝试窃取队列q 中的base下标的 task。 即FIFO</span></span><br><span class=\"line\">                    <span class=\"comment\">// i: 在内存中，b下标对应的对象的偏移值。 a.length - 1 的二进制位 永远是 0[1...]s，所以 (a.length - 1) &amp; b = b，主要是保证了b不会越界</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((n = (b = q.base) - q.top) &lt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                        (a = q.array) != <span class=\"keyword\">null</span>) &#123;      <span class=\"comment\">// non-empty</span></span><br><span class=\"line\">                        <span class=\"keyword\">long</span> i = (((a.length - <span class=\"number\">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class=\"line\">                                  U.getObjectVolatile(a, i))) != <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                            q.base == b) &#123;</span><br><span class=\"line\">                               <span class=\"comment\">// ss 是小偷的 scanState，大于0代表当前的worker是激活的</span></span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (ss &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                                  <span class=\"comment\">// 把 task 从 队列中取出来，然后队列的base+1，如果被窃取的队列中有多于1个的task，则尝试唤醒其他的worker</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (U.compareAndSwapObject(a, i, t, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                                    q.base = b + <span class=\"number\">1</span>;</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (n &lt; -<span class=\"number\">1</span>)       <span class=\"comment\">// signal others</span></span><br><span class=\"line\">                                        signalWork(ws, q);</span><br><span class=\"line\">                                    <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                              <span class=\"comment\">// ss小于0代表当前的worker是未激活的，并且当前是第一次扫描，这时候尝试激活worker</span></span><br><span class=\"line\">                            <span class=\"comment\">// oldSum: 上一次遍历周期的 base 值的和。</span></span><br><span class=\"line\">                            <span class=\"comment\">// (int) c : 可以拿到当前栈顶的空闲worker。sp = (int) c</span></span><br><span class=\"line\">                            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldSum == <span class=\"number\">0</span> &amp;&amp;   <span class=\"comment\">// try to activate</span></span><br><span class=\"line\">                                     w.scanState &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                                tryRelease(c = ctl, ws[m &amp; (<span class=\"keyword\">int</span>)c], AC_UNIT);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (ss &lt; <span class=\"number\">0</span>)                   <span class=\"comment\">// refresh</span></span><br><span class=\"line\">                            ss = w.scanState;</span><br><span class=\"line\">                        <span class=\"comment\">// 更新随机值，重新初始化所有控制变量，重新定位队列</span></span><br><span class=\"line\">                        r ^= r &lt;&lt; <span class=\"number\">1</span>; r ^= r &gt;&gt;&gt; <span class=\"number\">3</span>; r ^= r &lt;&lt; <span class=\"number\">10</span>;</span><br><span class=\"line\">                        origin = k = r &amp; m;           <span class=\"comment\">// move and rescan</span></span><br><span class=\"line\">                        oldSum = checkSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    checkSum += b;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 每次没有窃取到task的时候，都会k+1（k值不会超过m），当k遍历了一圈还没有steal到任务，则当前小偷worker是过剩的，则inactive这个小偷worker</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((k = (k + <span class=\"number\">1</span>) &amp; m) == origin) &#123;    <span class=\"comment\">// continue until stable</span></span><br><span class=\"line\">                      <span class=\"comment\">// oldSum == (oldSum = checkSum) 实际上就是 oldSum == checkSum ， oldSum = checkSum</span></span><br><span class=\"line\">                    <span class=\"comment\">// oldSum == checkSum 是判断 这个周期和上个周期 的base和是否一直，如果一直， 说明base可能没有变过</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((ss &gt;= <span class=\"number\">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class=\"line\">                        oldSum == (oldSum = checkSum)) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (ss &lt; <span class=\"number\">0</span> || w.qlock &lt; <span class=\"number\">0</span>)    <span class=\"comment\">// already inactive</span></span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> ns = ss | INACTIVE;       <span class=\"comment\">// try to inactivate</span></span><br><span class=\"line\">                        <span class=\"keyword\">long</span> nc = ((SP_MASK &amp; ns) |</span><br><span class=\"line\">                                   (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class=\"line\">                        <span class=\"comment\">// 维护 队列的 stack，可以指向前一个栈顶的队列</span></span><br><span class=\"line\">                        w.stackPred = (<span class=\"keyword\">int</span>)c;         <span class=\"comment\">// hold prev stack top</span></span><br><span class=\"line\">                        U.putInt(w, QSCANSTATE, ns);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (U.compareAndSwapLong(<span class=\"keyword\">this</span>, CTL, c, nc))</span><br><span class=\"line\">                            ss = ns;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            w.scanState = ss;         <span class=\"comment\">// back out</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    checkSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-4-1-7-signalWork\"><a href=\"#2-4-1-7-signalWork\" class=\"headerlink\" title=\"2.4.1.7 signalWork\"></a>2.4.1.7 signalWork</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">signalWork</span><span class=\"params\">(WorkQueue[] ws, WorkQueue q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> c; <span class=\"keyword\">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class=\"line\">        <span class=\"comment\">// AC是负数，所以 active worker不足</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((c = ctl) &lt; <span class=\"number\">0L</span>) &#123;                       <span class=\"comment\">// too few active</span></span><br><span class=\"line\">            <span class=\"comment\">// sp:第一位是0，没有版本号，没有inactive的worker</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((sp = (<span class=\"keyword\">int</span>)c) == <span class=\"number\">0</span>) &#123;                  <span class=\"comment\">// no idle workers</span></span><br><span class=\"line\">                <span class=\"comment\">//tc: tc不为0，就是代表 total worker - parallelism &lt; 0, 所以需要添加worker</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((c &amp; ADD_WORKER) != <span class=\"number\">0L</span>)            <span class=\"comment\">// too few workers</span></span><br><span class=\"line\">                    tryAddWorker(c);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == <span class=\"keyword\">null</span>)                            <span class=\"comment\">// unstarted/terminated</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 取栈顶的worker，如果下标已经越界或queue为null，线程池都是终止了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class=\"comment\">// terminated</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((v = ws[i]) == <span class=\"keyword\">null</span>)                   <span class=\"comment\">// terminating</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 新的scanState，版本+1，设置状态为激活，INACTIVE = 1 &lt;&lt; 31，~INACTIVE = 01111111....</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE;        <span class=\"comment\">// next scanState</span></span><br><span class=\"line\">            <span class=\"comment\">// 确认 worker的 sp没有变化</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> d = sp - v.scanState;                  <span class=\"comment\">// screen CAS</span></span><br><span class=\"line\">            <span class=\"comment\">// 生成新的 ctl，(UC_MASK &amp; (c + AC_UNIT))设置 高32位， (SP_MASK &amp; v.stackPred)设置低32位</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (d == <span class=\"number\">0</span> &amp;&amp; U.compareAndSwapLong(<span class=\"keyword\">this</span>, CTL, c, nc)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//激活worker</span></span><br><span class=\"line\">                v.scanState = vs;                      <span class=\"comment\">// activate v</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((p = v.parker) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    U.unpark(p);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//当前queue没有task 需要执行了，则停止signal</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q != <span class=\"keyword\">null</span> &amp;&amp; q.base == q.top)          <span class=\"comment\">// no more work</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-4-1-8-ForkJoinTask的fork方法实现原理\"><a href=\"#2-4-1-8-ForkJoinTask的fork方法实现原理\" class=\"headerlink\" title=\"2.4.1.8 ForkJoinTask的fork方法实现原理\"></a>2.4.1.8 ForkJoinTask的fork方法实现原理</h6><p>当我们调用ForkJoinTask的fork方法时，程序会把任务放在ForkJoinWorkerThread的pushTask的workQueue中，异步地执行这个任务，然后立即返回结果，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ForkJoinTask&lt;V&gt; <span class=\"title\">fork</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((t = Thread.currentThread()) <span class=\"keyword\">instanceof</span> ForkJoinWorkerThread)</span><br><span class=\"line\">        ((ForkJoinWorkerThread)t).workQueue.push(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        ForkJoinPool.common.externalPush(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>若当前线程是ForkJoinWorkerThread线程，则强制类型转换（向下转换）成ForkJoinWorkerThread，然后将任务push到这个线程负责的队列里面去，在ForkJoinWorkerThread类中有一个pool和一个workQueue字段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程工作的ForkJoinPool</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ForkJoinPool pool;                <span class=\"comment\">// the pool this thread works in</span></span><br><span class=\"line\"><span class=\"comment\">// 工作窃取队列</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> ForkJoinPool.WorkQueue workQueue; <span class=\"comment\">// work-stealing mechanics</span></span><br></pre></td></tr></table></figure>\n\n<p>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class=\"line\">    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = base, s = top, n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((a = array) != <span class=\"keyword\">null</span>) &#123;    <span class=\"comment\">// ignore if queue removed</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = a.length - <span class=\"number\">1</span>;     <span class=\"comment\">// fenced write for task visibility</span></span><br><span class=\"line\">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class=\"line\">        U.putOrderedInt(<span class=\"keyword\">this</span>, QTOP, s + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((n = s - b) &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((p = pool) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                p.signalWork(p.workQueues, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &gt;= m)</span><br><span class=\"line\">            growArray();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该方法的主要功能就是将当前任务存放在ForkJoinTask数组array里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。</p>\n<h6 id=\"2-4-1-9-ForkJoinTask的join方法实现原理\"><a href=\"#2-4-1-9-ForkJoinTask的join方法实现原理\" class=\"headerlink\" title=\"2.4.1.9 ForkJoinTask的join方法实现原理\"></a>2.4.1.9 ForkJoinTask的join方法实现原理</h6><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">join</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class=\"line\">        reportException(s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getRawResult();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>　　首先，它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有四种：已完成（NORMAL），被取消（CANCELLED），信号（SIGNAL）和出现异常（EXCEPTIONAL）：　　</p>\n<p>　　若状态不是NORMAL，则通过reportException(int)方法来处理状态：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">reportException</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == CANCELLED)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CancellationException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == EXCEPTIONAL)</span><br><span class=\"line\">        rethrow(getThrowableException());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>如果任务状态是已完成，则直接返回任务结果。</li>\n<li>如果任务状态是被取消，则直接抛出CancellationException。</li>\n<li>如果任务状态是抛出异常，则直接抛出对应的异常。</li>\n</ul>\n<p>　　doJoin()方法的实现代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">doJoin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (s = status) &lt; <span class=\"number\">0</span> ? s :</span><br><span class=\"line\">        ((t = Thread.currentThread()) <span class=\"keyword\">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class=\"line\">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class=\"line\">        tryUnpush(<span class=\"keyword\">this</span>) &amp;&amp; (s = doExec()) &lt; <span class=\"number\">0</span> ? s :</span><br><span class=\"line\">        wt.pool.awaitJoin(w, <span class=\"keyword\">this</span>, <span class=\"number\">0L</span>) :</span><br><span class=\"line\">        externalAwaitDone();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>　　在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完了，如果执行完了，则直接返回任务状态，如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成了，则设置任务状态为NORMAL，如果出现异常，则纪录异常，并将任务状态设置为EXCEPTIONAL。</p>\n<p>　　执行任务是通过doExec()方法来完成的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">doExec</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s; <span class=\"keyword\">boolean</span> completed;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((s = status) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            completed = exec();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable rex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> setExceptionalCompletion(rex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (completed)</span><br><span class=\"line\">            s = setCompletion(NORMAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>真正的执行过程是由exec()方法来完成的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exec</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>这就是我们需要重写的方法，若是我们的任务继承自RecursiveAction，则我们需要重写RecursiveAction的compute()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecursiveAction</span> <span class=\"keyword\">extends</span> <span class=\"title\">ForkJoinTask</span>&lt;<span class=\"title\">Void</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">5232453952276485070L</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The main computation performed by this task.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">compute</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Always returns &#123;<span class=\"doctag\">@code</span> null&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> null&#125; always</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Void <span class=\"title\">getRawResult</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Requires null completion value.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setRawResult</span><span class=\"params\">(Void mustBeNull)</span> </span>&#123; &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Implements execution conventions for RecursiveActions.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exec</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        compute();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>若是我们的任务继承自RecursiveTask，则我们同样需要重写RecursiveTask的compute()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecursiveTask</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">ForkJoinTask</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">5232453952276485270L</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The result of the computation.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    V result;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The main computation performed by this task.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the result of the computation</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> V <span class=\"title\">compute</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> V <span class=\"title\">getRawResult</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setRawResult</span><span class=\"params\">(V value)</span> </span>&#123;</span><br><span class=\"line\">        result = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Implements execution conventions for RecursiveTask.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">exec</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        result = compute();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过上面的分析可知，执行我们的业务代码是在调用了join()之后的，也就是说，fork仅仅是分割任务，只有当我们执行join的时候，我们的任务才会被执行。</p>\n<h5 id=\"2-4-2-异常处理\"><a href=\"#2-4-2-异常处理\" class=\"headerlink\" title=\"2.4.2 异常处理\"></a>2.4.2 异常处理</h5><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(task.isCompletedAbnormally())&#123;</span><br><span class=\"line\">    System.out.println(task.getException());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Throwable <span class=\"title\">getException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = status &amp; DONE_MASK;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((s &gt;= NORMAL)    ? <span class=\"keyword\">null</span> :</span><br><span class=\"line\">                (s == CANCELLED) ? <span class=\"keyword\">new</span> CancellationException() :</span><br><span class=\"line\">                getThrowableException());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2-4-2forkjoin-的使用\"><a href=\"#2-4-2forkjoin-的使用\" class=\"headerlink\" title=\"2.4.2forkjoin 的使用\"></a>2.4.2forkjoin 的使用</h5><p>　ForkJoinPool 使用submit 或 invoke 提交的区别：invoke是同步执行，调用之后需要等待任务完成，才能执行后面的代码；submit是异步执行，只有在Future调用get的时候会阻塞。</p>\n<p>　　这里继承的是RecursiveTask 适用于有返回值的场景；还可以继承RecursiveAction，适合于没有返回值的场景</p>\n<p>　　执行子任务调用fork方法并不是最佳的选择，最佳的选择是invokeAll方法。</p>\n<h5 id=\"2-4-3-示例代码\"><a href=\"#2-4-3-示例代码\" class=\"headerlink\" title=\"2.4.3 示例代码\"></a>2.4.3 示例代码</h5><p>   这个示例是在做某支付任务异步解耦后的业务逻辑校验，这个是一个接收返回的任务 <code>RecursiveTask</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CheckTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecursiveTask</span>&lt;<span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t\t*  这个是阈值，具体任务列表拆分到什么程度再开始执行</span></span><br><span class=\"line\"><span class=\"comment\">\t\t**/</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    \t*\t这个是当前处理的集合列表</span></span><br><span class=\"line\"><span class=\"comment\">    \t**/</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> List&lt;CbVaPaymentFileContent&gt; list;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 初始化任务对象</span></span><br><span class=\"line\"><span class=\"comment\">        **/</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">CheckTask</span><span class=\"params\">(<span class=\"keyword\">int</span> threshold, List&lt;CbVaPaymentFileContent&gt; list)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == list) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"[list] is null.\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.threshold = threshold &lt;= <span class=\"number\">0</span> ? <span class=\"keyword\">this</span>.threshold : threshold;</span><br><span class=\"line\"><span class=\"comment\">//            this.threshold = list.size() / Runtime.getRuntime().availableProcessors();</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.list = list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> Integer <span class=\"title\">compute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list.size() &lt;= threshold) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 处理</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (CbVaPaymentFileContent content : list) &#123;</span><br><span class=\"line\">                    count += process(content);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 分解</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> middle = list.size() / <span class=\"number\">2</span>;</span><br><span class=\"line\">                List&lt;CbVaPaymentFileContent&gt; leftList = list.subList(<span class=\"number\">0</span>, middle);</span><br><span class=\"line\">                List&lt;CbVaPaymentFileContent&gt; rightList = list.subList(middle, list.size());</span><br><span class=\"line\">                CheckTask left = <span class=\"keyword\">new</span> CheckTask(threshold, leftList);</span><br><span class=\"line\">                CheckTask right = <span class=\"keyword\">new</span> CheckTask(threshold, rightList);</span><br><span class=\"line\">                <span class=\"comment\">// left.fork();</span></span><br><span class=\"line\">                <span class=\"comment\">// right.fork();</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 这两个方法，使用invokeAll方法的主要原因是为了充分利用线程池，在invokeAll的N个任务中，其中N-1个任务会使用fork()交给其它线程执行，但是，它还会留一个任务自己执行，这样，就充分利用了线程池，保证没有空闲的不干活的线程。</span></span><br><span class=\"line\">                invokeAll(left, right);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 结合</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> left.join() + right.join();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>　　该代码就是通过Fork/Join框架来计算数组的和，计算耗时4031毫秒。通过该代码作为应用示例主要是为了告诉大家，使用Fork/Join模型的正确方式，在源代码中可以看到，SumTask继承自RecursiveTask，重写的compute方法为：</p>\n<p>　　compute()方法使用了invokeAll方法来分解任务，而不是它下面的subtask1.fork();</p>\n<p>　　这两个方法，使用invokeAll方法的主要原因是为了充分利用线程池，在invokeAll的N个任务中，其中N-1个任务会使用fork()交给其它线程执行，但是，它还会留一个任务自己执行，这样，就充分利用了线程池，保证没有空闲的不干活的线程。</p>\n<p>　　若是采用另外一种方式来运行，程序的运行时间为6028毫秒，可以看到，明显比invokeAll方式慢了很多。</p>\n<h5 id=\"2-4-3-JDK8中的最佳实践\"><a href=\"#2-4-3-JDK8中的最佳实践\" class=\"headerlink\" title=\"2.4.3 JDK8中的最佳实践\"></a>2.4.3 JDK8中的最佳实践</h5><h5 id=\"2-4-3-1-通过forkjoin来看parallelStream\"><a href=\"#2-4-3-1-通过forkjoin来看parallelStream\" class=\"headerlink\" title=\"2.4.3.1 通过forkjoin来看parallelStream\"></a>2.4.3.1 通过forkjoin来看parallelStream</h5><p>在Java 8引入了自动并行化的概念。它能够让一部分Java代码自动地以并行的方式执行，即使用了ForkJoinPool的ParallelStream。　　</p>\n<p>　　Java 8为ForkJoinPool添加了一个通用线程池，这个线程池用来处理那些没有被显式提交到任何线程池的任务。它是ForkJoinPool类型上的一个静态元素，它拥有的默认线程数量等于运行计算机上的处理器数量。当调用Arrays类上添加的新方法时，自动并行化就会发生。比如用来排序一个数组的并行快速排序，用来对一个数组中的元素进行并行遍历。自动并行化也被运用在Java 8新添加的Stream API中。</p>\n<p>　　一般ForkJoinPool中的通用线程池处理，也可以使用ThreadPoolExecutor完成，但是就代码的可读性和代码量而言，使用ForkJoinPool明显更胜一筹。</p>\n<h5 id=\"2-4-3-2-线程池数量\"><a href=\"#2-4-3-2-线程池数量\" class=\"headerlink\" title=\"2.4.3.2 线程池数量\"></a>2.4.3.2 线程池数量</h5><p>​    <strong>1、系统CPU数量：[如机器8核，即8]</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure>\n\n<p>　　<strong>2、parallelStream默认的并发线程数:【parallelStream核心使用ForkJoinPool实现，故如下】【输出是7个】</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ForkJoinPool.getCommonPoolParallelism()</span><br></pre></td></tr></table></figure>\n\n<p>　　<strong>3、为什么parallelStream默认的并发线程数要比CPU处理器的数量少1个？</strong></p>\n<p>　　　　因为最优的策略是每个CPU处理器分配一个线程，然而主线程也算一个线程，所以要占一个名额。如果只有1个CPU，默认的并发线程数就是1</p>\n<p>　　<strong>4、修改默认并发数</strong></p>\n<p>　　　　默认的并发线程数不可以反复修改。因为<code>java.util.concurrent.ForkJoinPool.common.parallelism</code>是<code>final</code>类型的，整个JVM中只允许设置一次。多次修改以第一次为主</p>\n<p>　　　　1、系统property</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, &quot;20&quot;);</span><br><span class=\"line\">System.out.println(ForkJoinPool.getCommonPoolParallelism());</span><br></pre></td></tr></table></figure>\n\n<p>　　　　2、当然上述参数也可以通过jvm设置系统属性：-Djava.util.concurrent.ForkJoinPool.common.parallelism=N （N为线程数量）　　</p>\n<p>　　<strong>5、既然默认的并发线程数不能反复修改，进行不同线程数量的并发测试，可以引入<code>ForkJoinPool</code>。用法如下</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testSetParallelMutli() throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">    int[] threadCountArr &#x3D; &#123;2, 4, 6&#125;;</span><br><span class=\"line\">    List&lt;Integer&gt; para &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; 7; i++) &#123;</span><br><span class=\"line\">        para.add(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int threadCount : threadCountArr) &#123;</span><br><span class=\"line\">        new ForkJoinPool(threadCount).submit(() -&gt; &#123;&#x2F;&#x2F;多线程任务</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;).get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>　　　　使用get 是为了阻塞 得到结果；如果主线程没有关闭的情况下可以不用get</p>\n<h5 id=\"2-4-3-2-测试示例\"><a href=\"#2-4-3-2-测试示例\" class=\"headerlink\" title=\"2.4.3.2 测试示例\"></a>2.4.3.2 测试示例</h5><p><strong>实际应用示例</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">logger.info(<span class=\"string\">\"[消息补偿任务-并行执行]开始，本次预处理总数为[&#123;&#125;]\"</span>, list.size());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 手动扩容下,当然这个综合考虑使用</span></span><br><span class=\"line\">System.setProperty(DEFAULT_FORK_JOIN_PARALLELISM, (Runtime.getRuntime().availableProcessors() * appConfig.getMutiple()) + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 拆分任务到JobSender</span></span><br><span class=\"line\"><span class=\"comment\"> *  &#123;<span class=\"doctag\">@link</span> Stream#reduce(Object, BiFunction, BinaryOperator)&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *  &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *      reduce.Object --&gt; 初始值，只是为了来初始化参数类型</span></span><br><span class=\"line\"><span class=\"comment\"> *      reduce.BiFunction.apply(T t, U u) --&gt;  t表示当前值， u表示当前操作对象</span></span><br><span class=\"line\"><span class=\"comment\"> *      reduce.BinaryOperator(T t, U u) --&gt; t=u=初始值类型，用来合并结果的</span></span><br><span class=\"line\"><span class=\"comment\"> *  &lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> total = list.parallelStream().filter(op -&gt; lockAdaptor.lock(op.getId(), LockAdaptor.DEFAULT_TIMEOUT)).reduce(<span class=\"number\">0</span>, (cur, channel) -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建发送器 + 并处理</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ava;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ava = (jobSenderFactory.getSender(channel).process().dealSuccess() ? <span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">        lockAdaptor.unlock(channel.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cur + ava;</span><br><span class=\"line\">&#125;, (a, b) -&gt; a + b);</span><br><span class=\"line\">logger.info(<span class=\"string\">\"[消息补偿任务-并行执行]结束，本次预处理总数为[&#123;&#125;]， 成功总数[&#123;&#125;], 未成功总数[&#123;&#125;]\"</span>, list.size(), total, list.size() - total);</span><br></pre></td></tr></table></figure>\n\n<p>1、测试一、8核机器，每个任务均耗时2秒，一共16个任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testSetParallelMutli2() throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">    List&lt;Integer&gt; para &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; 16; i++) &#123;</span><br><span class=\"line\">        para.add(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    para.parallelStream().forEach(i -&gt; &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(2000);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(LocalDateTime.now() + &quot;||&quot; + Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>　　输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-1:5</span><br><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-6:1</span><br><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-2:14</span><br><span class=\"line\">2019-09-13T10:51:04.344||main:10</span><br><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-4:13</span><br><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-3:2</span><br><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-7:4</span><br><span class=\"line\">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-5:7</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-4:3</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-6:0</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-1:12</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-2:15</span><br><span class=\"line\">2019-09-13T10:51:06.350||main:11</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-5:8</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-3:6</span><br><span class=\"line\">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-7:9</span><br></pre></td></tr></table></figure>\n\n<p>　　结论：会有7个 ForkJoinPool.commonPool-worker 线程和1个主线程main一起执行任务。并且8个一组一组执行，每个线程执行了两个任务。</p>\n<p>2、测试二、8核机器，每个任务耗时2秒内随机，一共16个任务 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    @Test</span><br><span class=\"line\">    public void testSetParallelMutli2() throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; para &#x3D; new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i &#x3D; 0; i &lt; 16; i++) &#123;</span><br><span class=\"line\">            para.add(i);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        para.parallelStream().forEach(i -&gt; &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">&#x2F;&#x2F;                Thread.sleep(2000);</span><br><span class=\"line\">                Thread.sleep(new Random().nextInt(2000));</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(LocalDateTime.now() + &quot;||&quot; + Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-09-13T10:54:01.486||ForkJoinPool.commonPool-worker-5:7</span><br><span class=\"line\">2019-09-13T10:54:01.751||main:10</span><br><span class=\"line\">2019-09-13T10:54:01.774||main:11</span><br><span class=\"line\">2019-09-13T10:54:01.862||ForkJoinPool.commonPool-worker-5:6</span><br><span class=\"line\">2019-09-13T10:54:02.203||ForkJoinPool.commonPool-worker-5:15</span><br><span class=\"line\">2019-09-13T10:54:02.285||ForkJoinPool.commonPool-worker-6:1</span><br><span class=\"line\">2019-09-13T10:54:02.407||ForkJoinPool.commonPool-worker-6:0</span><br><span class=\"line\">2019-09-13T10:54:02.479||ForkJoinPool.commonPool-worker-1:5</span><br><span class=\"line\">2019-09-13T10:54:02.496||ForkJoinPool.commonPool-worker-2:14</span><br><span class=\"line\">2019-09-13T10:54:02.518||ForkJoinPool.commonPool-worker-4:13</span><br><span class=\"line\">2019-09-13T10:54:02.732||main:9</span><br><span class=\"line\">2019-09-13T10:54:02.740||ForkJoinPool.commonPool-worker-7:4</span><br><span class=\"line\">2019-09-13T10:54:02.791||ForkJoinPool.commonPool-worker-3:2</span><br><span class=\"line\">2019-09-13T10:54:03.178||ForkJoinPool.commonPool-worker-5:12</span><br><span class=\"line\">2019-09-13T10:54:03.743||ForkJoinPool.commonPool-worker-1:8</span><br><span class=\"line\">2019-09-13T10:54:04.003||ForkJoinPool.commonPool-worker-6:3</span><br></pre></td></tr></table></figure>\n\n<p>　　结论：会有7个 ForkJoinPool.commonPool-worker 线程和1个主线程main一起执行任务。并且是强占式【工作窃取法】的执行任务：如上线程5、主线程执行了各3个任务，其他有2个或一个的。</p>\n<p>3、示例三、接收消息队列消息，每次消息个数n个，每个消息是一个100个的list<String>,接收时候使用parallelStream消费并发处理</p>\n<p>发送消息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testMq() throws Exception &#123;</span><br><span class=\"line\">    for (int j &#x3D; 0; j &lt; 1; j++) &#123;</span><br><span class=\"line\">        List&lt;String&gt; list &#x3D; Lists.newArrayList();</span><br><span class=\"line\">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">            list.add(j+&quot;___________&quot;+i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        producerMessageService.sendMessage(&quot;test_parallel&quot;, UUID.randomUUID().toString(), JSON.toJSONString(list));</span><br><span class=\"line\">        Thread.sleep(1000);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    logger.error(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;生产 ok&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    Thread.sleep(2000000000);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接收消费</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onMessage(List&lt;Message&gt; messages) throws Exception &#123;</span><br><span class=\"line\">    if (messages &#x3D;&#x3D; null || messages.isEmpty()) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; messages.size(); i++) &#123;</span><br><span class=\"line\">        Message message &#x3D; messages.get(i);</span><br><span class=\"line\">        logger.info(String.format(&quot;收到一条消息,消息主题（队列名）：%s,内容是：%s&quot;, message.getTopic(), message.getText()));</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; strings &#x3D; JSONArray.parseArray(message.getText(), String.class);</span><br><span class=\"line\">        strings.parallelStream().forEach(p -&gt; &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                Thread.sleep(2000);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            logger.error(LocalDateTime.now() + &quot;_______________&quot; + Thread.currentThread().getName() + &quot;:&quot; + p);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>　　说明：</p>\n<p>　　　　发送消息，1s后会发送完毕，此时如果有订阅就会出现一条消息积压。</p>\n<p>　　　　订阅消息者，订阅后会收到词条消息，此时如果正常执行完毕（不论使用不使用多线程）消息积压就没有了，因为一般消息监听会在方法正常执行完毕后，使用消息Id将此条消息从订阅队列中移除。</p>\n<p>　　　　　　接收到1条消息，里面会有一个jsonstring，反序列化为List，大小是100，交给parallelStream处理，此时会有8个线程处理【如果是8核机器】，处理速度大约是2秒8个。其余的92进入workQueue中等待处理。</p>\n<p>　　　　　　此时如果程序中断，订阅的消息不会被消费使用，下次重连时，需要做已处理消息的去重。</p>\n<p>　　　　　　此时如果有新消息发送过来，也会在积压中，不会被消息消费。</p>\n<p> 4、示例四、从a中100个数找出整除5的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void testExec() throws ExecutionException, InterruptedException &#123;</span><br><span class=\"line\">    List&lt;Integer&gt; a &#x3D; Lists.newArrayList();</span><br><span class=\"line\">    for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class=\"line\">        a.add(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;Integer&gt; b &#x3D; Lists.newArrayList();</span><br><span class=\"line\">    a.parallelStream().forEach(p -&gt; &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(100);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (p % 5 &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">            b.add(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;+b.size());</span><br><span class=\"line\">    b.forEach(p -&gt; System.out.print(p+&quot; &quot;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：正确应该是20</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;18</span><br><span class=\"line\">15 90 45 30 25 35 85 75 0 40 5 80 95 20 60 70 50 55</span><br></pre></td></tr></table></figure>\n\n\n\n<p>对此运行结果不一致，以及会有多线程问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.ArrayIndexOutOfBoundsException</span><br><span class=\"line\">    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class=\"line\">　　……</span><br><span class=\"line\"></span><br><span class=\"line\">Caused by: java.lang.ArrayIndexOutOfBoundsException: 15</span><br><span class=\"line\">    at java.util.ArrayList.add(ArrayList.java:463)</span><br><span class=\"line\">    at com.github.bjlhx15.common.thread.juc.collection.jdk8stream.TStreamTest.lambda$testExec$6(TStreamTest.java:118)</span><br><span class=\"line\">    at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)</span><br><span class=\"line\">    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382)</span><br><span class=\"line\">    at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)</span><br><span class=\"line\">    at java.util.stream.ForEachOps$ForEachTask.compute(ForEachOps.java:291)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>原因：parallelStream 并行执行，多线程异步，可能没有b添加完毕就遍历，ArrayList不是线程安全的</p>\n<p>修正：</p>\n<p>　　方案一、在遍历前，需全部执行完毕【串行】</p>\n<p>　　　　将 parallelStream 改为 stream串行处理【不可取，处理速度慢】</p>\n<p>　　方案二、在遍历前，需全部执行完毕</p>\n<p>　　　　继承 RecursiveTask或者RecursiveAction写任务　　　　</p>\n<p>　　方案三、将ArrayList替换安全集合CopyOnWriteArrayLIst</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; b &#x3D; Lists.newCopyOnWriteArrayList();</span><br></pre></td></tr></table></figure>\n\n<p>　　　　此时运行就会出现正确结果。按理说应该会有结果不准确问题吧。但是没有，个人理解，因为是每次8个同时执行，所以即使最后一次主线程提前结束，也有其他线程在锁着b，所以最后执行b的操作会有等待</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckcbaj7jk0007vgja33027yzv","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7jv000rvgjaezybd0nz"},{"post_id":"ckcbaj7jl0008vgja06sybtvr","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7jy000wvgjabzvr8vrx"},{"post_id":"ckcbaj7jl0008vgja06sybtvr","category_id":"ckcbaj7jt000mvgjael4u3de2","_id":"ckcbaj7jz0010vgja62xz8dzx"},{"post_id":"ckcbaj7jf0003vgjae7r8d0iy","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7k00012vgja7avq2ssb"},{"post_id":"ckcbaj7jf0003vgjae7r8d0iy","category_id":"ckcbaj7jv000svgja7tpv19ib","_id":"ckcbaj7k20016vgja3zrsgjz3"},{"post_id":"ckcbaj7jm0009vgjaegny5rux","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7k3001bvgja9ufudlre"},{"post_id":"ckcbaj7jm0009vgjaegny5rux","category_id":"ckcbaj7jy000xvgja8yzg1sfp","_id":"ckcbaj7k4001gvgja67gm466c"},{"post_id":"ckcbaj7jo000dvgjaa8498xy4","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7k5001jvgjac6fg9c6n"},{"post_id":"ckcbaj7jo000dvgjaa8498xy4","category_id":"ckcbaj7k10014vgja09aj5848","_id":"ckcbaj7k6001nvgja15n12m65"},{"post_id":"ckcbaj7jg0004vgja9pesbh1f","category_id":"ckcbaj7jm000avgjady1h3qr2","_id":"ckcbaj7k7001pvgjahke268zp"},{"post_id":"ckcbaj7jg0004vgja9pesbh1f","category_id":"ckcbaj7k3001cvgja3az5a012","_id":"ckcbaj7kc001svgja8hx66868"},{"post_id":"ckcbaj7jp000fvgjahip84slm","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7kc001tvgja5xmg25e2"},{"post_id":"ckcbaj7jp000fvgjahip84slm","category_id":"ckcbaj7k5001kvgja44fz3wws","_id":"ckcbaj7kc001wvgjaexoc4pck"},{"post_id":"ckcbaj7jr000jvgja5imf67pt","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7kd001zvgja5mi4a3y1"},{"post_id":"ckcbaj7jr000jvgja5imf67pt","category_id":"ckcbaj7k7001qvgja9ps67mzd","_id":"ckcbaj7kd0023vgjabica5pne"},{"post_id":"ckcbaj7ju000ovgja7vof0z62","category_id":"ckcbaj7kc001uvgjaeg45ftnn","_id":"ckcbaj7kq0038vgja2vnf9wxt"},{"post_id":"ckcbaj7ju000ovgja7vof0z62","category_id":"ckcbaj7ko0032vgja5t3ofqwd","_id":"ckcbaj7kr003bvgjahn4x9att"},{"post_id":"ckcbaj7jv000qvgjahqn26zx2","category_id":"ckcbaj7kc001uvgjaeg45ftnn","_id":"ckcbaj7kr003dvgjabhwyb6v6"},{"post_id":"ckcbaj7jv000qvgjahqn26zx2","category_id":"ckcbaj7kp0035vgja322ggi33","_id":"ckcbaj7kr003gvgja5joxeuy1"},{"post_id":"ckcbaj7jw000uvgja9tps11em","category_id":"ckcbaj7ke0025vgjah57oexmd","_id":"ckcbaj7ks003ivgja7gbgb8dc"},{"post_id":"ckcbaj7jw000uvgja9tps11em","category_id":"ckcbaj7kq0039vgja504g1ix7","_id":"ckcbaj7ks003lvgjac3z0b872"},{"post_id":"ckcbaj7jx000vvgja4i9o0zlr","category_id":"ckcbaj7ke0028vgja96ku8tzb","_id":"ckcbaj7kt003nvgja1avj7jhy"},{"post_id":"ckcbaj7jx000vvgja4i9o0zlr","category_id":"ckcbaj7kr003evgjafb9dg2us","_id":"ckcbaj7kt003qvgja0otahgn6"},{"post_id":"ckcbaj7jy000zvgjac9dx3i9k","category_id":"ckcbaj7kf002avgja6nqtb4m5","_id":"ckcbaj7ku003rvgja6yknh16x"},{"post_id":"ckcbaj7jy000zvgjac9dx3i9k","category_id":"ckcbaj7ks003jvgjadb7wf1a3","_id":"ckcbaj7ku003uvgja4hsdg7vi"},{"post_id":"ckcbaj7jz0011vgja0bgk1ihc","category_id":"ckcbaj7kg002cvgjabrwp16zp","_id":"ckcbaj7ku003vvgjagnapes16"},{"post_id":"ckcbaj7jz0011vgja0bgk1ihc","category_id":"ckcbaj7kt003ovgjafh93cwr6","_id":"ckcbaj7kv003yvgjab8ljet6q"},{"post_id":"ckcbaj7k00013vgjaeo0040q5","category_id":"ckcbaj7kh002gvgja3edz2dns","_id":"ckcbaj7kv0041vgja8r2k4kn8"},{"post_id":"ckcbaj7k00013vgjaeo0040q5","category_id":"ckcbaj7ku003svgja9cbi69y0","_id":"ckcbaj7kw0044vgja51i7h0ht"},{"post_id":"ckcbaj7k3001avgja4dyg5k5e","category_id":"ckcbaj7ki002kvgja6udbcrlj","_id":"ckcbaj7kx0046vgjac5rd9ra9"},{"post_id":"ckcbaj7k3001avgja4dyg5k5e","category_id":"ckcbaj7ku003wvgja2scshsrp","_id":"ckcbaj7kx0048vgjabh6oakr0"},{"post_id":"ckcbaj7k4001fvgja2niu2vf0","category_id":"ckcbaj7kj002ovgja92u6cbls","_id":"ckcbaj7ky0049vgja2opc9dkt"},{"post_id":"ckcbaj7k4001fvgja2niu2vf0","category_id":"ckcbaj7kv0042vgja3r17a16s","_id":"ckcbaj7ky004bvgja20ez1ctj"},{"post_id":"ckcbaj7k5001ivgjacbqqfpvq","category_id":"ckcbaj7kk002svgja5oree4fe","_id":"ckcbaj7l1004cvgjadex203th"},{"post_id":"ckcbaj7k5001ivgjacbqqfpvq","category_id":"ckcbaj7kx0047vgjaebzv0mm8","_id":"ckcbaj7l1004evgjad0nafrfz"},{"post_id":"ckcbaj7k6001mvgja0fcz4189","category_id":"ckcbaj7kk002svgja5oree4fe","_id":"ckcbaj7l2004fvgja166zcfny"},{"post_id":"ckcbaj7k6001mvgja0fcz4189","category_id":"ckcbaj7ky004avgjafp0h3n1f","_id":"ckcbaj7l2004gvgja3f1lhrbx"},{"post_id":"ckcbaj7k7001ovgjaf5z0ag3v","category_id":"ckcbaj7km002zvgjacah87l53","_id":"ckcbaj7l2004hvgja71a9206d"},{"post_id":"ckcbaj7k7001ovgjaf5z0ag3v","category_id":"ckcbaj7l1004dvgja4e7y770s","_id":"ckcbaj7l2004ivgjaf9bg7ci1"},{"post_id":"ckcbaj7lf004jvgjaa0hoh8uv","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7ll004uvgja0dt3ccvl"},{"post_id":"ckcbaj7lf004jvgjaa0hoh8uv","category_id":"ckcbaj7li004nvgja5vnb1d45","_id":"ckcbaj7ll004yvgja5kji8iay"},{"post_id":"ckcbaj7lg004kvgja2tug5tui","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7ll004zvgja7sxu4cge"},{"post_id":"ckcbaj7lg004kvgja2tug5tui","category_id":"ckcbaj7lk004rvgja65qz7qjk","_id":"ckcbaj7lm0053vgjab9x1gkoo"},{"post_id":"ckcbaj7lh004mvgja3rm4g69k","category_id":"ckcbaj7ke0025vgjah57oexmd","_id":"ckcbaj7lm0055vgja0bf68jh9"},{"post_id":"ckcbaj7lh004mvgja3rm4g69k","category_id":"ckcbaj7ll004wvgja1mlcfass","_id":"ckcbaj7ln0059vgja8uodbl04"},{"post_id":"ckcbaj7li004ovgja9jpvha7s","category_id":"ckcbaj7kh002gvgja3edz2dns","_id":"ckcbaj7ln005bvgjaek4ie45b"},{"post_id":"ckcbaj7li004ovgja9jpvha7s","category_id":"ckcbaj7ll0051vgjae4ny56gc","_id":"ckcbaj7ln005evgjaeise70lz"},{"post_id":"ckcbaj7lj004pvgjacuwm20a3","category_id":"ckcbaj7kk002svgja5oree4fe","_id":"ckcbaj7lo005jvgjahlcj6aq7"},{"post_id":"ckcbaj7lj004pvgjacuwm20a3","category_id":"ckcbaj7lm0057vgja4fd1577y","_id":"ckcbaj7lo005kvgja8cvn3rjl"},{"post_id":"ckcbaj7lj004pvgjacuwm20a3","category_id":"ckcbaj7ln005fvgjaf8bg7wsi","_id":"ckcbaj7lo005lvgja3pyg800s"},{"post_id":"ckcbaj7lq005mvgja8vv73jz7","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7lu005xvgja26ehby4g"},{"post_id":"ckcbaj7lq005mvgja8vv73jz7","category_id":"ckcbaj7ls005qvgja6qy7b7ac","_id":"ckcbaj7lu0060vgja150g4kr4"},{"post_id":"ckcbaj7lr005nvgjad9ex18l8","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7lu0062vgjaevc9648u"},{"post_id":"ckcbaj7lr005nvgjad9ex18l8","category_id":"ckcbaj7lt005uvgja24oy0f9o","_id":"ckcbaj7lu0063vgja26mmhw3u"},{"post_id":"ckcbaj7ls005pvgja5k1x7s5j","category_id":"ckcbaj7kk002svgja5oree4fe","_id":"ckcbaj7lu0064vgja0tjaceze"},{"post_id":"ckcbaj7ls005pvgja5k1x7s5j","category_id":"ckcbaj7lu005yvgjaa623c3xq","_id":"ckcbaj7lv0065vgja9hyv6ggk"},{"post_id":"ckcbaj7m10067vgjacsmkbew1","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7ma006hvgja1p38b9mu"},{"post_id":"ckcbaj7m10067vgjacsmkbew1","category_id":"ckcbaj7m8006dvgjae30t37tb","_id":"ckcbaj7mb006kvgjafb0xeyn5"},{"post_id":"ckcbaj7m40069vgjahzxp928p","category_id":"ckcbaj7kk002svgja5oree4fe","_id":"ckcbaj7mc006ovgja9ltz38tb"},{"post_id":"ckcbaj7m40069vgjahzxp928p","category_id":"ckcbaj7m9006fvgja8igx71gg","_id":"ckcbaj7mc006qvgjae3zm75az"},{"post_id":"ckcbaj7m00066vgja98e20ofs","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7md006xvgjaddqv9lfi"},{"post_id":"ckcbaj7m00066vgja98e20ofs","category_id":"ckcbaj7jv000svgja7tpv19ib","_id":"ckcbaj7me006zvgja9uzpeb7w"},{"post_id":"ckcbaj7m00066vgja98e20ofs","category_id":"ckcbaj7m5006avgjad5cafue5","_id":"ckcbaj7me0071vgja6rgw4ety"},{"post_id":"ckcbaj7m00066vgja98e20ofs","category_id":"ckcbaj7mc006nvgja3tqjcggd","_id":"ckcbaj7me0073vgja1ua01xjf"},{"post_id":"ckcbaj7m6006bvgja0d29d4b0","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7me0075vgja6jym7tn6"},{"post_id":"ckcbaj7m6006bvgja0d29d4b0","category_id":"ckcbaj7m8006dvgjae30t37tb","_id":"ckcbaj7me0077vgja6jma3d34"},{"post_id":"ckcbaj7m6006bvgja0d29d4b0","category_id":"ckcbaj7mc006tvgja7stz7y60","_id":"ckcbaj7me0078vgjagsz8fmct"},{"post_id":"ckcbaj7mg007avgja1636brvz","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7mk007jvgja8cqx7dha"},{"post_id":"ckcbaj7mg007avgja1636brvz","category_id":"ckcbaj7mi007evgja1iw06c2y","_id":"ckcbaj7mk007lvgjabd5xbvoz"},{"post_id":"ckcbaj7mg0079vgjabvkbabae","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7mk007nvgja3ybm0ba8"},{"post_id":"ckcbaj7mg0079vgjabvkbabae","category_id":"ckcbaj7mi007cvgja9f2i8wof","_id":"ckcbaj7mk007pvgjac64z5pam"},{"post_id":"ckcbaj7mg0079vgjabvkbabae","category_id":"ckcbaj7mj007gvgja8duz42ou","_id":"ckcbaj7mk007qvgja1uu74rtp"},{"post_id":"ckcbaj7mm007rvgja2nk6etj4","category_id":"ckcbaj7jh0005vgjaf3mxaoew","_id":"ckcbaj7mp007yvgja4fy8awhc"},{"post_id":"ckcbaj7mm007rvgja2nk6etj4","category_id":"ckcbaj7k7001qvgja9ps67mzd","_id":"ckcbaj7mp0080vgja13cb1mto"},{"post_id":"ckcbaj7mm007rvgja2nk6etj4","category_id":"ckcbaj7mo007tvgjaeaff4kto","_id":"ckcbaj7mp0081vgjafz5qaqlb"}],"PostTag":[{"post_id":"ckcbaj7jl0008vgja06sybtvr","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7jn000cvgja5kcs9cfp"},{"post_id":"ckcbaj7jf0003vgjae7r8d0iy","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7jo000evgja699t3dpx"},{"post_id":"ckcbaj7jo000dvgjaa8498xy4","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7jr000ivgja0u2p0b3i"},{"post_id":"ckcbaj7jg0004vgja9pesbh1f","tag_id":"ckcbaj7jn000bvgja89k9cqv5","_id":"ckcbaj7js000kvgjadzl44mgn"},{"post_id":"ckcbaj7jk0007vgja33027yzv","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7ju000pvgja0ipuaj2j"},{"post_id":"ckcbaj7jm0009vgjaegny5rux","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7k20017vgja54zvb36x"},{"post_id":"ckcbaj7jm0009vgjaegny5rux","tag_id":"ckcbaj7jt000nvgja9i6480xb","_id":"ckcbaj7k30019vgja59vi5zyz"},{"post_id":"ckcbaj7jm0009vgjaegny5rux","tag_id":"ckcbaj7jv000tvgja1lmraoja","_id":"ckcbaj7k4001evgjaecwuglet"},{"post_id":"ckcbaj7jm0009vgjaegny5rux","tag_id":"ckcbaj7jy000yvgja0gqw1vbc","_id":"ckcbaj7k5001hvgjac4kf9vsq"},{"post_id":"ckcbaj7jp000fvgjahip84slm","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7kd001xvgja5ggjgaul"},{"post_id":"ckcbaj7jp000fvgjahip84slm","tag_id":"ckcbaj7k10015vgja46yaaqth","_id":"ckcbaj7kd001yvgja5265gw8l"},{"post_id":"ckcbaj7jp000fvgjahip84slm","tag_id":"ckcbaj7k4001dvgja360o3s2g","_id":"ckcbaj7kd0022vgja7f4a8irv"},{"post_id":"ckcbaj7jp000fvgjahip84slm","tag_id":"ckcbaj7k6001lvgja8sdp863p","_id":"ckcbaj7ke0024vgja172z8tpe"},{"post_id":"ckcbaj7jp000fvgjahip84slm","tag_id":"ckcbaj7k8001rvgja8hhc4tr1","_id":"ckcbaj7ke0027vgja7eek38zu"},{"post_id":"ckcbaj7jr000jvgja5imf67pt","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7kh002evgja77rt012a"},{"post_id":"ckcbaj7jr000jvgja5imf67pt","tag_id":"ckcbaj7kc001vvgja2eq5640j","_id":"ckcbaj7kh002fvgjafi8xhlyl"},{"post_id":"ckcbaj7jr000jvgja5imf67pt","tag_id":"ckcbaj7kd0021vgjags4eeohw","_id":"ckcbaj7ki002ivgja8tp67ryi"},{"post_id":"ckcbaj7jr000jvgja5imf67pt","tag_id":"ckcbaj7ke0026vgja2aux3qtc","_id":"ckcbaj7ki002jvgjagitzd6s0"},{"post_id":"ckcbaj7jr000jvgja5imf67pt","tag_id":"ckcbaj7kf0029vgja2ken005n","_id":"ckcbaj7kj002mvgjaelyi7i68"},{"post_id":"ckcbaj7jr000jvgja5imf67pt","tag_id":"ckcbaj7kg002bvgjagh7o9j08","_id":"ckcbaj7kj002nvgja4og446q3"},{"post_id":"ckcbaj7ju000ovgja7vof0z62","tag_id":"ckcbaj7kg002dvgja7v1lguxz","_id":"ckcbaj7kk002qvgjae20agna3"},{"post_id":"ckcbaj7ju000ovgja7vof0z62","tag_id":"ckcbaj7kh002hvgja718a54yp","_id":"ckcbaj7kk002rvgjadrhd4sps"},{"post_id":"ckcbaj7jv000qvgjahqn26zx2","tag_id":"ckcbaj7kg002dvgja7v1lguxz","_id":"ckcbaj7kl002uvgja7ccl1wps"},{"post_id":"ckcbaj7jw000uvgja9tps11em","tag_id":"ckcbaj7kk002pvgjaer793xxw","_id":"ckcbaj7kl002vvgja0csw2osr"},{"post_id":"ckcbaj7jx000vvgja4i9o0zlr","tag_id":"ckcbaj7kk002tvgjacdah2n0f","_id":"ckcbaj7km002yvgjahj8kgc0u"},{"post_id":"ckcbaj7jy000zvgjac9dx3i9k","tag_id":"ckcbaj7kl002xvgjacwns7m3i","_id":"ckcbaj7kn0031vgjaaftgdnhp"},{"post_id":"ckcbaj7jz0011vgja0bgk1ihc","tag_id":"ckcbaj7kn0030vgjafpagbfz1","_id":"ckcbaj7kp0034vgjadorh5e8c"},{"post_id":"ckcbaj7k00013vgjaeo0040q5","tag_id":"ckcbaj7ko0033vgjahgxd293t","_id":"ckcbaj7kp0037vgja8qzs3lq9"},{"post_id":"ckcbaj7k3001avgja4dyg5k5e","tag_id":"ckcbaj7kp0036vgjafmaje67u","_id":"ckcbaj7kr003cvgjagycu9vl9"},{"post_id":"ckcbaj7k4001fvgja2niu2vf0","tag_id":"ckcbaj7kq003avgja60fn56k9","_id":"ckcbaj7ks003hvgjaboq19gh3"},{"post_id":"ckcbaj7k5001ivgjacbqqfpvq","tag_id":"ckcbaj7kr003fvgja7z30bm8b","_id":"ckcbaj7ks003mvgjaa9laez7a"},{"post_id":"ckcbaj7k6001mvgja0fcz4189","tag_id":"ckcbaj7kr003fvgja7z30bm8b","_id":"ckcbaj7kv003zvgjadlfj8yr8"},{"post_id":"ckcbaj7k6001mvgja0fcz4189","tag_id":"ckcbaj7kt003pvgjaciki2fus","_id":"ckcbaj7kv0040vgjagch7ahjo"},{"post_id":"ckcbaj7k6001mvgja0fcz4189","tag_id":"ckcbaj7ku003tvgjacb5r93j9","_id":"ckcbaj7kw0043vgja4zsnehym"},{"post_id":"ckcbaj7k7001ovgjaf5z0ag3v","tag_id":"ckcbaj7kv003xvgja7p4u917i","_id":"ckcbaj7kx0045vgja36gsadga"},{"post_id":"ckcbaj7li004ovgja9jpvha7s","tag_id":"ckcbaj7ko0033vgjahgxd293t","_id":"ckcbaj7lk004svgjafx926ohf"},{"post_id":"ckcbaj7lf004jvgjaa0hoh8uv","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7lk004tvgjaf229390e"},{"post_id":"ckcbaj7lf004jvgjaa0hoh8uv","tag_id":"ckcbaj7lh004lvgja0z0fck3j","_id":"ckcbaj7ll004xvgja5l157knl"},{"post_id":"ckcbaj7lg004kvgja2tug5tui","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7lm0052vgjabo8b5lg2"},{"post_id":"ckcbaj7lg004kvgja2tug5tui","tag_id":"ckcbaj7lk004qvgja2l8i85bm","_id":"ckcbaj7lm0054vgja6qeh9khl"},{"post_id":"ckcbaj7lg004kvgja2tug5tui","tag_id":"ckcbaj7ll004vvgjagfai72wg","_id":"ckcbaj7lm0058vgja53xohpc5"},{"post_id":"ckcbaj7lh004mvgja3rm4g69k","tag_id":"ckcbaj7kk002pvgjaer793xxw","_id":"ckcbaj7ln005avgja6vwdglkn"},{"post_id":"ckcbaj7lh004mvgja3rm4g69k","tag_id":"ckcbaj7ll0050vgjaf4jc7wa7","_id":"ckcbaj7ln005dvgja1hvw7rkh"},{"post_id":"ckcbaj7lj004pvgjacuwm20a3","tag_id":"ckcbaj7kr003fvgja7z30bm8b","_id":"ckcbaj7lo005gvgja7wundx18"},{"post_id":"ckcbaj7lj004pvgjacuwm20a3","tag_id":"ckcbaj7lm0056vgjad62hdk38","_id":"ckcbaj7lo005hvgjaathcgu17"},{"post_id":"ckcbaj7lj004pvgjacuwm20a3","tag_id":"ckcbaj7ln005cvgjad8bc1gkq","_id":"ckcbaj7lo005ivgja4ajy7afh"},{"post_id":"ckcbaj7lq005mvgja8vv73jz7","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7ls005ovgjaad324nn6"},{"post_id":"ckcbaj7lq005mvgja8vv73jz7","tag_id":"ckcbaj7lk004qvgja2l8i85bm","_id":"ckcbaj7lt005rvgja6osp4dfy"},{"post_id":"ckcbaj7lq005mvgja8vv73jz7","tag_id":"ckcbaj7ll004vvgjagfai72wg","_id":"ckcbaj7lt005tvgjahyelejid"},{"post_id":"ckcbaj7lr005nvgjad9ex18l8","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7lu005vvgjadi177kry"},{"post_id":"ckcbaj7lr005nvgjad9ex18l8","tag_id":"ckcbaj7kg002bvgjagh7o9j08","_id":"ckcbaj7lu005wvgja5hn24qxc"},{"post_id":"ckcbaj7ls005pvgja5k1x7s5j","tag_id":"ckcbaj7kr003fvgja7z30bm8b","_id":"ckcbaj7lu005zvgjahkow5c4y"},{"post_id":"ckcbaj7ls005pvgja5k1x7s5j","tag_id":"ckcbaj7lt005svgjacshz3eu2","_id":"ckcbaj7lu0061vgja7s4e9tbv"},{"post_id":"ckcbaj7m00066vgja98e20ofs","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7mb006jvgja37orcgzp"},{"post_id":"ckcbaj7m00066vgja98e20ofs","tag_id":"ckcbaj7m40068vgja75ca9afg","_id":"ckcbaj7mb006lvgjagomx3vag"},{"post_id":"ckcbaj7m00066vgja98e20ofs","tag_id":"ckcbaj7m7006cvgjafajz9xgi","_id":"ckcbaj7mc006pvgja133r19hl"},{"post_id":"ckcbaj7m00066vgja98e20ofs","tag_id":"ckcbaj7m9006evgjaclloc6zs","_id":"ckcbaj7mc006rvgjaegw5bl0q"},{"post_id":"ckcbaj7m10067vgjacsmkbew1","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7md006uvgja3hhhbf76"},{"post_id":"ckcbaj7m10067vgjacsmkbew1","tag_id":"ckcbaj7ma006gvgja7rbob7ck","_id":"ckcbaj7md006vvgja0wjjeykl"},{"post_id":"ckcbaj7m40069vgjahzxp928p","tag_id":"ckcbaj7kr003fvgja7z30bm8b","_id":"ckcbaj7md006yvgja8d0710g3"},{"post_id":"ckcbaj7m40069vgjahzxp928p","tag_id":"ckcbaj7mb006mvgjaeey85oll","_id":"ckcbaj7me0070vgja05wcenyh"},{"post_id":"ckcbaj7m6006bvgja0d29d4b0","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7me0072vgjadw9sewl5"},{"post_id":"ckcbaj7m6006bvgja0d29d4b0","tag_id":"ckcbaj7ma006gvgja7rbob7ck","_id":"ckcbaj7me0074vgja4qkx98sy"},{"post_id":"ckcbaj7m6006bvgja0d29d4b0","tag_id":"ckcbaj7md006wvgja2041gape","_id":"ckcbaj7me0076vgja8orvfkj7"},{"post_id":"ckcbaj7mg0079vgjabvkbabae","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7mj007hvgjaha849mpf"},{"post_id":"ckcbaj7mg0079vgjabvkbabae","tag_id":"ckcbaj7mh007bvgjaacmm6vrl","_id":"ckcbaj7mj007ivgjabr71482y"},{"post_id":"ckcbaj7mg0079vgjabvkbabae","tag_id":"ckcbaj7mi007dvgja4pvagd90","_id":"ckcbaj7mk007kvgjab7lvas8w"},{"post_id":"ckcbaj7mg007avgja1636brvz","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7mk007mvgjacb9v9e8q"},{"post_id":"ckcbaj7mg007avgja1636brvz","tag_id":"ckcbaj7mj007fvgja0bi30kzs","_id":"ckcbaj7mk007ovgjadwa0ewop"},{"post_id":"ckcbaj7mm007rvgja2nk6etj4","tag_id":"ckcbaj7jj0006vgjaewn36l6h","_id":"ckcbaj7mo007svgja3jfrgxe2"},{"post_id":"ckcbaj7mm007rvgja2nk6etj4","tag_id":"ckcbaj7kc001vvgja2eq5640j","_id":"ckcbaj7mo007uvgja4pd0dt9h"},{"post_id":"ckcbaj7mm007rvgja2nk6etj4","tag_id":"ckcbaj7kd0021vgjags4eeohw","_id":"ckcbaj7mp007vvgja3wlv50z5"},{"post_id":"ckcbaj7mm007rvgja2nk6etj4","tag_id":"ckcbaj7ke0026vgja2aux3qtc","_id":"ckcbaj7mp007wvgja7leif7a0"},{"post_id":"ckcbaj7mm007rvgja2nk6etj4","tag_id":"ckcbaj7kf0029vgja2ken005n","_id":"ckcbaj7mp007xvgja8qz2ex98"},{"post_id":"ckcbaj7mm007rvgja2nk6etj4","tag_id":"ckcbaj7kg002bvgjagh7o9j08","_id":"ckcbaj7mp007zvgja7tpb2wv4"}],"Tag":[{"name":"java","_id":"ckcbaj7jj0006vgjaewn36l6h"},{"name":"区块链","_id":"ckcbaj7jn000bvgja89k9cqv5"},{"name":"jdk8","_id":"ckcbaj7jt000nvgja9i6480xb"},{"name":"lambda","_id":"ckcbaj7jv000tvgja1lmraoja"},{"name":"function/函数式编程","_id":"ckcbaj7jy000yvgja0gqw1vbc"},{"name":"proxy","_id":"ckcbaj7k10015vgja46yaaqth"},{"name":"javassist","_id":"ckcbaj7k4001dvgja360o3s2g"},{"name":"jdk 动态代理","_id":"ckcbaj7k6001lvgja8sdp863p"},{"name":"cglib 动态代理","_id":"ckcbaj7k8001rvgja8hhc4tr1"},{"name":"thread","_id":"ckcbaj7kc001vvgja2eq5640j"},{"name":"synchronized/lock","_id":"ckcbaj7kd0021vgjags4eeohw"},{"name":"ThreadPoolExecutor","_id":"ckcbaj7ke0026vgja2aux3qtc"},{"name":"fork/join","_id":"ckcbaj7kf0029vgja2ken005n"},{"name":"schedule","_id":"ckcbaj7kg002bvgjagh7o9j08"},{"name":"linux","_id":"ckcbaj7kg002dvgja7v1lguxz"},{"name":"openssl","_id":"ckcbaj7kh002hvgja718a54yp"},{"name":"分布式与微服务","_id":"ckcbaj7kk002pvgjaer793xxw"},{"name":"中间件","_id":"ckcbaj7kk002tvgjacdah2n0f"},{"name":"ORM","_id":"ckcbaj7kl002xvgjacwns7m3i"},{"name":"包管理","_id":"ckcbaj7kn0030vgjafpagbfz1"},{"name":"项目","_id":"ckcbaj7ko0033vgjahgxd293t"},{"name":"spring","_id":"ckcbaj7kp0036vgjafmaje67u"},{"name":"服务器","_id":"ckcbaj7kq003avgja60fn56k9"},{"name":"数据库","_id":"ckcbaj7kr003fvgja7z30bm8b"},{"name":"b+ tree","_id":"ckcbaj7kt003pvgjaciki2fus"},{"name":"b tree","_id":"ckcbaj7ku003tvgjacb5r93j9"},{"name":"数据结构与算法","_id":"ckcbaj7kv003xvgja7p4u917i"},{"name":"jvm工具","_id":"ckcbaj7lh004lvgja0z0fck3j"},{"name":"io","_id":"ckcbaj7lk004qvgja2l8i85bm"},{"name":"nio","_id":"ckcbaj7ll004vvgjagfai72wg"},{"name":"dubbo 配置","_id":"ckcbaj7ll0050vgjaf4jc7wa7"},{"name":"MySql","_id":"ckcbaj7lm0056vgjad62hdk38"},{"name":"MVCC多版本并发控制","_id":"ckcbaj7ln005cvgjad8bc1gkq"},{"name":"MySQL","_id":"ckcbaj7lt005svgjacshz3eu2"},{"name":"collection","_id":"ckcbaj7m40068vgja75ca9afg"},{"name":"disruptor","_id":"ckcbaj7m7006cvgjafajz9xgi"},{"name":"队列","_id":"ckcbaj7m9006evgjaclloc6zs"},{"name":"memory","_id":"ckcbaj7ma006gvgja7rbob7ck"},{"name":"分库分表方案","_id":"ckcbaj7mb006mvgjaeey85oll"},{"name":"garbage","_id":"ckcbaj7md006wvgja2041gape"},{"name":"concurrent","_id":"ckcbaj7mh007bvgjaacmm6vrl"},{"name":"AQS","_id":"ckcbaj7mi007dvgja4pvagd90"},{"name":"thread-pool","_id":"ckcbaj7mj007fvgja0bi30kzs"}]}}