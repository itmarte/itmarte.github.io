<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Marte 的it人生</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Marte 的个人博客,学习笔记,java,框架,springBoot,MQ,kafka,elastic job,undertow,OAuth2,JVM">
<meta property="og:type" content="website">
<meta property="og:title" content="Marte 的it人生">
<meta property="og:url" content="http://blob.itmarte.com/page/2/index.html">
<meta property="og:site_name" content="Marte 的it人生">
<meta property="og:description" content="Marte 的个人博客,学习笔记,java,框架,springBoot,MQ,kafka,elastic job,undertow,OAuth2,JVM">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="marte">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="java">
<meta property="article:tag" content="框架">
<meta property="article:tag" content="springBoot">
<meta property="article:tag" content="MQ">
<meta property="article:tag" content="kafka">
<meta property="article:tag" content="elastic job">
<meta property="article:tag" content="undertow">
<meta property="article:tag" content="OAuth2">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Marte 的it人生" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Marte 的it人生</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Marte 的个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/categories%20/%E5%88%86%E7%B1%BB">分类</a>
        
          <a class="main-nav-link" href="/tags%20%20%20/%E6%A0%87%E7%AD%BE">标签</a>
        
          <a class="main-nav-link" href="/about%20%20%20/%E5%85%B3%E4%BA%8E">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blob.itmarte.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java/IO-NIO" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/20/java/IO-NIO/" class="article-date">
  <time datetime="2020-05-20T08:19:27.000Z" itemprop="datePublished">2020-05-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/IO-NIO/">IO/NIO</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/20/java/IO-NIO/">Java IO/NIO 对比</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-NIO-Buffer-Channel-及-Selector"><a href="#Java-NIO-Buffer-Channel-及-Selector" class="headerlink" title="Java NIO Buffer, Channel 及 Selector"></a>Java NIO Buffer, Channel 及 Selector</h1><h2 id="Java-IO-VS-NIO"><a href="#Java-IO-VS-NIO" class="headerlink" title="Java IO VS NIO"></a>Java IO VS NIO</h2><ul>
<li><p>JDK 1.4 之前，java.io 包，</p>
<p>面向流的I/O系统</p>
<p>（字节流或者字符流）</p>
<ul>
<li>系统一次处理一个字节</li>
<li>速度慢</li>
</ul>
</li>
<li><p>JDK 1.4 提供，java.nio 包，</p>
<p>面向块的I/O系统</p>
<ul>
<li>系统一次处理一个块</li>
<li>速度快</li>
</ul>
<p>​</p>
<p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区),Selector。</p>
<p>​       传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p>
<p>NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。</p>
</li>
</ul>
<h2 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区"></a>Buffer 缓冲区</h2><p>缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组。<br>在 NIO 库中，所有数据都是用缓冲区处理的：</p>
<ul>
<li>在读取数据时，它是直接读到缓冲区中的；</li>
<li>在写入数据时，它也是写入到缓冲区中的；</li>
</ul>
<p>在 NIO 中，所有的缓冲区类型都继承于抽象类 Buffer。常见的缓冲区 Buffer 包括：</p>
<ul>
<li><p>ByteBuffer 存储了字节数组 <code>final byte[] hb;</code></p>
</li>
<li><p>CharBuffer </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">char</span>[] hb;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ByteBuffer 与 CharBuffer 之间的转换需要使用字符集 Charset</strong></li>
<li>Charset 具体使用，参见 <a href="https://www.jianshu.com/p/1c61e001b609" target="_blank" rel="noopener">Java Charset 字符集</a></li>
</ul>
</li>
<li><p>ShortBuffer <code>final short[] hb;</code></p>
</li>
<li><p>IntBuffer <code>final int[] hb;</code></p>
</li>
<li><p>LongBuffer <code>final long[] hb;</code></p>
</li>
<li><p>FloatBuffer <code>final float[] hb;</code></p>
</li>
<li><p>DoubleBuffer <code>final double[] hb;</code></p>
</li>
</ul>
<p>Buffer 类的属性：</p>
<ul>
<li><code>private int mark = -1;</code> 记录一个标记位置</li>
<li><code>private int position = 0;</code></li>
</ul>
<blockquote>
<p>A buffer’s <i>position</i> is the index of the next element to be read or written.  A buffer’s position is never negative and is never greater than its limit.<br>当前操作的位置</p>
</blockquote>
<ul>
<li><code>private int limit;</code></li>
</ul>
<blockquote>
<p>A buffer’s <i>limit</i> is the index of the first element that should not be read or written.  A buffer’s limit is never negative and is never greater than its capacity.<br>可以存放的元素的个数</p>
</blockquote>
<ul>
<li><code>private int capacity;</code></li>
</ul>
<blockquote>
<p>A buffer’s <i>capacity</i> is the number of elements it contains.  The capacity of a buffer is never negative and never changes.<br>数组容量</p>
</blockquote>
<ul>
<li>大小关系：<strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></li>
</ul>
<p>Buffer 类的方法：</p>
<ul>
<li><code>allocate(int capacity)</code> 分配一个缓冲区，默认 limit = capacity</li>
<li><code>put()</code> 在当前位置添加元素</li>
<li><code>get()</code> 得到当前位置的元素</li>
<li><code>clear()</code> 将 Buffer 从 读模式 切换到 写模式 （该方法实际不会清空原 Buffer 的内容）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>flip()</code>  将 Buffer 从 写模式 切换到 读模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** <code>clear()</code> VS <code>flip()</code>**：</p>
<ul>
<li>在写模式下，Buffer 的 limit 表示你最多能往 Buffer 里写多少数据。<ul>
<li>因此写之前，调用 <code>clear()</code>，使得 <code>limit = capacity;</code></li>
</ul>
</li>
<li>在读模式时，Buffer 的 limit 表示你最多能从 Buffer 里读多少数据。<ul>
<li>因此读之前，调用 <code>flip()</code>，使得 <code>limit = position;</code></li>
</ul>
</li>
</ul>
<p>IntBuffer 的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 int 缓冲区 capacity 为 4</span></span><br><span class="line">    <span class="comment">// 默认 limit = capacity</span></span><br><span class="line">    IntBuffer buffer = IntBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">"Capacity &amp; Limit: "</span> + buffer.capacity() + <span class="string">" "</span> + buffer.limit());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 Buffer 中写数据</span></span><br><span class="line">    buffer.put(<span class="number">11</span>);</span><br><span class="line">    buffer.put(<span class="number">22</span>);</span><br><span class="line">    buffer.put(<span class="number">33</span>);</span><br><span class="line">    buffer.put(<span class="number">44</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Position: "</span> + buffer.position());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">        System.out.print(buffer.get() + <span class="string">"  "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>Capacity &amp; Limit: 4 4<br>Position: 4<br>11  22  33  44</p>
</blockquote>
<h2 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel 通道"></a>Channel 通道</h2><ul>
<li>Java NIO 的核心概念，表示的是对支持 I/O 操作的实体的一个连接</li>
<li>通过它可以读取和写入数据（并不是直接操作，而是通过 Buffer 来处理）</li>
<li>双向的</li>
</ul>
<p>常用的 Channel 包括：</p>
<ul>
<li>FileChannel 从文件中读写数据</li>
<li>DatagramChannel 从 UDP 中读写数据</li>
<li>SocketChannel 从 TCP 中读写数据</li>
<li>ServerSocketChannel 监听新进来的 TCP 连接，每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<h3 id="FileChannel-连接到文件的通道"><a href="#FileChannel-连接到文件的通道" class="headerlink" title="FileChannel 连接到文件的通道"></a>FileChannel 连接到文件的通道</h3><p><strong>FileChannel 无法设置为非阻塞模式，只能运行在阻塞模式下</strong><br>常用方法：</p>
<ul>
<li><code>int read(ByteBuffer dst)</code> 从 Channel 中读取数据，写入 Buffer</li>
<li><code>int write(ByteBuffer src)</code> 从 Buffer 中读取数据，写入 Channel</li>
<li><code>long size()</code> 得到 Channel 中文件的大小</li>
<li><code>long position()</code> 得到 Channel 中文件的当前操作位置</li>
<li><code>FileChannel position(long newPosition)</code> 设置 Channel 中文件的当前操作位置</li>
</ul>
<p>使用 FileChannel 来复制文件的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 InputStream 或者 OutputStream 来构造 FileChannel</span></span><br><span class="line">    FileChannel in = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>).getChannel();</span><br><span class="line">    FileChannel out = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>).getChannel();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 channel 的 read 方法往 Buffer 中写数据</span></span><br><span class="line">    <span class="keyword">while</span>(in.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 从 Buffer 中读数据，写入到 channel</span></span><br><span class="line">        out.write(buffer);</span><br><span class="line">        <span class="comment">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用如下代码</span></span><br><span class="line">    <span class="comment">// out.transferFrom(in, 0, in.size());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SocketChannel-连接到-TCP-套接字的通道"><a href="#SocketChannel-连接到-TCP-套接字的通道" class="headerlink" title="SocketChannel 连接到 TCP 套接字的通道"></a>SocketChannel 连接到 TCP 套接字的通道</h3><p><strong>SocketChannel 可以设置为阻塞模式或非阻塞模式</strong><br>使用 SocketChannel 来建立 TCP 连接，发送并接收数据，默认使用 <strong>阻塞模式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 打开 SocketChannel</span></span><br><span class="line">    SocketChannel channel = SocketChannel.open();</span><br><span class="line">    <span class="comment">// connect 方法会阻塞，直至连接建立成功</span></span><br><span class="line">    channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    String msg = <span class="string">"This is client."</span>;</span><br><span class="line">    <span class="comment">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class="line">    buffer.clear();</span><br><span class="line">    buffer.put(msg.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    channel.write(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="comment">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class="line">    buffer.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 channel 的 read 方法往 Buffer 中写数据</span></span><br><span class="line">    channel.read(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 Buffer 中读数据</span></span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">        System.out.print(buffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 SocketChannel 的 <strong>非阻塞模式</strong> 来建立 TCP 连接，发送并接收数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 打开 SocketChannel</span></span><br><span class="line">    SocketChannel channel = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">    channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!channel.finishConnect()) &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        String msg = <span class="string">"This is client."</span>;</span><br><span class="line">        <span class="comment">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">        buffer.put(msg.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        channel.write(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="comment">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class="line">        buffer.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 channel 的 read 方法往 Buffer 中写数据</span></span><br><span class="line">        channel.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 Buffer 中读数据</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.print(buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ServerSocketChannel-监听-TCP-连接的通道"><a href="#ServerSocketChannel-监听-TCP-连接的通道" class="headerlink" title="ServerSocketChannel 监听 TCP 连接的通道"></a>ServerSocketChannel 监听 TCP 连接的通道</h3><p><strong>ServerSocketChannel 可以设置为阻塞模式或非阻塞模式</strong><br>使用 ServerSocketChannel 来监听 TCP 连接，默认使用 <strong>阻塞模式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 打开 SocketChannel</span></span><br><span class="line">    ServerSocketChannel channel = ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// accept 方法会阻塞，直至监听到 TCP 连接</span></span><br><span class="line">        SocketChannel socketChannel = channel.accept();</span><br><span class="line">        System.out.println(<span class="string">"A new connection..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="comment">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class="line">        buffer.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 channel 的 read 方法往 Buffer 中写数据</span></span><br><span class="line">        socketChannel.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 Buffer 中读数据</span></span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.print(buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        String msg = <span class="string">"This is server."</span>;</span><br><span class="line">        <span class="comment">// 在往 Buffer 中写数据之前，调用 clear()</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">        buffer.put(msg.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在从 Buffer 中读数据之前，调用 flip()</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector 选择器"></a>Selector 选择器</h2><p><strong>Selector 允许单个进程可以同时处理多个网络连接的 IO，即监听多个端口的 Channel</strong>。</p>
<p><strong>关于 IO 模式，参见 Linux IO 模型 中对多路复用 IO Multiplexing IO 的说明。</strong></p>
<p>引用：</p>
<hr>
<h2 id="多路复用-IO-Multiplexing-IO"><a href="#多路复用-IO-Multiplexing-IO" class="headerlink" title="多路复用 IO Multiplexing IO"></a>多路复用 IO Multiplexing IO</h2><ul>
<li><strong>单个进程可以同时处理多个网络连接的 IO，即监听多个端口的 IO</strong></li>
<li>适用于连接数很高的情况</li>
<li>实现方式：select，poll，epoll 系统调用<ul>
<li>注册多个端口的监听 Socket，比如 8080，8081</li>
<li>当用户进程调用 select 方法后，整个用户进程被阻塞，OS 内核会监听所有注册的 Socket</li>
<li>当任何一个端口的 Socket 中的数据准备好了（ 8080 或者 8081），select 方法就会返回</li>
<li>随后用户进程再调用 read 操作，将数据从 OS 内核缓存区拷贝到应用程序的地址空间。</li>
</ul>
</li>
<li>多路复用 IO 类似于 多线程结合阻塞 IO<ul>
<li>要实现监听多个端口的 IO，还可以通过多线程的方式，每一个线程负责监听一个端口的 IO</li>
<li>如果处理的连接数不是很高的话，使用 多路复用 IO 不一定比使用 <strong>多线程结合阻塞 IO</strong> 的服务器性能更好，可能延迟还更大</li>
<li>多路复用 IO 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Selector 使用步骤：</strong></p>
<ul>
<li><p><strong>创建 Selector</strong></p>
</li>
<li><p><strong>创建 Channel</strong>，可以创建多个 Channel，即监听多个端口，比如 8080，8081</p>
</li>
<li><p>将 Channel 注册到 Selector 中</p>
<ul>
<li><p>如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的, 即 <code>channel.configureBlocking(false);</code></p>
</li>
<li><p>因此 FileChannel 是不能够使用 Selector 的, 因为 FileChannel 都是阻塞的</p>
</li>
<li><p>注册时，需要指定了对 Channel 的什么事件感兴趣，包括：</p>
<ul>
<li>SelectionKey.OP_CONNECT：TCP 连接 <code>static final int OP_CONNECT = 1 &lt;&lt; 3;</code></li>
<li>SelectionKey.OP_ACCEPT：确认 <code>static final int OP_ACCEPT = 1 &lt;&lt; 4;</code></li>
<li>SelectionKey.OP_READ：读 <code>static final int OP_READ = 1 &lt;&lt; 0;</code></li>
<li>SelectionKey.OP_WRITE：写 <code>static final int OP_WRITE = 1 &lt;&lt; 2;</code></li>
<li>可以使用或运算 <strong>|</strong> 来组合，例如 <code>SelectionKey.OP_READ | SelectionKey.OP_WRITE</code></li>
</ul>
</li>
<li><p>register 方法返回一个 SelectionKey 对象，包括：</p>
<ul>
<li><p><code>int interestOps()</code>：调用 register 注册 channel 时所设置的 interest set.</p>
</li>
<li><p>```java<br>int readyOps()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      ：Channel 所准备好了的操作</span><br><span class="line"></span><br><span class="line">      - &#96;selectionKey.isAcceptable();&#96;</span><br><span class="line">      - &#96;selectionKey.isConnectable();&#96;</span><br><span class="line">      - &#96;selectionKey.isReadable();&#96;</span><br><span class="line">      - &#96;selectionKey.isWritable();&#96;</span><br><span class="line"></span><br><span class="line">    - &#96;public abstract SelectableChannel channel();&#96;： 得到 Channel</span><br><span class="line"></span><br><span class="line">    - &#96;public abstract Selector selector();&#96;：得到 Selector</span><br><span class="line"></span><br><span class="line">    - &#96;public final Object attachment&#96;：得到附加对象</span><br><span class="line"></span><br><span class="line">- 不断重复：</span><br><span class="line"></span><br><span class="line">  - 调用 Selector 对象的 select() 方法，**该方法会阻塞，直至注册的事件发生**</span><br><span class="line">  - **事件发生**，调用 Selector 对象的 selectedKeys() 方法获取 selected keys</span><br><span class="line">  - 遍历每个 selected key:</span><br><span class="line">    - 从 selected key 中获取对应的 Channel 并处理</span><br><span class="line">    - 在 OP_ACCEPT 事件中, 从 key.channel() 返回的是 ServerSocketChannel</span><br><span class="line">    - 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel</span><br><span class="line"></span><br><span class="line">- **关闭 Selector**</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public static void main(String args[]) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建 Selector</span><br><span class="line">    Selector selector &#x3D; Selector.open();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建 Server Socket，监听端口 8080</span><br><span class="line">    ServerSocketChannel serverChannel1 &#x3D; ServerSocketChannel.open();</span><br><span class="line">    serverChannel1.socket().bind(new InetSocketAddress(8080));</span><br><span class="line">    &#x2F;&#x2F; 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的</span><br><span class="line">    serverChannel1.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建 Server Socket，监听端口 8081</span><br><span class="line">    ServerSocketChannel serverChannel2 &#x3D; ServerSocketChannel.open();</span><br><span class="line">    serverChannel2.socket().bind(new InetSocketAddress(8081));</span><br><span class="line">    &#x2F;&#x2F; 如果一个 Channel 要注册到 Selector 中, 那么这个 Channel 必须是非阻塞的</span><br><span class="line">    serverChannel2.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将 Channel 注册到 Selector 中</span><br><span class="line">    serverChannel1.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    serverChannel2.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 不断重复</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用 Selector 对象的 select() 方法，该方法会阻塞，直至注册的事件发生</span><br><span class="line">        selector.select();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 事件发生，调用 Selector 对象的 selectedKeys() 方法获取 selected keys</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 遍历每个 selected key:</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            SelectionKey key &#x3D; it.next();</span><br><span class="line"></span><br><span class="line">            if (key.isAcceptable()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 在 OP_ACCEPT 事件中, 从 key.channel() 返回的是 ServerSocketChannel</span><br><span class="line">                ServerSocketChannel serverChannel &#x3D; (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 调用 accept 方法获取 TCP 连接 SocketChanne</span><br><span class="line">                SocketChannel clientChannel &#x3D; serverChannel.accept();</span><br><span class="line">                clientChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 注册 SocketChannel</span><br><span class="line">                clientChannel.register(key.selector(), SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;Accept event&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (key.isReadable()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel</span><br><span class="line">                SocketChannel clientChannel &#x3D; (SocketChannel) key.channel();</span><br><span class="line">                System.out.println(&quot;Read event&quot;);</span><br><span class="line">                &#x2F;&#x2F; 可以从 clientChannel 中读数据，通过 ByteBuffer</span><br><span class="line">                &#x2F;&#x2F; TO DO</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (key.isWritable()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 在 OP_WRITE 和 OP_READ 事件中, 从 key.channel() 返回的是 SocketChannel</span><br><span class="line">                SocketChannel clientChannel &#x3D; (SocketChannel) key.channel();</span><br><span class="line">                System.out.println(&quot;Write event&quot;);</span><br><span class="line">                &#x2F;&#x2F; 可以向 clientChannel 中写数据，通过 ByteBuffer</span><br><span class="line">                &#x2F;&#x2F; TO DO</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blob.itmarte.com/2020/05/20/java/IO-NIO/" data-id="ckc4mb0oz005j3wja139l0bow" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/io/" rel="tag">io</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nio/" rel="tag">nio</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/IO-NIO-reader-line" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/20/java/IO-NIO-reader-line/" class="article-date">
  <time datetime="2020-05-20T06:48:27.000Z" itemprop="datePublished">2020-05-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/read-line/">read line</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/20/java/IO-NIO-reader-line/">scanner、buffer reader、jdk8 stream、apache common io 效率对比</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="文件行读效率测试"><a href="#文件行读效率测试" class="headerlink" title="文件行读效率测试"></a>文件行读效率测试</h2><h2 id="scanner、buffer-reader、jdk8-stream、apache-common-io"><a href="#scanner、buffer-reader、jdk8-stream、apache-common-io" class="headerlink" title="scanner、buffer reader、jdk8 stream、apache common io"></a>scanner、buffer reader、jdk8 stream、apache common io</h2><h3 id="一、先看下代码"><a href="#一、先看下代码" class="headerlink" title="一、先看下代码"></a>一、先看下代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(FILE_PATH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// scanner</span></span><br><span class="line">        System.out.println(<span class="string">"------------************************-------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;scanner 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line">        Long cur = System.currentTimeMillis();</span><br><span class="line">        scanner(file);</span><br><span class="line">        System.out.println(<span class="string">"scanner 耗时["</span> + (System.currentTimeMillis() - cur) + <span class="string">"]ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;scanner 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">        System.out.println(<span class="string">"------------************************-------------"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// buffer reader</span></span><br><span class="line">        System.out.println(<span class="string">"------------************************-------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;buffer reader 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line">        cur = System.currentTimeMillis();</span><br><span class="line">        bufferReader(file);</span><br><span class="line">        System.out.println(<span class="string">"buffer reader 耗时["</span> + (System.currentTimeMillis() - cur) + <span class="string">"]ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;buffer reader 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">        System.out.println(<span class="string">"------------************************-------------"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JDK8</span></span><br><span class="line">        System.out.println(<span class="string">"------------************************-------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;JDK8 stream开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line">        cur = System.currentTimeMillis();</span><br><span class="line">        jdk8Reader(FILE_PATH);</span><br><span class="line">        System.out.println(<span class="string">"JDK8 stream 耗时["</span> + (System.currentTimeMillis() - cur) + <span class="string">"]ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;JDK8 stream 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">        System.out.println(<span class="string">"------------************************-------------"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// apache common io</span></span><br><span class="line">        System.out.println(<span class="string">"------------************************-------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;apache common io &gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line">        cur = System.currentTimeMillis();</span><br><span class="line">        commonIo(file);</span><br><span class="line">        System.out.println(<span class="string">"apache common io 耗时["</span> + (System.currentTimeMillis() - cur) + <span class="string">"]ms"</span>);</span><br><span class="line">        System.out.println(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;apache common io 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">        System.out.println(<span class="string">"------------************************-------------"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commonIo</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> (LineIterator lineIterator = FileUtils.lineIterator(file, <span class="string">"UTF-8"</span>)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lineIterator.hasNext()) &#123;</span><br><span class="line">                lineIterator.next();</span><br><span class="line">                total += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"[总行数]:"</span> + total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDK8</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jdk8Reader</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// Files.readAllLine 内部使用的是buffer reader</span></span><br><span class="line"><span class="comment">//        Files.readAllLines(file.toPath());</span></span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;String&gt; stream = Files.lines(Paths.get(filePath), StandardCharsets.UTF_8)) &#123;</span><br><span class="line">            total = stream.reduce(<span class="number">0</span>, (cur, op) -&gt; cur + <span class="number">1</span>, (a, b) -&gt; a + b);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"[总行数]:"</span> + total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * buffer reader</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bufferReader</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file))) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String line; (line = br.readLine()) != <span class="keyword">null</span>; total++);</span><br><span class="line">            <span class="comment">// line is not visible here.</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"[总行数]:"</span> + total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scanner</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>(Scanner scanner = <span class="keyword">new</span> Scanner(file))&#123;</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">                scanner.nextLine();</span><br><span class="line">                total+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"[总行数]:"</span> + total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="100W条真实数据测试结果："><a href="#100W条真实数据测试结果：" class="headerlink" title="100W条真实数据测试结果："></a>100W条真实数据测试结果：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">------------************************-------------</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;scanner 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">[总行数]:<span class="number">1056322</span></span><br><span class="line">scanner 耗时[<span class="number">8379</span>]ms</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;scanner 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">------------************************-------------</span><br><span class="line">    </span><br><span class="line">------------************************-------------</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;buffer reader 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">[总行数]:<span class="number">1056322</span></span><br><span class="line">buffer reader 耗时[<span class="number">901</span>]ms</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;buffer reader 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">------------************************-------------</span><br><span class="line">    </span><br><span class="line">------------************************-------------</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;JDK8 stream开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">[总行数]:<span class="number">1056322</span></span><br><span class="line">JDK8 stream 耗时[<span class="number">916</span>]ms</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;JDK8 stream 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">------------************************-------------</span><br><span class="line">    </span><br><span class="line">------------************************-------------</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;apache common io &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">[总行数]:<span class="number">1056322</span></span><br><span class="line">apache common io 耗时[<span class="number">929</span>]ms</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;apache common io 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">------------************************-------------</span><br></pre></td></tr></table></figure>

<h4 id="1000W条真实数据测试结果："><a href="#1000W条真实数据测试结果：" class="headerlink" title="1000W条真实数据测试结果："></a>1000W条真实数据测试结果：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">------------************************-------------</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;scanner 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">[总行数]:<span class="number">10563211</span></span><br><span class="line">scanner 耗时[<span class="number">79109</span>]ms</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;scanner 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">------------************************-------------</span><br><span class="line"></span><br><span class="line">------------************************-------------</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;buffer reader 开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">[总行数]:<span class="number">10563211</span></span><br><span class="line">buffer reader 耗时[<span class="number">8477</span>]ms</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;buffer reader 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">------------************************-------------</span><br><span class="line"></span><br><span class="line">------------************************-------------</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;JDK8 stream开始 &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">[总行数]:<span class="number">10563211</span></span><br><span class="line">JDK8 stream 耗时[<span class="number">8623</span>]ms</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;JDK8 stream 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">------------************************-------------</span><br><span class="line"></span><br><span class="line">------------************************-------------</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;apache common io &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">[总行数]:<span class="number">10563211</span></span><br><span class="line">apache common io 耗时[<span class="number">8573</span>]ms</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;apache common io 结束 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">------------************************-------------</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>scanner：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tries to read more input. May block.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buf.limit() == buf.capacity())</span><br><span class="line">        makeSpace();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare to receive data</span></span><br><span class="line">    <span class="keyword">int</span> p = buf.position();</span><br><span class="line">    buf.position(buf.limit());</span><br><span class="line">    buf.limit(buf.capacity());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        n = source.read(buf);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        lastException = ioe;</span><br><span class="line">        n = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">        sourceClosed = <span class="keyword">true</span>;</span><br><span class="line">        needInput = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        needInput = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore current position and limit for reading</span></span><br><span class="line">    buf.limit(buf.position());</span><br><span class="line">    buf.position(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>buffer reader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始大小为8192字节</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> defaultCharBufferSize = <span class="number">8192</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> defaultExpectedLineLength = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">(<span class="keyword">boolean</span> ignoreLF)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    StringBuffer s = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> startChar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        ensureOpen();</span><br><span class="line">        <span class="keyword">boolean</span> omitLF = ignoreLF || skipLF;</span><br><span class="line"></span><br><span class="line">    bufferLoop:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars)</span><br><span class="line">                fill();</span><br><span class="line">            <span class="keyword">if</span> (nextChar &gt;= nChars) &#123; <span class="comment">/* EOF */</span></span><br><span class="line">                <span class="keyword">if</span> (s != <span class="keyword">null</span> &amp;&amp; s.length() &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> s.toString();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> eol = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Skip a leftover '\n', if necessary */</span></span><br><span class="line">            <span class="keyword">if</span> (omitLF &amp;&amp; (cb[nextChar] == <span class="string">'\n'</span>))</span><br><span class="line">                nextChar++;</span><br><span class="line">            skipLF = <span class="keyword">false</span>;</span><br><span class="line">            omitLF = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        charLoop:</span><br><span class="line">            <span class="keyword">for</span> (i = nextChar; i &lt; nChars; i++) &#123;</span><br><span class="line">                c = cb[i];</span><br><span class="line">                <span class="keyword">if</span> ((c == <span class="string">'\n'</span>) || (c == <span class="string">'\r'</span>)) &#123;</span><br><span class="line">                    eol = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span> charLoop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            startChar = nextChar;</span><br><span class="line">            nextChar = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (eol) &#123;</span><br><span class="line">                String str;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    str = <span class="keyword">new</span> String(cb, startChar, i - startChar);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s.append(cb, startChar, i - startChar);</span><br><span class="line">                    str = s.toString();</span><br><span class="line">                &#125;</span><br><span class="line">                nextChar++;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'\r'</span>) &#123;</span><br><span class="line">                    skipLF = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> str;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> StringBuffer(defaultExpectedLineLength);</span><br><span class="line">            s.append(cb, startChar, i - startChar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK stream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">lines</span><span class="params">(Path path, Charset cs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 实际也用的buffer reader</span></span><br><span class="line">    BufferedReader br = Files.newBufferedReader(path, cs);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> br.lines().onClose(asUncheckedRunnable(br));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                e.addSuppressed(ex);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>common io</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cachedLine != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.finished) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                line = <span class="keyword">this</span>.bufferedReader.readLine();</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.finished = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.isValidLine(line));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.cachedLine = line;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var4) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var3) &#123;</span><br><span class="line">                var4.addSuppressed(var3);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以出了Scanner用的自己的缓存机制，其他的都用的buffer reader的缓存机制，所以后面的三种方法效果差不多，不过笔者还是喜欢jdk8的stream机制，所以选择了jdk8的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blob.itmarte.com/2020/05/20/java/IO-NIO-reader-line/" data-id="ckc4mb0ng004g3wjabdpq9t9e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/io/" rel="tag">io</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nio/" rel="tag">nio</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/thread-forkJoin" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/13/java/thread-forkJoin/" class="article-date">
  <time datetime="2020-05-12T17:09:49.000Z" itemprop="datePublished">2020-05-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/thread/">thread</a>►<a class="article-category-link" href="/categories/java/thread/fork-join/">fork/join</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/13/java/thread-forkJoin/">JDK8 parallelStream 与 fork/join 框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JDK1-8-parallelStream-与-fork-join-框架"><a href="#JDK1-8-parallelStream-与-fork-join-框架" class="headerlink" title="JDK1.8 parallelStream 与 fork/join 框架"></a>JDK1.8 parallelStream 与 fork/join 框架</h2><h3 id="一、JDK8开启并行串行流"><a href="#一、JDK8开启并行串行流" class="headerlink" title="一、JDK8开启并行串行流"></a>一、JDK8开启并行串行流</h3><p>tream是java8中新增加的一个特性,被java猿统称为流.</p>
<p>　　Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>
<p>　　Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p>
<p>　　而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.0</span>-<span class="number">1.4</span> 中的 java.lang.Thread  </span><br><span class="line"><span class="number">5.0</span> 中的 java.util.concurrent  </span><br><span class="line"><span class="number">6.0</span> 中的 Phasers 等  </span><br><span class="line"><span class="number">7.0</span> 中的 Fork/Join 框架  </span><br><span class="line"><span class="number">8.0</span> 中的 Lambda</span><br></pre></td></tr></table></figure>

<p>Stream 的另外一大特点是，数据源本身可以是无限的。</p>
<h4 id="1-1-什么是parallelStream"><a href="#1-1-什么是parallelStream" class="headerlink" title="1.1 什么是parallelStream"></a>1.1 什么是parallelStream</h4><p>parallelStream其实就是一个并行执行的流.它通过默认的ForkJoinPool,可能提高你的多线程任务的速度.实际是多线程，注意线程安全问题</p>
<p>　　在从stream和parallelStream方法中进行选择时,我们可以考虑以下几个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　1. 是否需要并行？  </span><br><span class="line">　　2. 任务之间是否是独立的？是否会引起任何竞态条件？  </span><br><span class="line">　　3. 结果是否取决于任务的调用顺序？</span><br></pre></td></tr></table></figure>

<p>　　对于问题1，需要弄清楚要解决的问题是什么，数据量有多大，计算的特点是什么？并不是所有的问题都适合使用并发程序来求解，比如当数据量不大时，顺序执行往往比并行执行更快。毕竟，准备线程池和其它相关资源也是需要时间的。但是，当任务涉及到I/O操作并且任务之间不互相依赖时，那么并行化就是一个不错的选择。通常而言，将这类程序并行化之后，执行速度会提升好几个等级。</p>
<p>　　对于问题2，如果任务之间是独立的，并且代码中不涉及到对同一个对象的某个状态或者某个变量的更新操作，那么就表明代码是可以被并行化的。</p>
<p>　　对于问题3，由于在并行环境中任务的执行顺序是不确定的，因此对于依赖于顺序的任务而言，并行化也许不能给出正确的结果。　　</p>
<p>　　场景：默认值适用的场景是CPU密集型的，而一般的Web项目是IO密集型的（一般的Web项目都是需要跟数据库打交道的，针对数据库的操作主要就都是IO，而对CPU的消耗并不高）。</p>
<p>　　当不能使用默认值的时候，需要开发人员额外去了解parallelStream的用法，如下：</p>
<h4 id="1-2-parallelStream作用"><a href="#1-2-parallelStream作用" class="headerlink" title="1.2 parallelStream作用"></a>1.2 parallelStream作用</h4><p>Stream具有平行处理能力，处理的过程会分而治之，也就是将一个大任务切分成多个小任务，这表示每个任务都是一个操作，因此像以下的程式片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line">numbers.parallelStream()</span><br><span class="line">       .forEach(out::println);</span><br></pre></td></tr></table></figure>

<p>　　得到的展示顺序不一定会是1、2、3、4、5、6、7、8、9，而可能是任意的顺序，就forEach()这个操作來讲，如果平行处理时，希望最后顺序是按照原来Stream的数据顺序，那可以调用forEachOrdered()。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line">numbers.parallelStream()</span><br><span class="line">       .forEachOrdered(out::println);</span><br></pre></td></tr></table></figure>

<p>　　注意:如果forEachOrdered()中间有其他如filter()的中介操作，会试着平行化处理，然后最终forEachOrdered()会以原数据顺序处理，因此，使用forEachOrdered()这类的有序处理,可能会（或完全失去）失去平行化的一些优势，实际上中介操作亦有可能如此，例如sorted()方法。</p>
<h4 id="1-3-开启串行流和并行流："><a href="#1-3-开启串行流和并行流：" class="headerlink" title="1.3 开启串行流和并行流："></a>1.3 开启串行流和并行流：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = getList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 串行流</span></span><br><span class="line">    list.stream();</span><br><span class="line">    list.stream().sequential();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并行流</span></span><br><span class="line">    list.stream().parallel();</span><br><span class="line">    list.parallelStream().reduce(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 串行流执行</span></span><br><span class="line">    list.stream().reduce((first, second) -&gt; first+second);/</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并行流执行</span></span><br><span class="line">    list.parallelStream().reduce((first, second) -&gt; first+second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-流处理"><a href="#1-2-流处理" class="headerlink" title="1.2 流处理"></a>1.2 流处理</h4><p>因为比较关心并行流的实现，所以看并行流的代码：</p>
<p>java.util.stream.ReduceOps.ReduceOp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ReduceOp</span>&lt;<span class="title">T</span>, <span class="title">R</span>, <span class="title">S</span> <span class="keyword">extends</span> <span class="title">AccumulatingSink</span>&lt;<span class="title">T</span>, <span class="title">R</span>, <span class="title">S</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">TerminalOp</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StreamShape inputShape;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a &#123;<span class="doctag">@code</span> ReduceOp&#125; of the specified stream shape which uses</span></span><br><span class="line"><span class="comment">     * the specified &#123;<span class="doctag">@code</span> Supplier&#125; to create accumulating sinks.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shape The shape of the stream pipeline</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ReduceOp(StreamShape shape) &#123;</span><br><span class="line">        inputShape = shape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> S <span class="title">makeSink</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StreamShape <span class="title">inputShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputShape;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;P_IN&gt; <span class="function">R <span class="title">evaluateSequential</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper.wrapAndCopyInto(makeSink(), spliterator).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;P_IN&gt; <span class="function">R <span class="title">evaluateParallel</span><span class="params">(PipelineHelper&lt;T&gt; helper,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里new出了一个 ReduceTask</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReduceTask&lt;&gt;(<span class="keyword">this</span>, helper, spliterator).invoke().get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>名称上看，这是个task任务（java.util.stream.ReduceOps.ReduceTask），再看下类图：</p>
<p><img src="/images/reduceTask-%E7%B1%BB%E5%9B%BE.png" alt="58929987340"></p>
<p>看到类图结构加上熟悉fork/join框架，大概明白了stream的并行流实现了，借助于fork/join</p>
<h3 id="二、Fork-Join-框架"><a href="#二、Fork-Join-框架" class="headerlink" title="二、Fork/Join 框架"></a>二、Fork/Join 框架</h3><p>Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<p>它同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。</p>
<p><img src="/images/forkjoin_%E4%BB%BB%E5%8A%A1%E6%8B%86%E5%88%86.png" alt="img"></p>
<h4 id="2-1分治法"><a href="#2-1分治法" class="headerlink" title="2.1分治法"></a>2.1分治法</h4><p><code>ForkJoinPool</code>主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。</p>
<p>　　典型的应用比如快速排序算法。这里的要点在于，ForkJoinPool需要使用相对少的线程来处理大量的任务。比如要对1000万个数据进行排序，那么会将这个任务分割成两个500万的排序任务和一个针对这两组500万数据的合并任务。以此类推，对于500万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。比如，当元素的数量小于10时，会停止分割，转而使用插入排序对它们进行排序。那么到最后，所有的任务加起来会有大概2000000+个。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。</p>
<p>　　所以当使用ThreadPoolExecutor时，使用分治法会存在问题，因为ThreadPoolExecutor中的线程无法像任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而使用ForkJoinPool时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。</p>
<p>那么使用ThreadPoolExecutor或者ForkJoinPool，会有什么性能的差异呢？</p>
<p>　　首先，使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有父子关系的任务，比如使用4个线程来完成超过200万个任务。但是，使用ThreadPoolExecutor时，是不可能完成的，因为ThreadPoolExecutor中的Thread无法选择优先执行子任务，需要完成200万个具有父子关系的任务时，也需要200万个线程，显然这是不可行的。</p>
<p>​    尝试改变JDK8的工作线程数量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_FORK_JOIN_PARALLELISM = <span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>;</span><br><span class="line"><span class="comment">// 设置线程数</span></span><br><span class="line">System.setProperty(DEFAULT_FORK_JOIN_PARALLELISM, (Runtime.getRuntime().availableProcessors() * <span class="number">2</span>) + <span class="string">""</span>);</span><br></pre></td></tr></table></figure>



<h4 id="2-2-工作窃取法"><a href="#2-2-工作窃取法" class="headerlink" title="2.2 工作窃取法"></a>2.2 工作窃取法</h4><p>　　forkjoin最核心的地方就是利用了现代硬件设备多核,在一个操作时候会有空闲的cpu,那么如何利用好这个空闲的cpu就成了提高性能的关键,而这里我们要提到的工作窃取（work-stealing）算法就是整个forkjion框架的核心理念,工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</p>
<p>　　那么为什么需要使用工作窃取算法呢？</p>
<p>　　假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<p>　　工作窃取的运行流程图如下：</p>
<p><img src="/images/forkjoin_%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%EF%BC%88%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%EF%BC%89.png" alt="img"></p>
<p>　　工作窃取算法的优点：充分利用线程进行并行计算，并减少了线程间的竞争；</p>
<p>　　工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p>
<h4 id="2-3-Fork-Join-涉及到的关键名称"><a href="#2-3-Fork-Join-涉及到的关键名称" class="headerlink" title="2.3 Fork/Join 涉及到的关键名称"></a>2.3 Fork/Join 涉及到的关键名称</h4><p>　　<code>ForkJoinPool</code>： 用来执行Task，或生成新的ForkJoinWorkerThread，执行 ForkJoinWorkerThread 间的 work-stealing 逻辑。ForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。</p>
<p>　　<code>ForkJoinTask</code>： 执行具体的分支逻辑，声明以同步/异步方式进行执行</p>
<p>　　<code>ForkJoinWorkerThread</code>： 是 ForkJoinPool 内的 worker thread，执行</p>
<p>　　<code>ForkJoinTask</code>, 内部有 ForkJoinPool.WorkQueue来保存要执行的ForkJoinTask。</p>
<p>　　<code>ForkJoinPool.WorkQueue</code>：保存要执行的ForkJoinTask。</p>
<h4 id="2-4-Fork-Join框架的实现原理"><a href="#2-4-Fork-Join框架的实现原理" class="headerlink" title="2.4 Fork/Join框架的实现原理"></a>2.4 Fork/Join框架的实现原理</h4><p>在Java的Fork/Join框架中，它提供了两个类来帮助我们完成任务分割以及执行任务并合并结果：</p>
<p>　　1、<code>ForkJoinTask</code>：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：</p>
<p>　　　　<code>RecursiveAction</code>：用于没有返回结果的任务。<br>　　　　<code>RecursiveTask</code> ：用于有返回结果的任务。</p>
<p>　　2、<code>ForkJoinPool</code> ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p>
<p>　　<code>ForkJoinPool</code>由<code>ForkJoinTask</code>数组和<code>ForkJoinWorkerThread</code>数组组成，<code>ForkJoinTask</code>数组负责将存放程序提交给<code>ForkJoinPool</code>，而<code>ForkJoinWorkerThread</code>负责执行这些任务。</p>
<p>基本思想</p>
<p>　　<code>ForkJoinPool</code> 的每个工作线程都维护着一个工作队列（<code>WorkQueue</code>），这是一个双端队列（<code>Deque</code>），里面存放的对象是任务（<code>ForkJoinTask</code>）。</p>
<p>　　每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 LIFO（<strong>后进先出</strong>） 方式，也就是说每次从队尾取出任务来执行。</p>
<p>　　每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。</p>
<p>　　在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。</p>
<p>　　在既没有自己的任务，也没有可以窃取的任务时，进入休眠。</p>
<h5 id="2-4-1-ForkJoinPool属性说明、工作队列说明、控制中心说明"><a href="#2-4-1-ForkJoinPool属性说明、工作队列说明、控制中心说明" class="headerlink" title="2.4.1 ForkJoinPool属性说明、工作队列说明、控制中心说明"></a>2.4.1 ForkJoinPool属性说明、工作队列说明、控制中心说明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance fields</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> ctl;                   <span class="comment">// 控制中心：非常重要，看下图解析</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> runState;               <span class="comment">// 负数是shutdown，其余都是2的次方</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> config;                    <span class="comment">// 配置：二进制的低16位代表 并行度（parallelism），</span></span><br><span class="line">                                                                                    <span class="comment">//高16位：mode可选FIFO_QUEUE（1 &lt;&lt; 16）和LIFO_QUEUE（1 &lt;&lt; 31），默认是LIFO_QUEUE</span></span><br><span class="line">    <span class="keyword">int</span> indexSeed;                       <span class="comment">// 生成worker的queue索引</span></span><br><span class="line">    <span class="keyword">volatile</span> WorkQueue[] workQueues;     <span class="comment">// main registry</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinWorkerThreadFactory factory;</span><br><span class="line">    <span class="keyword">final</span> UncaughtExceptionHandler ueh;  <span class="comment">// per-worker UEH</span></span><br><span class="line">    <span class="keyword">final</span> String workerNamePrefix;       <span class="comment">// to create worker name string</span></span><br><span class="line">    <span class="keyword">volatile</span> AtomicLong stealCounter;    <span class="comment">// also used as sync monitor</span></span><br></pre></td></tr></table></figure>



<h6 id="2-4-1-1-工作队列workQueues"><a href="#2-4-1-1-工作队列workQueues" class="headerlink" title="2.4.1.1 工作队列workQueues"></a>2.4.1.1 工作队列workQueues</h6><p>用于保存向ForkJoinPool提交的任务，而具体的执行由ForkJoinWorkerThread执行，而ForkJoinWorkerThreadFactory可以用于生产出ForkJoinWorkerThread：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns a new worker thread operating in the given pool.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> pool the pool this thread works in</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> the new worker thread</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> NullPointerException if the pool is null</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ForkJoinWorkerThread <span class="title">newThread</span><span class="params">(ForkJoinPool pool)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/292888-20190913110608100-591376294.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instance fields</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> scanState;    <span class="comment">// 负数：inactive, 非负数：active, 其中奇数代表scanning</span></span><br><span class="line"><span class="keyword">int</span> stackPred;             <span class="comment">// sp = (int)ctl, 前一个队列栈的标示信息，包含版本号、是否激活、以及队列索引</span></span><br><span class="line"><span class="keyword">int</span> nsteals;               <span class="comment">// 窃取的任务数</span></span><br><span class="line"><span class="keyword">int</span> hint;                  <span class="comment">// 一个随机数，用来帮助任务窃取，在 helpXXXX()的方法中会用到</span></span><br><span class="line"><span class="keyword">int</span> config;                <span class="comment">// 配置：二进制的低16位代表 在 queue[] 中的索引，</span></span><br><span class="line"><span class="comment">// 高16位：mode可选FIFO_QUEUE（1 &lt;&lt; 16）和LIFO_QUEUE（1 &lt;&lt; 31），默认是LIFO_QUEUE</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> qlock;        <span class="comment">// 锁定标示位：1: locked, &lt; 0: terminate; else 0</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> base;         <span class="comment">// index of next slot for poll</span></span><br><span class="line"><span class="keyword">int</span> top;                   <span class="comment">// index of next slot for push</span></span><br><span class="line">ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// 任务列表</span></span><br></pre></td></tr></table></figure>

<h6 id="2-4-1-2-控制中心ctl"><a href="#2-4-1-2-控制中心ctl" class="headerlink" title="2.4.1.2 控制中心ctl"></a>2.4.1.2 控制中心ctl</h6><p><img src="/images/292888-20190913111130827-1005682912.png" alt="img"></p>
<h6 id="2-4-1-3-方法说明"><a href="#2-4-1-3-方法说明" class="headerlink" title="2.4.1.3 方法说明"></a>2.4.1.3 方法说明</h6><p>队列与关键任务调用说明</p>
<p><img src="/images/292888-20190913110836624-260052587.png" alt="img"></p>
<p>2.4.1.4 externalPush || externalSubmit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">        WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="comment">//我们以前常用的Random，在并发下，多个线程同时计算种子需要用到同一个原子变量。</span></span><br><span class="line">        <span class="comment">//由于更新操作使用CAS，同时执行只有一个线程成功，其他线程的大量自旋造成性能损失，ThreadLocalRandom继承Random，对此进行了改进。</span></span><br><span class="line">                <span class="comment">//ThreadLocalRandom运用了ThreadLocal，每个线程内部维护一个种子变量，多线程下计算新种子时使用线程自己的种子变量进行更新，避免了竞争。</span></span><br><span class="line">        <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class="line">        <span class="keyword">int</span> rs = runState;</span><br><span class="line">        <span class="comment">// 外部提交的task，肯定会到偶数位下标的队列上</span></span><br><span class="line">        <span class="comment">// SQMASK = 0x007e = 1111110，任何数和 SQMASK 进行 &amp; 运算 都会是偶数</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (q = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="comment">//队列上锁</span></span><br><span class="line">            U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> am, n, s;</span><br><span class="line">            <span class="keyword">if</span> ((a = q.array) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                <span class="comment">//把 task 放到队列的 top端</span></span><br><span class="line">                U.putOrderedObject(a, j, task);</span><br><span class="line">                U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                U.putIntVolatile(q, QLOCK, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                    signalWork(ws, q);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//队列解锁</span></span><br><span class="line">            U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        externalSubmit(task);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-4-1-5-registerWorker"><a href="#2-4-1-5-registerWorker" class="headerlink" title="2.4.1.5 registerWorker"></a>2.4.1.5 registerWorker</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> WorkQueue <span class="title">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">            <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line">                <span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// worker的queue肯定放在pool中的queue[]中的奇数下标</span></span><br><span class="line">                  <span class="comment">// m = ws.lenght - 1, ws.lenght 肯定是偶数，则m 肯定是奇数</span></span><br><span class="line">                <span class="comment">// 1的二进制位：00000001, 所以任何数 "|" 1 都是奇数</span></span><br><span class="line">                <span class="comment">// 所以 奇数 &amp; 奇数 ， 1&amp;1 = 1，所以i肯定是奇数</span></span><br><span class="line">                i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// odd-numbered indices</span></span><br><span class="line">                <span class="keyword">if</span> (ws[i] != <span class="keyword">null</span>) &#123;                  <span class="comment">// collision</span></span><br><span class="line">                    <span class="keyword">int</span> probes = <span class="number">0</span>;                   <span class="comment">// step by approx half n</span></span><br><span class="line">                    <span class="keyword">int</span> step = (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">// 如果下标已经有队列，则重新生成奇数下标</span></span><br><span class="line">                    <span class="comment">// step肯定为偶数：EVENMASK：0xfffe：1111111111111110</span></span><br><span class="line">                      <span class="comment">// 所以 奇数+偶数，奇偶性不变</span></span><br><span class="line">                    <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (++probes &gt;= n) &#123;</span><br><span class="line">                            workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">                            m = n - <span class="number">1</span>;</span><br><span class="line">                            probes = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h6 id="2-4-1-6-scan"><a href="#2-4-1-6-scan" class="headerlink" title="2.4.1.6 scan"></a>2.4.1.6 scan</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="keyword">int</span> r) &#123;</span><br><span class="line">        WorkQueue[] ws; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ss = w.scanState;                     <span class="comment">// initially non-negative</span></span><br><span class="line">               <span class="comment">// k = r &amp; m 。 r是一个随机数，m 是 队列数组长度 - 1；用于定位去哪个 队列 窃取 task</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> origin = r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">                WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">                <span class="keyword">int</span> b, n; <span class="keyword">long</span> c;</span><br><span class="line">                <span class="keyword">if</span> ((q = ws[k]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">// 如果有还没执行的task，尝试窃取队列q 中的base下标的 task。 即FIFO</span></span><br><span class="line">                    <span class="comment">// i: 在内存中，b下标对应的对象的偏移值。 a.length - 1 的二进制位 永远是 0[1...]s，所以 (a.length - 1) &amp; b = b，主要是保证了b不会越界</span></span><br><span class="line">                    <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (a = q.array) != <span class="keyword">null</span>) &#123;      <span class="comment">// non-empty</span></span><br><span class="line">                        <span class="keyword">long</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                                  U.getObjectVolatile(a, i))) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            q.base == b) &#123;</span><br><span class="line">                               <span class="comment">// ss 是小偷的 scanState，大于0代表当前的worker是激活的</span></span><br><span class="line">                            <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                  <span class="comment">// 把 task 从 队列中取出来，然后队列的base+1，如果被窃取的队列中有多于1个的task，则尝试唤醒其他的worker</span></span><br><span class="line">                                <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                                    q.base = b + <span class="number">1</span>;</span><br><span class="line">                                    <span class="keyword">if</span> (n &lt; -<span class="number">1</span>)       <span class="comment">// signal others</span></span><br><span class="line">                                        signalWork(ws, q);</span><br><span class="line">                                    <span class="keyword">return</span> t;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                              <span class="comment">// ss小于0代表当前的worker是未激活的，并且当前是第一次扫描，这时候尝试激活worker</span></span><br><span class="line">                            <span class="comment">// oldSum: 上一次遍历周期的 base 值的和。</span></span><br><span class="line">                            <span class="comment">// (int) c : 可以拿到当前栈顶的空闲worker。sp = (int) c</span></span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   <span class="comment">// try to activate</span></span><br><span class="line">                                     w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                                tryRelease(c = ctl, ws[m &amp; (<span class="keyword">int</span>)c], AC_UNIT);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">                            ss = w.scanState;</span><br><span class="line">                        <span class="comment">// 更新随机值，重新初始化所有控制变量，重新定位队列</span></span><br><span class="line">                        r ^= r &lt;&lt; <span class="number">1</span>; r ^= r &gt;&gt;&gt; <span class="number">3</span>; r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                        origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">                        oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    checkSum += b;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 每次没有窃取到task的时候，都会k+1（k值不会超过m），当k遍历了一圈还没有steal到任务，则当前小偷worker是过剩的，则inactive这个小偷worker</span></span><br><span class="line">                <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;    <span class="comment">// continue until stable</span></span><br><span class="line">                      <span class="comment">// oldSum == (oldSum = checkSum) 实际上就是 oldSum == checkSum ， oldSum = checkSum</span></span><br><span class="line">                    <span class="comment">// oldSum == checkSum 是判断 这个周期和上个周期 的base和是否一直，如果一直， 说明base可能没有变过</span></span><br><span class="line">                    <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                        oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">int</span> ns = ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">                        <span class="keyword">long</span> nc = ((SP_MASK &amp; ns) |</span><br><span class="line">                                   (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">                        <span class="comment">// 维护 队列的 stack，可以指向前一个栈顶的队列</span></span><br><span class="line">                        w.stackPred = (<span class="keyword">int</span>)c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">                        U.putInt(w, QSCANSTATE, ns);</span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc))</span><br><span class="line">                            ss = ns;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    checkSum = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-4-1-7-signalWork"><a href="#2-4-1-7-signalWork" class="headerlink" title="2.4.1.7 signalWork"></a>2.4.1.7 signalWork</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> c; <span class="keyword">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class="line">        <span class="comment">// AC是负数，所以 active worker不足</span></span><br><span class="line">        <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123;                       <span class="comment">// too few active</span></span><br><span class="line">            <span class="comment">// sp:第一位是0，没有版本号，没有inactive的worker</span></span><br><span class="line">            <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)c) == <span class="number">0</span>) &#123;                  <span class="comment">// no idle workers</span></span><br><span class="line">                <span class="comment">//tc: tc不为0，就是代表 total worker - parallelism &lt; 0, 所以需要添加worker</span></span><br><span class="line">                <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>)            <span class="comment">// too few workers</span></span><br><span class="line">                    tryAddWorker(c);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ws == <span class="keyword">null</span>)                            <span class="comment">// unstarted/terminated</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 取栈顶的worker，如果下标已经越界或queue为null，线程池都是终止了</span></span><br><span class="line">            <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class="comment">// terminated</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = ws[i]) == <span class="keyword">null</span>)                   <span class="comment">// terminating</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 新的scanState，版本+1，设置状态为激活，INACTIVE = 1 &lt;&lt; 31，~INACTIVE = 01111111....</span></span><br><span class="line">            <span class="keyword">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line">            <span class="comment">// 确认 worker的 sp没有变化</span></span><br><span class="line">            <span class="keyword">int</span> d = sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line">            <span class="comment">// 生成新的 ctl，(UC_MASK &amp; (c + AC_UNIT))设置 高32位， (SP_MASK &amp; v.stackPred)设置低32位</span></span><br><span class="line">            <span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">                <span class="comment">//激活worker</span></span><br><span class="line">                v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">                <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(p);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前queue没有task 需要执行了，则停止signal</span></span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; q.base == q.top)          <span class="comment">// no more work</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-4-1-8-ForkJoinTask的fork方法实现原理"><a href="#2-4-1-8-ForkJoinTask的fork方法实现原理" class="headerlink" title="2.4.1.8 ForkJoinTask的fork方法实现原理"></a>2.4.1.8 ForkJoinTask的fork方法实现原理</h6><p>当我们调用ForkJoinTask的fork方法时，程序会把任务放在ForkJoinWorkerThread的pushTask的workQueue中，异步地执行这个任务，然后立即返回结果，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若当前线程是ForkJoinWorkerThread线程，则强制类型转换（向下转换）成ForkJoinWorkerThread，然后将任务push到这个线程负责的队列里面去，在ForkJoinWorkerThread类中有一个pool和一个workQueue字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程工作的ForkJoinPool</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool pool;                <span class="comment">// the pool this thread works in</span></span><br><span class="line"><span class="comment">// 工作窃取队列</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool.WorkQueue workQueue; <span class="comment">// work-stealing mechanics</span></span><br></pre></td></tr></table></figure>

<p>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class="line">    <span class="keyword">int</span> b = base, s = top, n;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123;    <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="keyword">int</span> m = a.length - <span class="number">1</span>;     <span class="comment">// fenced write for task visibility</span></span><br><span class="line">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = pool) != <span class="keyword">null</span>)</span><br><span class="line">                p.signalWork(p.workQueues, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)</span><br><span class="line">            growArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的主要功能就是将当前任务存放在ForkJoinTask数组array里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。</p>
<h6 id="2-4-1-9-ForkJoinTask的join方法实现原理"><a href="#2-4-1-9-ForkJoinTask的join方法实现原理" class="headerlink" title="2.4.1.9 ForkJoinTask的join方法实现原理"></a>2.4.1.9 ForkJoinTask的join方法实现原理</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　首先，它调用了doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有四种：已完成（NORMAL），被取消（CANCELLED），信号（SIGNAL）和出现异常（EXCEPTIONAL）：　　</p>
<p>　　若状态不是NORMAL，则通过reportException(int)方法来处理状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportException</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">if</span> (s == EXCEPTIONAL)</span><br><span class="line">        rethrow(getThrowableException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>如果任务状态是已完成，则直接返回任务结果。</li>
<li>如果任务状态是被取消，则直接抛出CancellationException。</li>
<li>如果任务状态是抛出异常，则直接抛出对应的异常。</li>
</ul>
<p>　　doJoin()方法的实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>　　在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完了，如果执行完了，则直接返回任务状态，如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成了，则设置任务状态为NORMAL，如果出现异常，则纪录异常，并将任务状态设置为EXCEPTIONAL。</p>
<p>　　执行任务是通过doExec()方法来完成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正的执行过程是由exec()方法来完成的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这就是我们需要重写的方法，若是我们的任务继承自RecursiveAction，则我们需要重写RecursiveAction的compute()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveAction</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5232453952276485070L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Always returns &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> null&#125; always</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Requires null completion value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void mustBeNull)</span> </span>&#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements execution conventions for RecursiveActions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若是我们的任务继承自RecursiveTask，则我们同样需要重写RecursiveTask的compute()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5232453952276485270L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The result of the computation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V result;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result of the computation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> V <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getRawResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        result = value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements execution conventions for RecursiveTask.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        result = compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的分析可知，执行我们的业务代码是在调用了join()之后的，也就是说，fork仅仅是分割任务，只有当我们执行join的时候，我们的任务才会被执行。</p>
<h5 id="2-4-2-异常处理"><a href="#2-4-2-异常处理" class="headerlink" title="2.4.2 异常处理"></a>2.4.2 异常处理</h5><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(task.isCompletedAbnormally())&#123;</span><br><span class="line">    System.out.println(task.getException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Throwable <span class="title">getException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = status &amp; DONE_MASK;</span><br><span class="line">        <span class="keyword">return</span> ((s &gt;= NORMAL)    ? <span class="keyword">null</span> :</span><br><span class="line">                (s == CANCELLED) ? <span class="keyword">new</span> CancellationException() :</span><br><span class="line">                getThrowableException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-4-2forkjoin-的使用"><a href="#2-4-2forkjoin-的使用" class="headerlink" title="2.4.2forkjoin 的使用"></a>2.4.2forkjoin 的使用</h5><p>　ForkJoinPool 使用submit 或 invoke 提交的区别：invoke是同步执行，调用之后需要等待任务完成，才能执行后面的代码；submit是异步执行，只有在Future调用get的时候会阻塞。</p>
<p>　　这里继承的是RecursiveTask 适用于有返回值的场景；还可以继承RecursiveAction，适合于没有返回值的场景</p>
<p>　　执行子任务调用fork方法并不是最佳的选择，最佳的选择是invokeAll方法。</p>
<h5 id="2-4-3-示例代码"><a href="#2-4-3-示例代码" class="headerlink" title="2.4.3 示例代码"></a>2.4.3 示例代码</h5><p>   这个示例是在做某支付任务异步解耦后的业务逻辑校验，这个是一个接收返回的任务 <code>RecursiveTask</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		*  这个是阈值，具体任务列表拆分到什么程度再开始执行</span></span><br><span class="line"><span class="comment">		**/</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> threshold = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	*	这个是当前处理的集合列表</span></span><br><span class="line"><span class="comment">    	**/</span></span><br><span class="line">        <span class="keyword">private</span> List&lt;CbVaPaymentFileContent&gt; list;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 初始化任务对象</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">CheckTask</span><span class="params">(<span class="keyword">int</span> threshold, List&lt;CbVaPaymentFileContent&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == list) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"[list] is null."</span>);</span><br><span class="line">            <span class="keyword">this</span>.threshold = threshold &lt;= <span class="number">0</span> ? <span class="keyword">this</span>.threshold : threshold;</span><br><span class="line"><span class="comment">//            this.threshold = list.size() / Runtime.getRuntime().availableProcessors();</span></span><br><span class="line">            <span class="keyword">this</span>.list = list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (list.size() &lt;= threshold) &#123;</span><br><span class="line">                <span class="comment">// 处理</span></span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (CbVaPaymentFileContent content : list) &#123;</span><br><span class="line">                    count += process(content);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 分解</span></span><br><span class="line">                <span class="keyword">int</span> middle = list.size() / <span class="number">2</span>;</span><br><span class="line">                List&lt;CbVaPaymentFileContent&gt; leftList = list.subList(<span class="number">0</span>, middle);</span><br><span class="line">                List&lt;CbVaPaymentFileContent&gt; rightList = list.subList(middle, list.size());</span><br><span class="line">                CheckTask left = <span class="keyword">new</span> CheckTask(threshold, leftList);</span><br><span class="line">                CheckTask right = <span class="keyword">new</span> CheckTask(threshold, rightList);</span><br><span class="line">                <span class="comment">// left.fork();</span></span><br><span class="line">                <span class="comment">// right.fork();</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 这两个方法，使用invokeAll方法的主要原因是为了充分利用线程池，在invokeAll的N个任务中，其中N-1个任务会使用fork()交给其它线程执行，但是，它还会留一个任务自己执行，这样，就充分利用了线程池，保证没有空闲的不干活的线程。</span></span><br><span class="line">                invokeAll(left, right);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 结合</span></span><br><span class="line">                <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>　　该代码就是通过Fork/Join框架来计算数组的和，计算耗时4031毫秒。通过该代码作为应用示例主要是为了告诉大家，使用Fork/Join模型的正确方式，在源代码中可以看到，SumTask继承自RecursiveTask，重写的compute方法为：</p>
<p>　　compute()方法使用了invokeAll方法来分解任务，而不是它下面的subtask1.fork();</p>
<p>　　这两个方法，使用invokeAll方法的主要原因是为了充分利用线程池，在invokeAll的N个任务中，其中N-1个任务会使用fork()交给其它线程执行，但是，它还会留一个任务自己执行，这样，就充分利用了线程池，保证没有空闲的不干活的线程。</p>
<p>　　若是采用另外一种方式来运行，程序的运行时间为6028毫秒，可以看到，明显比invokeAll方式慢了很多。</p>
<h5 id="2-4-3-JDK8中的最佳实践"><a href="#2-4-3-JDK8中的最佳实践" class="headerlink" title="2.4.3 JDK8中的最佳实践"></a>2.4.3 JDK8中的最佳实践</h5><h5 id="2-4-3-1-通过forkjoin来看parallelStream"><a href="#2-4-3-1-通过forkjoin来看parallelStream" class="headerlink" title="2.4.3.1 通过forkjoin来看parallelStream"></a>2.4.3.1 通过forkjoin来看parallelStream</h5><p>在Java 8引入了自动并行化的概念。它能够让一部分Java代码自动地以并行的方式执行，即使用了ForkJoinPool的ParallelStream。　　</p>
<p>　　Java 8为ForkJoinPool添加了一个通用线程池，这个线程池用来处理那些没有被显式提交到任何线程池的任务。它是ForkJoinPool类型上的一个静态元素，它拥有的默认线程数量等于运行计算机上的处理器数量。当调用Arrays类上添加的新方法时，自动并行化就会发生。比如用来排序一个数组的并行快速排序，用来对一个数组中的元素进行并行遍历。自动并行化也被运用在Java 8新添加的Stream API中。</p>
<p>　　一般ForkJoinPool中的通用线程池处理，也可以使用ThreadPoolExecutor完成，但是就代码的可读性和代码量而言，使用ForkJoinPool明显更胜一筹。</p>
<h5 id="2-4-3-2-线程池数量"><a href="#2-4-3-2-线程池数量" class="headerlink" title="2.4.3.2 线程池数量"></a>2.4.3.2 线程池数量</h5><p>​    <strong>1、系统CPU数量：[如机器8核，即8]</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure>

<p>　　<strong>2、parallelStream默认的并发线程数:【parallelStream核心使用ForkJoinPool实现，故如下】【输出是7个】</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool.getCommonPoolParallelism()</span><br></pre></td></tr></table></figure>

<p>　　<strong>3、为什么parallelStream默认的并发线程数要比CPU处理器的数量少1个？</strong></p>
<p>　　　　因为最优的策略是每个CPU处理器分配一个线程，然而主线程也算一个线程，所以要占一个名额。如果只有1个CPU，默认的并发线程数就是1</p>
<p>　　<strong>4、修改默认并发数</strong></p>
<p>　　　　默认的并发线程数不可以反复修改。因为<code>java.util.concurrent.ForkJoinPool.common.parallelism</code>是<code>final</code>类型的，整个JVM中只允许设置一次。多次修改以第一次为主</p>
<p>　　　　1、系统property</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, &quot;20&quot;);</span><br><span class="line">System.out.println(ForkJoinPool.getCommonPoolParallelism());</span><br></pre></td></tr></table></figure>

<p>　　　　2、当然上述参数也可以通过jvm设置系统属性：-Djava.util.concurrent.ForkJoinPool.common.parallelism=N （N为线程数量）　　</p>
<p>　　<strong>5、既然默认的并发线程数不能反复修改，进行不同线程数量的并发测试，可以引入<code>ForkJoinPool</code>。用法如下</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSetParallelMutli() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    int[] threadCountArr &#x3D; &#123;2, 4, 6&#125;;</span><br><span class="line">    List&lt;Integer&gt; para &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 7; i++) &#123;</span><br><span class="line">        para.add(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    for (int threadCount : threadCountArr) &#123;</span><br><span class="line">        new ForkJoinPool(threadCount).submit(() -&gt; &#123;&#x2F;&#x2F;多线程任务</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　　　使用get 是为了阻塞 得到结果；如果主线程没有关闭的情况下可以不用get</p>
<h5 id="2-4-3-2-测试示例"><a href="#2-4-3-2-测试示例" class="headerlink" title="2.4.3.2 测试示例"></a>2.4.3.2 测试示例</h5><p><strong>实际应用示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">logger.info(<span class="string">"[消息补偿任务-并行执行]开始，本次预处理总数为[&#123;&#125;]"</span>, list.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动扩容下,当然这个综合考虑使用</span></span><br><span class="line">System.setProperty(DEFAULT_FORK_JOIN_PARALLELISM, (Runtime.getRuntime().availableProcessors() * appConfig.getMutiple()) + <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拆分任务到JobSender</span></span><br><span class="line"><span class="comment"> *  &#123;<span class="doctag">@link</span> Stream#reduce(Object, BiFunction, BinaryOperator)&#125;</span></span><br><span class="line"><span class="comment"> *  &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *      reduce.Object --&gt; 初始值，只是为了来初始化参数类型</span></span><br><span class="line"><span class="comment"> *      reduce.BiFunction.apply(T t, U u) --&gt;  t表示当前值， u表示当前操作对象</span></span><br><span class="line"><span class="comment"> *      reduce.BinaryOperator(T t, U u) --&gt; t=u=初始值类型，用来合并结果的</span></span><br><span class="line"><span class="comment"> *  &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> total = list.parallelStream().filter(op -&gt; lockAdaptor.lock(op.getId(), LockAdaptor.DEFAULT_TIMEOUT)).reduce(<span class="number">0</span>, (cur, channel) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 构建发送器 + 并处理</span></span><br><span class="line">    <span class="keyword">int</span> ava;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ava = (jobSenderFactory.getSender(channel).process().dealSuccess() ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        lockAdaptor.unlock(channel.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur + ava;</span><br><span class="line">&#125;, (a, b) -&gt; a + b);</span><br><span class="line">logger.info(<span class="string">"[消息补偿任务-并行执行]结束，本次预处理总数为[&#123;&#125;]， 成功总数[&#123;&#125;], 未成功总数[&#123;&#125;]"</span>, list.size(), total, list.size() - total);</span><br></pre></td></tr></table></figure>

<p>1、测试一、8核机器，每个任务均耗时2秒，一共16个任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSetParallelMutli2() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    List&lt;Integer&gt; para &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 16; i++) &#123;</span><br><span class="line">        para.add(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    para.parallelStream().forEach(i -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(LocalDateTime.now() + &quot;||&quot; + Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-1:5</span><br><span class="line">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-6:1</span><br><span class="line">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-2:14</span><br><span class="line">2019-09-13T10:51:04.344||main:10</span><br><span class="line">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-4:13</span><br><span class="line">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-3:2</span><br><span class="line">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-7:4</span><br><span class="line">2019-09-13T10:51:04.344||ForkJoinPool.commonPool-worker-5:7</span><br><span class="line">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-4:3</span><br><span class="line">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-6:0</span><br><span class="line">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-1:12</span><br><span class="line">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-2:15</span><br><span class="line">2019-09-13T10:51:06.350||main:11</span><br><span class="line">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-5:8</span><br><span class="line">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-3:6</span><br><span class="line">2019-09-13T10:51:06.350||ForkJoinPool.commonPool-worker-7:9</span><br></pre></td></tr></table></figure>

<p>　　结论：会有7个 ForkJoinPool.commonPool-worker 线程和1个主线程main一起执行任务。并且8个一组一组执行，每个线程执行了两个任务。</p>
<p>2、测试二、8核机器，每个任务耗时2秒内随机，一共16个任务 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    @Test</span><br><span class="line">    public void testSetParallelMutli2() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        List&lt;Integer&gt; para &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 16; i++) &#123;</span><br><span class="line">            para.add(i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        para.parallelStream().forEach(i -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">&#x2F;&#x2F;                Thread.sleep(2000);</span><br><span class="line">                Thread.sleep(new Random().nextInt(2000));</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(LocalDateTime.now() + &quot;||&quot; + Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2019-09-13T10:54:01.486||ForkJoinPool.commonPool-worker-5:7</span><br><span class="line">2019-09-13T10:54:01.751||main:10</span><br><span class="line">2019-09-13T10:54:01.774||main:11</span><br><span class="line">2019-09-13T10:54:01.862||ForkJoinPool.commonPool-worker-5:6</span><br><span class="line">2019-09-13T10:54:02.203||ForkJoinPool.commonPool-worker-5:15</span><br><span class="line">2019-09-13T10:54:02.285||ForkJoinPool.commonPool-worker-6:1</span><br><span class="line">2019-09-13T10:54:02.407||ForkJoinPool.commonPool-worker-6:0</span><br><span class="line">2019-09-13T10:54:02.479||ForkJoinPool.commonPool-worker-1:5</span><br><span class="line">2019-09-13T10:54:02.496||ForkJoinPool.commonPool-worker-2:14</span><br><span class="line">2019-09-13T10:54:02.518||ForkJoinPool.commonPool-worker-4:13</span><br><span class="line">2019-09-13T10:54:02.732||main:9</span><br><span class="line">2019-09-13T10:54:02.740||ForkJoinPool.commonPool-worker-7:4</span><br><span class="line">2019-09-13T10:54:02.791||ForkJoinPool.commonPool-worker-3:2</span><br><span class="line">2019-09-13T10:54:03.178||ForkJoinPool.commonPool-worker-5:12</span><br><span class="line">2019-09-13T10:54:03.743||ForkJoinPool.commonPool-worker-1:8</span><br><span class="line">2019-09-13T10:54:04.003||ForkJoinPool.commonPool-worker-6:3</span><br></pre></td></tr></table></figure>

<p>　　结论：会有7个 ForkJoinPool.commonPool-worker 线程和1个主线程main一起执行任务。并且是强占式【工作窃取法】的执行任务：如上线程5、主线程执行了各3个任务，其他有2个或一个的。</p>
<p>3、示例三、接收消息队列消息，每次消息个数n个，每个消息是一个100个的list<String>,接收时候使用parallelStream消费并发处理</p>
<p>发送消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testMq() throws Exception &#123;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; 1; j++) &#123;</span><br><span class="line">        List&lt;String&gt; list &#x3D; Lists.newArrayList();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">            list.add(j+&quot;___________&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        producerMessageService.sendMessage(&quot;test_parallel&quot;, UUID.randomUUID().toString(), JSON.toJSONString(list));</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">    logger.error(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;生产 ok&quot;);</span><br><span class="line"></span><br><span class="line">    Thread.sleep(2000000000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收消费</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onMessage(List&lt;Message&gt; messages) throws Exception &#123;</span><br><span class="line">    if (messages &#x3D;&#x3D; null || messages.isEmpty()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; messages.size(); i++) &#123;</span><br><span class="line">        Message message &#x3D; messages.get(i);</span><br><span class="line">        logger.info(String.format(&quot;收到一条消息,消息主题（队列名）：%s,内容是：%s&quot;, message.getTopic(), message.getText()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; strings &#x3D; JSONArray.parseArray(message.getText(), String.class);</span><br><span class="line">        strings.parallelStream().forEach(p -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            logger.error(LocalDateTime.now() + &quot;_______________&quot; + Thread.currentThread().getName() + &quot;:&quot; + p);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　说明：</p>
<p>　　　　发送消息，1s后会发送完毕，此时如果有订阅就会出现一条消息积压。</p>
<p>　　　　订阅消息者，订阅后会收到词条消息，此时如果正常执行完毕（不论使用不使用多线程）消息积压就没有了，因为一般消息监听会在方法正常执行完毕后，使用消息Id将此条消息从订阅队列中移除。</p>
<p>　　　　　　接收到1条消息，里面会有一个jsonstring，反序列化为List，大小是100，交给parallelStream处理，此时会有8个线程处理【如果是8核机器】，处理速度大约是2秒8个。其余的92进入workQueue中等待处理。</p>
<p>　　　　　　此时如果程序中断，订阅的消息不会被消费使用，下次重连时，需要做已处理消息的去重。</p>
<p>　　　　　　此时如果有新消息发送过来，也会在积压中，不会被消息消费。</p>
<p> 4、示例四、从a中100个数找出整除5的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testExec() throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    List&lt;Integer&gt; a &#x3D; Lists.newArrayList();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">        a.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; b &#x3D; Lists.newArrayList();</span><br><span class="line">    a.parallelStream().forEach(p -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if (p % 5 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            b.add(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;+b.size());</span><br><span class="line">    b.forEach(p -&gt; System.out.print(p+&quot; &quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：正确应该是20</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;18</span><br><span class="line">15 90 45 30 25 35 85 75 0 40 5 80 95 20 60 70 50 55</span><br></pre></td></tr></table></figure>



<p>对此运行结果不一致，以及会有多线程问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArrayIndexOutOfBoundsException</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">　　……</span><br><span class="line"></span><br><span class="line">Caused by: java.lang.ArrayIndexOutOfBoundsException: 15</span><br><span class="line">    at java.util.ArrayList.add(ArrayList.java:463)</span><br><span class="line">    at com.github.bjlhx15.common.thread.juc.collection.jdk8stream.TStreamTest.lambda$testExec$6(TStreamTest.java:118)</span><br><span class="line">    at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)</span><br><span class="line">    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382)</span><br><span class="line">    at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)</span><br><span class="line">    at java.util.stream.ForEachOps$ForEachTask.compute(ForEachOps.java:291)</span><br></pre></td></tr></table></figure>



<p>原因：parallelStream 并行执行，多线程异步，可能没有b添加完毕就遍历，ArrayList不是线程安全的</p>
<p>修正：</p>
<p>　　方案一、在遍历前，需全部执行完毕【串行】</p>
<p>　　　　将 parallelStream 改为 stream串行处理【不可取，处理速度慢】</p>
<p>　　方案二、在遍历前，需全部执行完毕</p>
<p>　　　　继承 RecursiveTask或者RecursiveAction写任务　　　　</p>
<p>　　方案三、将ArrayList替换安全集合CopyOnWriteArrayLIst</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; b &#x3D; Lists.newCopyOnWriteArrayList();</span><br></pre></td></tr></table></figure>

<p>　　　　此时运行就会出现正确结果。按理说应该会有结果不准确问题吧。但是没有，个人理解，因为是每次8个同时执行，所以即使最后一次主线程提前结束，也有其他线程在锁着b，所以最后执行b的操作会有等待</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blob.itmarte.com/2020/05/13/java/thread-forkJoin/" data-id="ckc4mb0s2007h3wja7hxv9xhc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ThreadPoolExecutor/" rel="tag">ThreadPoolExecutor</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fork-join/" rel="tag">fork/join</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/schedule/" rel="tag">schedule</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/synchronized-lock/" rel="tag">synchronized/lock</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thread/" rel="tag">thread</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java/disruptor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/27/java/disruptor/" class="article-date">
  <time datetime="2020-04-27T07:34:37.000Z" itemprop="datePublished">2020-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/collection/">collection</a>►<a class="article-category-link" href="/categories/java/collection/queue/">queue</a>►<a class="article-category-link" href="/categories/java/collection/queue/disruptor/">disruptor</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/java/disruptor/">disruptor</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级）。基于Disruptor开发的系统单线程能支撑每秒600万订单，2010年在QCon演讲后，获得了业界关注。2011年，企业应用软件专家Martin Fowler专门撰写长文介绍。同年它还获得了Oracle官方的Duke大奖。</p>
<p>目前，包括Apache Storm、Camel、Log4j 2在内的很多知名项目都应用了Disruptor以获取高性能。在美团技术团队它也有不少应用，有的项目架构借鉴了它的设计机制。本文从实战角度剖析了Disruptor的实现原理。</p>
<p>需要特别指出的是，这里所说的队列是系统内部的内存队列，而不是Kafka这样的分布式队列。另外，本文所描述的Disruptor特性限于3.3.4。</p>
<h2 id="Java内置队列"><a href="#Java内置队列" class="headerlink" title="Java内置队列"></a>Java内置队列</h2><p>介绍Disruptor之前，我们先来看一看常用的线程安全的内置队列有什么问题。Java的内置队列如下表所示。</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>有界性</th>
<th>锁</th>
<th>数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>bounded</td>
<td>加锁</td>
<td>arraylist</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>optionally-bounded</td>
<td>加锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>ConcurrentLinkedQueue</td>
<td>unbounded</td>
<td>无锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>unbounded</td>
<td>无锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
</tbody></table>
<p>队列的底层一般分成三种：数组、链表和堆。其中，堆一般情况下是为了实现带有优先级特性的队列，暂且不考虑。</p>
<p>我们就从数组和链表两种数据结构来看，基于数组线程安全的队列，比较典型的是ArrayBlockingQueue，它主要通过加锁的方式来保证线程安全；基于链表的线程安全队列分成LinkedBlockingQueue和ConcurrentLinkedQueue两大类，前者也通过锁的方式来实现线程安全，而后者以及上面表格中的LinkedTransferQueue都是通过原子变量compare and swap（以下简称“CAS”）这种不加锁的方式来实现的。</p>
<p>通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在确定的范围内）；而加锁的方式，可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列；同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array/heap格式的数据结构。这样筛选下来，符合条件的队列就只有ArrayBlockingQueue。</p>
<h2 id="ArrayBlockingQueue的问题"><a href="#ArrayBlockingQueue的问题" class="headerlink" title="ArrayBlockingQueue的问题"></a>ArrayBlockingQueue的问题</h2><p>ArrayBlockingQueue在实际使用过程中，会因为加锁和伪共享等出现严重的性能问题，我们下面来分析一下。</p>
<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>现实编程过程中，加锁通常会严重地影响性能。线程会因为竞争不到锁而被挂起，等锁被释放的时候，线程又会被恢复，这个过程中存在着很大的开销，并且通常会有较长时间的中断，因为当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，例如发生了缺页错误、调度延迟或者其它类似情况，那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，就会发生优先级反转。</p>
<p>Disruptor论文中讲述了一个实验：</p>
<ul>
<li>这个测试程序调用了一个函数，该函数会对一个64位的计数器循环自增5亿次。</li>
<li>机器环境：2.4G 6核</li>
<li>运算： 64位的计数器累加5亿次</li>
</ul>
<p>|Method | Time (ms) | |— | —| |Single thread | 300| |Single thread with CAS | 5,700| |Single thread with lock | 10,000| |Single thread with volatile write | 4,700| |Two threads with CAS | 30,000| |Two threads with lock | 224,000|</p>
<p>CAS操作比单线程无锁慢了1个数量级；有锁且多线程并发的情况下，速度比单线程无锁慢3个数量级。可见无锁速度最快。</p>
<p>单线程情况下，不加锁的性能 &gt; CAS操作的性能 &gt; 加锁的性能。</p>
<p>在多线程情况下，为了保证线程安全，必须使用CAS或锁，这种情况下，CAS的性能超过锁的性能，前者大约是后者的8倍。</p>
<p>综上可知，加锁的性能是最差的。</p>
<p><strong>关于锁和CAS</strong></p>
<p>保证线程安全一般分成两种方式：锁和原子变量。</p>
<p><strong>锁</strong></p>
<p><img src="https://p1.meituan.net/travelcube/9b6a41f7d8527df9730b7832b38ec4d5180025.png" alt="图1 通过加锁的方式实现线程安全"></p>
<p>图1 通过加锁的方式实现线程安全</p>
<p>采取加锁的方式，默认线程会冲突，访问数据时，先加上锁再访问，访问之后再解锁。通过锁界定一个临界区，同时只有一个线程进入。如上图所示，Thread2访问Entry的时候，加了锁，Thread1就不能再执行访问Entry的代码，从而保证线程安全。</p>
<p>下面是ArrayBlockingQueue通过加锁的方式实现的offer方法，保证线程安全。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        if (count &#x3D;&#x3D; items.length)</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">            insert(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原子变量</strong></p>
<p>原子变量能够保证原子性的操作，意思是某个任务在执行过程中，要么全部成功，要么全部失败回滚，恢复到执行之前的初态，不存在初态和成功之间的中间状态。例如CAS操作，要么比较并交换成功，要么比较并交换失败。由CPU保证原子性。</p>
<p>通过原子变量可以实现线程安全。执行某个任务的时候，先假定不会有冲突，若不发生冲突，则直接执行成功；当发生冲突的时候，则执行失败，回滚再重新操作，直到不发生冲突。</p>
<p><img src="https://p0.meituan.net/travelcube/de0ced42337014947e7466db4d8f2d4d158395.png" alt="图2 通过原子变量CAS实现线程安全"></p>
<p>图2 通过原子变量CAS实现线程安全</p>
<p>如图所示，Thread1和Thread2都要把Entry加1。若不加锁，也不使用CAS，有可能Thread1取到了myValue=1，Thread2也取到了myValue=1，然后相加，Entry中的value值为2。这与预期不相符，我们预期的是Entry的值经过两次相加后等于3。</p>
<p>CAS会先把Entry现在的value跟线程当初读出的值相比较，若相同，则赋值；若不相同，则赋值执行失败。一般会通过while/for循环来重新执行，直到赋值成功。</p>
<p>代码示例是AtomicInteger的getAndAdd方法。CAS是CPU的一个指令，由CPU保证原子性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Atomically adds the given value to the current value.</span><br><span class="line"> *</span><br><span class="line"> * @param delta the value to add</span><br><span class="line"> * @return the previous value</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final int getAndAdd(int delta) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current &#x3D; get();</span><br><span class="line">        int next &#x3D; current + delta;</span><br><span class="line">        if (compareAndSet(current, next))</span><br><span class="line">            return current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#x2F;**</span><br><span class="line"> * Atomically sets the value to the given updated value</span><br><span class="line"> * if the current value &#123;@code &#x3D;&#x3D;&#125; the expected value.</span><br><span class="line"> *</span><br><span class="line"> * @param expect the expected value</span><br><span class="line"> * @param update the new value</span><br><span class="line"> * @return true if successful. False return indicates that</span><br><span class="line"> * the actual value was not equal to the expected value.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在高度竞争的情况下，锁的性能将超过原子变量的性能，但是更真实的竞争情况下，原子变量的性能将超过锁的性能。同时原子变量不会有死锁等活跃性问题。</p>
<h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><p><strong>什么是共享</strong></p>
<p>下图是计算的基本结构。L1、L2、L3分别表示一级缓存、二级缓存、三级缓存，越靠近CPU的缓存，速度越快，容量也越小。所以L1缓存很小但很快，并且紧靠着在使用它的CPU内核；L2大一些，也慢一些，并且仍然只能被一个单独的CPU核使用；L3更大、更慢，并且被单个插槽上的所有CPU核共享；最后是主存，由全部插槽上的所有CPU核共享。</p>
<p><img src="https://p1.meituan.net/travelcube/69ce8ffbe7a4ebee01c377dac174842d433755.png" alt="图3 计算机CPU与缓存示意图"></p>
<p>图3 计算机CPU与缓存示意图</p>
<p>当CPU执行运算的时候，它先去L1查找所需的数据、再去L2、然后是L3，如果最后这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果你在做一些很频繁的事，你要尽量确保数据在L1缓存中。</p>
<p>另外，线程之间共享一份数据的时候，需要一个线程把数据写回主存，而另一个线程访问主存中相应的数据。</p>
<p>下面是从CPU访问不同层级数据的时间概念:</p>
<table>
<thead>
<tr>
<th>从CPU到</th>
<th>大约需要的CPU周期</th>
<th>大约需要的时间</th>
</tr>
</thead>
<tbody><tr>
<td>主存</td>
<td>-</td>
<td>约60-80ns</td>
</tr>
<tr>
<td>QPI 总线传输(between sockets, not drawn)</td>
<td>-</td>
<td>约20ns</td>
</tr>
<tr>
<td>L3 cache</td>
<td>约40-45 cycles</td>
<td>约15ns</td>
</tr>
<tr>
<td>L2 cache</td>
<td>约10 cycles</td>
<td>约3ns</td>
</tr>
<tr>
<td>L1 cache</td>
<td>约3-4 cycles</td>
<td>约1ns</td>
</tr>
<tr>
<td>寄存器</td>
<td>1 cycle</td>
<td>-</td>
</tr>
</tbody></table>
<p>可见CPU读取主存中的数据会比从L1中读取慢了近2个数量级。</p>
<p><strong>缓存行</strong></p>
<p>Cache是由很多个cache line组成的。每个cache line通常是64字节，并且它有效地引用主内存中的一块儿地址。一个Java的long类型变量是8字节，因此在一个缓存行中可以存8个long类型的变量。</p>
<p>CPU每次从主存中拉取数据时，会把相邻的数据也存入同一个cache line。</p>
<p>在访问一个long数组的时候，如果数组中的一个值被加载到缓存中，它会自动加载另外7个。因此你能非常快的遍历这个数组。事实上，你可以非常快速的遍历在连续内存块中分配的任意数据结构。</p>
<p>下面的例子是测试利用cache line的特性和不利用cache line的特性的效果对比。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.meituan.FalseSharing;</span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author gongming</span><br><span class="line"> * @description</span><br><span class="line"> * @date 16&#x2F;6&#x2F;4</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CacheLineEffect &#123;</span><br><span class="line">    &#x2F;&#x2F;考虑一般缓存行大小是64字节，一个 long 类型占8字节</span><br><span class="line">    static  long[][] arr;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        arr &#x3D; new long[1024 * 1024][];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 1024 * 1024; i++) &#123;</span><br><span class="line">            arr[i] &#x3D; new long[8];</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 8; j++) &#123;</span><br><span class="line">                arr[i][j] &#x3D; 0L;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long sum &#x3D; 0L;</span><br><span class="line">        long marked &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 1024 * 1024; i+&#x3D;1) &#123;</span><br><span class="line">            for(int j &#x3D;0; j&lt; 8;j++)&#123;</span><br><span class="line">                sum &#x3D; arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Loop times:&quot; + (System.currentTimeMillis() - marked) + &quot;ms&quot;);</span><br><span class="line"> </span><br><span class="line">        marked &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 8; i+&#x3D;1) &#123;</span><br><span class="line">            for(int j &#x3D;0; j&lt; 1024 * 1024;j++)&#123;</span><br><span class="line">                sum &#x3D; arr[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Loop times:&quot; + (System.currentTimeMillis() - marked) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在2G Hz、2核、8G内存的运行环境中测试，速度差一倍。</p>
<p>结果：</p>
<p>Loop times:30ms Loop times:65ms</p>
<p><strong>什么是伪共享</strong></p>
<p>ArrayBlockingQueue有三个成员变量： - takeIndex：需要被取走的元素下标 - putIndex：可被元素插入的位置的下标 - count：队列中元素的数量</p>
<p>这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。</p>
<p><img src="https://p0.meituan.net/travelcube/192e9b87b7a5b68cac352fdeb81dc93b161543.png" alt="图4 ArrayBlockingQueue伪共享示意图"></p>
<p>图4 ArrayBlockingQueue伪共享示意图</p>
<p>如上图所示，当生产者线程put一个元素到ArrayBlockingQueue时，putIndex会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。</p>
<p>这种无法充分使用缓存行特性的现象，称为伪共享。</p>
<p>对于伪共享，一般的解决方案是，增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上，以空间换时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.meituan.FalseSharing;</span><br><span class="line"> </span><br><span class="line">public class FalseSharing implements Runnable&#123;</span><br><span class="line">        public final static long ITERATIONS &#x3D; 500L * 1000L * 100L;</span><br><span class="line">        private int arrayIndex &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">        private static ValuePadding[] longs;</span><br><span class="line">        public FalseSharing(final int arrayIndex) &#123;</span><br><span class="line">            this.arrayIndex &#x3D; arrayIndex;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public static void main(final String[] args) throws Exception &#123;</span><br><span class="line">            for(int i&#x3D;1;i&lt;10;i++)&#123;</span><br><span class="line">                System.gc();</span><br><span class="line">                final long start &#x3D; System.currentTimeMillis();</span><br><span class="line">                runTest(i);</span><br><span class="line">                System.out.println(&quot;Thread num &quot;+i+&quot; duration &#x3D; &quot; + (System.currentTimeMillis() - start));</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        private static void runTest(int NUM_THREADS) throws InterruptedException &#123;</span><br><span class="line">            Thread[] threads &#x3D; new Thread[NUM_THREADS];</span><br><span class="line">            longs &#x3D; new ValuePadding[NUM_THREADS];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; longs.length; i++) &#123;</span><br><span class="line">                longs[i] &#x3D; new ValuePadding();</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; threads.length; i++) &#123;</span><br><span class="line">                threads[i] &#x3D; new Thread(new FalseSharing(i));</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            for (Thread t : threads) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            for (Thread t : threads) &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public void run() &#123;</span><br><span class="line">            long i &#x3D; ITERATIONS + 1;</span><br><span class="line">            while (0 !&#x3D; --i) &#123;</span><br><span class="line">                longs[arrayIndex].value &#x3D; 0L;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public final static class ValuePadding &#123;</span><br><span class="line">            protected long p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">            protected volatile long value &#x3D; 0L;</span><br><span class="line">            protected long p9, p10, p11, p12, p13, p14;</span><br><span class="line">            protected long p15;</span><br><span class="line">        &#125;</span><br><span class="line">        public final static class ValueNoPadding &#123;</span><br><span class="line">            &#x2F;&#x2F; protected long p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">            protected volatile long value &#x3D; 0L;</span><br><span class="line">            &#x2F;&#x2F; protected long p9, p10, p11, p12, p13, p14, p15;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在2G Hz，2核，8G内存, jdk 1.7.0_45 的运行环境下，使用了共享机制比没有使用共享机制，速度快了4倍左右。</p>
<p>结果：</p>
<ul>
<li>Thread num 1 duration = 447</li>
<li>Thread num 2 duration = 463</li>
<li>Thread num 3 duration = 454</li>
<li>Thread num 4 duration = 464</li>
<li>Thread num 5 duration = 561</li>
<li>Thread num 6 duration = 606</li>
<li>Thread num 7 duration = 684</li>
<li>Thread num 8 duration = 870</li>
<li>Thread num 9 duration = 823</li>
</ul>
<p>把代码中ValuePadding都替换为ValueNoPadding后的结果：</p>
<ul>
<li>Thread num 1 duration = 446</li>
<li>Thread num 2 duration = 2549</li>
<li>Thread num 3 duration = 2898</li>
<li>Thread num 4 duration = 3931</li>
<li>Thread num 5 duration = 4716</li>
<li>Thread num 6 duration = 5424</li>
<li>Thread num 7 duration = 4868</li>
<li>Thread num 8 duration = 4595</li>
<li>Thread num 9 duration = 4540</li>
</ul>
<p>备注：在jdk1.8中，有专门的注解@Contended来避免伪共享，更优雅地解决问题。</p>
<h2 id="Disruptor的设计方案"><a href="#Disruptor的设计方案" class="headerlink" title="Disruptor的设计方案"></a>Disruptor的设计方案</h2><p>Disruptor通过以下设计来解决队列速度慢的问题：</p>
<ul>
<li>环形数组结构</li>
</ul>
<p>为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。</p>
<ul>
<li>元素位置定位</li>
</ul>
<p>数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</p>
<ul>
<li>无锁设计</li>
</ul>
<p>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</p>
<p>下面忽略数组的环形结构，介绍一下如何实现无锁设计。整个过程通过原子变量CAS，保证操作的线程安全。</p>
<h3 id="一个生产者"><a href="#一个生产者" class="headerlink" title="一个生产者"></a>一个生产者</h3><p><strong>写数据</strong></p>
<p>生产者单线程写数据的流程比较简单：</p>
<ol>
<li>申请写入m个元素；</li>
<li>若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素；</li>
<li>若是返回的正确，则生产者开始写入元素。</li>
</ol>
<p><img src="https://p1.meituan.net/travelcube/e71c1449273361ec413fffc7b0bf5507208689.png" alt="图5 单个生产者生产过程示意图"></p>
<p>图5 单个生产者生产过程示意图</p>
<h2 id="多个生产者"><a href="#多个生产者" class="headerlink" title="多个生产者"></a>多个生产者</h2><p>多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor的解决方法是，每个线程获取不同的一段数组空间进行操作。这个通过CAS很容易达到。只需要在分配元素的时候，通过CAS判断一下这段空间是否已经分配出去即可。</p>
<p>但是会遇到一个新问题：如何防止读取的时候，读到还未写的元素。Disruptor在多个生产者的情况下，引入了一个与Ring Buffer大小相同的buffer：available Buffer。当某个位置写入成功的时候，便把availble Buffer相应的位置置位，标记为写入成功。读取的时候，会遍历available Buffer，来判断元素是否已经就绪。</p>
<p>下面分读数据和写数据两种情况介绍。</p>
<h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><p>生产者多线程写入的情况会复杂很多：</p>
<ol>
<li>申请读取到序号n；</li>
<li>若writer cursor &gt;= n，这时仍然无法确定连续可读的最大下标。从reader cursor开始读取available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；</li>
<li>消费者读取元素。</li>
</ol>
<p>如下图所示，读线程读到下标为2的元素，三个线程Writer1/Writer2/Writer3正在向RingBuffer相应位置写数据，写线程被分配到的最大元素下标是11。</p>
<p>读线程申请读取到下标从3到11的元素，判断writer cursor&gt;=11。然后开始读取availableBuffer，从3开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。</p>
<p>然后，消费者读取下标从3到6共计4个元素。</p>
<p><img src="https://p0.meituan.net/travelcube/99c603494ea90c9535e165579daf340a161527.png" alt="图6 多个生产者情况下，消费者消费过程示意图"></p>
<p>图6 多个生产者情况下，消费者消费过程示意图</p>
<h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><p>多个生产者写入的时候：</p>
<ol>
<li>申请写入m个元素；</li>
<li>若是有m个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；</li>
<li>生产者写入元素，写入元素的同时设置available Buffer里面相应的位置，以标记自己哪些位置是已经写入成功的。</li>
</ol>
<p>如下图所示，Writer1和Writer2两个线程写入数组，都申请可写的数组空间。Writer1被分配了下标3到下表5的空间，Writer2被分配了下标6到下标9的空间。</p>
<p>Writer1写入下标3位置的元素，同时把available Buffer相应位置置位，标记已经写入成功，往后移一位，开始写下标4位置的元素。Writer2同样的方式。最终都写入完成。</p>
<p><img src="https://p1.meituan.net/travelcube/5e06841b1bba4dcf1d3fac169734ba36133983.png" alt="图7 多个生产者情况下，生产者生产过程示意图"></p>
<p>图7 多个生产者情况下，生产者生产过程示意图</p>
<p>防止不同生产者对同一段空间写入的代码，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public long tryNext(int n) throws InsufficientCapacityException</span><br><span class="line">&#123;</span><br><span class="line">    if (n &lt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;n must be &gt; 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    long current;</span><br><span class="line">    long next;</span><br><span class="line"> </span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        current &#x3D; cursor.get();</span><br><span class="line">        next &#x3D; current + n;</span><br><span class="line"> </span><br><span class="line">        if (!hasAvailableCapacity(gatingSequences, n, current))</span><br><span class="line">        &#123;</span><br><span class="line">            throw InsufficientCapacityException.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (!cursor.compareAndSet(current, next));</span><br><span class="line"> </span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过do/while循环的条件cursor.compareAndSet(current, next)，来判断每次申请的空间是否已经被其他生产者占据。假如已经被占据，该函数会返回失败，While循环重新执行，申请写入空间。</p>
<p>消费者的流程与生产者非常类似，这儿就不多描述了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Disruptor通过精巧的无锁设计实现了在高并发情形下的高性能。</p>
<p>在美团内部，很多高并发场景借鉴了Disruptor的设计，减少竞争的强度。其设计思想可以扩展到分布式场景，通过无锁设计，来提升服务性能。</p>
<p>使用Disruptor比使用ArrayBlockingQueue略微复杂，为方便读者上手，增加代码样例。</p>
<p>代码实现的功能：每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端。详细逻辑请细读代码。</p>
<p>以下代码基于3.3.4版本的Disruptor包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package com.meituan.Disruptor;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @description disruptor代码样例。每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端</span><br><span class="line"> *&#x2F;</span><br><span class="line">import com.lmax.disruptor.*;</span><br><span class="line">import com.lmax.disruptor.dsl.Disruptor;</span><br><span class="line">import com.lmax.disruptor.dsl.ProducerType;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ThreadFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class DisruptorMain</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 队列中的元素</span><br><span class="line">        class Element &#123;</span><br><span class="line"></span><br><span class="line">            private int value;</span><br><span class="line"></span><br><span class="line">            public int get()&#123;</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void set(int value)&#123;</span><br><span class="line">                this.value&#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 生产者的线程工厂</span><br><span class="line">        ThreadFactory threadFactory &#x3D; new ThreadFactory()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Thread newThread(Runnable r) &#123;</span><br><span class="line">                return new Thread(r, &quot;simpleThread&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; RingBuffer生产工厂,初始化RingBuffer的时候使用</span><br><span class="line">        EventFactory&lt;Element&gt; factory &#x3D; new EventFactory&lt;Element&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Element newInstance() &#123;</span><br><span class="line">                return new Element();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 处理Event的handler</span><br><span class="line">        EventHandler&lt;Element&gt; handler &#x3D; new EventHandler&lt;Element&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onEvent(Element element, long sequence, boolean endOfBatch)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;Element: &quot; + element.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 阻塞策略</span><br><span class="line">        BlockingWaitStrategy strategy &#x3D; new BlockingWaitStrategy();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 指定RingBuffer的大小</span><br><span class="line">        int bufferSize &#x3D; 16;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建disruptor，采用单生产者模式</span><br><span class="line">        Disruptor&lt;Element&gt; disruptor &#x3D; new Disruptor(factory, bufferSize, threadFactory, ProducerType.SINGLE, strategy);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置EventHandler</span><br><span class="line">        disruptor.handleEventsWith(handler);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 启动disruptor的线程</span><br><span class="line">        disruptor.start();</span><br><span class="line"></span><br><span class="line">        RingBuffer&lt;Element&gt; ringBuffer &#x3D; disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">        for (int l &#x3D; 0; true; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 获取下一个可用位置的下标</span><br><span class="line">            long sequence &#x3D; ringBuffer.next();  </span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; 返回可用位置的元素</span><br><span class="line">                Element event &#x3D; ringBuffer.get(sequence); </span><br><span class="line">                &#x2F;&#x2F; 设置该位置元素的值</span><br><span class="line">                event.set(l); </span><br><span class="line">            &#125;</span><br><span class="line">            finally</span><br><span class="line">            &#123;</span><br><span class="line">                ringBuffer.publish(sequence);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>以下面这些模式测试性能:</p>
<p><img src="https://p1.meituan.net/travelcube/ada37da4ad62709ab67d7a32147cb19a306409.png" alt="img"></p>
<p>吞吐量测试数据（每秒的数量）如下。</p>
<p>环境： - CPU:Intel Core i7 860 @ 2.8 GHz without HT - JVM:Java 1.6.0_25 64-bit - OS:Windows 7</p>
<table>
<thead>
<tr>
<th>-</th>
<th>ABQ</th>
<th>Disruptor</th>
</tr>
</thead>
<tbody><tr>
<td>Unicast: 1P – 1C</td>
<td>5,339,256</td>
<td>25,998,336</td>
</tr>
<tr>
<td>Pipeline: 1P – 3C</td>
<td>2,128,918</td>
<td>16,806,157</td>
</tr>
<tr>
<td>Sequencer: 3P – 1C</td>
<td>5,539,531</td>
<td>13,403,268</td>
</tr>
<tr>
<td>Multicast: 1P – 3C</td>
<td>1,077,384</td>
<td>9,377,871</td>
</tr>
<tr>
<td>Diamond: 1P – 3C</td>
<td>2,113,941</td>
<td>16,143,613</td>
</tr>
</tbody></table>
<p>环境：</p>
<ul>
<li>CPU:Intel Core i7-2720QM</li>
<li>JVM:Java 1.6.0_25 64-bit</li>
<li>OS:Ubuntu 11.04</li>
</ul>
<table>
<thead>
<tr>
<th>-</th>
<th>ABQ</th>
<th>Disruptor</th>
</tr>
</thead>
<tbody><tr>
<td>Unicast: 1P – 1C</td>
<td>4,057,453</td>
<td>22,381,378</td>
</tr>
<tr>
<td>Pipeline: 1P – 3C</td>
<td>2,006,903</td>
<td>15,857,913</td>
</tr>
<tr>
<td>Sequencer: 3P – 1C</td>
<td>2,056,118</td>
<td>14,540,519</td>
</tr>
<tr>
<td>Multicast: 1P – 3C</td>
<td>260,733</td>
<td>10,860,121</td>
</tr>
<tr>
<td>Diamond: 1P – 3C</td>
<td>2,082,725</td>
<td>15,295,197</td>
</tr>
</tbody></table>
<p>依据并发竞争的激烈程度的不同，Disruptor比ArrayBlockingQueue吞吐量快4~7倍。</p>
<p>按照Pipeline: 1P – 3C的连接模式测试延迟，生产者两次写入之间的延迟为1ms。</p>
<p>运行环境：</p>
<ul>
<li>CPU:2.2GHz Core i7-2720QM</li>
<li>Java: 1.6.0_25 64-bit</li>
<li>OS:Ubuntu 11.04.</li>
</ul>
<table>
<thead>
<tr>
<th>-</th>
<th>Array Blocking Queue (ns)</th>
<th>Disruptor (ns)</th>
</tr>
</thead>
<tbody><tr>
<td>99% observations less than</td>
<td>2,097,152</td>
<td>128</td>
</tr>
<tr>
<td>99.99% observations less than</td>
<td>4,194,304</td>
<td>8,192</td>
</tr>
<tr>
<td>Max Latency</td>
<td>5,069,086</td>
<td>175,567</td>
</tr>
<tr>
<td>Mean Latency</td>
<td>32,757</td>
<td>52</td>
</tr>
<tr>
<td>Min Latency</td>
<td>145</td>
<td>29</td>
</tr>
</tbody></table>
<p>可见，平均延迟差了3个数量级。</p>
<h2 id="等待策略"><a href="#等待策略" class="headerlink" title="等待策略"></a>等待策略</h2><h3 id="生产者的等待策略"><a href="#生产者的等待策略" class="headerlink" title="生产者的等待策略"></a>生产者的等待策略</h3><p>暂时只有休眠1ns。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LockSupport.parkNanos(1);</span><br></pre></td></tr></table></figure>

<h3 id="消费者的等待策略"><a href="#消费者的等待策略" class="headerlink" title="消费者的等待策略"></a>消费者的等待策略</h3><table>
<thead>
<tr>
<th>名称</th>
<th>措施</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>BlockingWaitStrategy</td>
<td>加锁</td>
<td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td>
</tr>
<tr>
<td>BusySpinWaitStrategy</td>
<td>自旋</td>
<td>通过不断重试，减少切换线程导致的系统调用，而降低延迟。推荐在线程绑定到固定的CPU的场景下使用</td>
</tr>
<tr>
<td>PhasedBackoffWaitStrategy</td>
<td>自旋 + yield + 自定义策略</td>
<td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td>
</tr>
<tr>
<td>SleepingWaitStrategy</td>
<td>自旋 + yield + sleep</td>
<td>性能和CPU资源之间有很好的折中。延迟不均匀</td>
</tr>
<tr>
<td>TimeoutBlockingWaitStrategy</td>
<td>加锁，有超时限制</td>
<td>CPU资源紧缺，吞吐量和延迟并不重要的场景</td>
</tr>
<tr>
<td>YieldingWaitStrategy</td>
<td>自旋 + yield + 自旋</td>
<td>性能和CPU资源之间有很好的折中。延迟比较均匀</td>
</tr>
</tbody></table>
<h2 id="Log4j-2应用场景"><a href="#Log4j-2应用场景" class="headerlink" title="Log4j 2应用场景"></a>Log4j 2应用场景</h2><p>Log4j 2相对于Log4j 1最大的优势在于多线程并发场景下性能更优。该特性源自于Log4j 2的异步模式采用了Disruptor来处理。 在Log4j 2的配置文件中可以配置WaitStrategy，默认是Timeout策略。下面是Log4j 2中对WaitStrategy的配置官方文档：</p>
<table>
<thead>
<tr>
<th>System Property</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>AsyncLogger.WaitStrategy</td>
<td>Timeout</td>
<td>Valid values: Block, Timeout, Sleep, Yield. Block is a strategy that uses a lock and condition variable for the I/O thread waiting for log events. Block can be used when throughput and low-latency are not as important as CPU resource. Recommended for resource constrained/virtualised environments. Timeout is a variation of the Block strategy that will periodically wake up from the lock condition await() call. This ensures that if a notification is missed somehow the consumer thread is not stuck but will recover with a small latency delay (default 10ms). Sleep is a strategy that initially spins, then uses a Thread.yield(), and eventually parks for the minimum number of nanos the OS and JVM will allow while the I/O thread is waiting for log events. Sleep is a good compromise between performance and CPU resource. This strategy has very low impact on the application thread, in exchange for some additional latency for actually getting the message logged. Yield is a strategy that uses a Thread.yield() for waiting for log events after an initially spinning. Yield is a good compromise between performance and CPU resource, but may use more CPU than Sleep in order to get the message logged to disk sooner.</td>
</tr>
</tbody></table>
<h3 id="性能差异"><a href="#性能差异" class="headerlink" title="性能差异"></a>性能差异</h3><p>loggers all async采用的是Disruptor，而Async Appender采用的是ArrayBlockingQueue队列。</p>
<p>由图可见，单线程情况下，loggers all async与Async Appender吞吐量相差不大，但是在64个线程的时候，loggers all async的吞吐量比Async Appender增加了12倍，是Sync模式的68倍。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/ad04b8bd.png" alt="图8 Log4j 2各个模式性能比较"></p>
<p>图8 Log4j 2各个模式性能比较</p>
<p>美团在公司内部统一推行日志接入规范，要求必须使用Log4j 2，使普通单机QPS的上限不再只停留在几千，极高地提升了服务性能。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="http://brokendreams.iteye.com/blog/2255720" target="_blank" rel="noopener">http://brokendreams.iteye.com/blog/2255720</a></li>
<li><a href="http://ifeve.com/dissecting-disruptor-whats-so-special/" target="_blank" rel="noopener">http://ifeve.com/dissecting-disruptor-whats-so-special/</a></li>
<li><a href="https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results" target="_blank" rel="noopener">https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results</a></li>
<li><a href="https://lmax-exchange.github.io/disruptor/" target="_blank" rel="noopener">https://lmax-exchange.github.io/disruptor/</a></li>
<li><a href="https://logging.apache.org/log4j/2.x/manual/async.html" target="_blank" rel="noopener">https://logging.apache.org/log4j/2.x/manual/async.html</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blob.itmarte.com/2020/04/27/java/disruptor/" data-id="ckc4mb0pm005x3wja0ns50ha8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/collection/" rel="tag">collection</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/disruptor/" rel="tag">disruptor</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/27/hello-world/" class="article-date">
  <time datetime="2020-04-27T07:32:30.284Z" itemprop="datePublished">2020-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line"><span class="comment"># 创建layout为 `post-java` 且路径为 java/schedule 文件名为chedule</span></span><br><span class="line">$ hexo new post-java  -p <span class="string">"java/schedule"</span> schedule</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blob.itmarte.com/2020/04/27/hello-world/" data-id="ckc4mb0dt00003wja12ww74hf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java/schedule" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/27/java/schedule/" class="article-date">
  <time datetime="2020-04-27T05:47:12.000Z" itemprop="datePublished">2020-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>►<a class="article-category-link" href="/categories/java/schedule/">schedule</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/java/schedule/">schedule</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>并发编程领域中<strong>定时器</strong> 相关内容经常被一些介绍并发编程书籍所遗忘，属于并发编程学习优先级较低的知识点。在JDK源码中有两种定时器实现，一种是JDK1.3引入的<strong>*Timer</strong>类<em>，它是一种基于单线程操作的简单任务调度器，虽然存在较多设计缺陷，但仍有很多应用场景和使用案例；另一种JDK1.5引入的*</em>ScheduledThreadPoolExecutor**类，是一种基于线程池操作的较复杂任务调度器，同时也是官方推荐的任务调度器实现。</p>
<p>定时器Timer，也称简单任务调度器。它由以下四个类组成，</p>
<ul>
<li>定时任务（TimerTask类）</li>
<li>任务队列（TaskQueue类）</li>
<li>定时线程（TimerThread类）</li>
<li>定时器（Timer类）</li>
</ul>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a><strong>定时任务</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class TimerTask implements Runnable &#123;</span><br><span class="line">    final Object lock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;任务状态</span><br><span class="line">    int state &#x3D; VIRGIN;</span><br><span class="line">    static final int VIRGIN &#x3D; 0;</span><br><span class="line">    static final int SCHEDULED   &#x3D; 1;</span><br><span class="line">    static final int EXECUTED    &#x3D; 2;</span><br><span class="line">    static final int CANCELLED   &#x3D; 3;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;下次执行时间</span><br><span class="line">    long nextExecutionTime;</span><br><span class="line">    &#x2F;&#x2F;调度至执行间隔时间</span><br><span class="line">    long period &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类TimerTask实现Runnable接口，表明该类作为定时任务模版，用户可以根据业务场景定义具体任务。TimerTask类要维护<strong>任务状态</strong> (state)、<strong>任务下次执行时间</strong>（nextExecutionTime）和<strong>任务调度至执行的间隔时间</strong>（period）。</p>
<blockquote>
<p>任务状态</p>
</blockquote>
<p>定时器任务生命周期中可能处于下表所示的4种不同的状态，在给定的时刻定时器任务只能处于其中一种状态。</p>
<p><img src="/images/java_time_task.png" alt="timer task"></p>
<blockquote>
<p>执行任务</p>
</blockquote>
<p>TimerTask类的抽象方法run来自Runnable接口，TimerTask并未实现该接口，延迟至子类实现。用户可在派生类中自定义任务逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract void run();</span><br></pre></td></tr></table></figure>

<p>抽象类TimerTask的run方法并不一定要来源于Runnable接口，它并未接受线程调度，而是由TimerThread线程从TimerQueue中消费任务，然后直接调用TimerTask.run()执行任务。基于这种理解，TimerTask类完全可以像这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public abstract class TimerTask &#123;  &#x2F;&#x2F; 舍去implement Runnable</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;由抽象类自己定义,而非来自Runnable接口</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TimerTask类这种写法可以理解为被<strong>过度设计</strong>了，读者可思之。</p>
<blockquote>
<p>取消任务</p>
</blockquote>
<p>如果当前任务正处于SCHEDULED状态，允许撤销当前任务，置任务为CANCELLED状态，返回true表示任务撤销成功；若任务处于其它状态，也置任务为CANCELLED状态，并返回false表示任务撤销失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean cancel() &#123;</span><br><span class="line">    synchronized(lock) &#123;</span><br><span class="line">        boolean result &#x3D; (state &#x3D;&#x3D; SCHEDULED);</span><br><span class="line">        &#x2F;&#x2F;实际上所有任务都能被取消</span><br><span class="line">        state &#x3D; CANCELLED;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用TimerTask.cancel()，虽然对不同状态有不同的返回值，但不管什么状态都能够被取消。设计逻辑匪夷所思，我认为这种<strong>设计不合理</strong>，读者可思之。</p>
<blockquote>
<p>调度执行时间</p>
</blockquote>
<p>scheduledExecutionTime方法获取任务被调度后最近的开始执行时间点，保证调度时间在下次执行时间之前。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public long scheduledExecutionTime() &#123;</span><br><span class="line">    synchronized(lock) &#123;</span><br><span class="line">        return (period &lt; 0 ? </span><br><span class="line">            nextExecutionTime + period : nextExecutionTime - period);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时线程"><a href="#定时线程" class="headerlink" title="定时线程"></a><strong>定时线程</strong></h2><p>从优先级队列里异步消费任务的操作由单线程完成。TimerThread是单线程，因此需要mainLoop循环逻辑来轮询消费任务队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class TimerThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    boolean newTasksMayBeScheduled &#x3D; true;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;内部维护一个队列</span><br><span class="line">    private TaskQueue queue;</span><br><span class="line"></span><br><span class="line">    TimerThread(TaskQueue queue) &#123;</span><br><span class="line">        this.queue &#x3D; queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>轮询任务</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;循环执行逻辑</span><br><span class="line">        mainLoop();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        synchronized(queue) &#123;</span><br><span class="line">            newTasksMayBeScheduled &#x3D; false;</span><br><span class="line">            &#x2F;&#x2F;清空任务队列. 在结束循环后可能仍有任务被加入到队列,因此需要清空.</span><br><span class="line">            queue.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void mainLoop() &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TimerTask task;</span><br><span class="line">            boolean taskFired;</span><br><span class="line">            synchronized(queue) &#123;  </span><br><span class="line">                &#x2F;&#x2F;若队列为空且定时器未被撤销,则挂起定时线程直至被唤醒       </span><br><span class="line">                while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled) &#123;                     </span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;若线程被唤醒后队列仍为空,则结束循环. 说明此时定时器被撤销.</span><br><span class="line">                if (queue.isEmpty()) &#123;</span><br><span class="line">                    break;            </span><br><span class="line">                &#125;    </span><br><span class="line">  </span><br><span class="line">                long currentTime, executionTime;</span><br><span class="line">                &#x2F;&#x2F;获取最近执行时间任务</span><br><span class="line">                task &#x3D; queue.getMin();</span><br><span class="line">                synchronized(task.lock) &#123;</span><br><span class="line">                    &#x2F;&#x2F;任务若被取消,则从队列中移除,并继续轮询</span><br><span class="line">                    if (task.state &#x3D;&#x3D; TimerTask.CANCELLED) &#123;</span><br><span class="line">                        queue.removeMin();</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    currentTime &#x3D; System.currentTimeMillis();</span><br><span class="line">                    executionTime &#x3D; task.nextExecutionTime;</span><br><span class="line">                    &#x2F;&#x2F;任务最近要执行</span><br><span class="line">                    if (taskFired &#x3D; (executionTime&lt;&#x3D;currentTime)) &#123;</span><br><span class="line">                        &#x2F;&#x2F;若为非重复执行任务,从队列中移除该任务,并设置该任务状态为已执行</span><br><span class="line">                        if (task.period &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            queue.removeMin();</span><br><span class="line">                            task.state &#x3D; TimerTask.EXECUTED;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            &#x2F;&#x2F;若为重复执行任务,则在指定时刻重新调度该任务</span><br><span class="line">                            queue.rescheduleMin(</span><br><span class="line">                                task.period&lt;0 ? currentTime-task.period</span><br><span class="line">                                    : executionTime + task.period);                      </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;若最近无任务要执行,则等待至要执行任务的指定时刻</span><br><span class="line">                    if (!taskFired) &#123;</span><br><span class="line">                        queue.wait(executionTime - currentTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F;任务已释放,运行任务</span><br><span class="line">            if (taskFired) &#123; </span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a><strong>任务队列</strong></h2><p>任务队列是基于完全二叉树实现的小顶堆。队列初始容量为128，由于0位置不存储任务，因此实际初始容量为127，size表示队列的任务数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class TaskQueue &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;基于顺序表实现的定时任务队列</span><br><span class="line">    private TimerTask[] queue &#x3D; new TimerTask[128];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;队列任务数</span><br><span class="line">    private int size &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查询容量</p>
</blockquote>
<p>查询队列任务数和判断队列是否为空都直接使用任务队列内部维护的size属性，因此这两个操作的时间复杂度为O(1)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 队列任务数 *&#x2F;</span><br><span class="line">int size() &#123; return size; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** 队列是否为空 *&#x2F;</span><br><span class="line">boolean isEmpty() &#123; return size&#x3D;&#x3D;0; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加任务</p>
</blockquote>
<p>主线程向任务队列中注入新任务。如果当前任务队列容量已达极限，则在原容量基础上扩容一倍，并在任务队列末尾追加新任务，并根据任务执行时间作为优先级调整新任务在任务队列中的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 新增任务并调整小顶堆 *&#x2F;</span><br><span class="line">void add(TimerTask task) &#123;</span><br><span class="line">    &#x2F;&#x2F;任务数达到队列最大容量,则扩容一倍</span><br><span class="line">    if (size + 1 &#x3D;&#x3D; queue.length) &#123;</span><br><span class="line">        queue &#x3D; Arrays.copyOf(queue, 2*queue.length);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;添加任务</span><br><span class="line">    queue[++size] &#x3D; task;</span><br><span class="line">    &#x2F;&#x2F;向上调整任务</span><br><span class="line">    fixUp(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/80/v2-3e64d663f2d599d0c7b40a7464dd0072_720w.jpg" alt="img"></p>
<blockquote>
<p>获取任务</p>
</blockquote>
<p>从任务队列中获取最近将要执行任务的时间复杂度为O(1)；获得指定位置任务的时间复杂度也是O(1)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 获得下次执行时间最小的任务,即最小堆根结点 *&#x2F;</span><br><span class="line">TimerTask getMin() &#123; return queue[1]; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** 获得指定位置的任务 *&#x2F;</span><br><span class="line">TimerTask get(int i) &#123; return queue[i]; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="images/getmint_20200427144736.png" alt="img"></p>
<blockquote>
<p>移除任务</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 移除下次执行时间最小的任务,即移除堆顶任务 *&#x2F;</span><br><span class="line">void removeMin() &#123;</span><br><span class="line">    queue[1] &#x3D; queue[size];</span><br><span class="line">    queue[size--] &#x3D; null;</span><br><span class="line">    fixDown(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-d0a23892cf5a8aaef780bf8f0e6f0e33_720w.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 快速移除指定位置处任务 *&#x2F;</span><br><span class="line">void quickRemove(int i) &#123;</span><br><span class="line">    assert i &lt;&#x3D; size;  &#x2F;&#x2F;assert生效需要编译器开启断言功能</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;指定位置元素直接用最后元素代替,不需要向下调整</span><br><span class="line">    queue[i] &#x3D; queue[size];</span><br><span class="line">    queue[size--] &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-d72f08b8ae0fbaaa9a3da508f9e64b54_720w.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 清空任务队列 *&#x2F;</span><br><span class="line">void clear() &#123;</span><br><span class="line">    for (int i&#x3D;1; i&lt;&#x3D;size; i++)</span><br><span class="line">        queue[i] &#x3D; null;</span><br><span class="line">    size &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重新调度任务</p>
</blockquote>
<p>重新调度任务不删除堆顶任务，而是将堆顶任务的nextExecutionTime加上period后得到新的nextExecutionTime值，然后根据任务优先级向下调整。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void rescheduleMin(long newTime) &#123;</span><br><span class="line">    queue[1].nextExecutionTime &#x3D; newTime;</span><br><span class="line">    fixDown(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/80/v2-26395bd09d3fc3d4fd4990a3707aa34a_720w.jpg" alt="img"></p>
<blockquote>
<p>基础算法</p>
</blockquote>
<p>任务队列是优先级队列，基于顺序结构完全二叉树实现的小顶堆。优先级的依据是任务下次执行时间。</p>
<p><img src="https://pic2.zhimg.com/80/v2-7dbfc6a56603dfc301213dd0ba8cfa0d_720w.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 提升优先级 *&#x2F;</span><br><span class="line">private void fixUp(int k) &#123;</span><br><span class="line">    while (k &gt; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F;父结点位置</span><br><span class="line">        int j &#x3D; k &gt;&gt; 1;</span><br><span class="line">        &#x2F;&#x2F;如果父结点的下次任务执行时间小于当前结点下次任务执行时间,结束调整操作</span><br><span class="line">        if (queue[j].nextExecutionTime &lt;&#x3D; queue[k].nextExecutionTime) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调整任务在任务队列中的位置</span><br><span class="line">        TimerTask tmp &#x3D; queue[j];  </span><br><span class="line">        queue[j] &#x3D; queue[k]; </span><br><span class="line">        queue[k] &#x3D; tmp;</span><br><span class="line">        k &#x3D; j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 降低优先级 *&#x2F;</span><br><span class="line">private void fixDown(int k) &#123;</span><br><span class="line">    int j;</span><br><span class="line">    while ((j &#x3D; k &lt;&lt; 1) &lt;&#x3D; size &amp;&amp; j &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;选择左右两侧子结点,选择更小的交换位置</span><br><span class="line">        if (j &lt; size &amp;&amp; </span><br><span class="line">            queue[j].nextExecutionTime &gt; queue[j+1].nextExecutionTime) &#123;</span><br><span class="line">            j++; </span><br><span class="line">        &#125;</span><br><span class="line">        if (queue[k].nextExecutionTime &lt;&#x3D; queue[j].nextExecutionTime) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调整任务在任务队列中的位置</span><br><span class="line">        TimerTask tmp &#x3D; queue[j];  </span><br><span class="line">        queue[j] &#x3D; queue[k]; </span><br><span class="line">        queue[k] &#x3D; tmp;</span><br><span class="line">        k &#x3D; j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调整当前完全二叉树为最小堆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 堆化 *&#x2F;</span><br><span class="line">void heapify() &#123;</span><br><span class="line">    for (int i &#x3D; size&#x2F;2; i &gt;&#x3D; 1; i--) &#123;</span><br><span class="line">        fixDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h2><p>一个定时器内部维护一个任务队列和一个定时线程。在Main线程往任务队列注入任务后，由定时线程异步轮询处理任务队列，这种处理方式实质上是异步串行方式，任务处理并发度为1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Timer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 任务队列 *&#x2F;</span><br><span class="line">    private final TaskQueue queue &#x3D; new TaskQueue();</span><br><span class="line"></span><br><span class="line">    &#x2F;** 定时线程 *&#x2F;</span><br><span class="line">    private final TimerThread thread &#x3D; new TimerThread(queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造器</p>
</blockquote>
<p>新建Timer实例，同时也新建了任务队列和定时线程，并启动定时线程。启动定时线程前可指定定时线程的名称，以及指定为后台线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Timer() &#123;</span><br><span class="line">    this(&quot;Timer-&quot; + serialNumber());</span><br><span class="line">&#125;</span><br><span class="line">public Timer(boolean isDaemon) &#123;</span><br><span class="line">    this(&quot;Timer-&quot; + serialNumber(), isDaemon);</span><br><span class="line">&#125;</span><br><span class="line">public Timer(String name) &#123;</span><br><span class="line">    thread.setName(name);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line">public Timer(String name, boolean isDaemon) &#123;</span><br><span class="line">    thread.setName(name); </span><br><span class="line">    thread.setDaemon(isDaemon);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;单机序列号生成</span><br><span class="line">private final static AtomicInteger nextSerialNumber &#x3D; new AtomicInteger(0);</span><br><span class="line">private static int serialNumber() &#123;</span><br><span class="line">    return nextSerialNumber.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定间隔调度</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 延迟调度 *&#x2F;</span><br><span class="line">public void schedule(TimerTask task, long delay) &#123;</span><br><span class="line">    if (delay &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从当前时间开始延时delay毫秒后调度</span><br><span class="line">    sched(task, System.currentTimeMillis()+delay, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** 定时调度 *&#x2F;</span><br><span class="line">public void schedule(TimerTask task, Date time) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;从指定时刻出开始调度</span><br><span class="line">    sched(task, time.getTime(), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** 延时周期性调度 *&#x2F;</span><br><span class="line">public void schedule(TimerTask task, long delay, long period) &#123;</span><br><span class="line">    if (delay &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span><br><span class="line">    if (period &lt;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class="line">    sched(task, System.currentTimeMillis()+delay, -period);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** 定时周期性调度 *&#x2F;</span><br><span class="line">public void schedule(TimerTask task, Date firstTime, long period) &#123;</span><br><span class="line">    if (period &lt;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class="line">    sched(task, firstTime.getTime(), -period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Timer.schedule()侧重period时间的一致性，保证执行任务的间隔时间相同。</p>
<p><img src="https://pic3.zhimg.com/80/v2-367f6ca013b337ab1d2f2547ed871766_720w.png" alt="img"></p>
<blockquote>
<p>定频率调度</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 延时周期性定速调度 *&#x2F;</span><br><span class="line">public void scheduleAtFixedRate(TimerTask task, long delay, long period) &#123;</span><br><span class="line">    if (delay &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Negative delay.&quot;);</span><br><span class="line">    if (period &lt;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class="line">    sched(task, System.currentTimeMillis()+delay, period);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** 定时周期性定速调度 *&#x2F;</span><br><span class="line">public void scheduleAtFixedRate(TimerTask task, Date firstTime, long period) &#123;</span><br><span class="line">    if (period &lt;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Non-positive period.&quot;);</span><br><span class="line">    sched(task, firstTime.getTime(), period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Timer.scheduleAtFixedRate()侧重执行频率的一致性，任务执行时间加period时间的和相等。</p>
<p><img src="https://pic4.zhimg.com/80/v2-493048111335ad7f57c1f51a29b37753_720w.png" alt="img"></p>
<blockquote>
<p>核心调度算法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private void sched(TimerTask task, long time, long period) &#123;</span><br><span class="line">    if (time &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal execution time.&quot;);      </span><br><span class="line">    if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1))</span><br><span class="line">        period &gt;&gt;&#x3D; 1;</span><br><span class="line"></span><br><span class="line">    synchronized(queue) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;保证定时器未被取消</span><br><span class="line">        if (!thread.newTasksMayBeScheduled) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Timer already cancelled.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized(task.lock) &#123;</span><br><span class="line">            &#x2F;&#x2F;保证任务最初处于未使用状态</span><br><span class="line">            if (task.state !&#x3D; TimerTask.VIRGIN) &#123;</span><br><span class="line">                throw new IllegalStateException(</span><br><span class="line">                    &quot;Task already scheduled or cancelled&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;下次任务执行时间</span><br><span class="line">            task.nextExecutionTime &#x3D; time;</span><br><span class="line">            &#x2F;&#x2F;任务执行周期</span><br><span class="line">            task.period &#x3D; period;</span><br><span class="line">            &#x2F;&#x2F;设置任务状态为已调度</span><br><span class="line">            task.state &#x3D; TimerTask.SCHEDULED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;往任务队列中添加任务</span><br><span class="line">        queue.add(task);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果队列中该任务为最近要执行的任务,则立即唤醒定时线程处理</span><br><span class="line">        if (queue.getMin() &#x3D;&#x3D; task) &#123;</span><br><span class="line">            queue.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>撤销定时器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void cancel() &#123;</span><br><span class="line">    synchronized(queue) &#123;</span><br><span class="line">        &#x2F;&#x2F;撤销定时器</span><br><span class="line">        thread.newTasksMayBeScheduled &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F;清空任务队列</span><br><span class="line">        queue.clear();</span><br><span class="line">        &#x2F;&#x2F;唤醒定时线程</span><br><span class="line">        queue.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>清理取消状态的任务</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int purge() &#123;</span><br><span class="line">    &#x2F;&#x2F;从队列中移除的任务数</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    synchronized(queue) &#123;</span><br><span class="line">        for (int i &#x3D; queue.size(); i &gt; 0; i--) &#123;</span><br><span class="line">            &#x2F;&#x2F;从队列中移除取消状态任务</span><br><span class="line">            if (queue.get(i).state &#x3D;&#x3D; TimerTask.CANCELLED) &#123;</span><br><span class="line">                queue.quickRemove(i);</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果仍有非取消任务,队列重新堆化</span><br><span class="line">        if (result !&#x3D; 0)</span><br><span class="line">            queue.heapify();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>读完源码后总结如下，</p>
<blockquote>
<p>数据结构</p>
</blockquote>
<p>小顶堆实现优先级队列，优先级标准是任务下次执行时间。</p>
<blockquote>
<p>任务状态转换</p>
</blockquote>
<p><img src="https://pic3.zhimg.com/80/v2-ad4c978cc45c7a22464335345f525932_720w.jpg" alt="img"></p>
<blockquote>
<p>定时器架构图</p>
</blockquote>
<p><img src="https://pic3.zhimg.com/80/v2-08da55ef92a07ae0f90a07f18521bb8e_720w.jpg" alt="img"></p>
<blockquote>
<p>架构缺陷</p>
</blockquote>
<p>单线程串行消费任务，前置任务消费延迟或失败会直接影响后续任务的消费。如果消费前置任务时抛出异常，线程退出，队列中的任务无法被继续消费，定时器失效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blob.itmarte.com/2020/04/27/java/schedule/" data-id="ckc4mb0p7005k3wja8nmc9qb5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/schedule/" rel="tag">schedule</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-project/open-api" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/15/project/open-api/" class="article-date">
  <time datetime="2020-04-15T12:16:19.000Z" itemprop="datePublished">2020-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a>►<a class="article-category-link" href="/categories/%E9%A1%B9%E7%9B%AE/Open-API/">Open API</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/15/project/open-api/">Open API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#架构图</p>
<h3 id="架构类"><a href="#架构类" class="headerlink" title="架构类"></a>架构类</h3><h4 id="框架上使用"><a href="#框架上使用" class="headerlink" title="框架上使用"></a>框架上使用</h4><p><code>spring</code>/<code>mybatis</code>/<code>undertow</code>  </p>
<h4 id="服务治理使用"><a href="#服务治理使用" class="headerlink" title="服务治理使用"></a>服务治理使用</h4><p><code>dubbo</code>   </p>
<h4 id="缓存服务使用"><a href="#缓存服务使用" class="headerlink" title="缓存服务使用"></a>缓存服务使用</h4><p><code>redis</code>（身份认证状态缓存，临时性字典数据缓存，提升效率）</p>
<h4 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h4><p><code>RocketMQ</code>（mq做业务解耦，流量削峰，业务驱动，回调通知队列，消息持久化和定时任务补偿保证数据不被丢失）</p>
<h4 id="分布式锁服务"><a href="#分布式锁服务" class="headerlink" title="分布式锁服务"></a>分布式锁服务</h4><p>zk</p>
<h4 id="webhook通知服务"><a href="#webhook通知服务" class="headerlink" title="webhook通知服务"></a>webhook通知服务</h4><p>okhttp3、forkjoin框架、rocketMq队列、elasticJob补偿</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>nginx、lua、redis、mq</p>
<h4 id="服务稳定性"><a href="#服务稳定性" class="headerlink" title="服务稳定性"></a>服务稳定性</h4><p>hystrix 熔断</p>
<h4 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h4><pre><code>接口模块-----api
    核心模块----core
    管理端模块----manager
    webhook回调通知模块----webhook --&gt; 订阅event --&gt; 消息letter生成 --&gt;入库 --&gt;生成待发送队列（两级队列：内存队列20w，rocketMQ消息队列；一个补偿任务elasticJob)--&gt;</code></pre><p><img src="/images/%E6%9E%B6%E6%9E%84.png" alt="架构"></p>
<h1 id="Open-API-介绍"><a href="#Open-API-介绍" class="headerlink" title="Open API 介绍"></a>Open API 介绍</h1><p>OpenAPI 项目是基于REST标准来设计的，为保证统一和安全，全局编码格式为UTF-8，全局使用https。我们的API具有可预测的面向资源的url，返回json编码的响应，并使用标准的HTTP响应代码、身份验证和请求动词。</p>
<p>为了数据准确性和生产环境数据安全，建议在沙盒环境测试这些接口.</p>
<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>当我们对API进行向后不兼容的更改时，我们会发布新版本。要使用的版本在URL中指定。当前版本是v1，比如:</p>
<pre><code>https://api.itmarte.com/payments/v1/...</code></pre><h1 id="授权认证"><a href="#授权认证" class="headerlink" title="授权认证"></a>授权认证</h1><p>在不同的对接场景下Open API存在两种认证方式（用户开发者和第三方应用开发者，通常情况下申请用户开发者），使用http头<code>Authorization</code>做认证：<br><img src="/images/%E6%8E%88%E6%9D%83%E5%9B%BE.png" alt="授权图"></p>
<h3 id="用户开发者模式"><a href="#用户开发者模式" class="headerlink" title="用户开发者模式"></a>用户开发者模式</h3><p>创建了用户开发者之后，会收到给您返回的<code>developerId</code>、<code>masterToken</code>（<code>masterToken</code>能行使用户所有权限，请您务必安全保管）和<code>LLP_RSA_PUB_KEY.pem</code>，身份认证格式如下:</p>
<pre><code>Authorization: Basic &amp;lt;&amp;lt;Base64.encode(developerId:masterToken)&amp;gt;&amp;gt;</code></pre><h3 id="第三方应用开发者模式"><a href="#第三方应用开发者模式" class="headerlink" title="第三方应用开发者模式"></a>第三方应用开发者模式</h3><p>创建第三方应用开发者之后，会收到<code>clientId</code>、<code>clientSecret</code>和<code>LLP_RSA_PUB_KEY.pem</code>，至于<code>accessToken</code>则需要通过OAuth2.0模式向有资源的用户申请，身份认证格式如下:</p>
<pre><code>Authorization: Bearer &amp;lt;&amp;lt;accessToken&amp;gt;&amp;gt;</code></pre><h1 id="请求安全"><a href="#请求安全" class="headerlink" title="请求安全"></a>请求安全</h1><p>为了请求安全防止重放攻击，要求所有请求都得有签名认证，在http头定义了<code>xxx-Signature</code>字段作为签名信息载体，<code>xxx-Signature</code>头文件中包含了请求包体和响应的epoch时间戳（是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数）例如：<code>xxx-Signature:t=&amp;lt;&amp;lt;epoch&amp;gt;&amp;gt;,v=&amp;lt;&amp;lt;signature&amp;gt;&amp;gt;</code>，一个请求的有效时间是5分钟。下面介绍下请求的签名格式：</p>
<h3 id="请求签名"><a href="#请求签名" class="headerlink" title="请求签名"></a>请求签名</h3><ol start="2">
<li>对<code>HTTP请求方式</code>、<code>URI</code>、<code>请求epoch时间</code>（单位秒）、<code>请求包体</code>的数据按照一定顺序用字符串“&amp;”做拼接后使用对接方的<code>RSA私钥</code>通过<code>SHA256WithRSA</code>算法做签名并用<code>Base64编码</code>，生成的签名字符串（<code>signature</code>）和<code>epoch</code>时间放入HTTP包头的<code>xxx-Signature</code>标签中，格式为：</li>
</ol>
<!---->


<pre><code>xxx-Signature:t=&amp;lt;&amp;lt;epoch&amp;gt;&amp;gt;,v=&amp;lt;&amp;lt;signature&amp;gt;&amp;gt;</code></pre><p><strong>第一步:</strong> 确定签名<code>payload</code></p>
<p>如下字段请用<code>&amp;</code>一次连接</p>
<ul>
<li><p><code>HTTP_METHOD</code>: 对应实际接口的方法（统一用大写），如<code>POST</code>、<code>PUT</code>、<code>GET</code>、<code>DELETE</code>等；</p>
</li>
<li><p><code>URI</code>: 请求的URI地址（除去host）.  例如<code>https://api.sandbox.itmarte.com/collections/v1/merchants</code>中<code>/collections/v1/merchants</code>为URI</p>
</li>
<li><p><code>REQUEST_EPOCH</code>: 是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数,该值应与<code>t</code>值保持一致</p>
</li>
<li><p><code>REQUEST_PAYLOAD</code>: 请求包体  <code>{&quot;currency&quot;:&quot;USD&quot;}</code></p>
</li>
<li><p><code>QUERY_STRING</code>: 查询字段例如：<code>https://api.sandbox.itmarte.com/collections/v1/merchants?attr1=value1&amp;attr2=value2</code>,其中<code>QUERY_STRING</code>=<code>attr1=value1&amp;attr2=value2</code>格式化为<code>attr1%3Dvalue1%26attr2%3Dvalue2</code></p>
<p><code>payload</code>示例:</p>
<p>  POST&amp;/collections/v1/merchants&amp;19879234&amp;{“currency”:”USD”}&amp;attr1%3Dvalue1%26attr2%3Dvalue2</p>
</li>
</ul>
<p><strong>第二部:</strong> 准备 <code>xxx-Signature</code> 签名头</p>
<p>你会用到以下内容:</p>
<ul>
<li>REQUEST_EPOCH (Seconds elapsed since 1970/1/1 00:00:00 GMT as a string)</li>
<li>连接字符串 <code>,</code></li>
<li>payload（第一步的结果）</li>
<li>your_rsa_pri_key：你的RSA私钥</li>
</ul>
<!---->

<pre><code>xxx-Signature: t=REQUEST_EPOCH,v=BASE64_ENCODE(SHA256WithRSA.sign(&amp;lt;&amp;lt;payload&amp;gt;&amp;gt;, &amp;lt;&amp;lt;your_rsa_pri_key&amp;gt;&amp;gt;))</code></pre><p><strong>请求示例</strong></p>
<pre><code>POST /api/mkt/balance HTTP/1.1 
Host: api.itmarte.com 
Content-Type: application/json 
Authorization: Basic WTgzcHNkcFdqY3J0Vml5eHVveTNyWGp2OWpzMjV3aUs6WTgzcHNkcFdqY3J0Vml5eHVveTNyWGp2OWpzMjV3aUs= 
xxx-Signature: t=1574130344,v=cJKgD/EpqNVnITR7yZ8BIev5j1E0ub0VbG4uGA69gR4T1FFc7NzqbiBoDEOBvkQtJXytQd7dY+WDo0Qm0c6gCnRHqIEyBen6SnBk/PjhIn7H93sHMyUEbesJqB6NAzOHA4uVj+8aTfREQWxKaizkDTT1dnrBUZ7KPxz4KKzRXtZ6tEh48HKsA5xqviedc+kpilaFbFSaoJmFj760TV8FB+mKCkZSrvX1Y+4x0bqTVBXAt2kE2Z8vCH16BDtlWGLZRSlWtZWyvpz6F0a/VWYVhoBEmgNFevnYDeAMGB6VEDBE1pZLMnhxfLfz6yu/p1pv1c2N2Yk5YSahQw4lLLiqQQ== 
Accept: */* 
Cache-Control: no-cache 
Content-Length: 18 
Connection: keep-alive 

{&quot;currency&quot;:&quot;USD&quot;} </code></pre><h3 id="请求结果签名验证"><a href="#请求结果签名验证" class="headerlink" title="请求结果签名验证"></a>请求结果签名验证</h3><ul>
<li>若请求成功返回200，包体格式查看具体接口，对响应包体使用连连支付的RSA私钥用SHA256WithRSA做签名并用Base64编码，生成的签名字符串放入HTTP包头xxx-Signature标签中，格式为xxx-Signature: t = response_epoch, v = signature。<br>其中：</li>
<li>t=响应时间戳(格林威治时间1970年01月01日00时00分00秒起至现在的总秒数)</li>
<li>v=BASE64_ENCODE(SHA256WithRSA(RESPONSE_EPOCH&amp;RESPONSE_BODY, LLPAY_RSA_PRIVATE_KEY))</li>
</ul>
<p><strong>第一步:</strong> 确定 <code>payload</code></p>
<p>如下字段创建<code>payload</code>用 <code>&amp;</code> 做连接</p>
<ul>
<li>Response Timestamp: 响应时间戳(格林威治时间1970年01月01日00时00分00秒起至现在的总秒数)</li>
<li>Response Payload: 响应包体，指定为JSON字符串如： <code>{&quot;currency&quot;:&quot;USD&quot;}</code></li>
</ul>
<p><code>payload</code>示例:</p>
<pre><code>19879234&amp;{&quot;currency&quot;:&quot;USD&quot;}</code></pre><p><strong>第二部:</strong> 使用连连的RSA公钥校验签名的有效性</p>
<pre><code>SHA256WithRSA.verify(xxx-Signature, &apos;19879234&amp;{&quot; currency&quot;:&quot;USD&quot;}&apos;,  LLPAY_RSA_PRIVATE_KEY)</code></pre><h1 id="响应结果"><a href="#响应结果" class="headerlink" title="响应结果"></a>响应结果</h1><p><strong>成功返回结果示例</strong></p>
<p>连连通过http状态码来判断请求的结果，一个成功的请求的http状态码为2XX，请求结果为相应的objects对象，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 </span><br><span class="line">status: 200 </span><br><span class="line">Content-Type: application&#x2F;json </span><br><span class="line">Content-Length: 61</span><br><span class="line">Connection: keep-alive </span><br><span class="line">xxx-Signature:t&#x3D;1574130398,v&#x3D;b0VbG4uGA69gR4T1FFc7NzqbiBoDEOBvkQtJXytQd7dY+WDo0QmgR4T1FFc7NzqbiBoDEOBvkQtJXytQpzMjV3aUs6R4T1FFc7NzqbiBoDEOBvWTgzcHNkcFdqY3J0Vml5eHVc6gCnRHqIEyBen6SnBk&#x2F;PjhIn7H93sHMyUEbesJqB6NAzOHA4uVj+8aTfREQWxKaizkDTT1dnrBUZ7KPxz4KKzRXtZ6tEh48HKsA5xqWGLZRSlWtZWyvpz6F0a&#x2F;VWYVhoBEmgNFevkE2Z8vCH16VEDBE1pZ6VEDBE1pZ6BDBE1pZ6VEDBE1DtlWGLnYviedc+kpilaFbFSaoJmFj76&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#123;&quot;currency&quot;:&quot;USD&quot;,&quot;balance&quot;:&quot;12.25&quot;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h4><p>一个失败的请求会收到4XX类的http状态码表示已知错误内容（具体错误码API文档给出），5XX的状态码表示未知的错误类型：</p>
<h4 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h4><p><strong><em>code</em></strong> <em>number</em><br>失败码类型，数字类型，用于快速定位错误类型</p>
<p><strong><em>message</em></strong> <em>string</em><br>失败描述</p>
<p><strong>失败返回结果示例</strong></p>
<pre><code>HTTP/1.1 400
status: 400
Date: Tue, 19 Nov 2019 02:26:38 GMT
Content-Type: application/json
Content-Length: 77
Connection: keep-alive

{&quot;code&quot;:&quot;999995&quot;,&quot;message&quot;:&quot;[holderType] is invalid&quot;}</code></pre><h3 id="HTTP状态码一览表"><a href="#HTTP状态码一览表" class="headerlink" title="HTTP状态码一览表"></a>HTTP状态码一览表</h3><table>
<thead>
<tr>
<th>CODE</th>
<th>DESCRIPTION</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>请求错误，例如：参数错误</td>
</tr>
<tr>
<td>401</td>
<td>授权认证失败或者是签名认证失败</td>
</tr>
<tr>
<td>403</td>
<td>请求未授权</td>
</tr>
<tr>
<td>404</td>
<td>资源未找到，这里的资源指的是实际的Objects对象</td>
</tr>
<tr>
<td>500, 502, 503, 504</td>
<td>系统错误</td>
</tr>
</tbody></table>
<h1 id="请求幂等保证"><a href="#请求幂等保证" class="headerlink" title="请求幂等保证"></a>请求幂等保证</h1><p>实际运行场景中，由于网络原因或者其他原因导致的网络中断是不可避免的，所以连连这边特意设计了请求幂等保证操作，所有的POST、PUT、DELETE请求都可以做幂等校验，幂等请求认证成功之后，会返回最初的请求结果（5XX未知异常类型的错误除外）。</p>
<p>你需要在http头加入<code>Idempotency-Key</code>以便让系统失败你的幂等请求：</p>
<pre><code>Idempotency-Key:&amp;lt;&amp;lt;unique id for client &amp;gt;&amp;gt;</code></pre><h1 id="Request-IDs"><a href="#Request-IDs" class="headerlink" title="Request IDs"></a>Request IDs</h1><p>每个API请求都有一个关联的请求标识符。您可以响应头找到<code>Request-Id</code>下这个键值。</p>
<h1 id="字段命名规范"><a href="#字段命名规范" class="headerlink" title="字段命名规范"></a>字段命名规范</h1><p>连连所有的字段命名规范为驼峰式:</p>
<pre><code>https://api...com/resource/?filterBy=&quot;filter&quot;

{
  &quot;storeName&quot;: &quot;My Store&quot;,
  &quot;kycStatus&quot;: &quot;success&quot;
}</code></pre><h1 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h1><p>你可以配置webhook地址来接收连连这边的回调信息（<code>event</code>），具体的回调信息（<code>event</code>）在相应的接口中定义</p>
<h1 id="对象关系模型"><a href="#对象关系模型" class="headerlink" title="对象关系模型"></a>对象关系模型</h1><p><img src="/images/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B.png" alt="对象关系模型"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blob.itmarte.com/2020/04/15/project/open-api/" data-id="ckc4mb0nk004j3wjabghq6lab" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spring/spring" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/15/spring/spring/" class="article-date">
  <time datetime="2020-04-15T12:06:16.000Z" itemprop="datePublished">2020-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/spring/">spring</a>►<a class="article-category-link" href="/categories/spring/spring/">spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/15/spring/spring/">spring</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blob.itmarte.com/2020/04/15/spring/spring/" data-id="ckc4mb0kl00143wjad14bbdo0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-sql/sql" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/15/sql/sql/" class="article-date">
  <time datetime="2020-04-15T12:05:46.000Z" itemprop="datePublished">2020-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>►<a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/sql/">sql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/15/sql/sql/">sql</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blob.itmarte.com/2020/04/15/sql/sql/" data-id="ckc4mb0kn00163wjackzm9f2p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-server/server" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/15/server/server/" class="article-date">
  <time datetime="2020-04-15T12:05:08.000Z" itemprop="datePublished">2020-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a>►<a class="article-category-link" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/server/">server</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/15/server/server/">server</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blob.itmarte.com/2020/04/15/server/server/" data-id="ckc4mb0kf000z3wja0ri1cq39" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ORM/">ORM</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ORM/orm/">orm</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/IO-NIO/">IO/NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/collection/">collection</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/collection/queue/">queue</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/collection/queue/disruptor/">disruptor</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/concurrent/">concurrent</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/concurrent/AQS/">AQS</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/j2ee/">j2ee</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/jdk8/">jdk8</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/jvm/">jvm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/jvm%E5%B7%A5%E5%85%B7/">jvm工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/memory/">memory</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/memory/garbage/">garbage</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/proxy/">proxy</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/read-line/">read line</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/schedule/">schedule</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/thread/">thread</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/thread/fork-join/">fork/join</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/thread-pool/">thread-pool</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux/linux/">linux</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/spring/spring/">spring</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/middleware/">middleware</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/">分布式与微服务</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/dubbo%E9%85%8D%E7%BD%AE/">dubbo配置</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/microservices/">microservices</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8C%85%E7%AE%A1%E7%90%86/">包管理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8C%85%E7%AE%A1%E7%90%86/packageManager/">packageManager</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/blockChina/">blockChina</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySql/">MySql</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySql/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">MVCC多版本并发控制</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/sql/">sql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/">分库分表方案</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95/">索引</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/algorithms/">algorithms</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/server/">server</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/Open-API/">Open API</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/project/">project</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AQS/" rel="tag">AQS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" rel="tag">MVCC多版本并发控制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySql/" rel="tag">MySql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ORM/" rel="tag">ORM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ThreadPoolExecutor/" rel="tag">ThreadPoolExecutor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/b-tree/" rel="tag">b tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/b-tree/" rel="tag">b+ tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cglib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" rel="tag">cglib 动态代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/collection/" rel="tag">collection</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/concurrent/" rel="tag">concurrent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/disruptor/" rel="tag">disruptor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo-%E9%85%8D%E7%BD%AE/" rel="tag">dubbo 配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fork-join/" rel="tag">fork/join</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/function-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">function/函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/garbage/" rel="tag">garbage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io/" rel="tag">io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javassist/" rel="tag">javassist</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" rel="tag">jdk 动态代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdk8/" rel="tag">jdk8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm%E5%B7%A5%E5%85%B7/" rel="tag">jvm工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lambda/" rel="tag">lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/memory/" rel="tag">memory</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nio/" rel="tag">nio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/proxy/" rel="tag">proxy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/schedule/" rel="tag">schedule</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/synchronized-lock/" rel="tag">synchronized/lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread/" rel="tag">thread</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thread-pool/" rel="tag">thread-pool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">分布式与微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/" rel="tag">分库分表方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86/" rel="tag">包管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/AQS/" style="font-size: 10px;">AQS</a> <a href="/tags/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" style="font-size: 10px;">MVCC多版本并发控制</a> <a href="/tags/MySql/" style="font-size: 10px;">MySql</a> <a href="/tags/ORM/" style="font-size: 10px;">ORM</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 12.5px;">ThreadPoolExecutor</a> <a href="/tags/b-tree/" style="font-size: 10px;">b tree</a> <a href="/tags/b-tree/" style="font-size: 10px;">b+ tree</a> <a href="/tags/cglib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" style="font-size: 10px;">cglib 动态代理</a> <a href="/tags/collection/" style="font-size: 10px;">collection</a> <a href="/tags/concurrent/" style="font-size: 10px;">concurrent</a> <a href="/tags/disruptor/" style="font-size: 10px;">disruptor</a> <a href="/tags/dubbo-%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">dubbo 配置</a> <a href="/tags/fork-join/" style="font-size: 12.5px;">fork/join</a> <a href="/tags/function-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">function/函数式编程</a> <a href="/tags/garbage/" style="font-size: 10px;">garbage</a> <a href="/tags/io/" style="font-size: 12.5px;">io</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/javassist/" style="font-size: 10px;">javassist</a> <a href="/tags/jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" style="font-size: 10px;">jdk 动态代理</a> <a href="/tags/jdk8/" style="font-size: 10px;">jdk8</a> <a href="/tags/jvm%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">jvm工具</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/memory/" style="font-size: 12.5px;">memory</a> <a href="/tags/nio/" style="font-size: 12.5px;">nio</a> <a href="/tags/proxy/" style="font-size: 10px;">proxy</a> <a href="/tags/schedule/" style="font-size: 15px;">schedule</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/synchronized-lock/" style="font-size: 12.5px;">synchronized/lock</a> <a href="/tags/thread/" style="font-size: 12.5px;">thread</a> <a href="/tags/thread-pool/" style="font-size: 10px;">thread-pool</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 10px;">中间件</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 12.5px;">分布式与微服务</a> <a href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/" style="font-size: 10px;">分库分表方案</a> <a href="/tags/%E5%8C%85%E7%AE%A1%E7%90%86/" style="font-size: 10px;">包管理</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 10px;">区块链</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 17.5px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 10px;">数据结构与算法</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">服务器</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 10px;">队列</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 12.5px;">项目</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/02/sql/MySQL-InnoDB-MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">MySQL-InnoDB-MVCC多版本并发控制</a>
          </li>
        
          <li>
            <a href="/2020/06/04/java/JDK%20%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/">JDK 监控和故障处理工具总结</a>
          </li>
        
          <li>
            <a href="/2020/06/04/sql/Mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/">\[转\]Mysql分库分表方案</a>
          </li>
        
          <li>
            <a href="/2020/06/04/microservices/dubbo%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%85%8D%E7%BD%AE%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/">dubbo 连接数配置导致连接爆发</a>
          </li>
        
          <li>
            <a href="/2020/06/03/sql/btree%E7%B4%A2%E5%BC%95/">MySQL索引使用的数据结构：B-Tree和B+Tree</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 marte<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories%20/%E5%88%86%E7%B1%BB" class="mobile-nav-link">分类</a>
  
    <a href="/tags%20%20%20/%E6%A0%87%E7%AD%BE" class="mobile-nav-link">标签</a>
  
    <a href="/about%20%20%20/%E5%85%B3%E4%BA%8E" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>